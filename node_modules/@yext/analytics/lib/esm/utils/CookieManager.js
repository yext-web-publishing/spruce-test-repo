import { COOKIE_PARAM } from '../models';
import { COOKIE_REMOVAL_VALUE } from '../models/constants';
/**
 * CookieManager will manager conversion tracking cookies
 *
 * @public
 */
var CookieManager = /** @class */ (function () {
    /**
     * Takes the window and document
     * @param _outerWindow - typically the window object or a mock
     * @param _outerDocument - typically teh document object or a mock
     */
    function CookieManager(_outerWindow, _outerDocument) {
        if (_outerWindow === void 0) { _outerWindow = window; }
        if (_outerDocument === void 0) { _outerDocument = document; }
        this._outerWindow = _outerWindow;
        this._outerDocument = _outerDocument;
    }
    /**
     * Gets the existing YFPC ID, or sets a new one if it doesn't already exist.
     * You should only call this method if doing so complies with your GDPR/CCPA compliance requirements.
     *
     * @public
     */
    CookieManager.prototype.setAndGetYextCookie = function () {
        var cookieValue = this.fetchCookie();
        if (!cookieValue) {
            cookieValue = CookieManager.generateRandomCookie().toString();
        }
        this.setCookieAndRemoveOldCookies(cookieValue);
        return cookieValue;
    };
    /**
     */
    CookieManager.generateRandomCookie = function () {
        return Math.floor(Math.random() * new Date().getTime());
    };
    /**
     * Retrieves the identifier stored as a cookie on the user's browser, if present. Otherwise
     * returns empty. This is accomplished by attempting to set a cookie at domains in order of
     * increasing specificity (e.g. ".com", then ".example.com", then ".subdomain.example.com"), and
     * the first one that we can set a cookie in is the root domain. Check if we already have a cookie
     * in the root domain and if not, check if a cookie exists without a domain, for legacy reasons.
     *
     */
    CookieManager.prototype.fetchCookie = function () {
        var _this = this;
        var cookieValue = '';
        var checkDomain = function (domain) {
            if (_this.canSetCookieWithDomain(domain)) {
                var removedValue = _this.removeCookieByDomain(domain);
                if (removedValue) {
                    // We found and removed a value, so put it back
                    cookieValue = removedValue;
                    _this.setCookie(cookieValue, domain);
                }
                // Exit the loop once we've reached root domain (the first domain where we can set a cookie)
                return true;
            }
        };
        this.forEachDomainIncreasingSpecificity(checkDomain);
        // If no cookie was present in the root domain, check for a cookie that doesn't have a domain
        // specified (by passing an empty string to checkDomain, indicating no domain).
        if (!cookieValue)
            checkDomain('');
        return cookieValue;
    };
    /**
     * Runs a function on each possible domain in order of increasing specificity (e.g. .com,
     * .example.com, .full.example.com). Note that empty string, indicating unset domain, is iterated
     * through at the end. A truthy return value indicates to break out of the loop.
     *
     * @param func - A function to call on each possible domain
     */
    CookieManager.prototype.forEachDomainIncreasingSpecificity = function (func) {
        var exitedLoop = false;
        var domainParts = this._outerDocument.location.hostname.split('.').reverse();
        var currDomain = '';
        for (var i = 0; i < domainParts.length; i++) {
            currDomain = '.' + domainParts[i] + currDomain;
            if (func(currDomain)) {
                exitedLoop = true;
                break;
            }
        }
        if (!exitedLoop)
            func('');
    };
    /**
     * Removes a COOKIE_PARAM cookie by domain, then returns its value if successful and empty string
     * otherwise.
     *
     * @param cookieDomain - The domain to remove the cookie from
     */
    CookieManager.prototype.removeCookieByDomain = function (cookieDomain) {
        var prevRemainingCookies = this.persistentCookies();
        this.clearCookie(cookieDomain);
        var remainingCookies = this.persistentCookies();
        if (remainingCookies.length < prevRemainingCookies.length) {
            return CookieManager.listDifference(prevRemainingCookies, remainingCookies)[0] || '';
        }
        return '';
    };
    /**
     * Returns the list difference between a superlist and sublist, accounting for number of
     * occurrences.
     *
     * @param superlist - The full array
     * @param sublist - The subarray
     */
    CookieManager.listDifference = function (superlist, sublist) {
        var superlistCopy = Array.from(superlist);
        for (var i = 0; i < sublist.length; i++) {
            var index = superlistCopy.indexOf(sublist[i]);
            if (index !== -1) {
                superlistCopy.splice(index, 1);
            }
        }
        return superlistCopy;
    };
    /**
     * Retrieves a list of values of cookies with the name of COOKIE_PARAM that are present and not
     * set to be removed (i.e. having the specific value this script uses to indicate a removed
     * cookie).
     *
     */
    CookieManager.prototype.persistentCookies = function () {
        return this.allCookies().filter(function (val) { return val !== COOKIE_REMOVAL_VALUE; });
    };
    /**
     * Retrieves a list of values of cookies with the name of COOKIE_PARAM that are present.
     *
     */
    CookieManager.prototype.allCookies = function () {
        var arr = [];
        this.forEachCookieNameValue(function (name, value) {
            if (name === COOKIE_PARAM) {
                arr.push(value);
            }
        });
        return arr;
    };
    /**
     * Runs nameValueFunc on each cookie's key and value (after trimming), only if the key and value
     * are both truthy.
     *
     * @param nameValueFunc - A function to run on each cookie key-value pair
     */
    CookieManager.prototype.forEachCookieNameValue = function (nameValueFunc) {
        this._outerDocument.cookie.split(';').forEach(function (cookie) {
            var keyValue = cookie.split('='), key = keyValue[0], value = keyValue[1];
            if (key && value) {
                nameValueFunc(key.trim(), value.trim());
            }
        });
    };
    /**
     * Stores a tracking cookie on the user's browser with the given value in the root domain, and
     * removes first party cookies from all other domains (which may be present for legacy reasons).
     *
     * @param cookieValue - The value to set as the first party cookie
     */
    CookieManager.prototype.setCookieAndRemoveOldCookies = function (cookieValue) {
        var _this = this;
        var rootDomainReached = false;
        var totalCookies = this.allCookies().length;
        var numCookiesEncountered = 0;
        // Iterate until we find the topmost domain (the root domain), where we set the cookie,
        // then continue iterating, just deleting any cookies we find afterwards.
        this.forEachDomainIncreasingSpecificity(function (domain) {
            if (rootDomainReached) {
                if (_this.removeCookieByDomain(domain))
                    numCookiesEncountered++;
            }
            else {
                if (_this.canSetCookieWithDomain(domain)) {
                    // In root domain, so set cookie
                    if (_this.removeCookieByDomain(domain))
                        numCookiesEncountered++;
                    _this.setCookie(cookieValue, domain);
                    rootDomainReached = true;
                }
            }
            if (numCookiesEncountered >= totalCookies && rootDomainReached) {
                // Break if we've already encountered every cookie and we already set one in root domain
                return true;
            }
        });
    };
    /**
     * Returns whether we are able to set a cookie (formatted like the actual cookie for tracking)
     * at a specified domain or not. Preserves existing cookies in the same domain (but not their
     * expiration dates).
     *
     * @param domain - The value for the cookie's domain attribute
     */
    CookieManager.prototype.canSetCookieWithDomain = function (domain) {
        var lostCookie = this.removeCookieByDomain(domain);
        var existingCookies = this.allCookies();
        this.setCookie(COOKIE_REMOVAL_VALUE, domain);
        var newCookies = this.allCookies();
        if (existingCookies.length < newCookies.length) {
            // Cookie was successfully saved, so wipe it and put back the old cookie if there was one
            if (lostCookie) {
                this.setCookie(lostCookie, domain);
            }
            else {
                this.clearCookie(domain);
            }
            return true;
        }
        return false;
    };
    /**
     * Stores a cookie on the user's browser with the given value and domain, with name COOKIE_PARAM.
     *
     * @param cookieValue - The value to set as the first party cookie
     * @param cookieDomain - The domain in which to set the cookie
     */
    CookieManager.prototype.setCookie = function (cookieValue, cookieDomain) {
        this._outerDocument.cookie = this.formatCookie(COOKIE_PARAM, cookieValue, cookieDomain);
    };
    /**
     * Creates a formatted cookie string given a key, value, domain, and, optionally, a path.
     * `Expires` is set to ensure the cookie is persistent, `Samesite=None` so the value can be
     * included in cross-site requests,`Domain` defaults to root domain (if possible) to enable
     * tracking across subdomains, and `Secure` is required when using
     * `Samesite=None`: https://www.chromestatus.com/feature/5633521622188032
     *
     * @param cookieName - The name of the cookie
     * @param cookieValue - The value of the cookie
     * @param domain - The domain to set the cookie for
     * @param path - The path to set the cookie for
     */
    CookieManager.prototype.formatCookie = function (cookieName, cookieValue, domain, path) {
        if (path === void 0) { path = '/'; }
        var cookieString = cookieName + '=' + cookieValue;
        var now = new Date();
        now.setTime(now.getTime() + 90 * 24 * 60 * 60 * 1000);
        cookieString += ';path=' + path;
        cookieString += ';expires=' + now.toUTCString();
        if (domain)
            cookieString += ';domain=' + domain;
        cookieString += ';samesite=None;';
        if (this._outerWindow.location.protocol === 'https:') {
            cookieString += ' Secure ';
        }
        return cookieString;
    };
    /**
     * Sets a cookie with name COOKIE_PARAM to make it expire immediately.
     *
     * @param cookieDomain - The domain of the cookie to clear
     * @param cookiePath - The path of the cookie to be deleted (defaults to '/')
     */
    CookieManager.prototype.clearCookie = function (cookieDomain, cookiePath) {
        if (cookieDomain === void 0) { cookieDomain = ''; }
        if (cookiePath === void 0) { cookiePath = '/'; }
        var epoch = new Date(0);
        var cookieString = COOKIE_PARAM + '=' + COOKIE_REMOVAL_VALUE;
        cookieString += ';path=' + cookiePath;
        cookieString += ';expires=' + epoch.toUTCString();
        if (cookieDomain)
            cookieString += ';domain=' + cookieDomain + ';';
        cookieString += ';samesite=None;';
        if (this._outerWindow.location.protocol === 'https:') {
            cookieString += ' Secure ';
        }
        this._outerDocument.cookie = cookieString;
    };
    return CookieManager;
}());
export { CookieManager };
//# sourceMappingURL=CookieManager.js.map