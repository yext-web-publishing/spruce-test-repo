/**
 * CookieManager will manager conversion tracking cookies
 *
 * @public
 */
export declare class CookieManager {
    private _outerWindow;
    private _outerDocument;
    /**
     * Takes the window and document
     * @param _outerWindow - typically the window object or a mock
     * @param _outerDocument - typically teh document object or a mock
     */
    constructor(_outerWindow?: Window, _outerDocument?: Document);
    /**
     * Gets the existing YFPC ID, or sets a new one if it doesn't already exist.
     * You should only call this method if doing so complies with your GDPR/CCPA compliance requirements.
     *
     * @public
     */
    setAndGetYextCookie(): string;
    /**
     */
    private static generateRandomCookie;
    /**
     * Retrieves the identifier stored as a cookie on the user's browser, if present. Otherwise
     * returns empty. This is accomplished by attempting to set a cookie at domains in order of
     * increasing specificity (e.g. ".com", then ".example.com", then ".subdomain.example.com"), and
     * the first one that we can set a cookie in is the root domain. Check if we already have a cookie
     * in the root domain and if not, check if a cookie exists without a domain, for legacy reasons.
     *
     */
    private fetchCookie;
    /**
     * Runs a function on each possible domain in order of increasing specificity (e.g. .com,
     * .example.com, .full.example.com). Note that empty string, indicating unset domain, is iterated
     * through at the end. A truthy return value indicates to break out of the loop.
     *
     * @param func - A function to call on each possible domain
     */
    private forEachDomainIncreasingSpecificity;
    /**
     * Removes a COOKIE_PARAM cookie by domain, then returns its value if successful and empty string
     * otherwise.
     *
     * @param cookieDomain - The domain to remove the cookie from
     */
    private removeCookieByDomain;
    /**
     * Returns the list difference between a superlist and sublist, accounting for number of
     * occurrences.
     *
     * @param superlist - The full array
     * @param sublist - The subarray
     */
    private static listDifference;
    /**
     * Retrieves a list of values of cookies with the name of COOKIE_PARAM that are present and not
     * set to be removed (i.e. having the specific value this script uses to indicate a removed
     * cookie).
     *
     */
    private persistentCookies;
    /**
     * Retrieves a list of values of cookies with the name of COOKIE_PARAM that are present.
     *
     */
    private allCookies;
    /**
     * Runs nameValueFunc on each cookie's key and value (after trimming), only if the key and value
     * are both truthy.
     *
     * @param nameValueFunc - A function to run on each cookie key-value pair
     */
    private forEachCookieNameValue;
    /**
     * Stores a tracking cookie on the user's browser with the given value in the root domain, and
     * removes first party cookies from all other domains (which may be present for legacy reasons).
     *
     * @param cookieValue - The value to set as the first party cookie
     */
    private setCookieAndRemoveOldCookies;
    /**
     * Returns whether we are able to set a cookie (formatted like the actual cookie for tracking)
     * at a specified domain or not. Preserves existing cookies in the same domain (but not their
     * expiration dates).
     *
     * @param domain - The value for the cookie's domain attribute
     */
    private canSetCookieWithDomain;
    /**
     * Stores a cookie on the user's browser with the given value and domain, with name COOKIE_PARAM.
     *
     * @param cookieValue - The value to set as the first party cookie
     * @param cookieDomain - The domain in which to set the cookie
     */
    private setCookie;
    /**
     * Creates a formatted cookie string given a key, value, domain, and, optionally, a path.
     * `Expires` is set to ensure the cookie is persistent, `Samesite=None` so the value can be
     * included in cross-site requests,`Domain` defaults to root domain (if possible) to enable
     * tracking across subdomains, and `Secure` is required when using
     * `Samesite=None`: https://www.chromestatus.com/feature/5633521622188032
     *
     * @param cookieName - The name of the cookie
     * @param cookieValue - The value of the cookie
     * @param domain - The domain to set the cookie for
     * @param path - The path to set the cookie for
     */
    private formatCookie;
    /**
     * Sets a cookie with name COOKIE_PARAM to make it expire immediately.
     *
     * @param cookieDomain - The domain of the cookie to clear
     * @param cookiePath - The path of the cookie to be deleted (defaults to '/')
     */
    private clearCookie;
}
//# sourceMappingURL=CookieManager.d.ts.map