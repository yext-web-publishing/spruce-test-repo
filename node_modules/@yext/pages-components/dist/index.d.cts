import * as react_jsx_runtime from 'react/jsx-runtime';
import * as React$1 from 'react';
import React__default, { MouseEvent, PropsWithChildren, ReactElement } from 'react';
import { ConversionDetails, Visitor } from '@yext/analytics';
import { EditorThemeClasses } from 'lexical';

/**
 * The type definition for an address.
 *
 * @public
 */
interface AddressType {
    line1: string;
    line2?: string;
    line3?: string;
    city: string;
    region?: string;
    postalCode: string;
    countryCode: string;
    sublocality?: string;
    extraDescription?: string;
    localizedRegionName?: string;
    localizedCountryName?: string;
}
type AddressLine = (keyof AddressType | ",")[];
/**
 * The shape of the data passed to {@link Address}.
 *
 * @public
 */
interface AddressProps extends React.HTMLProps<HTMLDivElement> {
    address: AddressType;
    lines?: AddressLine[];
    separator?: string;
}
/**
 * The shape of the data passed to {@link AddressLine}.
 *
 * @public
 */
type AddressLineProps = {
    address: AddressType;
    line: AddressLine;
    separator?: string;
};
/**
 * The available listing publishers
 *
 * @public
 */
declare const ListingPublisherOption: {
    readonly GOOGLEMYBUSINESS: "GOOGLEMYBUSINESS";
};
/**
 * The type definition for the listing publisher
 *
 * @public
 */
type ListingPublisher = (typeof ListingPublisherOption)[keyof typeof ListingPublisherOption];
/**
 * The type definition for a Listing
 *
 * @public
 */
interface ListingType {
    listingUrl: string;
    publisher?: ListingPublisher;
}
/**
 * The available map providers
 *
 * @public
 */
declare const MapProviderOption: {
    readonly GOOGLE: "google";
    readonly APPLE: "apple";
    readonly BING: "bing";
};
/**
 * The type definition for the map provider
 *
 * @public
 */
type MapProvider$1 = (typeof MapProviderOption)[keyof typeof MapProviderOption];
/**
 * The Yext profile fields used to create a getDirections URL
 */
interface GetDirectionsConfig {
    provider?: MapProvider$1;
    route?: boolean;
}

/**
 * Renders an HTML address based from the Yext Knowledge Graph. Example of using the component to render
 * a location entity's address from Yext Knowledge Graph:
 * ```
 * import { Address } from "@yext/pages/components";
 *
 * const address = (<Address address={document.address} />);
 *   --> 1101 Wilson Blvd., Suite 2300,
 *       Arlington, VA, 22201,
 *       US
 * const customAddress = (<Address address={document.address} lines={[['line1', 'city', 'region']]} />);
 *   --> 1101 Wilson Blvd., Arlington, VA
 * ```
 *
 * @public
 */
declare const Address: ({ address, lines, separator, ...props }: AddressProps) => react_jsx_runtime.JSX.Element;

/**
 * Get a third-party maps url for a Yext location
 *
 * @param address - Yext address
 * @param listings - List of available Yext Listings
 * @param googlePlaceId - Google Place ID
 * @param config - Options for determining URL
 *
 * @returns Maps service url
 */
declare const getDirections: (address?: AddressType, listings?: ListingType[], googlePlaceId?: string, config?: GetDirectionsConfig) => string | undefined;

/**
 * The shape of the data passed directly to the different template functions with the
 * exception of the render function (getPath, getHeadConfig, etc).
 *
 * @public
 */
interface TemplateProps<T = Record<string, any>> {
    /** The entire document returned after applying the stream to a single entity */
    document: T;
}

/**
 * The AnalyticsMethod interface specifies the methods that can be used with
 * the Analytics Provider.
 *
 */
interface AnalyticsMethods {
    /**
     * The track method will send a generic analytics event to Yext.
     *
     * @param eventName - the name of the event, will appear in Yext's Report Builder UI
     * @param conversionData - optional details for tracking an event as a conversion
     */
    track(eventName: string, conversionData?: ConversionDetails): Promise<void>;
    /**
     * The identify method will allow you to tie analytics events to a specific user.
     *
     * @param visitor - the Visitor object
     */
    identify(visitor: Visitor): void;
    /**
     * The pageView method will track a pageview event.
     */
    pageView(): Promise<void>;
    /**
     * trackClick will return an event handler that delays navigation to allow
     * a click event to send.  To use it you simply pass it to the onClick prop,
     * like so:
     * ```ts
     * <a onClick={trackClick('my click')}
     * ```
     */
    trackClick(eventName: string, conversionData?: ConversionDetails): (e: MouseEvent<HTMLAnchorElement>) => Promise<void>;
    /**
     * The optIn method should be called when a user opts into analytics tracking,
     * e.g. via a Consent Management Banner or other opt-in method.
     */
    optIn(): Promise<void>;
    /**
     * Use the enableTrackingCookie method to enable conversion tracking on
     * your page.  This should be done only if you have conversion tracking
     * configured in your Yext account.
     */
    enableTrackingCookie(): void;
    /**
     * Use the setDebugEnabled method to toggle debugging on or off. Currently,
     * this will log tracked events to the dev console.
     *
     * @param enabled - boolean value for whethere debugging should be on or off.
     */
    setDebugEnabled(enabled: boolean): void;
}
/**
 * The AnalyticsProviderProps interface represents the component properties
 * to be passed into the AnalyticsProvider.
 *
 * @public
 */
interface AnalyticsProviderProps {
    /**
     * The TemplateProps that come from the rendering system
     */
    templateData: TemplateProps;
    /**
     * requireOptIn should be set to true if your compliance requirements require
     * you to put all marketing analytics behind a user opt-in banner or if you
     * use a Compliance Management tool of some kind.
     */
    requireOptIn?: boolean | undefined;
    /**
     * enableTrackingCookie will set a tracking cookie when a user does any
     * trackable action on your site, such as a page view, click, etc.
     */
    enableTrackingCookie?: boolean | undefined;
    /**
     * enableDebugging can be set to true if you want to expose tracked events
     * in the developer console.
     */
    enableDebugging?: boolean | undefined;
    /**
     * The domain of the page to send with API requests. If none is specified,
     * the hostname for the site ID is used. The domain string must include the
     * scheme (e.g. https://foo.com).
     */
    pageDomain?: string;
    /**
     * isStaging() will evaluate to false if the the event is fired from any of
     * provided domains in productionDomains.
     */
    productionDomains?: string[];
}
/**
 * AnalyticsScopeProps defines the component properties required by the
 * AnalyticsScopeProvider component.
 *
 * @public
 */
interface AnalyticsScopeProps {
    /**
     * The string to prepend to all analytics events that come from components
     * below the AnalyticsScopeProvider component in the tree.
     */
    name: string;
}

/**
 * The Analytics class creates a stateful facade in front of the \@yext/analytics
 * Library's pagesAnalyticsProvider class. It takes in some data from the
 * template configuration and uses it to provide configuration to the
 * pagesAnalyticsProvider.
 *
 * Additionally, it provides handlers for controlling user opt-in for compliance
 * requirements as well as for debugging, enabling conversion tracking, saving
 * user identity information, and creating named analytics scopes for
 * easy tagging.
 *
 * @public
 */
declare class Analytics implements AnalyticsMethods {
    private templateData;
    private pageDomain?;
    private productionDomains;
    private _optedIn;
    private _conversionTrackingEnabled;
    private _cookieManager;
    private _analyticsReporter;
    private _pageViewFired;
    private _enableDebugging;
    /**
     * Creates an Analytics instance, will fire a pageview event if requireOptin
     * is false
     *
     * @param templateData - template data object from the pages system
     * @param requireOptIn - boolean, set to true if you require user opt in before tracking analytics
     */
    constructor(templateData: TemplateProps, requireOptIn?: boolean | undefined, pageDomain?: string | undefined, productionDomains?: string[]);
    private calculatePageType;
    private makeReporter;
    private canTrack;
    private setupConversionTracking;
    /** {@inheritDoc AnalyticsMethods.enableConversionTracking} */
    enableTrackingCookie(): void;
    /** {@inheritDoc AnalyticsMethods.identify} */
    identify(visitor: Visitor): void;
    /** {@inheritDoc AnalyticsMethods.async} */
    optIn(): Promise<void>;
    /** {@inheritDoc AnalyticsMethods.async} */
    pageView(): Promise<void>;
    /** {@inheritDoc AnalyticsMethods.track} */
    track(eventName: string, conversionData?: ConversionDetails): Promise<void>;
    /** {@inheritDoc AnalyticsMethods.setDebugEnabled} */
    setDebugEnabled(enabled: boolean): void;
    /** {@inheritDoc AnalyticsMethods.trackClick} */
    trackClick(eventName: string, conversionData?: ConversionDetails): (e: MouseEvent<HTMLAnchorElement>) => Promise<void>;
}

/**
 * Default react context for use with Yext Analytics.
 *
 * @public
 */
declare const AnalyticsContext: React$1.Context<AnalyticsMethods | null>;

declare global {
    interface Window {
        setAnalyticsOptIn: () => void;
    }
}
/**
 * The useAnalytics hook can be used anywhere in the tree below a configured
 * AnalyticsProvider.  Calling it will return an object to give you access to
 * the analytics convenience methods for use in your components,
 * such as track(), pageView(), optIn() etc.
 *
 * @public
 */
declare function useAnalytics(): AnalyticsMethods | null;
/**
 * Simpler hook that just returns the analytics track() method.
 *
 * @public
 */
declare const useTrack: () => ((eventName: string, conversionData?: ConversionDetails | undefined) => Promise<void>) | undefined;
/**
 * Simpler hook that just returns returns the analytics pageView method
 *
 * @public
 */
declare const usePageView: () => (() => Promise<void>) | undefined;
/**
 * Simpler hook that just returns the analytics identify method
 *
 * @public
 */
declare const useIdentify: () => ((visitor: Visitor) => void) | undefined;

/**
 * The main Analytics component for you to use. Sets up the proper react context
 * and bootstraps the Analytics reporter.
 *
 * @param props - A PropsWithChildren that implements AnalyticsProviderProps
 *
 * @public
 */
declare function AnalyticsProvider(props: PropsWithChildren<AnalyticsProviderProps>): JSX.Element;

/**
 * The useScope hook will return the current scope from the Analytics Scope. For
 * use within the context of an AnalyticsScopeProvider for scoping analytics events.
 */
declare const useScope: () => string;
/**
 * The AnalyticsScopeProvider will allow you to pre-pend a given string to all
 * events that happen in the node tree below where setScope is called.
 * For example, if you call setScope('header') and there is an `a` element
 * below whose onClick calls `track('my link')` the calculated event name
 * that will be sent to Yext Analytics is `header_mylink`
 *
 * @param props - AnalyticsScopeProps
 */
declare function AnalyticsScopeProvider(props: PropsWithChildren<AnalyticsScopeProps>): JSX.Element;

/**
 * The type definition for a thumbnail.
 *
 * @public
 */
type ThumbnailType = {
    height: number;
    width: number;
    url: string;
};
/**
 * The type definition for a complex image.
 *
 * @public
 */
type ComplexImageType = {
    image: {
        alternateText?: string;
        height: number;
        width: number;
        url: string;
        thumbnails?: ThumbnailType[];
    };
};
/**
 * The type definition for an image.
 *
 * @public
 */
type ImageType = {
    alternateText?: string;
    height: number;
    width: number;
    url: string;
};
/**
 * Layout option on the Image component.
 *
 * @public
 */
declare const ImageLayoutOption: {
    /**
     * The the default layout if one is not specified. An image will be scaled down to fit the
     * container but not exceed the absolute size of the image.
     */
    readonly INTRINSIC: "intrinsic";
    /**
     * Shows the image in a fixed size. `width` or `height` must be passed in. If both `width` and
     * `height` are passed in, but the aspect ratio does not match the aspect ratio of the image,
     * the image will be centered. This behavior can be adjusted using the `objectFit` and
     * `objectPosition` props of the `style` rpop.
     */
    readonly FIXED: "fixed";
    /** Shows the image in a fixed aspect ratio. The `aspectRatio` prop must be provided. */
    readonly ASPECT: "aspect";
    /** Always fills the image to 100% of the container's width. */
    readonly FILL: "fill";
};
/**
 * The type definition for the image layout.
 *
 * @public
 */
type ImageLayout = (typeof ImageLayoutOption)[keyof typeof ImageLayoutOption];
/**
 * The shape of the data passed to {@link Image}.
 */
interface BaseImageProps {
    /** The image field from Knowledge Graph. */
    image: ComplexImageType | ImageType;
    /** Overrides the className on the underlying img tag. */
    className?: string;
    /** Specifies how the image is rendered. */
    layout?: ImageLayout;
    /** The absolute width of the image. Only impacts if layout is set to "fixed". */
    width?: number;
    /** The absolute height of the image. Only impacts if layout is set to "fixed". */
    height?: number;
    /** The aspect ratio of the image. Only impacts if layout is set to "aspect". */
    aspectRatio?: number;
    /** A pass through react component that is displayed when the image is loading. */
    placeholder?: React$1.ReactNode;
    /** Pass through props that are on the native HTML img tag. The Image component may not work if src and/or srcsets are included. */
    imgOverrides?: Record<string, unknown>;
    /** The pass through style of the underlying img tag. */
    style?: React$1.CSSProperties;
    /** Set the loading state of the image. */
    loading?: "eager" | "lazy";
}
/**
 * The shape of the data passed to {@link Image} when layout is {@link ImageLayoutOption.INTRINSIC},
 * {@link ImageLayoutOption.FILL} or not provided.
 */
interface OtherImageProps extends BaseImageProps {
    /** Specifies how the image is rendered. */
    layout?: "intrinsic" | "fill";
}
/**
 * The shape of the data passed to {@link Image} when layout is {@link ImageLayoutOption.FIXED}.
 * Extends the {@link BaseImageProps} interface and has the additions of a width and height,
 * at least one of which must be specified.
 */
interface FixedImageProps extends BaseImageProps {
    /** Specifies how the image is rendered. */
    layout: "fixed";
    /** The absolute width of the image. Only impacts if layout is set to "fixed". */
    width?: number;
    /** The absolute height of the image. Only impacts if layout is set to "fixed". */
    height?: number;
}
/**
 * The shape of the data passed to {@link Image} when layout is {@link ImageLayoutOption.ASPECT}.
 * Extends the {@link BaseImageProps} interface and has the additions of a required aspectRatio.
 */
interface AspectImageProps extends BaseImageProps {
    /** Specifies how the image is rendered. */
    layout: "aspect";
    /** The aspect ratio of the image. Only impacts if layout is set to "aspect". */
    aspectRatio: number;
}
/**
 * The shape of the data passed to {@link Image}.
 *
 * @public
 */
type ImageProps = OtherImageProps | FixedImageProps | AspectImageProps;

/**
 * Renders an image based from the Yext Knowledge Graph. Example of using the component to render
 * simple and complex image fields from Yext Knowledge Graph:
 * ```
 * import { Image } from "@yext/pages/components";
 *
 * const simpleImage = (<Image image={document.logo} />);
 * const complexImage = (<Image image={document.photoGallery[0]} />);
 * ```
 *
 * @public
 */
declare const Image: ({ image, className, width, height, aspectRatio, layout, placeholder, imgOverrides, style, loading, }: ImageProps) => react_jsx_runtime.JSX.Element;

/**
 * Constants for available link types.
 *
 * @public
 */
declare const LinkTypes: {
    readonly URL: "URL";
    readonly Email: "Email";
    readonly Phone: "Phone";
};
/**
 * Type of link types that might be received from the platform.
 *
 * @public
 */
type LinkType = (typeof LinkTypes)[keyof typeof LinkTypes];
/**
 * Type for CTA field
 * Note that when coming from the platform the label will always be a string
 * but ReactNode allows for more general usage.
 *
 * @public
 */
interface CTA {
    link: string;
    label?: React.ReactNode;
    linkType?: LinkType;
}
/**
 * Configuration options available for any usages of the Link component.
 */
interface LinkConfig extends React.DetailedHTMLProps<React.AnchorHTMLAttributes<HTMLAnchorElement>, HTMLAnchorElement> {
    obfuscate?: boolean;
    eventName?: string;
    conversionDetails?: ConversionDetails | undefined;
}
/**
 * The shape of the data passed to {@link Link} when directly passing an HREF to the Link component.
 *
 * @public
 */
interface HREFLinkProps extends LinkConfig {
    href: string;
    cta?: never;
}
/**
 * The shape of the data passed to {@link Link} when using a CTA field, and not overriding children.
 *
 * @public
 */
interface CTAWithChildrenLinkProps extends LinkConfig {
    href?: never;
    cta: CTA;
    children?: React.ReactNode;
}
/**
 * The shape of the data passed to {@link Link} when using a CTA field, and overriding children.
 *
 * @public
 */
interface CTAWithoutChildrenLinkProps extends LinkConfig {
    href?: never;
    cta: Omit<CTA, "label">;
    children: React.ReactNode;
}
/**
 * The shape of the data passed to {@link Link} when using a CTA field.
 */
type CTALinkProps = CTAWithChildrenLinkProps | CTAWithoutChildrenLinkProps;
/**
 * The shape of the data passed to {@link Link}.
 *
 * @public
 */
type LinkProps = CTALinkProps | HREFLinkProps;

/**
 * Renders an anchor tag using either a directly provided HREF or from a field in the Yext Knowledge Graph.
 *
 * Example of using the component to render
 * a link with and without sourcing from a knowledge graph field:
 *
 * @example
 * ```ts
 * import { Link } from "@yext/pages/components";
 *
 * <Link href="/search">Locator</Link>
 * <Link cta={document.c_exampleCTA} />
 * <Link cta={{link: "https://www.yext.com", label: "Click Here", linkType: "URL"}} />
 * ```
 *
 * @public
 */
declare const Link: React__default.ForwardRefExoticComponent<(Omit<HREFLinkProps, "ref"> | Omit<CTAWithChildrenLinkProps, "ref"> | Omit<CTAWithoutChildrenLinkProps, "ref">) & React__default.RefAttributes<HTMLAnchorElement>>;

/**
 * This class represents a point on a sphere defined by latitude and longitude.
 * Latitude is a degree number in the range [-90, 90].
 * Longitude is a degree number without limits but is normalized to [-180, 180).
 */
declare class Coordinate$1 {
    /**
     * Constructor takes either 1 or 2 arguments.
     * 2 arguments: latitude and longitude.
     * 1 argument: an object with at least one {@link module:@yext/components-geo~Coordinate~LATITUDE_ALIASES latitude alias}
     * and one one {@link module:@yext/components-geo~CoordinateCoordinate~LONGITUDE_ALIASES longitude alias}.
     * @param {number|Object} latitudeOrObject
     * @param {number} [longitude] Optional only if the first argument is a {@link module:@yext/components-geo~Coordinate Coordinate}-like object
     */
    constructor(latitudeOrObject: number | Object, longitude?: number | undefined);
    set latitude(newLat: number);
    /**
     * Degrees latitude in the range [-90, 90].
     * If setting a value outside this range, it will be set to -90 or 90, whichever is closer.
     * @type {number}
     */
    get latitude(): number;
    set longitude(newLon: number);
    /**
     * Degrees longitude in the range [-Infinity, Infinity].
     * @type {number}
     */
    get longitude(): number;
    /**
     * Degrees longitude in the range [-180, 180).
     * If the coordinate's longitude is outside this range, the equivalent value within it is used.
     * Examples: 123 => 123, 270 => -90, -541 => 179
     * @type {number}
     */
    get normalLon(): number;
    _lat: number | undefined;
    _lon: number | undefined;
    /**
     * Add distance to the coordinate to change its position.
     * @param {number} latDist latitude distance
     * @param {number} lonDist longitude distance
     * @param {module:@yext/components-geo~Unit} [unit=Unit.DEGREE] The unit of latDist and lonDist
     * @param {module:@yext/components-geo~Projection} [projection=Projection.SPHERICAL] The projection of Earth (not relevant when using a physical distance unit, e.g. Mile)
     */
    add(latDist: number, lonDist: number, unit?: any, projection?: any): void;
    /**
     * Calculate the distance from this coordinate to another coordinate.
     * @param {module:@yext/components-geo~Coordinate} coordinate
     * @param {module:@yext/components-geo~Unit} [unit=Unit.MILE] The unit of distance
     * @param {module:@yext/components-geo~Projection} [projection=Projection.SPHERICAL] The projection of Earth (not relevant when using a physical distance unit, e.g. Mile)
     * @returns {number} Distance in the requested unit
     */
    distanceTo(coordinate: any, unit?: any, projection?: any): number;
    /**
     * Test if this coordinate has the same latitude and longitude as another.
     * @param {module:@yext/components-geo~Coordinate} coordinate
     * @returns {boolean}
     */
    equals(coordinate: any): boolean;
    /**
     * Get the coordinate as a string that can be used in a search query.
     * Example: {latitude: -45, longitude: 123} => '-45,123'
     * @returns {string}
     */
    searchQueryString(): string;
}

/**
 * This class represents a bounded coordinate region of a sphere.
 * The bounds are defined by two {@link module:@yext/components-geo~Coordinate Coordinates}: southwest and northeast.
 * If the northeast coordinate does not have a greater latitude and longitude than the soutwest
 * coordinate, the behavior of this object is undefined.
 */
declare class GeoBounds {
    /**
     * Create a new {@link module:@yext/components-geo~GeoBounds GeoBounds} with minimal area that
     * contains all the given coordinates
     * @param {module:@yext/components-geo~Coordinate[]} coordinates
     * @returns {module:@yext/components-geo~GeoBounds}
     */
    static fit(coordinates: any): any;
    /**
     * @param {module:@yext/components-geo~Coordinate} sw Southwest coordinate
     * @param {module:@yext/components-geo~Coordinate} ne Northeast coordinate
     */
    constructor(sw: any, ne: any);
    _ne: Coordinate$1;
    _sw: Coordinate$1;
    set ne(newNE: any);
    /**
     * Northeast coordinate
     * @type {module:@yext/components-geo~Coordinate}
     */
    get ne(): any;
    set sw(newSW: any);
    /**
     * Southwest coordinate
     * @type {module:@yext/components-geo~Coordinate}
     */
    get sw(): any;
    /**
     * Whether the coordinate lies within the region defined by the bounds.
     * {@link module:@yext/components-geo~Coordinate#normalLon Normalized longitudes} are used for the
     * bounds and the coordinate.
     * @param {module:@yext/components-geo~Coordinate} coordinate
     * @returns {boolean}
     */
    contains(coordinate: any): boolean;
    /**
     * Extend the bounds if necessary so that the coordinate is contained by them.
     * @param {module:@yext/components-geo~Coordinate} coordinate
     */
    extend(coordinate: any): void;
    /**
     * Calculate the center of the bounds using the given projection.
     * To find the visual center on a Mercator map, use Projection.MERCATOR.
     * To find the center for geolocation or geosearch purposes, use Projection.SPHERICAL.
     * @param {module:@yext/components-geo~Projection} [projection=Projection.SPHERICAL]
     * @returns {module:@yext/components-geo~Coordinate}
     */
    getCenter(projection?: any): any;
}

/**
 * An interactive map that supports various map providers, such as Google Maps and Mapbox, with a
 * single API. Code written using this class functions approximately the same regardless of the map
 * provider used. Any map provider can be supported via an instance of {@link module:@yext/components-maps~MapProvider MapProvider}.
 */
declare class Map$1 {
    /**
     * The {@link module:@yext/components-maps~MapProvider MapProvider} for the map must be loaded
     * before calling this constructor.
     * @param {module:@yext/components-maps~MapOptions} options
     */
    constructor(options: any);
    _defaultCenter: any;
    _defaultZoom: any;
    _legendPins: any;
    _provider: any;
    _singlePinZoom: any;
    _wrapper: any;
    _padding: {};
    _cachedBounds: GeoBounds | null;
    _resolveIdle: () => null;
    _resolveMoving: () => null;
    _idlePromise: Promise<void>;
    _panHandlerRunning: boolean;
    _panStartHandlerRunning: boolean;
    _map: any;
    _currentBounds: any;
    /**
     * Set the map bounds so that all the given coordinates are within the {@link module:@yext/components-maps~MapOptions#withPadding padded}
     * view.
     * @param {module:@yext/components-tsx-geo~Coordinate[]} coordinates
     * @param {boolean} [animated=false] Whether to transition smoothly to the new bounds
     * @param {number} [maxZoom=singlePinZoom] The max zoom level after fitting. Uses {@link module:@yext/components-maps~MapOptions#withSinglePinZoom singlePinZoom}
     *   by default.
     */
    fitCoordinates(coordinates: any, animated?: boolean | undefined, maxZoom?: number | undefined): void;
    /**
     * Get the current visible region of the map. If the map is zoomed out to show multiple copies of
     * the world, the longitude bounds will be outside [-180, 180) but the center will always be
     * within [-180, 180).
     * @returns {module:@yext/components-tsx-geo~GeoBounds}
     */
    getBounds(): any;
    /**
     * @returns {module:@yext/components-tsx-geo~Coordinate} The center of the current visible region of
     *   the map
     */
    getCenter(): any;
    /**
     * Intended for internal use only
     * @returns {module:@yext/components-maps~ProviderMap} The map's {@link module:@yext/components-maps~ProviderMap ProviderMap}
     *   instance
     */
    getProviderMap(): any;
    /**
     * To standardize zoom for all providers, zoom level is calculated with this formula:
     * zoom = log2(pixel width of equator) - 8.
     * At zoom = 0, the entire world is 256 pixels wide.
     * At zoom = 1, the entire world is 512 pixels wide.
     * Zoom 2 → 1024 pixels, zoom 3 → 2056 pixels, etc.
     * Negative and non-integer zoom levels are valid and follow the formula.
     * @returns {number} The current zoom level of the map
     */
    getZoom(): number;
    /**
     * Returns when the map is not moving.
     * Use map.idle().then(callback) to run callback immediately if the map is currently idle or once
     * the map becomes idle if it's not.
     */
    idle(): Promise<void>;
    /**
     * Returns when the map is moving.
     * Use map.moving().then(callback) to run callback immediately if the map is currently moving or
     * once the map starts moving if it's not.
     */
    moving(): Promise<void>;
    /**
     * @returns {module:@yext/components-maps~MapPinOptions} A {@link module:@yext/components-maps~MapPinOptions MapPinOptions}
     *   instance with the same provider as this map
     */
    newPinOptions(): any;
    /**
     * Called when the map has finished moving, at most once per animation frame.
     * Passes the current and previous bounds to the custom pan handler given by {@link module:@yext/components-maps~MapOptions#withPanHandler MapOptions#withPanHandler}
     */
    panHandler(): void;
    /**
     * Called when the map has started moving, at most once per animation frame.
     * Passes the current bounds to the custom pan handler given by {@link module:@yext/components-maps~MapOptions#withPanStartHandler MapOptions#withPanStartHandler}
     */
    panStartHandler(): void;
    /**
     * @param {Object} bounds
     * @param {Object} bounds.ne The northeast corner of the bounds -- must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
     * @param {Object} bounds.sw The southwest corner of the bounds -- must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
     * @param {boolean} [animated=false] Whether to transition smoothly to the new bounds
     * @param {Object} [padding={}]
     * @param {number|module:@yext/components-maps~PaddingFunction} padding.bottom Minimum number of
     *   pixels between the map's bottom edge and a pin
     * @param {number|module:@yext/components-maps~PaddingFunction} padding.left Minimum number of
     *   pixels between the map's left edge and a pin
     * @param {number|module:@yext/components-maps~PaddingFunction} padding.right Minimum number of
     *   pixels between the map's right edge and a pin
     * @param {number|module:@yext/components-maps~PaddingFunction} padding.top Minimum number of
     *   pixels between the map's top edge and a pin
     * @param {number} [maxZoom=Infinity]
     */
    setBounds({ ne, sw }: {
        ne: Object;
        sw: Object;
    }, animated?: boolean | undefined, padding?: Object | undefined, maxZoom?: number | undefined): void;
    /**
     * @param {Object} coordinate Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
     * @param {boolean} [animated=false] Whether to transition smoothly to the new center
     */
    setCenter(coordinate: Object, animated?: boolean | undefined): void;
    /**
     * Padding is used by {@link module:@yext/components-maps~Map#fitCoordinates Map#fitCoordinates}.
     * Padding can either be constant values or funtions that return a padding value.
     * Constant values are good if the map should always have the same padding on every breakpoint.
     * Functions are useful if the map should have different padding at different breakpoints/layouts.
     * The function can check window.innerWidth or any other condition before returning a number.
     * @param {Object} padding
     * @param {number|module:@yext/components-maps~PaddingFunction} padding.bottom Minimum number of
     *   pixels between the map's bottom edge and a pin
     * @param {number|module:@yext/components-maps~PaddingFunction} padding.left Minimum number of
     *   pixels between the map's left edge and a pin
     * @param {number|module:@yext/components-maps~PaddingFunction} padding.right Minimum number of
     *   pixels between the map's right edge and a pin
     * @param {number|module:@yext/components-maps~PaddingFunction} padding.top Minimum number of
     *   pixels between the map's top edge and a pin
     * @returns {module:@yext/components-maps~Map}
     */
    setPadding({ bottom, left, right, top, }: Object): any;
    /**
     * @param {module:@yext/components-maps~Map~panHandler} panHandler
     */
    setPanHandler(panHandler: any): void;
    _panHandler: any;
    /**
     * @param {module:@yext/components-maps~Map~panStartHandler} panStartHandler
     */
    setPanStartHandler(panStartHandler: any): void;
    _panStartHandler: any;
    /**
     * @param {number} zoom
     * @param {boolean} [animated=false] Whether to transition smoothly to the new zoom
     * @see module:@yext/components-maps~Map#getZoom
     */
    setZoom(zoom: number, animated?: boolean | undefined): void;
    /**
     * @param {number} zoom
     * @param {Object} center Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
     * @param {boolean} [animated=false] Whether to transition smoothly to the new bounds
     * @see module:@yext/components-maps~Map#setZoom
     * @see module:@yext/components-maps~Map#setCenter
     */
    setZoomCenter(zoom: number, center: Object, animated?: boolean | undefined): void;
    /**
     * Set the map state to idle
     * @protected
     */
    protected _setIdle(): void;
    _movingPromise: Promise<any> | undefined;
    /**
     * Set the map state to moving
     * @protected
     */
    protected _setMoving(): void;
}

/**
 * A pin for a {@link module:@yext/components-maps~Map Map} that displays at a given {@link module:@yext/components-tsx-geo~Coordinate Coordinate}.
 * A MapPin can be displayed on at most one Map at a time. Pins support event handlers for clicking,
 * hovering, and focusing. The pin can change its appearance based on its current status, which is
 * changed by {@link module:@yext/components-maps~MapPin#setStatus setStatus}.
 */
declare class MapPin {
    /**
     * @param {module:@yext/components-maps~MapPinOptions} options
     */
    constructor(options: any);
    _coordinate: any;
    _hideOffscreen: any;
    _icons: any;
    _propertiesForStatus: any;
    _type: any;
    _clickHandler: () => null;
    _focusHandler: (focused: any) => null;
    _hoverHandler: (hovered: any) => null;
    _hidden: boolean;
    _cancelHiddenUpdater: () => null;
    _map: any;
    _pin: any;
    _status: {};
    /**
     * @returns {module:@yext/components-tsx-geo~Coordinate} The coordinate of the pin
     */
    getCoordinate(): any;
    /**
     * Get the icon for a string key, such as 'default', 'hovered', or 'selected'
     * @param {string} key The unique name of the icon
     * @returns {string} The URL or data URI of the icon image
     * @see module:@yext/components-maps~MapPinOptions#withIcon
     */
    getIcon(key: string): string;
    /**
     * @returns {module:@yext/components-maps~Map} The map that the pin is currently on, or null if
     * not on a map
     */
    getMap(): any;
    /**
     * Intended for internal use only
     * @returns {module:@yext/components-maps~ProviderPin} The pin's {@link module:@yext/components-maps~ProviderPin ProviderPin}
     *   instance
     */
    getProviderPin(): any;
    /**
     * @returns {string} The string describing the type of pin
     */
    getType(): string;
    /**
     * Remove this pin from its current map, if on one.
     */
    remove(): void;
    /**
     * Set a handler function for when the pin is clicked, replacing any previously set click handler.
     * @param {module:@yext/components-maps~PinClickHandler} clickHandler
     */
    setClickHandler(clickHandler: any): void;
    /**
     * @param {Object} coordinate Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
     */
    setCoordinate(coordinate: Object): void;
    /**
     * Set a handler function for when the pin is (un)focused, replacing any previously set focus handler.
     * @param {module:@yext/components-maps~PinFocusHandler} focusHandler
     */
    setFocusHandler(focusHandler: any): void;
    /**
     * Set a handler function for when the pin is (un)hovered, replacing any previously set hover handler.
     * @param {module:@yext/components-maps~PinHoverHandler} hoverHandler
     */
    setHoverHandler(hoverHandler: any): void;
    /**
     * Add the pin to a map, removing it from its current map if on one.
     * @param {?Map} map
     */
    setMap(map: Map$1 | null): void;
    /**
     * Assign all properties in an object to the pin's status.
     * Example: if the pin's status is { a: true, b: true }, passing in { a: false, c: true } will
     * change the pin's status to { a: false, b: true, c: true }
     * @param {Object} status
     */
    setStatus(status: Object): void;
    /**
     * Add or remove the pin from the map based on whether its coordinate is within the current bounds
     * @protected
     */
    protected _hideIfOffscreen(): void;
}

/**
 * This class is used for loading the API for a map provider such as Google Maps and creating {@link module:@yext/components-maps~ProviderMap ProviderMap}
 * and {@link module:@yext/components-maps~ProviderPin ProviderPin} instances.
 * Provider map implementations return an instance of this class for their provider that you can use
 * to load the API and pass in to {@link module:@yext/components-maps~MapOptions MapOptions} and {@link module:@yext/components-maps~MapPinOptions MapPinOptions} objects as the provider.
 * Example using {@link module:@yext/components-maps~GoogleMaps GoogleMaps}, an instance of this
 * class: GoogleMaps.load().then(() => map = new MapOptions().withProvider(GoogleMaps).build());
 */
declare class MapProvider {
    /**
     * @param {module:@yext/components-maps~MapProviderOptions} options
     */
    constructor(options: any);
    _loadFunction: any;
    _mapClass: any;
    _pinClass: any;
    _providerName: any;
    _loadPromise: Promise<any>;
    _resolveLoad: (value: any) => void;
    _rejectLoad: (reason?: any) => void;
    _apiKey: string;
    _loadInvoked: boolean;
    _loaded: boolean;
    _options: {};
    /**
     * Returns true if the map provider has been successfully loaded
     * @type {boolean}
     */
    get loaded(): boolean;
    /**
     * @returns {module:@yext/components-maps~ProviderMap}
     * @see module:@yext/components-maps~MapProviderOptions#withMapClass
     */
    getMapClass(): any;
    /**
     * @returns {module:@yext/components-maps~ProviderPin}
     * @see module:@yext/components-maps~MapProviderOptions#withPinClass
     */
    getPinClass(): any;
    /**
     * @returns {string}
     * @see module:@yext/components-maps~MapProviderOptions#withProviderName
     */
    getProviderName(): string;
    /**
     * Call {@link module:@yext/components-maps~MapPinOptions~loadFunction MapPinOptions~loadFunction}
     * and resolve or reject when loading succeeds or fails
     * @async
     * @param {string} [apiKey] Provider API key -- uses value from {@link module:@yext/components-maps~MapProvider#setLoadOptions MapProvider#setLoadOptions}
     *   if not passed
     * @param {Object} [options] Additional provider-specific options -- uses value from {@link module:@yext/components-maps~MapProvider#setLoadOptions MapProvider#setLoadOptions}
     *   if not passed
     */
    load(apiKey?: string | undefined, options?: Object | undefined): Promise<void>;
    /**
     * Resolves or rejects when the map provider has loaded successfully or unsuccessfully
     * @async
     */
    ready(): Promise<void>;
    /**
     * Set the API key and provider options used on load. Does nothing if load was already called.
     * @param {string} apiKey Provider API key
     * @param {?Object} [options=null] Additional provider-specific options
     */
    setLoadOptions(apiKey: string, options?: Object | null | undefined): void;
}

interface Coordinate {
    latitude: number;
    longitude: number;
}
interface MapContextType {
    map: Map$1;
    provider: MapProvider;
}
interface MapProps {
    apiKey?: string;
    bounds?: Coordinate[];
    className?: string;
    clientKey?: string;
    children?: any;
    controls: boolean;
    defaultCenter?: Coordinate;
    defaultZoom?: number;
    mapRef?: React__default.MutableRefObject<Map$1 | null>;
    padding?: number | {
        bottom: number | (() => number);
        left: number | (() => number);
        right: number | (() => number);
        top: number | (() => number);
    };
    panHandler: (previousBounds: GeoBounds, currentBounds: GeoBounds) => void;
    panStartHandler?: (currentBounds: GeoBounds) => void;
    provider: MapProvider;
    providerOptions?: {
        [key: string]: any;
    };
    singleZoom: number;
}
interface MarkerProps {
    children?: React__default.ReactChild;
    coordinate: Coordinate;
    hideOffscreen?: boolean;
    icon?: JSX.Element;
    id: string;
    onClick: (id: string) => void;
    onHover: (hovered: boolean, id: string) => void;
    onFocus: (focused: boolean, id: string) => void;
    statusOptions?: {
        [key: string]: boolean;
    };
    zIndex?: number;
}
type ClusterTemplateProps = {
    count?: number;
};
type ClustererProps = {
    clusterRadius?: number;
    children: JSX.Element[] | JSX.Element;
    ClusterTemplate?: (props: ClusterTemplateProps) => JSX.Element;
};
type PinStoreType = {
    id: string;
    pin: MapPin;
};
interface ClustererContextType {
    clusters: PinStoreType[][];
    clusterIds: string[];
    setPinStore: React__default.Dispatch<React__default.SetStateAction<PinStoreType[]>>;
}

declare function useMapContext(): Map$1;
declare const Map: {
    ({ apiKey, bounds, children, className, clientKey, controls, defaultCenter, defaultZoom, mapRef, padding, panStartHandler, panHandler, provider, providerOptions, singleZoom, }: MapProps): react_jsx_runtime.JSX.Element;
    defaultProps: {
        controls: boolean;
        defaultCenter: {
            latitude: number;
            longitude: number;
        };
        defaultZoom: number;
        padding: {
            bottom: number;
            left: number;
            right: number;
            top: number;
        };
        panHandler: () => null;
        panStartHandler: () => null;
        provider: any;
        providerOptions: {};
        singleZoom: number;
    };
};

declare const Marker: {
    ({ children, coordinate, hideOffscreen, id, icon, onClick, onFocus, onHover, zIndex, }: MarkerProps): JSX.Element | null;
    defaultProps: {
        hideOffscreen: boolean;
        icon: react_jsx_runtime.JSX.Element;
        onClick: () => null;
        onHover: () => null;
        onFocus: () => null;
    };
};

declare function useClusterContext(): ClustererContextType;
declare const Clusterer: ({ clusterRadius, children, ClusterTemplate, }: ClustererProps) => react_jsx_runtime.JSX.Element;

interface LocationMapProps extends MapProps {
    children?: React.ReactChild;
    coordinate: Coordinate;
    linkSameTab?: boolean;
    pinUrl?: string;
    onClick?: (id: string) => void;
    onHover?: (hovered: boolean, id: string) => void;
    onFocus?: (focused: boolean, id: string) => void;
}

declare const LocationMap: {
    ({ children, coordinate, linkSameTab, pinUrl, onClick, onHover, onFocus, ...mapProps }: LocationMapProps): react_jsx_runtime.JSX.Element;
    defaultProps: {
        controls: boolean;
        panHandler: () => null;
        provider: any;
        singleZoom: number;
    };
};

/**
 * The shape of data passed to {@link LexicalRichText}.
 */
interface LexicalRichTextProps {
    /** A JSON-serialized Lexical Dev AST. */
    serializedAST: string;
    /** CSS Class names for the various Lexical Node types. */
    nodeClassNames?: EditorThemeClasses;
}

/**
 * Renders a read-only view of a Lexical Rich Text field. Styling for the various
 * types of Rich Text element can be optionally provided. If not provided, Yext default
 * styling will be applied.
 */
declare function LexicalRichText({ serializedAST, nodeClassNames, }: LexicalRichTextProps): react_jsx_runtime.JSX.Element;

/**
 * A Component for rendering the legacy rich text field. This field's value
 * is stored as "Yext" Markdown.
 */
declare const LegacyRichText: (props: {
    markdown: string;
}) => ReactElement<any, string | React$1.JSXElementConstructor<any>> | null;

declare class HoursIntervalManipulator {
    end: Date;
    start: Date;
    /**
     * @param date - the Date for the day on which the interval starts
     * @param interval - the Yext Streams interval data
     */
    constructor(date: Date, interval: IntervalType);
    /**
     * @param date - A moment in time
     * @returns True if the given moment is within the interval
     */
    contains(date: Date): boolean;
    /**
     * @param opts - intl.DateTimeFormatOptions
     * @param locale - defaults to 'en-US'
     * @returns representation of this interval's start time
     */
    getStartTime(locale?: string, opts?: Intl.DateTimeFormatOptions): string;
    /**
     * @param opts - intl.DateTimeFormatOptions
     * @param locale - defaults to 'en-US'
     * @returns representation of this interval's end time
     */
    getEndTime(locale?: string, opts?: Intl.DateTimeFormatOptions): string;
    /**
     * @param other - HoursIntervalManipulator
     * @returns if this interval and 'other' have the same start/end
     */
    timeIsEqualTo(other: HoursIntervalManipulator): boolean;
}
declare class HoursManipulator {
    holidayHoursByDate: Record<string, HolidayType>;
    hours: HoursType;
    /**
     * @param hours - Hours object in the format returned by Yext Streams
     */
    constructor(hours: HoursType);
    /**
     * @param date - A moment in time
     * @returns The first interval that contains the given moment, null if none
     */
    getInterval(date: Date): HoursIntervalManipulator | null;
    /**
     * @returns The first interval that contains the current time, null if none
     */
    getCurrentInterval(): HoursIntervalManipulator | null;
    /**
     * @param date - A moment in time
     * @returns The next interval that hasn't started as of the given moment
     */
    getIntervalAfter(date: Date): HoursIntervalManipulator | null;
    /**
     * @returns The next interval that hasn't started as of the current time
     */
    getNextInterval(): HoursIntervalManipulator | null;
    /**
     * @param n - number of days to check
     * @param startDate - first day to check
     * @returns list of intervals in range [startDate, startDate+7]
     */
    getIntervalsForNDays(n: number, startDate: Date): HoursIntervalManipulator[];
    /**
     * @param date - The day to get the hours for
     * @returns The daily holiday hours object from the original Streams response for the
     *   given date, null if none
     */
    getHolidayHours(date: Date): HolidayType | null;
    /**
     * @param date - The day to get the hours for
     * @returns The daily normal hours object from the original Streams response for the
     *   given date, null if none
     */
    getNormalHours(date: Date): DayType | null;
    /**
     * @param date - The day to get the hours for
     * @returns The daily hours object from the original Streams response for the given
     *   date, null if none
     */
    getHours(date: Date): DayType | HolidayType | null;
    /**
     * @param date - A day
     * @returns True if the given day has holiday hours
     */
    isHoliday(date: Date): boolean;
    /**
     * Yext platform uses the field `hours.reopenDate` to indicate an entity is
     *  temporarily closed for more than one day.
     * @param targetDate - the date to check against
     * @returns True if the given date is before 'reopenDate'
     */
    isTemporarilyClosedAt(targetDate: Date): boolean;
    /**
     * @param date - A moment in time
     * @returns True if the given moment falls within any interval
     */
    isOpenAt(date: Date): boolean;
    /**
     * @returns True if the current time falls within any interval
     */
    isOpenNow(): boolean;
    /**
     * Convert ISO Date which have 1-based months, to Yext date string which have 0-based months
     * @param date - a moment in time
     * @returns a Yext date string
     */
    transformDateToYext(date: Date): string;
}

interface WeekType {
    monday?: DayType;
    tuesday?: DayType;
    wednesday?: DayType;
    thursday?: DayType;
    friday?: DayType;
    saturday?: DayType;
    sunday?: DayType;
}
interface DayType {
    isClosed: boolean;
    openIntervals: IntervalType[];
}
interface HolidayType {
    date: string;
    isClosed?: boolean;
    openIntervals: IntervalType[];
    isRegularHours: boolean;
}
interface IntervalType {
    start: string;
    end: string;
}
interface HoursType extends WeekType {
    holidayHours?: HolidayType[];
    reopenDate?: string;
}
type DayOfWeekNames = {
    [Property in keyof WeekType]?: string;
};
interface HoursTableProps {
    /** Hours data from Yext Streams */
    hours: HoursType;
    /** Label for each day of week, ordered starting from Sunday */
    dayOfWeekNames?: DayOfWeekNames;
    /** Set the day of the first row of the table */
    startOfWeek?: keyof DayOfWeekNames | "today";
    timeOptions?: Intl.DateTimeFormatOptions;
    /** Combine adjacent rows (days) with the same intervals */
    collapseDays?: boolean;
    /** Override rendering for the interval on each table row */
    intervalStringsBuilderFn?: (h: HoursTableDayData, t?: Intl.DateTimeFormatOptions) => string[];
    className?: string;
}
interface HoursTableDayData {
    dayOfWeek: string;
    intervals: HoursIntervalManipulator[];
    sortIdx: number;
    isToday: boolean;
    startDay?: string;
    endDay?: string;
}

/**
 * The HoursTable component uses HoursManipulator data to generate a table
 * listing the business hours of the entity.
 */
declare const Hours: React__default.FC<HoursTableProps>;

/**
 * @type {module:@yext/components-maps~MapProvider}
 */
declare const BaiduMaps: any;

/**
 * @type {module:@yext/components-maps~MapProvider}
 */
declare const BingMaps: any;

/**
 * @type {module:@yext/components-maps~MapProvider}
 */
declare const GoogleMaps: any;

/**
 * @type {module:@yext/components-maps~MapProvider}
 */
declare const MapboxMaps: any;

/**
 * @type {module:@yext/components-maps~MapProvider}
 */
declare const LeafletMaps: any;

/**
 * @type {module:@yext/components-maps~MapProvider}
 */
declare const MapQuestMaps: any;

export { Address, type AddressLine, type AddressLineProps, type AddressProps, type AddressType, Analytics, AnalyticsContext, AnalyticsProvider, AnalyticsScopeProvider, BaiduMaps, BingMaps, type CTA, type CTAWithChildrenLinkProps, type CTAWithoutChildrenLinkProps, type ClusterTemplateProps, Clusterer, type ClustererContextType, type ClustererProps, type ComplexImageType, type Coordinate, type DayOfWeekNames, type DayType, type GetDirectionsConfig, GoogleMaps, type HREFLinkProps, type HolidayType, Hours, HoursManipulator, type HoursTableDayData, type HoursTableProps, type HoursType, Image, type ImageLayout, ImageLayoutOption, type ImageProps, type ImageType, type IntervalType, LeafletMaps, LegacyRichText, LexicalRichText, type LexicalRichTextProps, Link, type LinkProps, type LinkType, LinkTypes, type ListingPublisher, ListingPublisherOption, type ListingType, LocationMap, type LocationMapProps, Map, type MapContextType, type MapProps, type MapProvider$1 as MapProvider, MapProviderOption, MapQuestMaps, MapboxMaps, Marker, type MarkerProps, type PinStoreType, type ThumbnailType, type WeekType, getDirections, useAnalytics, useClusterContext, useIdentify, useMapContext, usePageView, useScope, useTrack };
