import zn from "react";
import { n as cr, c as fr, g as Hn, m as K, a as D, s as In, p as Sn, r as Pe, b as De, d as Tn, e as vn, f as me, h as pr, i as hr, j as dr, k as ge, l as bn, o as mr, v as gr } from "./index-i0mhhNq7.js";
import "react-dom";
function yr(n) {
  const t = [];
  let e = -1;
  for (; ++e < n.footnoteOrder.length; ) {
    const r = n.footnoteById[n.footnoteOrder[e]];
    if (!r)
      continue;
    const i = n.all(r), l = String(r.identifier).toUpperCase(), o = cr(l.toLowerCase());
    let a = 0;
    const c = [];
    for (; ++a <= n.footnoteCounts[l]; ) {
      const p = {
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + n.clobberPrefix + "fnref-" + o + (a > 1 ? "-" + a : ""),
          dataFootnoteBackref: !0,
          className: ["data-footnote-backref"],
          ariaLabel: n.footnoteBackLabel
        },
        children: [{ type: "text", value: "↩" }]
      };
      a > 1 && p.children.push({
        type: "element",
        tagName: "sup",
        children: [{ type: "text", value: String(a) }]
      }), c.length > 0 && c.push({ type: "text", value: " " }), c.push(p);
    }
    const s = i[i.length - 1];
    if (s && s.type === "element" && s.tagName === "p") {
      const p = s.children[s.children.length - 1];
      p && p.type === "text" ? p.value += " " : s.children.push({ type: "text", value: " " }), s.children.push(...c);
    } else
      i.push(...c);
    const d = {
      type: "element",
      tagName: "li",
      properties: { id: n.clobberPrefix + "fn-" + o },
      children: n.wrap(i, !0)
    };
    n.patch(r, d), t.push(d);
  }
  if (t.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: n.footnoteLabelTagName,
          properties: {
            // To do: use structured clone.
            ...JSON.parse(JSON.stringify(n.footnoteLabelProperties)),
            id: "footnote-label"
          },
          children: [{ type: "text", value: n.footnoteLabel }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: n.wrap(t, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
function Ot(n, t) {
  const e = fr(n, t), r = e.one(n, null), i = yr(e);
  return i && r.children.push({ type: "text", value: `
` }, i), Array.isArray(r) ? { type: "root", children: r } : r;
}
const xr = (
  /** @type {(import('unified').Plugin<[Processor, Options?]|[null|undefined, Options?]|[Options]|[], MdastRoot>)} */
  function(n, t) {
    return n && "run" in n ? kr(n, t) : Sr(n || t);
  }
), br = xr;
function kr(n, t) {
  return (e, r, i) => {
    n.run(Ot(e, t), r, (l) => {
      i(l);
    });
  };
}
function Sr(n) {
  return (t) => Ot(t, n);
}
const Be = ["http", "https", "mailto", "tel"];
function wr(n) {
  const t = (n || "").trim(), e = t.charAt(0);
  if (e === "#" || e === "/")
    return t;
  const r = t.indexOf(":");
  if (r === -1)
    return t;
  let i = -1;
  for (; ++i < Be.length; ) {
    const l = Be[i];
    if (r === l.length && t.slice(0, l.length).toLowerCase() === l)
      return t;
  }
  return i = t.indexOf("?"), i !== -1 && r > i || (i = t.indexOf("#"), i !== -1 && r > i) ? t : "javascript:void(0)";
}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var Er = function(t) {
  return t != null && t.constructor != null && typeof t.constructor.isBuffer == "function" && t.constructor.isBuffer(t);
};
const It = /* @__PURE__ */ Hn(Er);
function qn(n) {
  return !n || typeof n != "object" ? "" : "position" in n || "type" in n ? je(n.position) : "start" in n || "end" in n ? je(n) : "line" in n || "column" in n ? ye(n) : "";
}
function ye(n) {
  return $e(n && n.line) + ":" + $e(n && n.column);
}
function je(n) {
  return ye(n && n.start) + "-" + ye(n && n.end);
}
function $e(n) {
  return n && typeof n == "number" ? n : 1;
}
class wn extends Error {
  /**
   * Create a message for `reason` at `place` from `origin`.
   *
   * When an error is passed in as `reason`, the `stack` is copied.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   *
   *   > 👉 **Note**: you should use markdown.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // To do: next major: expose `undefined` everywhere instead of `null`.
  constructor(t, e, r) {
    const i = [null, null];
    let l = {
      // @ts-expect-error: we always follows the structure of `position`.
      start: { line: null, column: null },
      // @ts-expect-error: "
      end: { line: null, column: null }
    };
    if (super(), typeof e == "string" && (r = e, e = void 0), typeof r == "string") {
      const o = r.indexOf(":");
      o === -1 ? i[1] = r : (i[0] = r.slice(0, o), i[1] = r.slice(o + 1));
    }
    e && ("type" in e || "position" in e ? e.position && (l = e.position) : "start" in e || "end" in e ? l = e : ("line" in e || "column" in e) && (l.start = e)), this.name = qn(e) || "1:1", this.message = typeof t == "object" ? t.message : t, this.stack = "", typeof t == "object" && t.stack && (this.stack = t.stack), this.reason = this.message, this.fatal, this.line = l.start.line, this.column = l.start.column, this.position = l, this.source = i[0], this.ruleId = i[1], this.file, this.actual, this.expected, this.url, this.note;
  }
}
wn.prototype.file = "";
wn.prototype.name = "";
wn.prototype.reason = "";
wn.prototype.message = "";
wn.prototype.stack = "";
wn.prototype.fatal = null;
wn.prototype.column = null;
wn.prototype.line = null;
wn.prototype.source = null;
wn.prototype.ruleId = null;
wn.prototype.position = null;
const Cn = { basename: vr, dirname: Cr, extname: Tr, join: Pr, sep: "/" };
function vr(n, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  Vn(n);
  let e = 0, r = -1, i = n.length, l;
  if (t === void 0 || t.length === 0 || t.length > n.length) {
    for (; i--; )
      if (n.charCodeAt(i) === 47) {
        if (l) {
          e = i + 1;
          break;
        }
      } else
        r < 0 && (l = !0, r = i + 1);
    return r < 0 ? "" : n.slice(e, r);
  }
  if (t === n)
    return "";
  let o = -1, a = t.length - 1;
  for (; i--; )
    if (n.charCodeAt(i) === 47) {
      if (l) {
        e = i + 1;
        break;
      }
    } else
      o < 0 && (l = !0, o = i + 1), a > -1 && (n.charCodeAt(i) === t.charCodeAt(a--) ? a < 0 && (r = i) : (a = -1, r = o));
  return e === r ? r = o : r < 0 && (r = n.length), n.slice(e, r);
}
function Cr(n) {
  if (Vn(n), n.length === 0)
    return ".";
  let t = -1, e = n.length, r;
  for (; --e; )
    if (n.charCodeAt(e) === 47) {
      if (r) {
        t = e;
        break;
      }
    } else
      r || (r = !0);
  return t < 0 ? n.charCodeAt(0) === 47 ? "/" : "." : t === 1 && n.charCodeAt(0) === 47 ? "//" : n.slice(0, t);
}
function Tr(n) {
  Vn(n);
  let t = n.length, e = -1, r = 0, i = -1, l = 0, o;
  for (; t--; ) {
    const a = n.charCodeAt(t);
    if (a === 47) {
      if (o) {
        r = t + 1;
        break;
      }
      continue;
    }
    e < 0 && (o = !0, e = t + 1), a === 46 ? i < 0 ? i = t : l !== 1 && (l = 1) : i > -1 && (l = -1);
  }
  return i < 0 || e < 0 || // We saw a non-dot character immediately before the dot.
  l === 0 || // The (right-most) trimmed path component is exactly `..`.
  l === 1 && i === e - 1 && i === r + 1 ? "" : n.slice(i, e);
}
function Pr(...n) {
  let t = -1, e;
  for (; ++t < n.length; )
    Vn(n[t]), n[t] && (e = e === void 0 ? n[t] : e + "/" + n[t]);
  return e === void 0 ? "." : Or(e);
}
function Or(n) {
  Vn(n);
  const t = n.charCodeAt(0) === 47;
  let e = Ir(n, !t);
  return e.length === 0 && !t && (e = "."), e.length > 0 && n.charCodeAt(n.length - 1) === 47 && (e += "/"), t ? "/" + e : e;
}
function Ir(n, t) {
  let e = "", r = 0, i = -1, l = 0, o = -1, a, c;
  for (; ++o <= n.length; ) {
    if (o < n.length)
      a = n.charCodeAt(o);
    else {
      if (a === 47)
        break;
      a = 47;
    }
    if (a === 47) {
      if (!(i === o - 1 || l === 1))
        if (i !== o - 1 && l === 2) {
          if (e.length < 2 || r !== 2 || e.charCodeAt(e.length - 1) !== 46 || e.charCodeAt(e.length - 2) !== 46) {
            if (e.length > 2) {
              if (c = e.lastIndexOf("/"), c !== e.length - 1) {
                c < 0 ? (e = "", r = 0) : (e = e.slice(0, c), r = e.length - 1 - e.lastIndexOf("/")), i = o, l = 0;
                continue;
              }
            } else if (e.length > 0) {
              e = "", r = 0, i = o, l = 0;
              continue;
            }
          }
          t && (e = e.length > 0 ? e + "/.." : "..", r = 2);
        } else
          e.length > 0 ? e += "/" + n.slice(i + 1, o) : e = n.slice(i + 1, o), r = o - i - 1;
      i = o, l = 0;
    } else
      a === 46 && l > -1 ? l++ : l = -1;
  }
  return e;
}
function Vn(n) {
  if (typeof n != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(n)
    );
}
const Ar = { cwd: Rr };
function Rr() {
  return "/";
}
function xe(n) {
  return n !== null && typeof n == "object" && // @ts-expect-error: indexable.
  n.href && // @ts-expect-error: indexable.
  n.origin;
}
function _r(n) {
  if (typeof n == "string")
    n = new URL(n);
  else if (!xe(n)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + n + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (n.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return Lr(n);
}
function Lr(n) {
  if (n.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = n.pathname;
  let e = -1;
  for (; ++e < t.length; )
    if (t.charCodeAt(e) === 37 && t.charCodeAt(e + 1) === 50) {
      const r = t.charCodeAt(e + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(t);
}
const Zn = ["history", "path", "basename", "stem", "extname", "dirname"];
class At {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Buffer` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let e;
    t ? typeof t == "string" || zr(t) ? e = { value: t } : xe(t) ? e = { path: t } : e = t : e = {}, this.data = {}, this.messages = [], this.history = [], this.cwd = Ar.cwd(), this.value, this.stored, this.result, this.map;
    let r = -1;
    for (; ++r < Zn.length; ) {
      const l = Zn[r];
      l in e && e[l] !== void 0 && e[l] !== null && (this[l] = l === "history" ? [...e[l]] : e[l]);
    }
    let i;
    for (i in e)
      Zn.includes(i) || (this[i] = e[i]);
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {string | URL} path
   */
  set path(t) {
    xe(t) && (t = _r(t)), ee(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the parent path (example: `'~'`).
   */
  get dirname() {
    return typeof this.path == "string" ? Cn.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   */
  set dirname(t) {
    Ne(this.basename, "dirname"), this.path = Cn.join(t || "", this.basename);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   */
  get basename() {
    return typeof this.path == "string" ? Cn.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set basename(t) {
    ee(t, "basename"), ne(t, "basename"), this.path = Cn.join(this.dirname || "", t);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   */
  get extname() {
    return typeof this.path == "string" ? Cn.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   */
  set extname(t) {
    if (ne(t, "extname"), Ne(this.dirname, "extname"), t) {
      if (t.charCodeAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Cn.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   */
  get stem() {
    return typeof this.path == "string" ? Cn.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set stem(t) {
    ee(t, "stem"), ne(t, "stem"), this.path = Cn.join(this.dirname || "", t + (this.extname || ""));
  }
  /**
   * Serialize the file.
   *
   * @param {BufferEncoding | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Buffer`
   *   (default: `'utf8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return (this.value || "").toString(t || void 0);
  }
  /**
   * Create a warning message associated with the file.
   *
   * Its `fatal` is set to `false` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, e, r) {
    const i = new wn(t, e, r);
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Create an info message associated with the file.
   *
   * Its `fatal` is set to `null` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, e, r) {
    const i = this.message(t, e, r);
    return i.fatal = null, i;
  }
  /**
   * Create a fatal error associated with the file.
   *
   * Its `fatal` is set to `true` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * > 👉 **Note**: a fatal error means that a file is no longer processable.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Message.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, e, r) {
    const i = this.message(t, e, r);
    throw i.fatal = !0, i;
  }
}
function ne(n, t) {
  if (n && n.includes(Cn.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + Cn.sep + "`"
    );
}
function ee(n, t) {
  if (!n)
    throw new Error("`" + t + "` cannot be empty");
}
function Ne(n, t) {
  if (!n)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function zr(n) {
  return It(n);
}
function qe(n) {
  if (n)
    throw n;
}
var Xn = Object.prototype.hasOwnProperty, Rt = Object.prototype.toString, Ue = Object.defineProperty, He = Object.getOwnPropertyDescriptor, Ve = function(t) {
  return typeof Array.isArray == "function" ? Array.isArray(t) : Rt.call(t) === "[object Array]";
}, Ye = function(t) {
  if (!t || Rt.call(t) !== "[object Object]")
    return !1;
  var e = Xn.call(t, "constructor"), r = t.constructor && t.constructor.prototype && Xn.call(t.constructor.prototype, "isPrototypeOf");
  if (t.constructor && !e && !r)
    return !1;
  var i;
  for (i in t)
    ;
  return typeof i > "u" || Xn.call(t, i);
}, We = function(t, e) {
  Ue && e.name === "__proto__" ? Ue(t, e.name, {
    enumerable: !0,
    configurable: !0,
    value: e.newValue,
    writable: !0
  }) : t[e.name] = e.newValue;
}, Qe = function(t, e) {
  if (e === "__proto__")
    if (Xn.call(t, e)) {
      if (He)
        return He(t, e).value;
    } else
      return;
  return t[e];
}, Mr = function n() {
  var t, e, r, i, l, o, a = arguments[0], c = 1, s = arguments.length, d = !1;
  for (typeof a == "boolean" && (d = a, a = arguments[1] || {}, c = 2), (a == null || typeof a != "object" && typeof a != "function") && (a = {}); c < s; ++c)
    if (t = arguments[c], t != null)
      for (e in t)
        r = Qe(a, e), i = Qe(t, e), a !== i && (d && i && (Ye(i) || (l = Ve(i))) ? (l ? (l = !1, o = r && Ve(r) ? r : []) : o = r && Ye(r) ? r : {}, We(a, { name: e, newValue: n(d, o, i) })) : typeof i < "u" && We(a, { name: e, newValue: i }));
  return a;
};
const Xe = /* @__PURE__ */ Hn(Mr);
function be(n) {
  if (typeof n != "object" || n === null)
    return !1;
  const t = Object.getPrototypeOf(n);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in n) && !(Symbol.iterator in n);
}
function Fr() {
  const n = [], t = { run: e, use: r };
  return t;
  function e(...i) {
    let l = -1;
    const o = i.pop();
    if (typeof o != "function")
      throw new TypeError("Expected function as last argument, not " + o);
    a(null, ...i);
    function a(c, ...s) {
      const d = n[++l];
      let p = -1;
      if (c) {
        o(c);
        return;
      }
      for (; ++p < i.length; )
        (s[p] === null || s[p] === void 0) && (s[p] = i[p]);
      i = s, d ? Dr(d, a)(...s) : o(null, ...s);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return n.push(i), t;
  }
}
function Dr(n, t) {
  let e;
  return r;
  function r(...o) {
    const a = n.length > o.length;
    let c;
    a && o.push(i);
    try {
      c = n.apply(this, o);
    } catch (s) {
      const d = (
        /** @type {Error} */
        s
      );
      if (a && e)
        throw d;
      return i(d);
    }
    a || (c instanceof Promise ? c.then(l, i) : c instanceof Error ? i(c) : l(c));
  }
  function i(o, ...a) {
    e || (e = !0, t(o, ...a));
  }
  function l(o) {
    i(null, o);
  }
}
const Br = Lt().freeze(), _t = {}.hasOwnProperty;
function Lt() {
  const n = Fr(), t = [];
  let e = {}, r, i = -1;
  return l.data = o, l.Parser = void 0, l.Compiler = void 0, l.freeze = a, l.attachers = t, l.use = c, l.parse = s, l.stringify = d, l.run = p, l.runSync = m, l.process = h, l.processSync = w, l;
  function l() {
    const g = Lt();
    let y = -1;
    for (; ++y < t.length; )
      g.use(...t[y]);
    return g.data(Xe(!0, {}, e)), g;
  }
  function o(g, y) {
    return typeof g == "string" ? arguments.length === 2 ? (ie("data", r), e[g] = y, l) : _t.call(e, g) && e[g] || null : g ? (ie("data", r), e = g, l) : e;
  }
  function a() {
    if (r)
      return l;
    for (; ++i < t.length; ) {
      const [g, ...y] = t[i];
      if (y[0] === !1)
        continue;
      y[0] === !0 && (y[0] = void 0);
      const k = g.call(l, ...y);
      typeof k == "function" && n.use(k);
    }
    return r = !0, i = Number.POSITIVE_INFINITY, l;
  }
  function c(g, ...y) {
    let k;
    if (ie("use", r), g != null)
      if (typeof g == "function")
        S(g, ...y);
      else if (typeof g == "object")
        Array.isArray(g) ? L(g) : v(g);
      else
        throw new TypeError("Expected usable value, not `" + g + "`");
    return k && (e.settings = Object.assign(e.settings || {}, k)), l;
    function M(x) {
      if (typeof x == "function")
        S(x);
      else if (typeof x == "object")
        if (Array.isArray(x)) {
          const [R, ...q] = x;
          S(R, ...q);
        } else
          v(x);
      else
        throw new TypeError("Expected usable value, not `" + x + "`");
    }
    function v(x) {
      L(x.plugins), x.settings && (k = Object.assign(k || {}, x.settings));
    }
    function L(x) {
      let R = -1;
      if (x != null)
        if (Array.isArray(x))
          for (; ++R < x.length; ) {
            const q = x[R];
            M(q);
          }
        else
          throw new TypeError("Expected a list of plugins, not `" + x + "`");
    }
    function S(x, R) {
      let q = -1, X;
      for (; ++q < t.length; )
        if (t[q][0] === x) {
          X = t[q];
          break;
        }
      X ? (be(X[1]) && be(R) && (R = Xe(!0, X[1], R)), X[1] = R) : t.push([...arguments]);
    }
  }
  function s(g) {
    l.freeze();
    const y = Nn(g), k = l.Parser;
    return te("parse", k), Ke(k, "parse") ? new k(String(y), y).parse() : k(String(y), y);
  }
  function d(g, y) {
    l.freeze();
    const k = Nn(y), M = l.Compiler;
    return re("stringify", M), Ge(g), Ke(M, "compile") ? new M(g, k).compile() : M(g, k);
  }
  function p(g, y, k) {
    if (Ge(g), l.freeze(), !k && typeof y == "function" && (k = y, y = void 0), !k)
      return new Promise(M);
    M(null, k);
    function M(v, L) {
      n.run(g, Nn(y), S);
      function S(x, R, q) {
        R = R || g, x ? L(x) : v ? v(R) : k(null, R, q);
      }
    }
  }
  function m(g, y) {
    let k, M;
    return l.run(g, y, v), Je("runSync", "run", M), k;
    function v(L, S) {
      qe(L), k = S, M = !0;
    }
  }
  function h(g, y) {
    if (l.freeze(), te("process", l.Parser), re("process", l.Compiler), !y)
      return new Promise(k);
    k(null, y);
    function k(M, v) {
      const L = Nn(g);
      l.run(l.parse(L), L, (x, R, q) => {
        if (x || !R || !q)
          S(x);
        else {
          const X = l.stringify(R, q);
          X == null || (Nr(X) ? q.value = X : q.result = X), S(x, q);
        }
      });
      function S(x, R) {
        x || !R ? v(x) : M ? M(R) : y(null, R);
      }
    }
  }
  function w(g) {
    let y;
    l.freeze(), te("processSync", l.Parser), re("processSync", l.Compiler);
    const k = Nn(g);
    return l.process(k, M), Je("processSync", "process", y), k;
    function M(v) {
      y = !0, qe(v);
    }
  }
}
function Ke(n, t) {
  return typeof n == "function" && // Prototypes do exist.
  // type-coverage:ignore-next-line
  n.prototype && // A function with keys in its prototype is probably a constructor.
  // Classes’ prototype methods are not enumerable, so we check if some value
  // exists in the prototype.
  // type-coverage:ignore-next-line
  (jr(n.prototype) || t in n.prototype);
}
function jr(n) {
  let t;
  for (t in n)
    if (_t.call(n, t))
      return !0;
  return !1;
}
function te(n, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + n + "` without `Parser`");
}
function re(n, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + n + "` without `Compiler`");
}
function ie(n, t) {
  if (t)
    throw new Error(
      "Cannot call `" + n + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function Ge(n) {
  if (!be(n) || typeof n.type != "string")
    throw new TypeError("Expected node, got `" + n + "`");
}
function Je(n, t, e) {
  if (!e)
    throw new Error(
      "`" + n + "` finished async. Use `" + t + "` instead"
    );
}
function Nn(n) {
  return $r(n) ? n : new At(n);
}
function $r(n) {
  return !!(n && typeof n == "object" && "message" in n && "messages" in n);
}
function Nr(n) {
  return typeof n == "string" || It(n);
}
const qr = {};
function Ur(n, t) {
  const e = t || qr, r = typeof e.includeImageAlt == "boolean" ? e.includeImageAlt : !0, i = typeof e.includeHtml == "boolean" ? e.includeHtml : !0;
  return zt(n, r, i);
}
function zt(n, t, e) {
  if (Hr(n)) {
    if ("value" in n)
      return n.type === "html" && !e ? "" : n.value;
    if (t && "alt" in n && n.alt)
      return n.alt;
    if ("children" in n)
      return Ze(n.children, t, e);
  }
  return Array.isArray(n) ? Ze(n, t, e) : "";
}
function Ze(n, t, e) {
  const r = [];
  let i = -1;
  for (; ++i < n.length; )
    r[i] = zt(n[i], t, e);
  return r.join("");
}
function Hr(n) {
  return !!(n && typeof n == "object");
}
function an(n, t, e, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let l = 0;
  return o;
  function o(c) {
    return K(c) ? (n.enter(e), a(c)) : t(c);
  }
  function a(c) {
    return K(c) && l++ < i ? (n.consume(c), a) : (n.exit(e), t(c));
  }
}
const Vr = {
  tokenize: Yr
};
function Yr(n) {
  const t = n.attempt(
    this.parser.constructs.contentInitial,
    r,
    i
  );
  let e;
  return t;
  function r(a) {
    if (a === null) {
      n.consume(a);
      return;
    }
    return n.enter("lineEnding"), n.consume(a), n.exit("lineEnding"), an(n, t, "linePrefix");
  }
  function i(a) {
    return n.enter("paragraph"), l(a);
  }
  function l(a) {
    const c = n.enter("chunkText", {
      contentType: "text",
      previous: e
    });
    return e && (e.next = c), e = c, o(a);
  }
  function o(a) {
    if (a === null) {
      n.exit("chunkText"), n.exit("paragraph"), n.consume(a);
      return;
    }
    return D(a) ? (n.consume(a), n.exit("chunkText"), l) : (n.consume(a), o);
  }
}
const Wr = {
  tokenize: Qr
}, nt = {
  tokenize: Xr
};
function Qr(n) {
  const t = this, e = [];
  let r = 0, i, l, o;
  return a;
  function a(v) {
    if (r < e.length) {
      const L = e[r];
      return t.containerState = L[1], n.attempt(
        L[0].continuation,
        c,
        s
      )(v);
    }
    return s(v);
  }
  function c(v) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, i && M();
      const L = t.events.length;
      let S = L, x;
      for (; S--; )
        if (t.events[S][0] === "exit" && t.events[S][1].type === "chunkFlow") {
          x = t.events[S][1].end;
          break;
        }
      k(r);
      let R = L;
      for (; R < t.events.length; )
        t.events[R][1].end = Object.assign({}, x), R++;
      return In(
        t.events,
        S + 1,
        0,
        t.events.slice(L)
      ), t.events.length = R, s(v);
    }
    return a(v);
  }
  function s(v) {
    if (r === e.length) {
      if (!i)
        return m(v);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return w(v);
      t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, n.check(
      nt,
      d,
      p
    )(v);
  }
  function d(v) {
    return i && M(), k(r), m(v);
  }
  function p(v) {
    return t.parser.lazy[t.now().line] = r !== e.length, o = t.now().offset, w(v);
  }
  function m(v) {
    return t.containerState = {}, n.attempt(
      nt,
      h,
      w
    )(v);
  }
  function h(v) {
    return r++, e.push([t.currentConstruct, t.containerState]), m(v);
  }
  function w(v) {
    if (v === null) {
      i && M(), k(0), n.consume(v);
      return;
    }
    return i = i || t.parser.flow(t.now()), n.enter("chunkFlow", {
      contentType: "flow",
      previous: l,
      _tokenizer: i
    }), g(v);
  }
  function g(v) {
    if (v === null) {
      y(n.exit("chunkFlow"), !0), k(0), n.consume(v);
      return;
    }
    return D(v) ? (n.consume(v), y(n.exit("chunkFlow")), r = 0, t.interrupt = void 0, a) : (n.consume(v), g);
  }
  function y(v, L) {
    const S = t.sliceStream(v);
    if (L && S.push(null), v.previous = l, l && (l.next = v), l = v, i.defineSkip(v.start), i.write(S), t.parser.lazy[v.start.line]) {
      let x = i.events.length;
      for (; x--; )
        if (
          // The token starts before the line ending…
          i.events[x][1].start.offset < o && // …and either is not ended yet…
          (!i.events[x][1].end || // …or ends after it.
          i.events[x][1].end.offset > o)
        )
          return;
      const R = t.events.length;
      let q = R, X, sn;
      for (; q--; )
        if (t.events[q][0] === "exit" && t.events[q][1].type === "chunkFlow") {
          if (X) {
            sn = t.events[q][1].end;
            break;
          }
          X = !0;
        }
      for (k(r), x = R; x < t.events.length; )
        t.events[x][1].end = Object.assign({}, sn), x++;
      In(
        t.events,
        q + 1,
        0,
        t.events.slice(R)
      ), t.events.length = x;
    }
  }
  function k(v) {
    let L = e.length;
    for (; L-- > v; ) {
      const S = e[L];
      t.containerState = S[1], S[0].exit.call(t, n);
    }
    e.length = v;
  }
  function M() {
    i.write([null]), l = void 0, i = void 0, t.containerState._closeFlow = void 0;
  }
}
function Xr(n, t, e) {
  return an(
    n,
    n.attempt(this.parser.constructs.document, t, e),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
const ke = {
  name: "attention",
  tokenize: Gr,
  resolveAll: Kr
};
function Kr(n, t) {
  let e = -1, r, i, l, o, a, c, s, d;
  for (; ++e < n.length; )
    if (n[e][0] === "enter" && n[e][1].type === "attentionSequence" && n[e][1]._close) {
      for (r = e; r--; )
        if (n[r][0] === "exit" && n[r][1].type === "attentionSequence" && n[r][1]._open && // If the markers are the same:
        t.sliceSerialize(n[r][1]).charCodeAt(0) === t.sliceSerialize(n[e][1]).charCodeAt(0)) {
          if ((n[r][1]._close || n[e][1]._open) && (n[e][1].end.offset - n[e][1].start.offset) % 3 && !((n[r][1].end.offset - n[r][1].start.offset + n[e][1].end.offset - n[e][1].start.offset) % 3))
            continue;
          c = n[r][1].end.offset - n[r][1].start.offset > 1 && n[e][1].end.offset - n[e][1].start.offset > 1 ? 2 : 1;
          const p = Object.assign({}, n[r][1].end), m = Object.assign({}, n[e][1].start);
          et(p, -c), et(m, c), o = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: p,
            end: Object.assign({}, n[r][1].end)
          }, a = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, n[e][1].start),
            end: m
          }, l = {
            type: c > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, n[r][1].end),
            end: Object.assign({}, n[e][1].start)
          }, i = {
            type: c > 1 ? "strong" : "emphasis",
            start: Object.assign({}, o.start),
            end: Object.assign({}, a.end)
          }, n[r][1].end = Object.assign({}, o.start), n[e][1].start = Object.assign({}, a.end), s = [], n[r][1].end.offset - n[r][1].start.offset && (s = Sn(s, [
            ["enter", n[r][1], t],
            ["exit", n[r][1], t]
          ])), s = Sn(s, [
            ["enter", i, t],
            ["enter", o, t],
            ["exit", o, t],
            ["enter", l, t]
          ]), s = Sn(
            s,
            Pe(
              t.parser.constructs.insideSpan.null,
              n.slice(r + 1, e),
              t
            )
          ), s = Sn(s, [
            ["exit", l, t],
            ["enter", a, t],
            ["exit", a, t],
            ["exit", i, t]
          ]), n[e][1].end.offset - n[e][1].start.offset ? (d = 2, s = Sn(s, [
            ["enter", n[e][1], t],
            ["exit", n[e][1], t]
          ])) : d = 0, In(n, r - 1, e - r + 3, s), e = r + s.length - d - 2;
          break;
        }
    }
  for (e = -1; ++e < n.length; )
    n[e][1].type === "attentionSequence" && (n[e][1].type = "data");
  return n;
}
function Gr(n, t) {
  const e = this.parser.constructs.attentionMarkers.null, r = this.previous, i = De(r);
  let l;
  return o;
  function o(c) {
    return l = c, n.enter("attentionSequence"), a(c);
  }
  function a(c) {
    if (c === l)
      return n.consume(c), a;
    const s = n.exit("attentionSequence"), d = De(c), p = !d || d === 2 && i || e.includes(c), m = !i || i === 2 && d || e.includes(r);
    return s._open = !!(l === 42 ? p : p && (i || !m)), s._close = !!(l === 42 ? m : m && (d || !p)), t(c);
  }
}
function et(n, t) {
  n.column += t, n.offset += t, n._bufferIndex += t;
}
const Jr = {
  name: "autolink",
  tokenize: Zr
};
function Zr(n, t, e) {
  let r = 0;
  return i;
  function i(h) {
    return n.enter("autolink"), n.enter("autolinkMarker"), n.consume(h), n.exit("autolinkMarker"), n.enter("autolinkProtocol"), l;
  }
  function l(h) {
    return Tn(h) ? (n.consume(h), o) : s(h);
  }
  function o(h) {
    return h === 43 || h === 45 || h === 46 || vn(h) ? (r = 1, a(h)) : s(h);
  }
  function a(h) {
    return h === 58 ? (n.consume(h), r = 0, c) : (h === 43 || h === 45 || h === 46 || vn(h)) && r++ < 32 ? (n.consume(h), a) : (r = 0, s(h));
  }
  function c(h) {
    return h === 62 ? (n.exit("autolinkProtocol"), n.enter("autolinkMarker"), n.consume(h), n.exit("autolinkMarker"), n.exit("autolink"), t) : h === null || h === 32 || h === 60 || me(h) ? e(h) : (n.consume(h), c);
  }
  function s(h) {
    return h === 64 ? (n.consume(h), d) : pr(h) ? (n.consume(h), s) : e(h);
  }
  function d(h) {
    return vn(h) ? p(h) : e(h);
  }
  function p(h) {
    return h === 46 ? (n.consume(h), r = 0, d) : h === 62 ? (n.exit("autolinkProtocol").type = "autolinkEmail", n.enter("autolinkMarker"), n.consume(h), n.exit("autolinkMarker"), n.exit("autolink"), t) : m(h);
  }
  function m(h) {
    if ((h === 45 || vn(h)) && r++ < 63) {
      const w = h === 45 ? m : p;
      return n.consume(h), w;
    }
    return e(h);
  }
}
const Gn = {
  tokenize: ni,
  partial: !0
};
function ni(n, t, e) {
  return r;
  function r(l) {
    return K(l) ? an(n, i, "linePrefix")(l) : i(l);
  }
  function i(l) {
    return l === null || D(l) ? t(l) : e(l);
  }
}
const Mt = {
  name: "blockQuote",
  tokenize: ei,
  continuation: {
    tokenize: ti
  },
  exit: ri
};
function ei(n, t, e) {
  const r = this;
  return i;
  function i(o) {
    if (o === 62) {
      const a = r.containerState;
      return a.open || (n.enter("blockQuote", {
        _container: !0
      }), a.open = !0), n.enter("blockQuotePrefix"), n.enter("blockQuoteMarker"), n.consume(o), n.exit("blockQuoteMarker"), l;
    }
    return e(o);
  }
  function l(o) {
    return K(o) ? (n.enter("blockQuotePrefixWhitespace"), n.consume(o), n.exit("blockQuotePrefixWhitespace"), n.exit("blockQuotePrefix"), t) : (n.exit("blockQuotePrefix"), t(o));
  }
}
function ti(n, t, e) {
  const r = this;
  return i;
  function i(o) {
    return K(o) ? an(
      n,
      l,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(o) : l(o);
  }
  function l(o) {
    return n.attempt(Mt, t, e)(o);
  }
}
function ri(n) {
  n.exit("blockQuote");
}
const Ft = {
  name: "characterEscape",
  tokenize: ii
};
function ii(n, t, e) {
  return r;
  function r(l) {
    return n.enter("characterEscape"), n.enter("escapeMarker"), n.consume(l), n.exit("escapeMarker"), i;
  }
  function i(l) {
    return hr(l) ? (n.enter("characterEscapeValue"), n.consume(l), n.exit("characterEscapeValue"), n.exit("characterEscape"), t) : e(l);
  }
}
const tt = document.createElement("i");
function Oe(n) {
  const t = "&" + n + ";";
  tt.innerHTML = t;
  const e = tt.textContent;
  return e.charCodeAt(e.length - 1) === 59 && n !== "semi" || e === t ? !1 : e;
}
const Dt = {
  name: "characterReference",
  tokenize: li
};
function li(n, t, e) {
  const r = this;
  let i = 0, l, o;
  return a;
  function a(p) {
    return n.enter("characterReference"), n.enter("characterReferenceMarker"), n.consume(p), n.exit("characterReferenceMarker"), c;
  }
  function c(p) {
    return p === 35 ? (n.enter("characterReferenceMarkerNumeric"), n.consume(p), n.exit("characterReferenceMarkerNumeric"), s) : (n.enter("characterReferenceValue"), l = 31, o = vn, d(p));
  }
  function s(p) {
    return p === 88 || p === 120 ? (n.enter("characterReferenceMarkerHexadecimal"), n.consume(p), n.exit("characterReferenceMarkerHexadecimal"), n.enter("characterReferenceValue"), l = 6, o = dr, d) : (n.enter("characterReferenceValue"), l = 7, o = ge, d(p));
  }
  function d(p) {
    if (p === 59 && i) {
      const m = n.exit("characterReferenceValue");
      return o === vn && !Oe(r.sliceSerialize(m)) ? e(p) : (n.enter("characterReferenceMarker"), n.consume(p), n.exit("characterReferenceMarker"), n.exit("characterReference"), t);
    }
    return o(p) && i++ < l ? (n.consume(p), d) : e(p);
  }
}
const rt = {
  tokenize: ai,
  partial: !0
}, it = {
  name: "codeFenced",
  tokenize: oi,
  concrete: !0
};
function oi(n, t, e) {
  const r = this, i = {
    tokenize: S,
    partial: !0
  };
  let l = 0, o = 0, a;
  return c;
  function c(x) {
    return s(x);
  }
  function s(x) {
    const R = r.events[r.events.length - 1];
    return l = R && R[1].type === "linePrefix" ? R[2].sliceSerialize(R[1], !0).length : 0, a = x, n.enter("codeFenced"), n.enter("codeFencedFence"), n.enter("codeFencedFenceSequence"), d(x);
  }
  function d(x) {
    return x === a ? (o++, n.consume(x), d) : o < 3 ? e(x) : (n.exit("codeFencedFenceSequence"), K(x) ? an(n, p, "whitespace")(x) : p(x));
  }
  function p(x) {
    return x === null || D(x) ? (n.exit("codeFencedFence"), r.interrupt ? t(x) : n.check(rt, g, L)(x)) : (n.enter("codeFencedFenceInfo"), n.enter("chunkString", {
      contentType: "string"
    }), m(x));
  }
  function m(x) {
    return x === null || D(x) ? (n.exit("chunkString"), n.exit("codeFencedFenceInfo"), p(x)) : K(x) ? (n.exit("chunkString"), n.exit("codeFencedFenceInfo"), an(n, h, "whitespace")(x)) : x === 96 && x === a ? e(x) : (n.consume(x), m);
  }
  function h(x) {
    return x === null || D(x) ? p(x) : (n.enter("codeFencedFenceMeta"), n.enter("chunkString", {
      contentType: "string"
    }), w(x));
  }
  function w(x) {
    return x === null || D(x) ? (n.exit("chunkString"), n.exit("codeFencedFenceMeta"), p(x)) : x === 96 && x === a ? e(x) : (n.consume(x), w);
  }
  function g(x) {
    return n.attempt(i, L, y)(x);
  }
  function y(x) {
    return n.enter("lineEnding"), n.consume(x), n.exit("lineEnding"), k;
  }
  function k(x) {
    return l > 0 && K(x) ? an(
      n,
      M,
      "linePrefix",
      l + 1
    )(x) : M(x);
  }
  function M(x) {
    return x === null || D(x) ? n.check(rt, g, L)(x) : (n.enter("codeFlowValue"), v(x));
  }
  function v(x) {
    return x === null || D(x) ? (n.exit("codeFlowValue"), M(x)) : (n.consume(x), v);
  }
  function L(x) {
    return n.exit("codeFenced"), t(x);
  }
  function S(x, R, q) {
    let X = 0;
    return sn;
    function sn(Y) {
      return x.enter("lineEnding"), x.consume(Y), x.exit("lineEnding"), _;
    }
    function _(Y) {
      return x.enter("codeFencedFence"), K(Y) ? an(
        x,
        O,
        "linePrefix",
        r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(Y) : O(Y);
    }
    function O(Y) {
      return Y === a ? (x.enter("codeFencedFenceSequence"), W(Y)) : q(Y);
    }
    function W(Y) {
      return Y === a ? (X++, x.consume(Y), W) : X >= o ? (x.exit("codeFencedFenceSequence"), K(Y) ? an(x, en, "whitespace")(Y) : en(Y)) : q(Y);
    }
    function en(Y) {
      return Y === null || D(Y) ? (x.exit("codeFencedFence"), R(Y)) : q(Y);
    }
  }
}
function ai(n, t, e) {
  const r = this;
  return i;
  function i(o) {
    return o === null ? e(o) : (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), l);
  }
  function l(o) {
    return r.parser.lazy[r.now().line] ? e(o) : t(o);
  }
}
const le = {
  name: "codeIndented",
  tokenize: si
}, ui = {
  tokenize: ci,
  partial: !0
};
function si(n, t, e) {
  const r = this;
  return i;
  function i(s) {
    return n.enter("codeIndented"), an(n, l, "linePrefix", 5)(s);
  }
  function l(s) {
    const d = r.events[r.events.length - 1];
    return d && d[1].type === "linePrefix" && d[2].sliceSerialize(d[1], !0).length >= 4 ? o(s) : e(s);
  }
  function o(s) {
    return s === null ? c(s) : D(s) ? n.attempt(ui, o, c)(s) : (n.enter("codeFlowValue"), a(s));
  }
  function a(s) {
    return s === null || D(s) ? (n.exit("codeFlowValue"), o(s)) : (n.consume(s), a);
  }
  function c(s) {
    return n.exit("codeIndented"), t(s);
  }
}
function ci(n, t, e) {
  const r = this;
  return i;
  function i(o) {
    return r.parser.lazy[r.now().line] ? e(o) : D(o) ? (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), i) : an(n, l, "linePrefix", 5)(o);
  }
  function l(o) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? t(o) : D(o) ? i(o) : e(o);
  }
}
const fi = {
  name: "codeText",
  tokenize: di,
  resolve: pi,
  previous: hi
};
function pi(n) {
  let t = n.length - 4, e = 3, r, i;
  if ((n[e][1].type === "lineEnding" || n[e][1].type === "space") && (n[t][1].type === "lineEnding" || n[t][1].type === "space")) {
    for (r = e; ++r < t; )
      if (n[r][1].type === "codeTextData") {
        n[e][1].type = "codeTextPadding", n[t][1].type = "codeTextPadding", e += 2, t -= 2;
        break;
      }
  }
  for (r = e - 1, t++; ++r <= t; )
    i === void 0 ? r !== t && n[r][1].type !== "lineEnding" && (i = r) : (r === t || n[r][1].type === "lineEnding") && (n[i][1].type = "codeTextData", r !== i + 2 && (n[i][1].end = n[r - 1][1].end, n.splice(i + 2, r - i - 2), t -= r - i - 2, r = i + 2), i = void 0);
  return n;
}
function hi(n) {
  return n !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function di(n, t, e) {
  let r = 0, i, l;
  return o;
  function o(p) {
    return n.enter("codeText"), n.enter("codeTextSequence"), a(p);
  }
  function a(p) {
    return p === 96 ? (n.consume(p), r++, a) : (n.exit("codeTextSequence"), c(p));
  }
  function c(p) {
    return p === null ? e(p) : p === 32 ? (n.enter("space"), n.consume(p), n.exit("space"), c) : p === 96 ? (l = n.enter("codeTextSequence"), i = 0, d(p)) : D(p) ? (n.enter("lineEnding"), n.consume(p), n.exit("lineEnding"), c) : (n.enter("codeTextData"), s(p));
  }
  function s(p) {
    return p === null || p === 32 || p === 96 || D(p) ? (n.exit("codeTextData"), c(p)) : (n.consume(p), s);
  }
  function d(p) {
    return p === 96 ? (n.consume(p), i++, d) : i === r ? (n.exit("codeTextSequence"), n.exit("codeText"), t(p)) : (l.type = "codeTextData", s(p));
  }
}
function Bt(n) {
  const t = {};
  let e = -1, r, i, l, o, a, c, s;
  for (; ++e < n.length; ) {
    for (; e in t; )
      e = t[e];
    if (r = n[e], e && r[1].type === "chunkFlow" && n[e - 1][1].type === "listItemPrefix" && (c = r[1]._tokenizer.events, l = 0, l < c.length && c[l][1].type === "lineEndingBlank" && (l += 2), l < c.length && c[l][1].type === "content"))
      for (; ++l < c.length && c[l][1].type !== "content"; )
        c[l][1].type === "chunkText" && (c[l][1]._isInFirstContentOfListItem = !0, l++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, mi(n, e)), e = t[e], s = !0);
    else if (r[1]._container) {
      for (l = e, i = void 0; l-- && (o = n[l], o[1].type === "lineEnding" || o[1].type === "lineEndingBlank"); )
        o[0] === "enter" && (i && (n[i][1].type = "lineEndingBlank"), o[1].type = "lineEnding", i = l);
      i && (r[1].end = Object.assign({}, n[i][1].start), a = n.slice(i, e), a.unshift(r), In(n, i, e - i + 1, a));
    }
  }
  return !s;
}
function mi(n, t) {
  const e = n[t][1], r = n[t][2];
  let i = t - 1;
  const l = [], o = e._tokenizer || r.parser[e.contentType](e.start), a = o.events, c = [], s = {};
  let d, p, m = -1, h = e, w = 0, g = 0;
  const y = [g];
  for (; h; ) {
    for (; n[++i][1] !== h; )
      ;
    l.push(i), h._tokenizer || (d = r.sliceStream(h), h.next || d.push(null), p && o.defineSkip(h.start), h._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0), o.write(d), h._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)), p = h, h = h.next;
  }
  for (h = e; ++m < a.length; )
    // Find a void token that includes a break.
    a[m][0] === "exit" && a[m - 1][0] === "enter" && a[m][1].type === a[m - 1][1].type && a[m][1].start.line !== a[m][1].end.line && (g = m + 1, y.push(g), h._tokenizer = void 0, h.previous = void 0, h = h.next);
  for (o.events = [], h ? (h._tokenizer = void 0, h.previous = void 0) : y.pop(), m = y.length; m--; ) {
    const k = a.slice(y[m], y[m + 1]), M = l.pop();
    c.unshift([M, M + k.length - 1]), In(n, M, 2, k);
  }
  for (m = -1; ++m < c.length; )
    s[w + c[m][0]] = w + c[m][1], w += c[m][1] - c[m][0] - 1;
  return s;
}
const gi = {
  tokenize: bi,
  resolve: xi
}, yi = {
  tokenize: ki,
  partial: !0
};
function xi(n) {
  return Bt(n), n;
}
function bi(n, t) {
  let e;
  return r;
  function r(a) {
    return n.enter("content"), e = n.enter("chunkContent", {
      contentType: "content"
    }), i(a);
  }
  function i(a) {
    return a === null ? l(a) : D(a) ? n.check(
      yi,
      o,
      l
    )(a) : (n.consume(a), i);
  }
  function l(a) {
    return n.exit("chunkContent"), n.exit("content"), t(a);
  }
  function o(a) {
    return n.consume(a), n.exit("chunkContent"), e.next = n.enter("chunkContent", {
      contentType: "content",
      previous: e
    }), e = e.next, i;
  }
}
function ki(n, t, e) {
  const r = this;
  return i;
  function i(o) {
    return n.exit("chunkContent"), n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), an(n, l, "linePrefix");
  }
  function l(o) {
    if (o === null || D(o))
      return e(o);
    const a = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? t(o) : n.interrupt(r.parser.constructs.flow, e, t)(o);
  }
}
function jt(n, t, e, r, i, l, o, a, c) {
  const s = c || Number.POSITIVE_INFINITY;
  let d = 0;
  return p;
  function p(k) {
    return k === 60 ? (n.enter(r), n.enter(i), n.enter(l), n.consume(k), n.exit(l), m) : k === null || k === 32 || k === 41 || me(k) ? e(k) : (n.enter(r), n.enter(o), n.enter(a), n.enter("chunkString", {
      contentType: "string"
    }), g(k));
  }
  function m(k) {
    return k === 62 ? (n.enter(l), n.consume(k), n.exit(l), n.exit(i), n.exit(r), t) : (n.enter(a), n.enter("chunkString", {
      contentType: "string"
    }), h(k));
  }
  function h(k) {
    return k === 62 ? (n.exit("chunkString"), n.exit(a), m(k)) : k === null || k === 60 || D(k) ? e(k) : (n.consume(k), k === 92 ? w : h);
  }
  function w(k) {
    return k === 60 || k === 62 || k === 92 ? (n.consume(k), h) : h(k);
  }
  function g(k) {
    return !d && (k === null || k === 41 || bn(k)) ? (n.exit("chunkString"), n.exit(a), n.exit(o), n.exit(r), t(k)) : d < s && k === 40 ? (n.consume(k), d++, g) : k === 41 ? (n.consume(k), d--, g) : k === null || k === 32 || k === 40 || me(k) ? e(k) : (n.consume(k), k === 92 ? y : g);
  }
  function y(k) {
    return k === 40 || k === 41 || k === 92 ? (n.consume(k), g) : g(k);
  }
}
function $t(n, t, e, r, i, l) {
  const o = this;
  let a = 0, c;
  return s;
  function s(h) {
    return n.enter(r), n.enter(i), n.consume(h), n.exit(i), n.enter(l), d;
  }
  function d(h) {
    return a > 999 || h === null || h === 91 || h === 93 && !c || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    h === 94 && !a && "_hiddenFootnoteSupport" in o.parser.constructs ? e(h) : h === 93 ? (n.exit(l), n.enter(i), n.consume(h), n.exit(i), n.exit(r), t) : D(h) ? (n.enter("lineEnding"), n.consume(h), n.exit("lineEnding"), d) : (n.enter("chunkString", {
      contentType: "string"
    }), p(h));
  }
  function p(h) {
    return h === null || h === 91 || h === 93 || D(h) || a++ > 999 ? (n.exit("chunkString"), d(h)) : (n.consume(h), c || (c = !K(h)), h === 92 ? m : p);
  }
  function m(h) {
    return h === 91 || h === 92 || h === 93 ? (n.consume(h), a++, p) : p(h);
  }
}
function Nt(n, t, e, r, i, l) {
  let o;
  return a;
  function a(m) {
    return m === 34 || m === 39 || m === 40 ? (n.enter(r), n.enter(i), n.consume(m), n.exit(i), o = m === 40 ? 41 : m, c) : e(m);
  }
  function c(m) {
    return m === o ? (n.enter(i), n.consume(m), n.exit(i), n.exit(r), t) : (n.enter(l), s(m));
  }
  function s(m) {
    return m === o ? (n.exit(l), c(o)) : m === null ? e(m) : D(m) ? (n.enter("lineEnding"), n.consume(m), n.exit("lineEnding"), an(n, s, "linePrefix")) : (n.enter("chunkString", {
      contentType: "string"
    }), d(m));
  }
  function d(m) {
    return m === o || m === null || D(m) ? (n.exit("chunkString"), s(m)) : (n.consume(m), m === 92 ? p : d);
  }
  function p(m) {
    return m === o || m === 92 ? (n.consume(m), d) : d(m);
  }
}
function Un(n, t) {
  let e;
  return r;
  function r(i) {
    return D(i) ? (n.enter("lineEnding"), n.consume(i), n.exit("lineEnding"), e = !0, r) : K(i) ? an(
      n,
      r,
      e ? "linePrefix" : "lineSuffix"
    )(i) : t(i);
  }
}
function Mn(n) {
  return n.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const Si = {
  name: "definition",
  tokenize: Ei
}, wi = {
  tokenize: vi,
  partial: !0
};
function Ei(n, t, e) {
  const r = this;
  let i;
  return l;
  function l(h) {
    return n.enter("definition"), o(h);
  }
  function o(h) {
    return $t.call(
      r,
      n,
      a,
      // Note: we don’t need to reset the way `markdown-rs` does.
      e,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(h);
  }
  function a(h) {
    return i = Mn(
      r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
    ), h === 58 ? (n.enter("definitionMarker"), n.consume(h), n.exit("definitionMarker"), c) : e(h);
  }
  function c(h) {
    return bn(h) ? Un(n, s)(h) : s(h);
  }
  function s(h) {
    return jt(
      n,
      d,
      // Note: we don’t need to reset the way `markdown-rs` does.
      e,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(h);
  }
  function d(h) {
    return n.attempt(wi, p, p)(h);
  }
  function p(h) {
    return K(h) ? an(n, m, "whitespace")(h) : m(h);
  }
  function m(h) {
    return h === null || D(h) ? (n.exit("definition"), r.parser.defined.push(i), t(h)) : e(h);
  }
}
function vi(n, t, e) {
  return r;
  function r(a) {
    return bn(a) ? Un(n, i)(a) : e(a);
  }
  function i(a) {
    return Nt(
      n,
      l,
      e,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(a);
  }
  function l(a) {
    return K(a) ? an(n, o, "whitespace")(a) : o(a);
  }
  function o(a) {
    return a === null || D(a) ? t(a) : e(a);
  }
}
const Ci = {
  name: "hardBreakEscape",
  tokenize: Ti
};
function Ti(n, t, e) {
  return r;
  function r(l) {
    return n.enter("hardBreakEscape"), n.consume(l), i;
  }
  function i(l) {
    return D(l) ? (n.exit("hardBreakEscape"), t(l)) : e(l);
  }
}
const Pi = {
  name: "headingAtx",
  tokenize: Ii,
  resolve: Oi
};
function Oi(n, t) {
  let e = n.length - 2, r = 3, i, l;
  return n[r][1].type === "whitespace" && (r += 2), e - 2 > r && n[e][1].type === "whitespace" && (e -= 2), n[e][1].type === "atxHeadingSequence" && (r === e - 1 || e - 4 > r && n[e - 2][1].type === "whitespace") && (e -= r + 1 === e ? 2 : 4), e > r && (i = {
    type: "atxHeadingText",
    start: n[r][1].start,
    end: n[e][1].end
  }, l = {
    type: "chunkText",
    start: n[r][1].start,
    end: n[e][1].end,
    contentType: "text"
  }, In(n, r, e - r + 1, [
    ["enter", i, t],
    ["enter", l, t],
    ["exit", l, t],
    ["exit", i, t]
  ])), n;
}
function Ii(n, t, e) {
  let r = 0;
  return i;
  function i(d) {
    return n.enter("atxHeading"), l(d);
  }
  function l(d) {
    return n.enter("atxHeadingSequence"), o(d);
  }
  function o(d) {
    return d === 35 && r++ < 6 ? (n.consume(d), o) : d === null || bn(d) ? (n.exit("atxHeadingSequence"), a(d)) : e(d);
  }
  function a(d) {
    return d === 35 ? (n.enter("atxHeadingSequence"), c(d)) : d === null || D(d) ? (n.exit("atxHeading"), t(d)) : K(d) ? an(n, a, "whitespace")(d) : (n.enter("atxHeadingText"), s(d));
  }
  function c(d) {
    return d === 35 ? (n.consume(d), c) : (n.exit("atxHeadingSequence"), a(d));
  }
  function s(d) {
    return d === null || d === 35 || bn(d) ? (n.exit("atxHeadingText"), a(d)) : (n.consume(d), s);
  }
}
const Ai = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], lt = ["pre", "script", "style", "textarea"], Ri = {
  name: "htmlFlow",
  tokenize: Mi,
  resolveTo: zi,
  concrete: !0
}, _i = {
  tokenize: Di,
  partial: !0
}, Li = {
  tokenize: Fi,
  partial: !0
};
function zi(n) {
  let t = n.length;
  for (; t-- && !(n[t][0] === "enter" && n[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && n[t - 2][1].type === "linePrefix" && (n[t][1].start = n[t - 2][1].start, n[t + 1][1].start = n[t - 2][1].start, n.splice(t - 2, 2)), n;
}
function Mi(n, t, e) {
  const r = this;
  let i, l, o, a, c;
  return s;
  function s(f) {
    return d(f);
  }
  function d(f) {
    return n.enter("htmlFlow"), n.enter("htmlFlowData"), n.consume(f), p;
  }
  function p(f) {
    return f === 33 ? (n.consume(f), m) : f === 47 ? (n.consume(f), l = !0, g) : f === 63 ? (n.consume(f), i = 3, r.interrupt ? t : u) : Tn(f) ? (n.consume(f), o = String.fromCharCode(f), y) : e(f);
  }
  function m(f) {
    return f === 45 ? (n.consume(f), i = 2, h) : f === 91 ? (n.consume(f), i = 5, a = 0, w) : Tn(f) ? (n.consume(f), i = 4, r.interrupt ? t : u) : e(f);
  }
  function h(f) {
    return f === 45 ? (n.consume(f), r.interrupt ? t : u) : e(f);
  }
  function w(f) {
    const z = "CDATA[";
    return f === z.charCodeAt(a++) ? (n.consume(f), a === z.length ? r.interrupt ? t : O : w) : e(f);
  }
  function g(f) {
    return Tn(f) ? (n.consume(f), o = String.fromCharCode(f), y) : e(f);
  }
  function y(f) {
    if (f === null || f === 47 || f === 62 || bn(f)) {
      const z = f === 47, H = o.toLowerCase();
      return !z && !l && lt.includes(H) ? (i = 1, r.interrupt ? t(f) : O(f)) : Ai.includes(o.toLowerCase()) ? (i = 6, z ? (n.consume(f), k) : r.interrupt ? t(f) : O(f)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? e(f) : l ? M(f) : v(f));
    }
    return f === 45 || vn(f) ? (n.consume(f), o += String.fromCharCode(f), y) : e(f);
  }
  function k(f) {
    return f === 62 ? (n.consume(f), r.interrupt ? t : O) : e(f);
  }
  function M(f) {
    return K(f) ? (n.consume(f), M) : sn(f);
  }
  function v(f) {
    return f === 47 ? (n.consume(f), sn) : f === 58 || f === 95 || Tn(f) ? (n.consume(f), L) : K(f) ? (n.consume(f), v) : sn(f);
  }
  function L(f) {
    return f === 45 || f === 46 || f === 58 || f === 95 || vn(f) ? (n.consume(f), L) : S(f);
  }
  function S(f) {
    return f === 61 ? (n.consume(f), x) : K(f) ? (n.consume(f), S) : v(f);
  }
  function x(f) {
    return f === null || f === 60 || f === 61 || f === 62 || f === 96 ? e(f) : f === 34 || f === 39 ? (n.consume(f), c = f, R) : K(f) ? (n.consume(f), x) : q(f);
  }
  function R(f) {
    return f === c ? (n.consume(f), c = null, X) : f === null || D(f) ? e(f) : (n.consume(f), R);
  }
  function q(f) {
    return f === null || f === 34 || f === 39 || f === 47 || f === 60 || f === 61 || f === 62 || f === 96 || bn(f) ? S(f) : (n.consume(f), q);
  }
  function X(f) {
    return f === 47 || f === 62 || K(f) ? v(f) : e(f);
  }
  function sn(f) {
    return f === 62 ? (n.consume(f), _) : e(f);
  }
  function _(f) {
    return f === null || D(f) ? O(f) : K(f) ? (n.consume(f), _) : e(f);
  }
  function O(f) {
    return f === 45 && i === 2 ? (n.consume(f), tn) : f === 60 && i === 1 ? (n.consume(f), ln) : f === 62 && i === 4 ? (n.consume(f), T) : f === 63 && i === 3 ? (n.consume(f), u) : f === 93 && i === 5 ? (n.consume(f), mn) : D(f) && (i === 6 || i === 7) ? (n.exit("htmlFlowData"), n.check(
      _i,
      F,
      W
    )(f)) : f === null || D(f) ? (n.exit("htmlFlowData"), W(f)) : (n.consume(f), O);
  }
  function W(f) {
    return n.check(
      Li,
      en,
      F
    )(f);
  }
  function en(f) {
    return n.enter("lineEnding"), n.consume(f), n.exit("lineEnding"), Y;
  }
  function Y(f) {
    return f === null || D(f) ? W(f) : (n.enter("htmlFlowData"), O(f));
  }
  function tn(f) {
    return f === 45 ? (n.consume(f), u) : O(f);
  }
  function ln(f) {
    return f === 47 ? (n.consume(f), o = "", hn) : O(f);
  }
  function hn(f) {
    if (f === 62) {
      const z = o.toLowerCase();
      return lt.includes(z) ? (n.consume(f), T) : O(f);
    }
    return Tn(f) && o.length < 8 ? (n.consume(f), o += String.fromCharCode(f), hn) : O(f);
  }
  function mn(f) {
    return f === 93 ? (n.consume(f), u) : O(f);
  }
  function u(f) {
    return f === 62 ? (n.consume(f), T) : f === 45 && i === 2 ? (n.consume(f), u) : O(f);
  }
  function T(f) {
    return f === null || D(f) ? (n.exit("htmlFlowData"), F(f)) : (n.consume(f), T);
  }
  function F(f) {
    return n.exit("htmlFlow"), t(f);
  }
}
function Fi(n, t, e) {
  const r = this;
  return i;
  function i(o) {
    return D(o) ? (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), l) : e(o);
  }
  function l(o) {
    return r.parser.lazy[r.now().line] ? e(o) : t(o);
  }
}
function Di(n, t, e) {
  return r;
  function r(i) {
    return n.enter("lineEnding"), n.consume(i), n.exit("lineEnding"), n.attempt(Gn, t, e);
  }
}
const Bi = {
  name: "htmlText",
  tokenize: ji
};
function ji(n, t, e) {
  const r = this;
  let i, l, o;
  return a;
  function a(u) {
    return n.enter("htmlText"), n.enter("htmlTextData"), n.consume(u), c;
  }
  function c(u) {
    return u === 33 ? (n.consume(u), s) : u === 47 ? (n.consume(u), S) : u === 63 ? (n.consume(u), v) : Tn(u) ? (n.consume(u), q) : e(u);
  }
  function s(u) {
    return u === 45 ? (n.consume(u), d) : u === 91 ? (n.consume(u), l = 0, w) : Tn(u) ? (n.consume(u), M) : e(u);
  }
  function d(u) {
    return u === 45 ? (n.consume(u), h) : e(u);
  }
  function p(u) {
    return u === null ? e(u) : u === 45 ? (n.consume(u), m) : D(u) ? (o = p, ln(u)) : (n.consume(u), p);
  }
  function m(u) {
    return u === 45 ? (n.consume(u), h) : p(u);
  }
  function h(u) {
    return u === 62 ? tn(u) : u === 45 ? m(u) : p(u);
  }
  function w(u) {
    const T = "CDATA[";
    return u === T.charCodeAt(l++) ? (n.consume(u), l === T.length ? g : w) : e(u);
  }
  function g(u) {
    return u === null ? e(u) : u === 93 ? (n.consume(u), y) : D(u) ? (o = g, ln(u)) : (n.consume(u), g);
  }
  function y(u) {
    return u === 93 ? (n.consume(u), k) : g(u);
  }
  function k(u) {
    return u === 62 ? tn(u) : u === 93 ? (n.consume(u), k) : g(u);
  }
  function M(u) {
    return u === null || u === 62 ? tn(u) : D(u) ? (o = M, ln(u)) : (n.consume(u), M);
  }
  function v(u) {
    return u === null ? e(u) : u === 63 ? (n.consume(u), L) : D(u) ? (o = v, ln(u)) : (n.consume(u), v);
  }
  function L(u) {
    return u === 62 ? tn(u) : v(u);
  }
  function S(u) {
    return Tn(u) ? (n.consume(u), x) : e(u);
  }
  function x(u) {
    return u === 45 || vn(u) ? (n.consume(u), x) : R(u);
  }
  function R(u) {
    return D(u) ? (o = R, ln(u)) : K(u) ? (n.consume(u), R) : tn(u);
  }
  function q(u) {
    return u === 45 || vn(u) ? (n.consume(u), q) : u === 47 || u === 62 || bn(u) ? X(u) : e(u);
  }
  function X(u) {
    return u === 47 ? (n.consume(u), tn) : u === 58 || u === 95 || Tn(u) ? (n.consume(u), sn) : D(u) ? (o = X, ln(u)) : K(u) ? (n.consume(u), X) : tn(u);
  }
  function sn(u) {
    return u === 45 || u === 46 || u === 58 || u === 95 || vn(u) ? (n.consume(u), sn) : _(u);
  }
  function _(u) {
    return u === 61 ? (n.consume(u), O) : D(u) ? (o = _, ln(u)) : K(u) ? (n.consume(u), _) : X(u);
  }
  function O(u) {
    return u === null || u === 60 || u === 61 || u === 62 || u === 96 ? e(u) : u === 34 || u === 39 ? (n.consume(u), i = u, W) : D(u) ? (o = O, ln(u)) : K(u) ? (n.consume(u), O) : (n.consume(u), en);
  }
  function W(u) {
    return u === i ? (n.consume(u), i = void 0, Y) : u === null ? e(u) : D(u) ? (o = W, ln(u)) : (n.consume(u), W);
  }
  function en(u) {
    return u === null || u === 34 || u === 39 || u === 60 || u === 61 || u === 96 ? e(u) : u === 47 || u === 62 || bn(u) ? X(u) : (n.consume(u), en);
  }
  function Y(u) {
    return u === 47 || u === 62 || bn(u) ? X(u) : e(u);
  }
  function tn(u) {
    return u === 62 ? (n.consume(u), n.exit("htmlTextData"), n.exit("htmlText"), t) : e(u);
  }
  function ln(u) {
    return n.exit("htmlTextData"), n.enter("lineEnding"), n.consume(u), n.exit("lineEnding"), hn;
  }
  function hn(u) {
    return K(u) ? an(
      n,
      mn,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(u) : mn(u);
  }
  function mn(u) {
    return n.enter("htmlTextData"), o(u);
  }
}
const Ie = {
  name: "labelEnd",
  tokenize: Vi,
  resolveTo: Hi,
  resolveAll: Ui
}, $i = {
  tokenize: Yi
}, Ni = {
  tokenize: Wi
}, qi = {
  tokenize: Qi
};
function Ui(n) {
  let t = -1;
  for (; ++t < n.length; ) {
    const e = n[t][1];
    (e.type === "labelImage" || e.type === "labelLink" || e.type === "labelEnd") && (n.splice(t + 1, e.type === "labelImage" ? 4 : 2), e.type = "data", t++);
  }
  return n;
}
function Hi(n, t) {
  let e = n.length, r = 0, i, l, o, a;
  for (; e--; )
    if (i = n[e][1], l) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      n[e][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (o) {
      if (n[e][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (l = e, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else
      i.type === "labelEnd" && (o = e);
  const c = {
    type: n[l][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, n[l][1].start),
    end: Object.assign({}, n[n.length - 1][1].end)
  }, s = {
    type: "label",
    start: Object.assign({}, n[l][1].start),
    end: Object.assign({}, n[o][1].end)
  }, d = {
    type: "labelText",
    start: Object.assign({}, n[l + r + 2][1].end),
    end: Object.assign({}, n[o - 2][1].start)
  };
  return a = [
    ["enter", c, t],
    ["enter", s, t]
  ], a = Sn(a, n.slice(l + 1, l + r + 3)), a = Sn(a, [["enter", d, t]]), a = Sn(
    a,
    Pe(
      t.parser.constructs.insideSpan.null,
      n.slice(l + r + 4, o - 3),
      t
    )
  ), a = Sn(a, [
    ["exit", d, t],
    n[o - 2],
    n[o - 1],
    ["exit", s, t]
  ]), a = Sn(a, n.slice(o + 1)), a = Sn(a, [["exit", c, t]]), In(n, l, n.length, a), n;
}
function Vi(n, t, e) {
  const r = this;
  let i = r.events.length, l, o;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      l = r.events[i][1];
      break;
    }
  return a;
  function a(m) {
    return l ? l._inactive ? p(m) : (o = r.parser.defined.includes(
      Mn(
        r.sliceSerialize({
          start: l.end,
          end: r.now()
        })
      )
    ), n.enter("labelEnd"), n.enter("labelMarker"), n.consume(m), n.exit("labelMarker"), n.exit("labelEnd"), c) : e(m);
  }
  function c(m) {
    return m === 40 ? n.attempt(
      $i,
      d,
      o ? d : p
    )(m) : m === 91 ? n.attempt(
      Ni,
      d,
      o ? s : p
    )(m) : o ? d(m) : p(m);
  }
  function s(m) {
    return n.attempt(
      qi,
      d,
      p
    )(m);
  }
  function d(m) {
    return t(m);
  }
  function p(m) {
    return l._balanced = !0, e(m);
  }
}
function Yi(n, t, e) {
  return r;
  function r(p) {
    return n.enter("resource"), n.enter("resourceMarker"), n.consume(p), n.exit("resourceMarker"), i;
  }
  function i(p) {
    return bn(p) ? Un(n, l)(p) : l(p);
  }
  function l(p) {
    return p === 41 ? d(p) : jt(
      n,
      o,
      a,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(p);
  }
  function o(p) {
    return bn(p) ? Un(n, c)(p) : d(p);
  }
  function a(p) {
    return e(p);
  }
  function c(p) {
    return p === 34 || p === 39 || p === 40 ? Nt(
      n,
      s,
      e,
      "resourceTitle",
      "resourceTitleMarker",
      "resourceTitleString"
    )(p) : d(p);
  }
  function s(p) {
    return bn(p) ? Un(n, d)(p) : d(p);
  }
  function d(p) {
    return p === 41 ? (n.enter("resourceMarker"), n.consume(p), n.exit("resourceMarker"), n.exit("resource"), t) : e(p);
  }
}
function Wi(n, t, e) {
  const r = this;
  return i;
  function i(a) {
    return $t.call(
      r,
      n,
      l,
      o,
      "reference",
      "referenceMarker",
      "referenceString"
    )(a);
  }
  function l(a) {
    return r.parser.defined.includes(
      Mn(
        r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
      )
    ) ? t(a) : e(a);
  }
  function o(a) {
    return e(a);
  }
}
function Qi(n, t, e) {
  return r;
  function r(l) {
    return n.enter("reference"), n.enter("referenceMarker"), n.consume(l), n.exit("referenceMarker"), i;
  }
  function i(l) {
    return l === 93 ? (n.enter("referenceMarker"), n.consume(l), n.exit("referenceMarker"), n.exit("reference"), t) : e(l);
  }
}
const Xi = {
  name: "labelStartImage",
  tokenize: Ki,
  resolveAll: Ie.resolveAll
};
function Ki(n, t, e) {
  const r = this;
  return i;
  function i(a) {
    return n.enter("labelImage"), n.enter("labelImageMarker"), n.consume(a), n.exit("labelImageMarker"), l;
  }
  function l(a) {
    return a === 91 ? (n.enter("labelMarker"), n.consume(a), n.exit("labelMarker"), n.exit("labelImage"), o) : e(a);
  }
  function o(a) {
    return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? e(a) : t(a);
  }
}
const Gi = {
  name: "labelStartLink",
  tokenize: Ji,
  resolveAll: Ie.resolveAll
};
function Ji(n, t, e) {
  const r = this;
  return i;
  function i(o) {
    return n.enter("labelLink"), n.enter("labelMarker"), n.consume(o), n.exit("labelMarker"), n.exit("labelLink"), l;
  }
  function l(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? e(o) : t(o);
  }
}
const oe = {
  name: "lineEnding",
  tokenize: Zi
};
function Zi(n, t) {
  return e;
  function e(r) {
    return n.enter("lineEnding"), n.consume(r), n.exit("lineEnding"), an(n, t, "linePrefix");
  }
}
const Kn = {
  name: "thematicBreak",
  tokenize: nl
};
function nl(n, t, e) {
  let r = 0, i;
  return l;
  function l(s) {
    return n.enter("thematicBreak"), o(s);
  }
  function o(s) {
    return i = s, a(s);
  }
  function a(s) {
    return s === i ? (n.enter("thematicBreakSequence"), c(s)) : r >= 3 && (s === null || D(s)) ? (n.exit("thematicBreak"), t(s)) : e(s);
  }
  function c(s) {
    return s === i ? (n.consume(s), r++, c) : (n.exit("thematicBreakSequence"), K(s) ? an(n, a, "whitespace")(s) : a(s));
  }
}
const yn = {
  name: "list",
  tokenize: rl,
  continuation: {
    tokenize: il
  },
  exit: ol
}, el = {
  tokenize: al,
  partial: !0
}, tl = {
  tokenize: ll,
  partial: !0
};
function rl(n, t, e) {
  const r = this, i = r.events[r.events.length - 1];
  let l = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, o = 0;
  return a;
  function a(h) {
    const w = r.containerState.type || (h === 42 || h === 43 || h === 45 ? "listUnordered" : "listOrdered");
    if (w === "listUnordered" ? !r.containerState.marker || h === r.containerState.marker : ge(h)) {
      if (r.containerState.type || (r.containerState.type = w, n.enter(w, {
        _container: !0
      })), w === "listUnordered")
        return n.enter("listItemPrefix"), h === 42 || h === 45 ? n.check(Kn, e, s)(h) : s(h);
      if (!r.interrupt || h === 49)
        return n.enter("listItemPrefix"), n.enter("listItemValue"), c(h);
    }
    return e(h);
  }
  function c(h) {
    return ge(h) && ++o < 10 ? (n.consume(h), c) : (!r.interrupt || o < 2) && (r.containerState.marker ? h === r.containerState.marker : h === 41 || h === 46) ? (n.exit("listItemValue"), s(h)) : e(h);
  }
  function s(h) {
    return n.enter("listItemMarker"), n.consume(h), n.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || h, n.check(
      Gn,
      // Can’t be empty when interrupting.
      r.interrupt ? e : d,
      n.attempt(
        el,
        m,
        p
      )
    );
  }
  function d(h) {
    return r.containerState.initialBlankLine = !0, l++, m(h);
  }
  function p(h) {
    return K(h) ? (n.enter("listItemPrefixWhitespace"), n.consume(h), n.exit("listItemPrefixWhitespace"), m) : e(h);
  }
  function m(h) {
    return r.containerState.size = l + r.sliceSerialize(n.exit("listItemPrefix"), !0).length, t(h);
  }
}
function il(n, t, e) {
  const r = this;
  return r.containerState._closeFlow = void 0, n.check(Gn, i, l);
  function i(a) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, an(
      n,
      t,
      "listItemIndent",
      r.containerState.size + 1
    )(a);
  }
  function l(a) {
    return r.containerState.furtherBlankLines || !K(a) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, o(a)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, n.attempt(tl, t, o)(a));
  }
  function o(a) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, an(
      n,
      n.attempt(yn, t, e),
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(a);
  }
}
function ll(n, t, e) {
  const r = this;
  return an(
    n,
    i,
    "listItemIndent",
    r.containerState.size + 1
  );
  function i(l) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "listItemIndent" && o[2].sliceSerialize(o[1], !0).length === r.containerState.size ? t(l) : e(l);
  }
}
function ol(n) {
  n.exit(this.containerState.type);
}
function al(n, t, e) {
  const r = this;
  return an(
    n,
    i,
    "listItemPrefixWhitespace",
    r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5
  );
  function i(l) {
    const o = r.events[r.events.length - 1];
    return !K(l) && o && o[1].type === "listItemPrefixWhitespace" ? t(l) : e(l);
  }
}
const ot = {
  name: "setextUnderline",
  tokenize: sl,
  resolveTo: ul
};
function ul(n, t) {
  let e = n.length, r, i, l;
  for (; e--; )
    if (n[e][0] === "enter") {
      if (n[e][1].type === "content") {
        r = e;
        break;
      }
      n[e][1].type === "paragraph" && (i = e);
    } else
      n[e][1].type === "content" && n.splice(e, 1), !l && n[e][1].type === "definition" && (l = e);
  const o = {
    type: "setextHeading",
    start: Object.assign({}, n[i][1].start),
    end: Object.assign({}, n[n.length - 1][1].end)
  };
  return n[i][1].type = "setextHeadingText", l ? (n.splice(i, 0, ["enter", o, t]), n.splice(l + 1, 0, ["exit", n[r][1], t]), n[r][1].end = Object.assign({}, n[l][1].end)) : n[r][1] = o, n.push(["exit", o, t]), n;
}
function sl(n, t, e) {
  const r = this;
  let i;
  return l;
  function l(s) {
    let d = r.events.length, p;
    for (; d--; )
      if (r.events[d][1].type !== "lineEnding" && r.events[d][1].type !== "linePrefix" && r.events[d][1].type !== "content") {
        p = r.events[d][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || p) ? (n.enter("setextHeadingLine"), i = s, o(s)) : e(s);
  }
  function o(s) {
    return n.enter("setextHeadingLineSequence"), a(s);
  }
  function a(s) {
    return s === i ? (n.consume(s), a) : (n.exit("setextHeadingLineSequence"), K(s) ? an(n, c, "lineSuffix")(s) : c(s));
  }
  function c(s) {
    return s === null || D(s) ? (n.exit("setextHeadingLine"), t(s)) : e(s);
  }
}
const cl = {
  tokenize: fl
};
function fl(n) {
  const t = this, e = n.attempt(
    // Try to parse a blank line.
    Gn,
    r,
    // Try to parse initial flow (essentially, only code).
    n.attempt(
      this.parser.constructs.flowInitial,
      i,
      an(
        n,
        n.attempt(
          this.parser.constructs.flow,
          i,
          n.attempt(gi, i)
        ),
        "linePrefix"
      )
    )
  );
  return e;
  function r(l) {
    if (l === null) {
      n.consume(l);
      return;
    }
    return n.enter("lineEndingBlank"), n.consume(l), n.exit("lineEndingBlank"), t.currentConstruct = void 0, e;
  }
  function i(l) {
    if (l === null) {
      n.consume(l);
      return;
    }
    return n.enter("lineEnding"), n.consume(l), n.exit("lineEnding"), t.currentConstruct = void 0, e;
  }
}
const pl = {
  resolveAll: Ut()
}, hl = qt("string"), dl = qt("text");
function qt(n) {
  return {
    tokenize: t,
    resolveAll: Ut(
      n === "text" ? ml : void 0
    )
  };
  function t(e) {
    const r = this, i = this.parser.constructs[n], l = e.attempt(i, o, a);
    return o;
    function o(d) {
      return s(d) ? l(d) : a(d);
    }
    function a(d) {
      if (d === null) {
        e.consume(d);
        return;
      }
      return e.enter("data"), e.consume(d), c;
    }
    function c(d) {
      return s(d) ? (e.exit("data"), l(d)) : (e.consume(d), c);
    }
    function s(d) {
      if (d === null)
        return !0;
      const p = i[d];
      let m = -1;
      if (p)
        for (; ++m < p.length; ) {
          const h = p[m];
          if (!h.previous || h.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function Ut(n) {
  return t;
  function t(e, r) {
    let i = -1, l;
    for (; ++i <= e.length; )
      l === void 0 ? e[i] && e[i][1].type === "data" && (l = i, i++) : (!e[i] || e[i][1].type !== "data") && (i !== l + 2 && (e[l][1].end = e[i - 1][1].end, e.splice(l + 2, i - l - 2), i = l + 2), l = void 0);
    return n ? n(e, r) : e;
  }
}
function ml(n, t) {
  let e = 0;
  for (; ++e <= n.length; )
    if ((e === n.length || n[e][1].type === "lineEnding") && n[e - 1][1].type === "data") {
      const r = n[e - 1][1], i = t.sliceStream(r);
      let l = i.length, o = -1, a = 0, c;
      for (; l--; ) {
        const s = i[l];
        if (typeof s == "string") {
          for (o = s.length; s.charCodeAt(o - 1) === 32; )
            a++, o--;
          if (o)
            break;
          o = -1;
        } else if (s === -2)
          c = !0, a++;
        else if (s !== -1) {
          l++;
          break;
        }
      }
      if (a) {
        const s = {
          type: e === n.length || c || a < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - a,
            offset: r.end.offset - a,
            _index: r.start._index + l,
            _bufferIndex: l ? o : r.start._bufferIndex + o
          },
          end: Object.assign({}, r.end)
        };
        r.end = Object.assign({}, s.start), r.start.offset === r.end.offset ? Object.assign(r, s) : (n.splice(
          e,
          0,
          ["enter", s, t],
          ["exit", s, t]
        ), e += 2);
      }
      e++;
    }
  return n;
}
function gl(n, t, e) {
  let r = Object.assign(
    e ? Object.assign({}, e) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const i = {}, l = [];
  let o = [], a = [];
  const c = {
    consume: M,
    enter: v,
    exit: L,
    attempt: R(S),
    check: R(x),
    interrupt: R(x, {
      interrupt: !0
    })
  }, s = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: n,
    sliceStream: h,
    sliceSerialize: m,
    now: w,
    defineSkip: g,
    write: p
  };
  let d = t.tokenize.call(s, c);
  return t.resolveAll && l.push(t), s;
  function p(_) {
    return o = Sn(o, _), y(), o[o.length - 1] !== null ? [] : (q(t, 0), s.events = Pe(l, s.events, s), s.events);
  }
  function m(_, O) {
    return xl(h(_), O);
  }
  function h(_) {
    return yl(o, _);
  }
  function w() {
    const { line: _, column: O, offset: W, _index: en, _bufferIndex: Y } = r;
    return {
      line: _,
      column: O,
      offset: W,
      _index: en,
      _bufferIndex: Y
    };
  }
  function g(_) {
    i[_.line] = _.column, sn();
  }
  function y() {
    let _;
    for (; r._index < o.length; ) {
      const O = o[r._index];
      if (typeof O == "string")
        for (_ = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === _ && r._bufferIndex < O.length; )
          k(O.charCodeAt(r._bufferIndex));
      else
        k(O);
    }
  }
  function k(_) {
    d = d(_);
  }
  function M(_) {
    D(_) ? (r.line++, r.column = 1, r.offset += _ === -3 ? 2 : 1, sn()) : _ !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === o[r._index].length && (r._bufferIndex = -1, r._index++)), s.previous = _;
  }
  function v(_, O) {
    const W = O || {};
    return W.type = _, W.start = w(), s.events.push(["enter", W, s]), a.push(W), W;
  }
  function L(_) {
    const O = a.pop();
    return O.end = w(), s.events.push(["exit", O, s]), O;
  }
  function S(_, O) {
    q(_, O.from);
  }
  function x(_, O) {
    O.restore();
  }
  function R(_, O) {
    return W;
    function W(en, Y, tn) {
      let ln, hn, mn, u;
      return Array.isArray(en) ? F(en) : "tokenize" in en ? (
        // @ts-expect-error Looks like a construct.
        F([en])
      ) : T(en);
      function T(I) {
        return B;
        function B(j) {
          const Q = j !== null && I[j], V = j !== null && I.null, fn = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(Q) ? Q : Q ? [Q] : [],
            ...Array.isArray(V) ? V : V ? [V] : []
          ];
          return F(fn)(j);
        }
      }
      function F(I) {
        return ln = I, hn = 0, I.length === 0 ? tn : f(I[hn]);
      }
      function f(I) {
        return B;
        function B(j) {
          return u = X(), mn = I, I.partial || (s.currentConstruct = I), I.name && s.parser.constructs.disable.null.includes(I.name) ? H() : I.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            O ? Object.assign(Object.create(s), O) : s,
            c,
            z,
            H
          )(j);
        }
      }
      function z(I) {
        return _(mn, u), Y;
      }
      function H(I) {
        return u.restore(), ++hn < ln.length ? f(ln[hn]) : tn;
      }
    }
  }
  function q(_, O) {
    _.resolveAll && !l.includes(_) && l.push(_), _.resolve && In(
      s.events,
      O,
      s.events.length - O,
      _.resolve(s.events.slice(O), s)
    ), _.resolveTo && (s.events = _.resolveTo(s.events, s));
  }
  function X() {
    const _ = w(), O = s.previous, W = s.currentConstruct, en = s.events.length, Y = Array.from(a);
    return {
      restore: tn,
      from: en
    };
    function tn() {
      r = _, s.previous = O, s.currentConstruct = W, s.events.length = en, a = Y, sn();
    }
  }
  function sn() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function yl(n, t) {
  const e = t.start._index, r = t.start._bufferIndex, i = t.end._index, l = t.end._bufferIndex;
  let o;
  if (e === i)
    o = [n[e].slice(r, l)];
  else {
    if (o = n.slice(e, i), r > -1) {
      const a = o[0];
      typeof a == "string" ? o[0] = a.slice(r) : o.shift();
    }
    l > 0 && o.push(n[i].slice(0, l));
  }
  return o;
}
function xl(n, t) {
  let e = -1;
  const r = [];
  let i;
  for (; ++e < n.length; ) {
    const l = n[e];
    let o;
    if (typeof l == "string")
      o = l;
    else
      switch (l) {
        case -5: {
          o = "\r";
          break;
        }
        case -4: {
          o = `
`;
          break;
        }
        case -3: {
          o = `\r
`;
          break;
        }
        case -2: {
          o = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && i)
            continue;
          o = " ";
          break;
        }
        default:
          o = String.fromCharCode(l);
      }
    i = l === -2, r.push(o);
  }
  return r.join("");
}
const bl = {
  42: yn,
  43: yn,
  45: yn,
  48: yn,
  49: yn,
  50: yn,
  51: yn,
  52: yn,
  53: yn,
  54: yn,
  55: yn,
  56: yn,
  57: yn,
  62: Mt
}, kl = {
  91: Si
}, Sl = {
  [-2]: le,
  [-1]: le,
  32: le
}, wl = {
  35: Pi,
  42: Kn,
  45: [ot, Kn],
  60: Ri,
  61: ot,
  95: Kn,
  96: it,
  126: it
}, El = {
  38: Dt,
  92: Ft
}, vl = {
  [-5]: oe,
  [-4]: oe,
  [-3]: oe,
  33: Xi,
  38: Dt,
  42: ke,
  60: [Jr, Bi],
  91: Gi,
  92: [Ci, Ft],
  93: Ie,
  95: ke,
  96: fi
}, Cl = {
  null: [ke, pl]
}, Tl = {
  null: [42, 95]
}, Pl = {
  null: []
}, Ol = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: Tl,
  contentInitial: kl,
  disable: Pl,
  document: bl,
  flow: wl,
  flowInitial: Sl,
  insideSpan: Cl,
  string: El,
  text: vl
}, Symbol.toStringTag, { value: "Module" }));
function Il(n) {
  const e = (
    /** @type {FullNormalizedExtension} */
    mr([Ol, ...(n || {}).extensions || []])
  ), r = {
    defined: [],
    lazy: {},
    constructs: e,
    content: i(Vr),
    document: i(Wr),
    flow: i(cl),
    string: i(hl),
    text: i(dl)
  };
  return r;
  function i(l) {
    return o;
    function o(a) {
      return gl(r, l, a);
    }
  }
}
const at = /[\0\t\n\r]/g;
function Al() {
  let n = 1, t = "", e = !0, r;
  return i;
  function i(l, o, a) {
    const c = [];
    let s, d, p, m, h;
    for (l = t + l.toString(o), p = 0, t = "", e && (l.charCodeAt(0) === 65279 && p++, e = void 0); p < l.length; ) {
      if (at.lastIndex = p, s = at.exec(l), m = s && s.index !== void 0 ? s.index : l.length, h = l.charCodeAt(m), !s) {
        t = l.slice(p);
        break;
      }
      if (h === 10 && p === m && r)
        c.push(-3), r = void 0;
      else
        switch (r && (c.push(-5), r = void 0), p < m && (c.push(l.slice(p, m)), n += m - p), h) {
          case 0: {
            c.push(65533), n++;
            break;
          }
          case 9: {
            for (d = Math.ceil(n / 4) * 4, c.push(-2); n++ < d; )
              c.push(-1);
            break;
          }
          case 10: {
            c.push(-4), n = 1;
            break;
          }
          default:
            r = !0, n = 1;
        }
      p = m + 1;
    }
    return a && (r && c.push(-5), t && c.push(t), c.push(null)), c;
  }
}
function Rl(n) {
  for (; !Bt(n); )
    ;
  return n;
}
function Ht(n, t) {
  const e = Number.parseInt(n, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    e < 9 || e === 11 || e > 13 && e < 32 || // Control character (DEL) of C0, and C1 controls.
    e > 126 && e < 160 || // Lone high surrogates and low surrogates.
    e > 55295 && e < 57344 || // Noncharacters.
    e > 64975 && e < 65008 || (e & 65535) === 65535 || (e & 65535) === 65534 || // Out of range
    e > 1114111 ? "�" : String.fromCharCode(e)
  );
}
const _l = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function Ll(n) {
  return n.replace(_l, zl);
}
function zl(n, t, e) {
  if (t)
    return t;
  if (e.charCodeAt(0) === 35) {
    const i = e.charCodeAt(1), l = i === 120 || i === 88;
    return Ht(e.slice(l ? 2 : 1), l ? 16 : 10);
  }
  return Oe(e) || n;
}
const Se = {}.hasOwnProperty, Ml = (
  /**
   * @type {(
   *   ((value: Value, encoding: Encoding, options?: Options) => Root) &
   *   ((value: Value, options?: Options) => Root)
   * )}
   */
  /**
   * @param {Value} value
   * @param {Encoding} [encoding]
   * @param {Options} [options]
   * @returns {Root}
   */
  function(n, t, e) {
    return typeof t != "string" && (e = t, t = void 0), Fl(e)(
      Rl(
        Il(e).document().write(Al()(n, t, !0))
      )
    );
  }
);
function Fl(n = {}) {
  const t = Vt(
    {
      transforms: [],
      canContainEols: [
        "emphasis",
        "fragment",
        "heading",
        "paragraph",
        "strong"
      ],
      enter: {
        autolink: c(Me),
        autolinkProtocol: O,
        autolinkEmail: O,
        atxHeading: c(Bn),
        blockQuote: c(P),
        characterEscape: O,
        characterReference: O,
        codeFenced: c(gn),
        codeFencedFenceInfo: s,
        codeFencedFenceMeta: s,
        codeIndented: c(gn, s),
        codeText: c(A, s),
        codeTextData: O,
        data: O,
        codeFlowValue: O,
        definition: c(On),
        definitionDestinationString: s,
        definitionLabelString: s,
        definitionTitleString: s,
        emphasis: c(_n),
        hardBreakEscape: c(Le),
        hardBreakTrailing: c(Le),
        htmlFlow: c(ze, s),
        htmlFlowData: O,
        htmlText: c(ze, s),
        htmlTextData: O,
        image: c(ir),
        label: s,
        link: c(Me),
        listItem: c(lr),
        listItemValue: g,
        listOrdered: c(Fe, w),
        listUnordered: c(Fe),
        paragraph: c(or),
        reference: I,
        referenceString: s,
        resourceDestinationString: s,
        resourceTitleString: s,
        setextHeading: c(Bn),
        strong: c(ar),
        thematicBreak: c(sr)
      },
      exit: {
        atxHeading: p(),
        atxHeadingSequence: q,
        autolink: p(),
        autolinkEmail: fn,
        autolinkProtocol: V,
        blockQuote: p(),
        characterEscapeValue: W,
        characterReferenceMarkerHexadecimal: j,
        characterReferenceMarkerNumeric: j,
        characterReferenceValue: Q,
        codeFenced: p(v),
        codeFencedFence: M,
        codeFencedFenceInfo: y,
        codeFencedFenceMeta: k,
        codeFlowValue: W,
        codeIndented: p(L),
        codeText: p(hn),
        codeTextData: W,
        data: W,
        definition: p(),
        definitionDestinationString: R,
        definitionLabelString: S,
        definitionTitleString: x,
        emphasis: p(),
        hardBreakEscape: p(Y),
        hardBreakTrailing: p(Y),
        htmlFlow: p(tn),
        htmlFlowData: W,
        htmlText: p(ln),
        htmlTextData: W,
        image: p(u),
        label: F,
        labelText: T,
        lineEnding: en,
        link: p(mn),
        listItem: p(),
        listOrdered: p(),
        listUnordered: p(),
        paragraph: p(),
        referenceString: B,
        resourceDestinationString: f,
        resourceTitleString: z,
        resource: H,
        setextHeading: p(_),
        setextHeadingLineSequence: sn,
        setextHeadingText: X,
        strong: p(),
        thematicBreak: p()
      }
    },
    n.mdastExtensions || []
  ), e = {};
  return r;
  function r(b) {
    let C = {
      type: "root",
      children: []
    };
    const N = [C], rn = [], kn = [], jn = {
      stack: N,
      tokenStack: rn,
      config: t,
      enter: d,
      exit: m,
      buffer: s,
      resume: h,
      setData: l,
      getData: o
    };
    let un = -1;
    for (; ++un < b.length; )
      if (b[un][1].type === "listOrdered" || b[un][1].type === "listUnordered")
        if (b[un][0] === "enter")
          kn.push(un);
        else {
          const dn = kn.pop();
          un = i(b, dn, un);
        }
    for (un = -1; ++un < b.length; ) {
      const dn = t[b[un][0]];
      Se.call(dn, b[un][1].type) && dn[b[un][1].type].call(
        Object.assign(
          {
            sliceSerialize: b[un][2].sliceSerialize
          },
          jn
        ),
        b[un][1]
      );
    }
    if (rn.length > 0) {
      const dn = rn[rn.length - 1];
      (dn[1] || ut).call(jn, void 0, dn[0]);
    }
    for (C.position = {
      start: a(
        b.length > 0 ? b[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: a(
        b.length > 0 ? b[b.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    }, un = -1; ++un < t.transforms.length; )
      C = t.transforms[un](C) || C;
    return C;
  }
  function i(b, C, N) {
    let rn = C - 1, kn = -1, jn = !1, un, dn, Ln, $n;
    for (; ++rn <= N; ) {
      const cn = b[rn];
      if (cn[1].type === "listUnordered" || cn[1].type === "listOrdered" || cn[1].type === "blockQuote" ? (cn[0] === "enter" ? kn++ : kn--, $n = void 0) : cn[1].type === "lineEndingBlank" ? cn[0] === "enter" && (un && !$n && !kn && !Ln && (Ln = rn), $n = void 0) : cn[1].type === "linePrefix" || cn[1].type === "listItemValue" || cn[1].type === "listItemMarker" || cn[1].type === "listItemPrefix" || cn[1].type === "listItemPrefixWhitespace" || ($n = void 0), !kn && cn[0] === "enter" && cn[1].type === "listItemPrefix" || kn === -1 && cn[0] === "exit" && (cn[1].type === "listUnordered" || cn[1].type === "listOrdered")) {
        if (un) {
          let Jn = rn;
          for (dn = void 0; Jn--; ) {
            const Pn = b[Jn];
            if (Pn[1].type === "lineEnding" || Pn[1].type === "lineEndingBlank") {
              if (Pn[0] === "exit")
                continue;
              dn && (b[dn][1].type = "lineEndingBlank", jn = !0), Pn[1].type = "lineEnding", dn = Jn;
            } else if (!(Pn[1].type === "linePrefix" || Pn[1].type === "blockQuotePrefix" || Pn[1].type === "blockQuotePrefixWhitespace" || Pn[1].type === "blockQuoteMarker" || Pn[1].type === "listItemIndent"))
              break;
          }
          Ln && (!dn || Ln < dn) && (un._spread = !0), un.end = Object.assign(
            {},
            dn ? b[dn][1].start : cn[1].end
          ), b.splice(dn || rn, 0, ["exit", un, cn[2]]), rn++, N++;
        }
        cn[1].type === "listItemPrefix" && (un = {
          type: "listItem",
          // @ts-expect-error Patched
          _spread: !1,
          start: Object.assign({}, cn[1].start)
        }, b.splice(rn, 0, ["enter", un, cn[2]]), rn++, N++, Ln = void 0, $n = !0);
      }
    }
    return b[C][1]._spread = jn, N;
  }
  function l(b, C) {
    e[b] = C;
  }
  function o(b) {
    return e[b];
  }
  function a(b) {
    return {
      line: b.line,
      column: b.column,
      offset: b.offset
    };
  }
  function c(b, C) {
    return N;
    function N(rn) {
      d.call(this, b(rn), rn), C && C.call(this, rn);
    }
  }
  function s() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function d(b, C, N) {
    return this.stack[this.stack.length - 1].children.push(b), this.stack.push(b), this.tokenStack.push([C, N]), b.position = {
      start: a(C.start)
    }, b;
  }
  function p(b) {
    return C;
    function C(N) {
      b && b.call(this, N), m.call(this, N);
    }
  }
  function m(b, C) {
    const N = this.stack.pop(), rn = this.tokenStack.pop();
    if (rn)
      rn[0].type !== b.type && (C ? C.call(this, b, rn[0]) : (rn[1] || ut).call(this, b, rn[0]));
    else
      throw new Error(
        "Cannot close `" + b.type + "` (" + qn({
          start: b.start,
          end: b.end
        }) + "): it’s not open"
      );
    return N.position.end = a(b.end), N;
  }
  function h() {
    return Ur(this.stack.pop());
  }
  function w() {
    l("expectingFirstListItemValue", !0);
  }
  function g(b) {
    if (o("expectingFirstListItemValue")) {
      const C = (
        /** @type {List} */
        this.stack[this.stack.length - 2]
      );
      C.start = Number.parseInt(this.sliceSerialize(b), 10), l("expectingFirstListItemValue");
    }
  }
  function y() {
    const b = this.resume(), C = (
      /** @type {Code} */
      this.stack[this.stack.length - 1]
    );
    C.lang = b;
  }
  function k() {
    const b = this.resume(), C = (
      /** @type {Code} */
      this.stack[this.stack.length - 1]
    );
    C.meta = b;
  }
  function M() {
    o("flowCodeInside") || (this.buffer(), l("flowCodeInside", !0));
  }
  function v() {
    const b = this.resume(), C = (
      /** @type {Code} */
      this.stack[this.stack.length - 1]
    );
    C.value = b.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), l("flowCodeInside");
  }
  function L() {
    const b = this.resume(), C = (
      /** @type {Code} */
      this.stack[this.stack.length - 1]
    );
    C.value = b.replace(/(\r?\n|\r)$/g, "");
  }
  function S(b) {
    const C = this.resume(), N = (
      /** @type {Definition} */
      this.stack[this.stack.length - 1]
    );
    N.label = C, N.identifier = Mn(
      this.sliceSerialize(b)
    ).toLowerCase();
  }
  function x() {
    const b = this.resume(), C = (
      /** @type {Definition} */
      this.stack[this.stack.length - 1]
    );
    C.title = b;
  }
  function R() {
    const b = this.resume(), C = (
      /** @type {Definition} */
      this.stack[this.stack.length - 1]
    );
    C.url = b;
  }
  function q(b) {
    const C = (
      /** @type {Heading} */
      this.stack[this.stack.length - 1]
    );
    if (!C.depth) {
      const N = this.sliceSerialize(b).length;
      C.depth = N;
    }
  }
  function X() {
    l("setextHeadingSlurpLineEnding", !0);
  }
  function sn(b) {
    const C = (
      /** @type {Heading} */
      this.stack[this.stack.length - 1]
    );
    C.depth = this.sliceSerialize(b).charCodeAt(0) === 61 ? 1 : 2;
  }
  function _() {
    l("setextHeadingSlurpLineEnding");
  }
  function O(b) {
    const C = (
      /** @type {Parent} */
      this.stack[this.stack.length - 1]
    );
    let N = C.children[C.children.length - 1];
    (!N || N.type !== "text") && (N = ur(), N.position = {
      start: a(b.start)
    }, C.children.push(N)), this.stack.push(N);
  }
  function W(b) {
    const C = this.stack.pop();
    C.value += this.sliceSerialize(b), C.position.end = a(b.end);
  }
  function en(b) {
    const C = this.stack[this.stack.length - 1];
    if (o("atHardBreak")) {
      const N = C.children[C.children.length - 1];
      N.position.end = a(b.end), l("atHardBreak");
      return;
    }
    !o("setextHeadingSlurpLineEnding") && t.canContainEols.includes(C.type) && (O.call(this, b), W.call(this, b));
  }
  function Y() {
    l("atHardBreak", !0);
  }
  function tn() {
    const b = this.resume(), C = (
      /** @type {HTML} */
      this.stack[this.stack.length - 1]
    );
    C.value = b;
  }
  function ln() {
    const b = this.resume(), C = (
      /** @type {HTML} */
      this.stack[this.stack.length - 1]
    );
    C.value = b;
  }
  function hn() {
    const b = this.resume(), C = (
      /** @type {InlineCode} */
      this.stack[this.stack.length - 1]
    );
    C.value = b;
  }
  function mn() {
    const b = (
      /** @type {Link & {identifier: string, label: string}} */
      this.stack[this.stack.length - 1]
    );
    o("inReference") ? (b.type += "Reference", b.referenceType = o("referenceType") || "shortcut", delete b.url, delete b.title) : (delete b.identifier, delete b.label), l("referenceType");
  }
  function u() {
    const b = (
      /** @type {Image & {identifier: string, label: string}} */
      this.stack[this.stack.length - 1]
    );
    o("inReference") ? (b.type += "Reference", b.referenceType = o("referenceType") || "shortcut", delete b.url, delete b.title) : (delete b.identifier, delete b.label), l("referenceType");
  }
  function T(b) {
    const C = (
      /** @type {(Link|Image) & {identifier: string, label: string}} */
      this.stack[this.stack.length - 2]
    ), N = this.sliceSerialize(b);
    C.label = Ll(N), C.identifier = Mn(N).toLowerCase();
  }
  function F() {
    const b = (
      /** @type {Fragment} */
      this.stack[this.stack.length - 1]
    ), C = this.resume(), N = (
      /** @type {(Link|Image) & {identifier: string, label: string}} */
      this.stack[this.stack.length - 1]
    );
    l("inReference", !0), N.type === "link" ? N.children = b.children : N.alt = C;
  }
  function f() {
    const b = this.resume(), C = (
      /** @type {Link|Image} */
      this.stack[this.stack.length - 1]
    );
    C.url = b;
  }
  function z() {
    const b = this.resume(), C = (
      /** @type {Link|Image} */
      this.stack[this.stack.length - 1]
    );
    C.title = b;
  }
  function H() {
    l("inReference");
  }
  function I() {
    l("referenceType", "collapsed");
  }
  function B(b) {
    const C = this.resume(), N = (
      /** @type {LinkReference|ImageReference} */
      this.stack[this.stack.length - 1]
    );
    N.label = C, N.identifier = Mn(
      this.sliceSerialize(b)
    ).toLowerCase(), l("referenceType", "full");
  }
  function j(b) {
    l("characterReferenceType", b.type);
  }
  function Q(b) {
    const C = this.sliceSerialize(b), N = o("characterReferenceType");
    let rn;
    N ? (rn = Ht(
      C,
      N === "characterReferenceMarkerNumeric" ? 10 : 16
    ), l("characterReferenceType")) : rn = Oe(C);
    const kn = this.stack.pop();
    kn.value += rn, kn.position.end = a(b.end);
  }
  function V(b) {
    W.call(this, b);
    const C = (
      /** @type {Link} */
      this.stack[this.stack.length - 1]
    );
    C.url = this.sliceSerialize(b);
  }
  function fn(b) {
    W.call(this, b);
    const C = (
      /** @type {Link} */
      this.stack[this.stack.length - 1]
    );
    C.url = "mailto:" + this.sliceSerialize(b);
  }
  function P() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function gn() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function A() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function On() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function _n() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Bn() {
    return {
      type: "heading",
      depth: void 0,
      children: []
    };
  }
  function Le() {
    return {
      type: "break"
    };
  }
  function ze() {
    return {
      type: "html",
      value: ""
    };
  }
  function ir() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function Me() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function Fe(b) {
    return {
      type: "list",
      ordered: b.type === "listOrdered",
      start: null,
      // @ts-expect-error Patched.
      spread: b._spread,
      children: []
    };
  }
  function lr(b) {
    return {
      type: "listItem",
      // @ts-expect-error Patched.
      spread: b._spread,
      checked: null,
      children: []
    };
  }
  function or() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function ar() {
    return {
      type: "strong",
      children: []
    };
  }
  function ur() {
    return {
      type: "text",
      value: ""
    };
  }
  function sr() {
    return {
      type: "thematicBreak"
    };
  }
}
function Vt(n, t) {
  let e = -1;
  for (; ++e < t.length; ) {
    const r = t[e];
    Array.isArray(r) ? Vt(n, r) : Dl(n, r);
  }
  return n;
}
function Dl(n, t) {
  let e;
  for (e in t)
    if (Se.call(t, e)) {
      const r = e === "canContainEols" || e === "transforms", l = (Se.call(n, e) ? n[e] : void 0) || (n[e] = r ? [] : {}), o = t[e];
      o && (r ? n[e] = [...l, ...o] : Object.assign(l, o));
    }
}
function ut(n, t) {
  throw n ? new Error(
    "Cannot close `" + n.type + "` (" + qn({
      start: n.start,
      end: n.end
    }) + "): a different token (`" + t.type + "`, " + qn({
      start: t.start,
      end: t.end
    }) + ") is open"
  ) : new Error(
    "Cannot close document, a token (`" + t.type + "`, " + qn({
      start: t.start,
      end: t.end
    }) + ") is still open"
  );
}
function Bl(n) {
  Object.assign(this, { Parser: (e) => {
    const r = (
      /** @type {Options} */
      this.data("settings")
    );
    return Ml(
      e,
      Object.assign({}, r, n, {
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: this.data("micromarkExtensions") || [],
        mdastExtensions: this.data("fromMarkdownExtensions") || []
      })
    );
  } });
}
var we = { exports: {} }, ae, st;
function Ae() {
  if (st)
    return ae;
  st = 1;
  var n = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return ae = n, ae;
}
var ue, ct;
function jl() {
  if (ct)
    return ue;
  ct = 1;
  var n = Ae();
  function t() {
  }
  function e() {
  }
  return e.resetWarningCache = t, ue = function() {
    function r(o, a, c, s, d, p) {
      if (p !== n) {
        var m = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw m.name = "Invariant Violation", m;
      }
    }
    r.isRequired = r;
    function i() {
      return r;
    }
    var l = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: i,
      element: r,
      elementType: r,
      instanceOf: i,
      node: r,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: e,
      resetWarningCache: t
    };
    return l.PropTypes = l, l;
  }, ue;
}
var Wn = { exports: {} }, G = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ft;
function $l() {
  return ft || (ft = 1, process.env.NODE_ENV !== "production" && function() {
    var n = typeof Symbol == "function" && Symbol.for, t = n ? Symbol.for("react.element") : 60103, e = n ? Symbol.for("react.portal") : 60106, r = n ? Symbol.for("react.fragment") : 60107, i = n ? Symbol.for("react.strict_mode") : 60108, l = n ? Symbol.for("react.profiler") : 60114, o = n ? Symbol.for("react.provider") : 60109, a = n ? Symbol.for("react.context") : 60110, c = n ? Symbol.for("react.async_mode") : 60111, s = n ? Symbol.for("react.concurrent_mode") : 60111, d = n ? Symbol.for("react.forward_ref") : 60112, p = n ? Symbol.for("react.suspense") : 60113, m = n ? Symbol.for("react.suspense_list") : 60120, h = n ? Symbol.for("react.memo") : 60115, w = n ? Symbol.for("react.lazy") : 60116, g = n ? Symbol.for("react.block") : 60121, y = n ? Symbol.for("react.fundamental") : 60117, k = n ? Symbol.for("react.responder") : 60118, M = n ? Symbol.for("react.scope") : 60119;
    function v(P) {
      return typeof P == "string" || typeof P == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      P === r || P === s || P === l || P === i || P === p || P === m || typeof P == "object" && P !== null && (P.$$typeof === w || P.$$typeof === h || P.$$typeof === o || P.$$typeof === a || P.$$typeof === d || P.$$typeof === y || P.$$typeof === k || P.$$typeof === M || P.$$typeof === g);
    }
    function L(P) {
      if (typeof P == "object" && P !== null) {
        var gn = P.$$typeof;
        switch (gn) {
          case t:
            var A = P.type;
            switch (A) {
              case c:
              case s:
              case r:
              case l:
              case i:
              case p:
                return A;
              default:
                var On = A && A.$$typeof;
                switch (On) {
                  case a:
                  case d:
                  case w:
                  case h:
                  case o:
                    return On;
                  default:
                    return gn;
                }
            }
          case e:
            return gn;
        }
      }
    }
    var S = c, x = s, R = a, q = o, X = t, sn = d, _ = r, O = w, W = h, en = e, Y = l, tn = i, ln = p, hn = !1;
    function mn(P) {
      return hn || (hn = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), u(P) || L(P) === c;
    }
    function u(P) {
      return L(P) === s;
    }
    function T(P) {
      return L(P) === a;
    }
    function F(P) {
      return L(P) === o;
    }
    function f(P) {
      return typeof P == "object" && P !== null && P.$$typeof === t;
    }
    function z(P) {
      return L(P) === d;
    }
    function H(P) {
      return L(P) === r;
    }
    function I(P) {
      return L(P) === w;
    }
    function B(P) {
      return L(P) === h;
    }
    function j(P) {
      return L(P) === e;
    }
    function Q(P) {
      return L(P) === l;
    }
    function V(P) {
      return L(P) === i;
    }
    function fn(P) {
      return L(P) === p;
    }
    G.AsyncMode = S, G.ConcurrentMode = x, G.ContextConsumer = R, G.ContextProvider = q, G.Element = X, G.ForwardRef = sn, G.Fragment = _, G.Lazy = O, G.Memo = W, G.Portal = en, G.Profiler = Y, G.StrictMode = tn, G.Suspense = ln, G.isAsyncMode = mn, G.isConcurrentMode = u, G.isContextConsumer = T, G.isContextProvider = F, G.isElement = f, G.isForwardRef = z, G.isFragment = H, G.isLazy = I, G.isMemo = B, G.isPortal = j, G.isProfiler = Q, G.isStrictMode = V, G.isSuspense = fn, G.isValidElementType = v, G.typeOf = L;
  }()), G;
}
var J = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var pt;
function Nl() {
  if (pt)
    return J;
  pt = 1;
  var n = typeof Symbol == "function" && Symbol.for, t = n ? Symbol.for("react.element") : 60103, e = n ? Symbol.for("react.portal") : 60106, r = n ? Symbol.for("react.fragment") : 60107, i = n ? Symbol.for("react.strict_mode") : 60108, l = n ? Symbol.for("react.profiler") : 60114, o = n ? Symbol.for("react.provider") : 60109, a = n ? Symbol.for("react.context") : 60110, c = n ? Symbol.for("react.async_mode") : 60111, s = n ? Symbol.for("react.concurrent_mode") : 60111, d = n ? Symbol.for("react.forward_ref") : 60112, p = n ? Symbol.for("react.suspense") : 60113, m = n ? Symbol.for("react.suspense_list") : 60120, h = n ? Symbol.for("react.memo") : 60115, w = n ? Symbol.for("react.lazy") : 60116, g = n ? Symbol.for("react.block") : 60121, y = n ? Symbol.for("react.fundamental") : 60117, k = n ? Symbol.for("react.responder") : 60118, M = n ? Symbol.for("react.scope") : 60119;
  function v(S) {
    if (typeof S == "object" && S !== null) {
      var x = S.$$typeof;
      switch (x) {
        case t:
          switch (S = S.type, S) {
            case c:
            case s:
            case r:
            case l:
            case i:
            case p:
              return S;
            default:
              switch (S = S && S.$$typeof, S) {
                case a:
                case d:
                case w:
                case h:
                case o:
                  return S;
                default:
                  return x;
              }
          }
        case e:
          return x;
      }
    }
  }
  function L(S) {
    return v(S) === s;
  }
  return J.AsyncMode = c, J.ConcurrentMode = s, J.ContextConsumer = a, J.ContextProvider = o, J.Element = t, J.ForwardRef = d, J.Fragment = r, J.Lazy = w, J.Memo = h, J.Portal = e, J.Profiler = l, J.StrictMode = i, J.Suspense = p, J.isAsyncMode = function(S) {
    return L(S) || v(S) === c;
  }, J.isConcurrentMode = L, J.isContextConsumer = function(S) {
    return v(S) === a;
  }, J.isContextProvider = function(S) {
    return v(S) === o;
  }, J.isElement = function(S) {
    return typeof S == "object" && S !== null && S.$$typeof === t;
  }, J.isForwardRef = function(S) {
    return v(S) === d;
  }, J.isFragment = function(S) {
    return v(S) === r;
  }, J.isLazy = function(S) {
    return v(S) === w;
  }, J.isMemo = function(S) {
    return v(S) === h;
  }, J.isPortal = function(S) {
    return v(S) === e;
  }, J.isProfiler = function(S) {
    return v(S) === l;
  }, J.isStrictMode = function(S) {
    return v(S) === i;
  }, J.isSuspense = function(S) {
    return v(S) === p;
  }, J.isValidElementType = function(S) {
    return typeof S == "string" || typeof S == "function" || S === r || S === s || S === l || S === i || S === p || S === m || typeof S == "object" && S !== null && (S.$$typeof === w || S.$$typeof === h || S.$$typeof === o || S.$$typeof === a || S.$$typeof === d || S.$$typeof === y || S.$$typeof === k || S.$$typeof === M || S.$$typeof === g);
  }, J.typeOf = v, J;
}
var ht;
function Yt() {
  return ht || (ht = 1, process.env.NODE_ENV === "production" ? Wn.exports = Nl() : Wn.exports = $l()), Wn.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var se, dt;
function ql() {
  if (dt)
    return se;
  dt = 1;
  var n = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, e = Object.prototype.propertyIsEnumerable;
  function r(l) {
    if (l == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(l);
  }
  function i() {
    try {
      if (!Object.assign)
        return !1;
      var l = new String("abc");
      if (l[5] = "de", Object.getOwnPropertyNames(l)[0] === "5")
        return !1;
      for (var o = {}, a = 0; a < 10; a++)
        o["_" + String.fromCharCode(a)] = a;
      var c = Object.getOwnPropertyNames(o).map(function(d) {
        return o[d];
      });
      if (c.join("") !== "0123456789")
        return !1;
      var s = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(d) {
        s[d] = d;
      }), Object.keys(Object.assign({}, s)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return se = i() ? Object.assign : function(l, o) {
    for (var a, c = r(l), s, d = 1; d < arguments.length; d++) {
      a = Object(arguments[d]);
      for (var p in a)
        t.call(a, p) && (c[p] = a[p]);
      if (n) {
        s = n(a);
        for (var m = 0; m < s.length; m++)
          e.call(a, s[m]) && (c[s[m]] = a[s[m]]);
      }
    }
    return c;
  }, se;
}
var ce, mt;
function Wt() {
  return mt || (mt = 1, ce = Function.call.bind(Object.prototype.hasOwnProperty)), ce;
}
var fe, gt;
function Ul() {
  if (gt)
    return fe;
  gt = 1;
  var n = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = Ae(), e = {}, r = Wt();
    n = function(l) {
      var o = "Warning: " + l;
      typeof console < "u" && console.error(o);
      try {
        throw new Error(o);
      } catch {
      }
    };
  }
  function i(l, o, a, c, s) {
    if (process.env.NODE_ENV !== "production") {
      for (var d in l)
        if (r(l, d)) {
          var p;
          try {
            if (typeof l[d] != "function") {
              var m = Error(
                (c || "React class") + ": " + a + " type `" + d + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof l[d] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw m.name = "Invariant Violation", m;
            }
            p = l[d](o, d, c, a, null, t);
          } catch (w) {
            p = w;
          }
          if (p && !(p instanceof Error) && n(
            (c || "React class") + ": type specification of " + a + " `" + d + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in e)) {
            e[p.message] = !0;
            var h = s ? s() : "";
            n(
              "Failed " + a + " type: " + p.message + (h ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (e = {});
  }, fe = i, fe;
}
var pe, yt;
function Hl() {
  if (yt)
    return pe;
  yt = 1;
  var n = Yt(), t = ql(), e = Ae(), r = Wt(), i = Ul(), l = function() {
  };
  process.env.NODE_ENV !== "production" && (l = function(a) {
    var c = "Warning: " + a;
    typeof console < "u" && console.error(c);
    try {
      throw new Error(c);
    } catch {
    }
  });
  function o() {
    return null;
  }
  return pe = function(a, c) {
    var s = typeof Symbol == "function" && Symbol.iterator, d = "@@iterator";
    function p(u) {
      var T = u && (s && u[s] || u[d]);
      if (typeof T == "function")
        return T;
    }
    var m = "<<anonymous>>", h = {
      array: k("array"),
      bigint: k("bigint"),
      bool: k("boolean"),
      func: k("function"),
      number: k("number"),
      object: k("object"),
      string: k("string"),
      symbol: k("symbol"),
      any: M(),
      arrayOf: v,
      element: L(),
      elementType: S(),
      instanceOf: x,
      node: sn(),
      objectOf: q,
      oneOf: R,
      oneOfType: X,
      shape: O,
      exact: W
    };
    function w(u, T) {
      return u === T ? u !== 0 || 1 / u === 1 / T : u !== u && T !== T;
    }
    function g(u, T) {
      this.message = u, this.data = T && typeof T == "object" ? T : {}, this.stack = "";
    }
    g.prototype = Error.prototype;
    function y(u) {
      if (process.env.NODE_ENV !== "production")
        var T = {}, F = 0;
      function f(H, I, B, j, Q, V, fn) {
        if (j = j || m, V = V || B, fn !== e) {
          if (c) {
            var P = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw P.name = "Invariant Violation", P;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var gn = j + ":" + B;
            !T[gn] && // Avoid spamming the console because they are often not actionable except for lib authors
            F < 3 && (l(
              "You are manually calling a React.PropTypes validation function for the `" + V + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), T[gn] = !0, F++);
          }
        }
        return I[B] == null ? H ? I[B] === null ? new g("The " + Q + " `" + V + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new g("The " + Q + " `" + V + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : u(I, B, j, Q, V);
      }
      var z = f.bind(null, !1);
      return z.isRequired = f.bind(null, !0), z;
    }
    function k(u) {
      function T(F, f, z, H, I, B) {
        var j = F[f], Q = tn(j);
        if (Q !== u) {
          var V = ln(j);
          return new g(
            "Invalid " + H + " `" + I + "` of type " + ("`" + V + "` supplied to `" + z + "`, expected ") + ("`" + u + "`."),
            { expectedType: u }
          );
        }
        return null;
      }
      return y(T);
    }
    function M() {
      return y(o);
    }
    function v(u) {
      function T(F, f, z, H, I) {
        if (typeof u != "function")
          return new g("Property `" + I + "` of component `" + z + "` has invalid PropType notation inside arrayOf.");
        var B = F[f];
        if (!Array.isArray(B)) {
          var j = tn(B);
          return new g("Invalid " + H + " `" + I + "` of type " + ("`" + j + "` supplied to `" + z + "`, expected an array."));
        }
        for (var Q = 0; Q < B.length; Q++) {
          var V = u(B, Q, z, H, I + "[" + Q + "]", e);
          if (V instanceof Error)
            return V;
        }
        return null;
      }
      return y(T);
    }
    function L() {
      function u(T, F, f, z, H) {
        var I = T[F];
        if (!a(I)) {
          var B = tn(I);
          return new g("Invalid " + z + " `" + H + "` of type " + ("`" + B + "` supplied to `" + f + "`, expected a single ReactElement."));
        }
        return null;
      }
      return y(u);
    }
    function S() {
      function u(T, F, f, z, H) {
        var I = T[F];
        if (!n.isValidElementType(I)) {
          var B = tn(I);
          return new g("Invalid " + z + " `" + H + "` of type " + ("`" + B + "` supplied to `" + f + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return y(u);
    }
    function x(u) {
      function T(F, f, z, H, I) {
        if (!(F[f] instanceof u)) {
          var B = u.name || m, j = mn(F[f]);
          return new g("Invalid " + H + " `" + I + "` of type " + ("`" + j + "` supplied to `" + z + "`, expected ") + ("instance of `" + B + "`."));
        }
        return null;
      }
      return y(T);
    }
    function R(u) {
      if (!Array.isArray(u))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? l(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : l("Invalid argument supplied to oneOf, expected an array.")), o;
      function T(F, f, z, H, I) {
        for (var B = F[f], j = 0; j < u.length; j++)
          if (w(B, u[j]))
            return null;
        var Q = JSON.stringify(u, function(fn, P) {
          var gn = ln(P);
          return gn === "symbol" ? String(P) : P;
        });
        return new g("Invalid " + H + " `" + I + "` of value `" + String(B) + "` " + ("supplied to `" + z + "`, expected one of " + Q + "."));
      }
      return y(T);
    }
    function q(u) {
      function T(F, f, z, H, I) {
        if (typeof u != "function")
          return new g("Property `" + I + "` of component `" + z + "` has invalid PropType notation inside objectOf.");
        var B = F[f], j = tn(B);
        if (j !== "object")
          return new g("Invalid " + H + " `" + I + "` of type " + ("`" + j + "` supplied to `" + z + "`, expected an object."));
        for (var Q in B)
          if (r(B, Q)) {
            var V = u(B, Q, z, H, I + "." + Q, e);
            if (V instanceof Error)
              return V;
          }
        return null;
      }
      return y(T);
    }
    function X(u) {
      if (!Array.isArray(u))
        return process.env.NODE_ENV !== "production" && l("Invalid argument supplied to oneOfType, expected an instance of array."), o;
      for (var T = 0; T < u.length; T++) {
        var F = u[T];
        if (typeof F != "function")
          return l(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + hn(F) + " at index " + T + "."
          ), o;
      }
      function f(z, H, I, B, j) {
        for (var Q = [], V = 0; V < u.length; V++) {
          var fn = u[V], P = fn(z, H, I, B, j, e);
          if (P == null)
            return null;
          P.data && r(P.data, "expectedType") && Q.push(P.data.expectedType);
        }
        var gn = Q.length > 0 ? ", expected one of type [" + Q.join(", ") + "]" : "";
        return new g("Invalid " + B + " `" + j + "` supplied to " + ("`" + I + "`" + gn + "."));
      }
      return y(f);
    }
    function sn() {
      function u(T, F, f, z, H) {
        return en(T[F]) ? null : new g("Invalid " + z + " `" + H + "` supplied to " + ("`" + f + "`, expected a ReactNode."));
      }
      return y(u);
    }
    function _(u, T, F, f, z) {
      return new g(
        (u || "React class") + ": " + T + " type `" + F + "." + f + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + z + "`."
      );
    }
    function O(u) {
      function T(F, f, z, H, I) {
        var B = F[f], j = tn(B);
        if (j !== "object")
          return new g("Invalid " + H + " `" + I + "` of type `" + j + "` " + ("supplied to `" + z + "`, expected `object`."));
        for (var Q in u) {
          var V = u[Q];
          if (typeof V != "function")
            return _(z, H, I, Q, ln(V));
          var fn = V(B, Q, z, H, I + "." + Q, e);
          if (fn)
            return fn;
        }
        return null;
      }
      return y(T);
    }
    function W(u) {
      function T(F, f, z, H, I) {
        var B = F[f], j = tn(B);
        if (j !== "object")
          return new g("Invalid " + H + " `" + I + "` of type `" + j + "` " + ("supplied to `" + z + "`, expected `object`."));
        var Q = t({}, F[f], u);
        for (var V in Q) {
          var fn = u[V];
          if (r(u, V) && typeof fn != "function")
            return _(z, H, I, V, ln(fn));
          if (!fn)
            return new g(
              "Invalid " + H + " `" + I + "` key `" + V + "` supplied to `" + z + "`.\nBad object: " + JSON.stringify(F[f], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(u), null, "  ")
            );
          var P = fn(B, V, z, H, I + "." + V, e);
          if (P)
            return P;
        }
        return null;
      }
      return y(T);
    }
    function en(u) {
      switch (typeof u) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !u;
        case "object":
          if (Array.isArray(u))
            return u.every(en);
          if (u === null || a(u))
            return !0;
          var T = p(u);
          if (T) {
            var F = T.call(u), f;
            if (T !== u.entries) {
              for (; !(f = F.next()).done; )
                if (!en(f.value))
                  return !1;
            } else
              for (; !(f = F.next()).done; ) {
                var z = f.value;
                if (z && !en(z[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Y(u, T) {
      return u === "symbol" ? !0 : T ? T["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && T instanceof Symbol : !1;
    }
    function tn(u) {
      var T = typeof u;
      return Array.isArray(u) ? "array" : u instanceof RegExp ? "object" : Y(T, u) ? "symbol" : T;
    }
    function ln(u) {
      if (typeof u > "u" || u === null)
        return "" + u;
      var T = tn(u);
      if (T === "object") {
        if (u instanceof Date)
          return "date";
        if (u instanceof RegExp)
          return "regexp";
      }
      return T;
    }
    function hn(u) {
      var T = ln(u);
      switch (T) {
        case "array":
        case "object":
          return "an " + T;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + T;
        default:
          return T;
      }
    }
    function mn(u) {
      return !u.constructor || !u.constructor.name ? m : u.constructor.name;
    }
    return h.checkPropTypes = i, h.resetWarningCache = i.resetWarningCache, h.PropTypes = h, h;
  }, pe;
}
if (process.env.NODE_ENV !== "production") {
  var Vl = Yt(), Yl = !0;
  we.exports = Hl()(Vl.isElement, Yl);
} else
  we.exports = jl()();
var Wl = we.exports;
const $ = /* @__PURE__ */ Hn(Wl);
class Yn {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, e, r) {
    this.property = t, this.normal = e, r && (this.space = r);
  }
}
Yn.prototype.property = {};
Yn.prototype.normal = {};
Yn.prototype.space = null;
function Qt(n, t) {
  const e = {}, r = {};
  let i = -1;
  for (; ++i < n.length; )
    Object.assign(e, n[i].property), Object.assign(r, n[i].normal);
  return new Yn(e, r, t);
}
function Ee(n) {
  return n.toLowerCase();
}
class En {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, e) {
    this.property = t, this.attribute = e;
  }
}
En.prototype.space = null;
En.prototype.boolean = !1;
En.prototype.booleanish = !1;
En.prototype.overloadedBoolean = !1;
En.prototype.number = !1;
En.prototype.commaSeparated = !1;
En.prototype.spaceSeparated = !1;
En.prototype.commaOrSpaceSeparated = !1;
En.prototype.mustUseProperty = !1;
En.prototype.defined = !1;
let Ql = 0;
const U = Rn(), pn = Rn(), Xt = Rn(), E = Rn(), on = Rn(), Fn = Rn(), xn = Rn();
function Rn() {
  return 2 ** ++Ql;
}
const ve = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: U,
  booleanish: pn,
  commaOrSpaceSeparated: xn,
  commaSeparated: Fn,
  number: E,
  overloadedBoolean: Xt,
  spaceSeparated: on
}, Symbol.toStringTag, { value: "Module" })), he = Object.keys(ve);
class Re extends En {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, e, r, i) {
    let l = -1;
    if (super(t, e), xt(this, "space", i), typeof r == "number")
      for (; ++l < he.length; ) {
        const o = he[l];
        xt(this, he[l], (r & ve[o]) === ve[o]);
      }
  }
}
Re.prototype.defined = !0;
function xt(n, t, e) {
  e && (n[t] = e);
}
const Xl = {}.hasOwnProperty;
function Dn(n) {
  const t = {}, e = {};
  let r;
  for (r in n.properties)
    if (Xl.call(n.properties, r)) {
      const i = n.properties[r], l = new Re(
        r,
        n.transform(n.attributes || {}, r),
        i,
        n.space
      );
      n.mustUseProperty && n.mustUseProperty.includes(r) && (l.mustUseProperty = !0), t[r] = l, e[Ee(r)] = r, e[Ee(l.attribute)] = r;
    }
  return new Yn(t, e, n.space);
}
const Kt = Dn({
  space: "xlink",
  transform(n, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), Gt = Dn({
  space: "xml",
  transform(n, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function Jt(n, t) {
  return t in n ? n[t] : t;
}
function Zt(n, t) {
  return Jt(n, t.toLowerCase());
}
const nr = Dn({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: Zt,
  properties: { xmlns: null, xmlnsXLink: null }
}), er = Dn({
  transform(n, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: pn,
    ariaAutoComplete: null,
    ariaBusy: pn,
    ariaChecked: pn,
    ariaColCount: E,
    ariaColIndex: E,
    ariaColSpan: E,
    ariaControls: on,
    ariaCurrent: null,
    ariaDescribedBy: on,
    ariaDetails: null,
    ariaDisabled: pn,
    ariaDropEffect: on,
    ariaErrorMessage: null,
    ariaExpanded: pn,
    ariaFlowTo: on,
    ariaGrabbed: pn,
    ariaHasPopup: null,
    ariaHidden: pn,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: on,
    ariaLevel: E,
    ariaLive: null,
    ariaModal: pn,
    ariaMultiLine: pn,
    ariaMultiSelectable: pn,
    ariaOrientation: null,
    ariaOwns: on,
    ariaPlaceholder: null,
    ariaPosInSet: E,
    ariaPressed: pn,
    ariaReadOnly: pn,
    ariaRelevant: null,
    ariaRequired: pn,
    ariaRoleDescription: on,
    ariaRowCount: E,
    ariaRowIndex: E,
    ariaRowSpan: E,
    ariaSelected: pn,
    ariaSetSize: E,
    ariaSort: null,
    ariaValueMax: E,
    ariaValueMin: E,
    ariaValueNow: E,
    ariaValueText: null,
    role: null
  }
}), Kl = Dn({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: Zt,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Fn,
    acceptCharset: on,
    accessKey: on,
    action: null,
    allow: null,
    allowFullScreen: U,
    allowPaymentRequest: U,
    allowUserMedia: U,
    alt: null,
    as: null,
    async: U,
    autoCapitalize: null,
    autoComplete: on,
    autoFocus: U,
    autoPlay: U,
    blocking: on,
    capture: U,
    charSet: null,
    checked: U,
    cite: null,
    className: on,
    cols: E,
    colSpan: null,
    content: null,
    contentEditable: pn,
    controls: U,
    controlsList: on,
    coords: E | Fn,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: U,
    defer: U,
    dir: null,
    dirName: null,
    disabled: U,
    download: Xt,
    draggable: pn,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: U,
    formTarget: null,
    headers: on,
    height: E,
    hidden: U,
    high: E,
    href: null,
    hrefLang: null,
    htmlFor: on,
    httpEquiv: on,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: U,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: U,
    itemId: null,
    itemProp: on,
    itemRef: on,
    itemScope: U,
    itemType: on,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: U,
    low: E,
    manifest: null,
    max: null,
    maxLength: E,
    media: null,
    method: null,
    min: null,
    minLength: E,
    multiple: U,
    muted: U,
    name: null,
    nonce: null,
    noModule: U,
    noValidate: U,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: U,
    optimum: E,
    pattern: null,
    ping: on,
    placeholder: null,
    playsInline: U,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: U,
    referrerPolicy: null,
    rel: on,
    required: U,
    reversed: U,
    rows: E,
    rowSpan: E,
    sandbox: on,
    scope: null,
    scoped: U,
    seamless: U,
    selected: U,
    shadowRootDelegatesFocus: U,
    shadowRootMode: null,
    shape: null,
    size: E,
    sizes: null,
    slot: null,
    span: E,
    spellCheck: pn,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: E,
    step: null,
    style: null,
    tabIndex: E,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: U,
    useMap: null,
    value: pn,
    width: E,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: on,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: E,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: E,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: U,
    // Lists. Use CSS to reduce space between items instead
    declare: U,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: E,
    // `<img>` and `<object>`
    leftMargin: E,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: E,
    // `<body>`
    marginWidth: E,
    // `<body>`
    noResize: U,
    // `<frame>`
    noHref: U,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: U,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: U,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: E,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: pn,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: E,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: E,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: U,
    disableRemotePlayback: U,
    prefix: null,
    property: null,
    results: E,
    security: null,
    unselectable: null
  }
}), Gl = Dn({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: Jt,
  properties: {
    about: xn,
    accentHeight: E,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: E,
    amplitude: E,
    arabicForm: null,
    ascent: E,
    attributeName: null,
    attributeType: null,
    azimuth: E,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: E,
    by: null,
    calcMode: null,
    capHeight: E,
    className: on,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: E,
    diffuseConstant: E,
    direction: null,
    display: null,
    dur: null,
    divisor: E,
    dominantBaseline: null,
    download: U,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: E,
    enableBackground: null,
    end: null,
    event: null,
    exponent: E,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: E,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Fn,
    g2: Fn,
    glyphName: Fn,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: E,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: E,
    horizOriginX: E,
    horizOriginY: E,
    id: null,
    ideographic: E,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: E,
    k: E,
    k1: E,
    k2: E,
    k3: E,
    k4: E,
    kernelMatrix: xn,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: E,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: E,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: E,
    overlineThickness: E,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: E,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: on,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: E,
    pointsAtY: E,
    pointsAtZ: E,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: xn,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: xn,
    rev: xn,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: xn,
    requiredFeatures: xn,
    requiredFonts: xn,
    requiredFormats: xn,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: E,
    specularExponent: E,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: E,
    strikethroughThickness: E,
    string: null,
    stroke: null,
    strokeDashArray: xn,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: E,
    strokeOpacity: E,
    strokeWidth: null,
    style: null,
    surfaceScale: E,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: xn,
    tabIndex: E,
    tableValues: null,
    target: null,
    targetX: E,
    targetY: E,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: xn,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: E,
    underlineThickness: E,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: E,
    values: null,
    vAlphabetic: E,
    vMathematical: E,
    vectorEffect: null,
    vHanging: E,
    vIdeographic: E,
    version: null,
    vertAdvY: E,
    vertOriginX: E,
    vertOriginY: E,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: E,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), Jl = /^data[-\w.:]+$/i, bt = /-[a-z]/g, Zl = /[A-Z]/g;
function no(n, t) {
  const e = Ee(t);
  let r = t, i = En;
  if (e in n.normal)
    return n.property[n.normal[e]];
  if (e.length > 4 && e.slice(0, 4) === "data" && Jl.test(t)) {
    if (t.charAt(4) === "-") {
      const l = t.slice(5).replace(bt, to);
      r = "data" + l.charAt(0).toUpperCase() + l.slice(1);
    } else {
      const l = t.slice(4);
      if (!bt.test(l)) {
        let o = l.replace(Zl, eo);
        o.charAt(0) !== "-" && (o = "-" + o), t = "data" + o;
      }
    }
    i = Re;
  }
  return new i(r, t);
}
function eo(n) {
  return "-" + n.toLowerCase();
}
function to(n) {
  return n.charAt(1).toUpperCase();
}
const kt = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, ro = Qt([Gt, Kt, nr, er, Kl], "html"), io = Qt([Gt, Kt, nr, er, Gl], "svg");
function lo(n) {
  if (n.allowedElements && n.disallowedElements)
    throw new TypeError(
      "Only one of `allowedElements` and `disallowedElements` should be defined"
    );
  if (n.allowedElements || n.disallowedElements || n.allowElement)
    return (t) => {
      gr(t, "element", (e, r, i) => {
        const l = (
          /** @type {Element|Root} */
          i
        );
        let o;
        if (n.allowedElements ? o = !n.allowedElements.includes(e.tagName) : n.disallowedElements && (o = n.disallowedElements.includes(e.tagName)), !o && n.allowElement && typeof r == "number" && (o = !n.allowElement(e, r, l)), o && typeof r == "number")
          return n.unwrapDisallowed && e.children ? l.children.splice(r, 1, ...e.children) : l.children.splice(r, 1), r;
      });
    };
}
var Ce = { exports: {} }, Z = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var St;
function oo() {
  return St || (St = 1, process.env.NODE_ENV !== "production" && function() {
    var n = Symbol.for("react.element"), t = Symbol.for("react.portal"), e = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), l = Symbol.for("react.provider"), o = Symbol.for("react.context"), a = Symbol.for("react.server_context"), c = Symbol.for("react.forward_ref"), s = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), m = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), w = !1, g = !1, y = !1, k = !1, M = !1, v;
    v = Symbol.for("react.module.reference");
    function L(A) {
      return !!(typeof A == "string" || typeof A == "function" || A === e || A === i || M || A === r || A === s || A === d || k || A === h || w || g || y || typeof A == "object" && A !== null && (A.$$typeof === m || A.$$typeof === p || A.$$typeof === l || A.$$typeof === o || A.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      A.$$typeof === v || A.getModuleId !== void 0));
    }
    function S(A) {
      if (typeof A == "object" && A !== null) {
        var On = A.$$typeof;
        switch (On) {
          case n:
            var _n = A.type;
            switch (_n) {
              case e:
              case i:
              case r:
              case s:
              case d:
                return _n;
              default:
                var Bn = _n && _n.$$typeof;
                switch (Bn) {
                  case a:
                  case o:
                  case c:
                  case m:
                  case p:
                  case l:
                    return Bn;
                  default:
                    return On;
                }
            }
          case t:
            return On;
        }
      }
    }
    var x = o, R = l, q = n, X = c, sn = e, _ = m, O = p, W = t, en = i, Y = r, tn = s, ln = d, hn = !1, mn = !1;
    function u(A) {
      return hn || (hn = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function T(A) {
      return mn || (mn = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function F(A) {
      return S(A) === o;
    }
    function f(A) {
      return S(A) === l;
    }
    function z(A) {
      return typeof A == "object" && A !== null && A.$$typeof === n;
    }
    function H(A) {
      return S(A) === c;
    }
    function I(A) {
      return S(A) === e;
    }
    function B(A) {
      return S(A) === m;
    }
    function j(A) {
      return S(A) === p;
    }
    function Q(A) {
      return S(A) === t;
    }
    function V(A) {
      return S(A) === i;
    }
    function fn(A) {
      return S(A) === r;
    }
    function P(A) {
      return S(A) === s;
    }
    function gn(A) {
      return S(A) === d;
    }
    Z.ContextConsumer = x, Z.ContextProvider = R, Z.Element = q, Z.ForwardRef = X, Z.Fragment = sn, Z.Lazy = _, Z.Memo = O, Z.Portal = W, Z.Profiler = en, Z.StrictMode = Y, Z.Suspense = tn, Z.SuspenseList = ln, Z.isAsyncMode = u, Z.isConcurrentMode = T, Z.isContextConsumer = F, Z.isContextProvider = f, Z.isElement = z, Z.isForwardRef = H, Z.isFragment = I, Z.isLazy = B, Z.isMemo = j, Z.isPortal = Q, Z.isProfiler = V, Z.isStrictMode = fn, Z.isSuspense = P, Z.isSuspenseList = gn, Z.isValidElementType = L, Z.typeOf = S;
  }()), Z;
}
var nn = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wt;
function ao() {
  if (wt)
    return nn;
  wt = 1;
  var n = Symbol.for("react.element"), t = Symbol.for("react.portal"), e = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), l = Symbol.for("react.provider"), o = Symbol.for("react.context"), a = Symbol.for("react.server_context"), c = Symbol.for("react.forward_ref"), s = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), m = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), w;
  w = Symbol.for("react.module.reference");
  function g(y) {
    if (typeof y == "object" && y !== null) {
      var k = y.$$typeof;
      switch (k) {
        case n:
          switch (y = y.type, y) {
            case e:
            case i:
            case r:
            case s:
            case d:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case a:
                case o:
                case c:
                case m:
                case p:
                case l:
                  return y;
                default:
                  return k;
              }
          }
        case t:
          return k;
      }
    }
  }
  return nn.ContextConsumer = o, nn.ContextProvider = l, nn.Element = n, nn.ForwardRef = c, nn.Fragment = e, nn.Lazy = m, nn.Memo = p, nn.Portal = t, nn.Profiler = i, nn.StrictMode = r, nn.Suspense = s, nn.SuspenseList = d, nn.isAsyncMode = function() {
    return !1;
  }, nn.isConcurrentMode = function() {
    return !1;
  }, nn.isContextConsumer = function(y) {
    return g(y) === o;
  }, nn.isContextProvider = function(y) {
    return g(y) === l;
  }, nn.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === n;
  }, nn.isForwardRef = function(y) {
    return g(y) === c;
  }, nn.isFragment = function(y) {
    return g(y) === e;
  }, nn.isLazy = function(y) {
    return g(y) === m;
  }, nn.isMemo = function(y) {
    return g(y) === p;
  }, nn.isPortal = function(y) {
    return g(y) === t;
  }, nn.isProfiler = function(y) {
    return g(y) === i;
  }, nn.isStrictMode = function(y) {
    return g(y) === r;
  }, nn.isSuspense = function(y) {
    return g(y) === s;
  }, nn.isSuspenseList = function(y) {
    return g(y) === d;
  }, nn.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === e || y === i || y === r || y === s || y === d || y === h || typeof y == "object" && y !== null && (y.$$typeof === m || y.$$typeof === p || y.$$typeof === l || y.$$typeof === o || y.$$typeof === c || y.$$typeof === w || y.getModuleId !== void 0);
  }, nn.typeOf = g, nn;
}
process.env.NODE_ENV === "production" ? Ce.exports = ao() : Ce.exports = oo();
var uo = Ce.exports;
const so = /* @__PURE__ */ Hn(uo);
function co(n) {
  const t = (
    // @ts-expect-error looks like a node.
    n && typeof n == "object" && n.type === "text" ? (
      // @ts-expect-error looks like a text.
      n.value || ""
    ) : n
  );
  return typeof t == "string" && t.replace(/[ \t\n\f\r]/g, "") === "";
}
function fo(n) {
  return n.join(" ").trim();
}
function po(n, t) {
  const e = t || {};
  return (n[n.length - 1] === "" ? [...n, ""] : n).join(
    (e.padRight ? " " : "") + "," + (e.padLeft === !1 ? "" : " ")
  ).trim();
}
var _e = { exports: {} }, Et = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, ho = /\n/g, mo = /^\s*/, go = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, yo = /^:\s*/, xo = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, bo = /^[;\s]*/, ko = /^\s+|\s+$/g, So = `
`, vt = "/", Ct = "*", An = "", wo = "comment", Eo = "declaration", vo = function(n, t) {
  if (typeof n != "string")
    throw new TypeError("First argument must be a string");
  if (!n)
    return [];
  t = t || {};
  var e = 1, r = 1;
  function i(w) {
    var g = w.match(ho);
    g && (e += g.length);
    var y = w.lastIndexOf(So);
    r = ~y ? w.length - y : r + w.length;
  }
  function l() {
    var w = { line: e, column: r };
    return function(g) {
      return g.position = new o(w), s(), g;
    };
  }
  function o(w) {
    this.start = w, this.end = { line: e, column: r }, this.source = t.source;
  }
  o.prototype.content = n;
  function a(w) {
    var g = new Error(
      t.source + ":" + e + ":" + r + ": " + w
    );
    if (g.reason = w, g.filename = t.source, g.line = e, g.column = r, g.source = n, !t.silent)
      throw g;
  }
  function c(w) {
    var g = w.exec(n);
    if (g) {
      var y = g[0];
      return i(y), n = n.slice(y.length), g;
    }
  }
  function s() {
    c(mo);
  }
  function d(w) {
    var g;
    for (w = w || []; g = p(); )
      g !== !1 && w.push(g);
    return w;
  }
  function p() {
    var w = l();
    if (!(vt != n.charAt(0) || Ct != n.charAt(1))) {
      for (var g = 2; An != n.charAt(g) && (Ct != n.charAt(g) || vt != n.charAt(g + 1)); )
        ++g;
      if (g += 2, An === n.charAt(g - 1))
        return a("End of comment missing");
      var y = n.slice(2, g - 2);
      return r += 2, i(y), n = n.slice(g), r += 2, w({
        type: wo,
        comment: y
      });
    }
  }
  function m() {
    var w = l(), g = c(go);
    if (g) {
      if (p(), !c(yo))
        return a("property missing ':'");
      var y = c(xo), k = w({
        type: Eo,
        property: Tt(g[0].replace(Et, An)),
        value: y ? Tt(y[0].replace(Et, An)) : An
      });
      return c(bo), k;
    }
  }
  function h() {
    var w = [];
    d(w);
    for (var g; g = m(); )
      g !== !1 && (w.push(g), d(w));
    return w;
  }
  return s(), h();
};
function Tt(n) {
  return n ? n.replace(ko, An) : An;
}
var Co = vo;
function tr(n, t) {
  var e = null;
  if (!n || typeof n != "string")
    return e;
  for (var r, i = Co(n), l = typeof t == "function", o, a, c = 0, s = i.length; c < s; c++)
    r = i[c], o = r.property, a = r.value, l ? t(o, a, r) : a && (e || (e = {}), e[o] = a);
  return e;
}
_e.exports = tr;
_e.exports.default = tr;
var To = _e.exports;
const Po = /* @__PURE__ */ Hn(To), Te = {}.hasOwnProperty, Oo = /* @__PURE__ */ new Set(["table", "thead", "tbody", "tfoot", "tr"]);
function rr(n, t) {
  const e = [];
  let r = -1, i;
  for (; ++r < t.children.length; )
    i = t.children[r], i.type === "element" ? e.push(Io(n, i, r, t)) : i.type === "text" ? (t.type !== "element" || !Oo.has(t.tagName) || !co(i)) && e.push(i.value) : i.type === "raw" && !n.options.skipHtml && e.push(i.value);
  return e;
}
function Io(n, t, e, r) {
  const i = n.options, l = i.transformLinkUri === void 0 ? wr : i.transformLinkUri, o = n.schema, a = t.tagName, c = {};
  let s = o, d;
  if (o.space === "html" && a === "svg" && (s = io, n.schema = s), t.properties)
    for (d in t.properties)
      Te.call(t.properties, d) && Ro(c, d, t.properties[d], n);
  (a === "ol" || a === "ul") && n.listDepth++;
  const p = rr(n, t);
  (a === "ol" || a === "ul") && n.listDepth--, n.schema = o;
  const m = t.position || {
    start: { line: null, column: null, offset: null },
    end: { line: null, column: null, offset: null }
  }, h = i.components && Te.call(i.components, a) ? i.components[a] : a, w = typeof h == "string" || h === zn.Fragment;
  if (!so.isValidElementType(h))
    throw new TypeError(
      `Component for name \`${a}\` not defined or is not renderable`
    );
  if (c.key = e, a === "a" && i.linkTarget && (c.target = typeof i.linkTarget == "function" ? i.linkTarget(
    String(c.href || ""),
    t.children,
    typeof c.title == "string" ? c.title : null
  ) : i.linkTarget), a === "a" && l && (c.href = l(
    String(c.href || ""),
    t.children,
    typeof c.title == "string" ? c.title : null
  )), !w && a === "code" && r.type === "element" && r.tagName !== "pre" && (c.inline = !0), !w && (a === "h1" || a === "h2" || a === "h3" || a === "h4" || a === "h5" || a === "h6") && (c.level = Number.parseInt(a.charAt(1), 10)), a === "img" && i.transformImageUri && (c.src = i.transformImageUri(
    String(c.src || ""),
    String(c.alt || ""),
    typeof c.title == "string" ? c.title : null
  )), !w && a === "li" && r.type === "element") {
    const g = Ao(t);
    c.checked = g && g.properties ? !!g.properties.checked : null, c.index = de(r, t), c.ordered = r.tagName === "ol";
  }
  return !w && (a === "ol" || a === "ul") && (c.ordered = a === "ol", c.depth = n.listDepth), (a === "td" || a === "th") && (c.align && (c.style || (c.style = {}), c.style.textAlign = c.align, delete c.align), w || (c.isHeader = a === "th")), !w && a === "tr" && r.type === "element" && (c.isHeader = r.tagName === "thead"), i.sourcePos && (c["data-sourcepos"] = zo(m)), !w && i.rawSourcePos && (c.sourcePosition = t.position), !w && i.includeElementIndex && (c.index = de(r, t), c.siblingCount = de(r)), w || (c.node = t), p.length > 0 ? zn.createElement(h, c, p) : zn.createElement(h, c);
}
function Ao(n) {
  let t = -1;
  for (; ++t < n.children.length; ) {
    const e = n.children[t];
    if (e.type === "element" && e.tagName === "input")
      return e;
  }
  return null;
}
function de(n, t) {
  let e = -1, r = 0;
  for (; ++e < n.children.length && n.children[e] !== t; )
    n.children[e].type === "element" && r++;
  return r;
}
function Ro(n, t, e, r) {
  const i = no(r.schema, t);
  let l = e;
  l == null || l !== l || (Array.isArray(l) && (l = i.commaSeparated ? po(l) : fo(l)), i.property === "style" && typeof l == "string" && (l = _o(l)), i.space && i.property ? n[Te.call(kt, i.property) ? kt[i.property] : i.property] = l : i.attribute && (n[i.attribute] = l));
}
function _o(n) {
  const t = {};
  try {
    Po(n, e);
  } catch {
  }
  return t;
  function e(r, i) {
    const l = r.slice(0, 4) === "-ms-" ? `ms-${r.slice(4)}` : r;
    t[l.replace(/-([a-z])/g, Lo)] = i;
  }
}
function Lo(n, t) {
  return t.toUpperCase();
}
function zo(n) {
  return [
    n.start.line,
    ":",
    n.start.column,
    "-",
    n.end.line,
    ":",
    n.end.column
  ].map(String).join("");
}
const Pt = {}.hasOwnProperty, Mo = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", Qn = {
  plugins: { to: "remarkPlugins", id: "change-plugins-to-remarkplugins" },
  renderers: { to: "components", id: "change-renderers-to-components" },
  astPlugins: { id: "remove-buggy-html-in-markdown-parser" },
  allowDangerousHtml: { id: "remove-buggy-html-in-markdown-parser" },
  escapeHtml: { id: "remove-buggy-html-in-markdown-parser" },
  source: { to: "children", id: "change-source-to-children" },
  allowNode: {
    to: "allowElement",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  allowedTypes: {
    to: "allowedElements",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  disallowedTypes: {
    to: "disallowedElements",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  includeNodeIndex: {
    to: "includeElementIndex",
    id: "change-includenodeindex-to-includeelementindex"
  }
};
function Fo(n) {
  for (const l in Qn)
    if (Pt.call(Qn, l) && Pt.call(n, l)) {
      const o = Qn[l];
      console.warn(
        `[react-markdown] Warning: please ${o.to ? `use \`${o.to}\` instead of` : "remove"} \`${l}\` (see <${Mo}#${o.id}> for more info)`
      ), delete Qn[l];
    }
  const t = Br().use(Bl).use(n.remarkPlugins || []).use(br, {
    ...n.remarkRehypeOptions,
    allowDangerousHtml: !0
  }).use(n.rehypePlugins || []).use(lo, n), e = new At();
  typeof n.children == "string" ? e.value = n.children : n.children !== void 0 && n.children !== null && console.warn(
    `[react-markdown] Warning: please pass a string as \`children\` (not: \`${n.children}\`)`
  );
  const r = t.runSync(t.parse(e), e);
  if (r.type !== "root")
    throw new TypeError("Expected a `root` node");
  let i = zn.createElement(
    zn.Fragment,
    {},
    rr({ options: n, schema: ro, listDepth: 0 }, r)
  );
  return n.className && (i = zn.createElement("div", { className: n.className }, i)), i;
}
Fo.propTypes = {
  // Core options:
  children: $.string,
  // Layout options:
  className: $.string,
  // Filter options:
  allowElement: $.func,
  allowedElements: $.arrayOf($.string),
  disallowedElements: $.arrayOf($.string),
  unwrapDisallowed: $.bool,
  // Plugin options:
  remarkPlugins: $.arrayOf(
    $.oneOfType([
      $.object,
      $.func,
      $.arrayOf(
        $.oneOfType([
          $.bool,
          $.string,
          $.object,
          $.func,
          $.arrayOf(
            // prettier-ignore
            // type-coverage:ignore-next-line
            $.any
          )
        ])
      )
    ])
  ),
  rehypePlugins: $.arrayOf(
    $.oneOfType([
      $.object,
      $.func,
      $.arrayOf(
        $.oneOfType([
          $.bool,
          $.string,
          $.object,
          $.func,
          $.arrayOf(
            // prettier-ignore
            // type-coverage:ignore-next-line
            $.any
          )
        ])
      )
    ])
  ),
  // Transform options:
  sourcePos: $.bool,
  rawSourcePos: $.bool,
  skipHtml: $.bool,
  includeElementIndex: $.bool,
  transformLinkUri: $.oneOfType([$.func, $.bool]),
  linkTarget: $.oneOfType([$.func, $.string]),
  transformImageUri: $.func,
  components: $.object
};
export {
  Fo as default,
  wr as uriTransformer
};
