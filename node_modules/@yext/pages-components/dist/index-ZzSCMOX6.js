var F_ = Object.defineProperty;
var B_ = (t, e, n) => e in t ? F_(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var $n = (t, e, n) => (B_(t, typeof e != "symbol" ? e + "" : e, n), n);
import * as H_ from "react";
import dn, { createElement as W_, createContext as pc, useContext as gs, useState as dr, useRef as od, useEffect as fr, Fragment as K_, useMemo as Qg } from "react";
import ep, { createPortal as U_ } from "react-dom";
var Ku = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function sd(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Uu = { exports: {} }, Fl = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var of;
function z_() {
  return of || (of = 1, process.env.NODE_ENV !== "production" && function() {
    var t = dn, e = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), c = Symbol.for("react.strict_mode"), d = Symbol.for("react.profiler"), h = Symbol.for("react.provider"), p = Symbol.for("react.context"), N = Symbol.for("react.forward_ref"), x = Symbol.for("react.suspense"), v = Symbol.for("react.suspense_list"), O = Symbol.for("react.memo"), M = Symbol.for("react.lazy"), A = Symbol.for("react.offscreen"), T = Symbol.iterator, w = "@@iterator";
    function P(ye) {
      if (ye === null || typeof ye != "object")
        return null;
      var Ge = T && ye[T] || ye[w];
      return typeof Ge == "function" ? Ge : null;
    }
    var K = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function $(ye) {
      {
        for (var Ge = arguments.length, et = new Array(Ge > 1 ? Ge - 1 : 0), yt = 1; yt < Ge; yt++)
          et[yt - 1] = arguments[yt];
        W("error", ye, et);
      }
    }
    function W(ye, Ge, et) {
      {
        var yt = K.ReactDebugCurrentFrame, Ft = yt.getStackAddendum();
        Ft !== "" && (Ge += "%s", et = et.concat([Ft]));
        var Wt = et.map(function(Pt) {
          return String(Pt);
        });
        Wt.unshift("Warning: " + Ge), Function.prototype.apply.call(console[ye], console, Wt);
      }
    }
    var H = !1, z = !1, te = !1, re = !1, ue = !1, q;
    q = Symbol.for("react.module.reference");
    function G(ye) {
      return !!(typeof ye == "string" || typeof ye == "function" || ye === r || ye === d || ue || ye === c || ye === x || ye === v || re || ye === A || H || z || te || typeof ye == "object" && ye !== null && (ye.$$typeof === M || ye.$$typeof === O || ye.$$typeof === h || ye.$$typeof === p || ye.$$typeof === N || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      ye.$$typeof === q || ye.getModuleId !== void 0));
    }
    function j(ye, Ge, et) {
      var yt = ye.displayName;
      if (yt)
        return yt;
      var Ft = Ge.displayName || Ge.name || "";
      return Ft !== "" ? et + "(" + Ft + ")" : et;
    }
    function _e(ye) {
      return ye.displayName || "Context";
    }
    function pe(ye) {
      if (ye == null)
        return null;
      if (typeof ye.tag == "number" && $("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof ye == "function")
        return ye.displayName || ye.name || null;
      if (typeof ye == "string")
        return ye;
      switch (ye) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case d:
          return "Profiler";
        case c:
          return "StrictMode";
        case x:
          return "Suspense";
        case v:
          return "SuspenseList";
      }
      if (typeof ye == "object")
        switch (ye.$$typeof) {
          case p:
            var Ge = ye;
            return _e(Ge) + ".Consumer";
          case h:
            var et = ye;
            return _e(et._context) + ".Provider";
          case N:
            return j(ye, ye.render, "ForwardRef");
          case O:
            var yt = ye.displayName || null;
            return yt !== null ? yt : pe(ye.type) || "Memo";
          case M: {
            var Ft = ye, Wt = Ft._payload, Pt = Ft._init;
            try {
              return pe(Pt(Wt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var J = Object.assign, ee = 0, F, D, V, ne, Y, U, Q;
    function k() {
    }
    k.__reactDisabledLog = !0;
    function m() {
      {
        if (ee === 0) {
          F = console.log, D = console.info, V = console.warn, ne = console.error, Y = console.group, U = console.groupCollapsed, Q = console.groupEnd;
          var ye = {
            configurable: !0,
            enumerable: !0,
            value: k,
            writable: !0
          };
          Object.defineProperties(console, {
            info: ye,
            log: ye,
            warn: ye,
            error: ye,
            group: ye,
            groupCollapsed: ye,
            groupEnd: ye
          });
        }
        ee++;
      }
    }
    function y() {
      {
        if (ee--, ee === 0) {
          var ye = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: J({}, ye, {
              value: F
            }),
            info: J({}, ye, {
              value: D
            }),
            warn: J({}, ye, {
              value: V
            }),
            error: J({}, ye, {
              value: ne
            }),
            group: J({}, ye, {
              value: Y
            }),
            groupCollapsed: J({}, ye, {
              value: U
            }),
            groupEnd: J({}, ye, {
              value: Q
            })
          });
        }
        ee < 0 && $("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var b = K.ReactCurrentDispatcher, Z;
    function ce(ye, Ge, et) {
      {
        if (Z === void 0)
          try {
            throw Error();
          } catch (Ft) {
            var yt = Ft.stack.trim().match(/\n( *(at )?)/);
            Z = yt && yt[1] || "";
          }
        return `
` + Z + ye;
      }
    }
    var ge = !1, ae;
    {
      var Te = typeof WeakMap == "function" ? WeakMap : Map;
      ae = new Te();
    }
    function Ae(ye, Ge) {
      if (!ye || ge)
        return "";
      {
        var et = ae.get(ye);
        if (et !== void 0)
          return et;
      }
      var yt;
      ge = !0;
      var Ft = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Wt;
      Wt = b.current, b.current = null, m();
      try {
        if (Ge) {
          var Pt = function() {
            throw Error();
          };
          if (Object.defineProperty(Pt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Pt, []);
            } catch (Zn) {
              yt = Zn;
            }
            Reflect.construct(ye, [], Pt);
          } else {
            try {
              Pt.call();
            } catch (Zn) {
              yt = Zn;
            }
            ye.call(Pt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Zn) {
            yt = Zn;
          }
          ye();
        }
      } catch (Zn) {
        if (Zn && yt && typeof Zn.stack == "string") {
          for (var It = Zn.stack.split(`
`), mn = yt.stack.split(`
`), on = It.length - 1, en = mn.length - 1; on >= 1 && en >= 0 && It[on] !== mn[en]; )
            en--;
          for (; on >= 1 && en >= 0; on--, en--)
            if (It[on] !== mn[en]) {
              if (on !== 1 || en !== 1)
                do
                  if (on--, en--, en < 0 || It[on] !== mn[en]) {
                    var Bn = `
` + It[on].replace(" at new ", " at ");
                    return ye.displayName && Bn.includes("<anonymous>") && (Bn = Bn.replace("<anonymous>", ye.displayName)), typeof ye == "function" && ae.set(ye, Bn), Bn;
                  }
                while (on >= 1 && en >= 0);
              break;
            }
        }
      } finally {
        ge = !1, b.current = Wt, y(), Error.prepareStackTrace = Ft;
      }
      var yr = ye ? ye.displayName || ye.name : "", Ni = yr ? ce(yr) : "";
      return typeof ye == "function" && ae.set(ye, Ni), Ni;
    }
    function ze(ye, Ge, et) {
      return Ae(ye, !1);
    }
    function oe(ye) {
      var Ge = ye.prototype;
      return !!(Ge && Ge.isReactComponent);
    }
    function ie(ye, Ge, et) {
      if (ye == null)
        return "";
      if (typeof ye == "function")
        return Ae(ye, oe(ye));
      if (typeof ye == "string")
        return ce(ye);
      switch (ye) {
        case x:
          return ce("Suspense");
        case v:
          return ce("SuspenseList");
      }
      if (typeof ye == "object")
        switch (ye.$$typeof) {
          case N:
            return ze(ye.render);
          case O:
            return ie(ye.type, Ge, et);
          case M: {
            var yt = ye, Ft = yt._payload, Wt = yt._init;
            try {
              return ie(Wt(Ft), Ge, et);
            } catch {
            }
          }
        }
      return "";
    }
    var de = Object.prototype.hasOwnProperty, we = {}, ke = K.ReactDebugCurrentFrame;
    function Be(ye) {
      if (ye) {
        var Ge = ye._owner, et = ie(ye.type, ye._source, Ge ? Ge.type : null);
        ke.setExtraStackFrame(et);
      } else
        ke.setExtraStackFrame(null);
    }
    function Ye(ye, Ge, et, yt, Ft) {
      {
        var Wt = Function.call.bind(de);
        for (var Pt in ye)
          if (Wt(ye, Pt)) {
            var It = void 0;
            try {
              if (typeof ye[Pt] != "function") {
                var mn = Error((yt || "React class") + ": " + et + " type `" + Pt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof ye[Pt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw mn.name = "Invariant Violation", mn;
              }
              It = ye[Pt](Ge, Pt, yt, et, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (on) {
              It = on;
            }
            It && !(It instanceof Error) && (Be(Ft), $("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", yt || "React class", et, Pt, typeof It), Be(null)), It instanceof Error && !(It.message in we) && (we[It.message] = !0, Be(Ft), $("Failed %s type: %s", et, It.message), Be(null));
          }
      }
    }
    var lt = Array.isArray;
    function _t(ye) {
      return lt(ye);
    }
    function ct(ye) {
      {
        var Ge = typeof Symbol == "function" && Symbol.toStringTag, et = Ge && ye[Symbol.toStringTag] || ye.constructor.name || "Object";
        return et;
      }
    }
    function ve(ye) {
      try {
        return se(ye), !1;
      } catch {
        return !0;
      }
    }
    function se(ye) {
      return "" + ye;
    }
    function he(ye) {
      if (ve(ye))
        return $("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ct(ye)), se(ye);
    }
    var Oe = K.ReactCurrentOwner, Me = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, De, We, qe;
    qe = {};
    function Qe(ye) {
      if (de.call(ye, "ref")) {
        var Ge = Object.getOwnPropertyDescriptor(ye, "ref").get;
        if (Ge && Ge.isReactWarning)
          return !1;
      }
      return ye.ref !== void 0;
    }
    function ut(ye) {
      if (de.call(ye, "key")) {
        var Ge = Object.getOwnPropertyDescriptor(ye, "key").get;
        if (Ge && Ge.isReactWarning)
          return !1;
      }
      return ye.key !== void 0;
    }
    function kt(ye, Ge) {
      if (typeof ye.ref == "string" && Oe.current && Ge && Oe.current.stateNode !== Ge) {
        var et = pe(Oe.current.type);
        qe[et] || ($('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', pe(Oe.current.type), ye.ref), qe[et] = !0);
      }
    }
    function Ve(ye, Ge) {
      {
        var et = function() {
          De || (De = !0, $("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ge));
        };
        et.isReactWarning = !0, Object.defineProperty(ye, "key", {
          get: et,
          configurable: !0
        });
      }
    }
    function je(ye, Ge) {
      {
        var et = function() {
          We || (We = !0, $("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ge));
        };
        et.isReactWarning = !0, Object.defineProperty(ye, "ref", {
          get: et,
          configurable: !0
        });
      }
    }
    var nt = function(ye, Ge, et, yt, Ft, Wt, Pt) {
      var It = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: ye,
        key: Ge,
        ref: et,
        props: Pt,
        // Record the component responsible for creating this element.
        _owner: Wt
      };
      return It._store = {}, Object.defineProperty(It._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(It, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: yt
      }), Object.defineProperty(It, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ft
      }), Object.freeze && (Object.freeze(It.props), Object.freeze(It)), It;
    };
    function mt(ye, Ge, et, yt, Ft) {
      {
        var Wt, Pt = {}, It = null, mn = null;
        et !== void 0 && (he(et), It = "" + et), ut(Ge) && (he(Ge.key), It = "" + Ge.key), Qe(Ge) && (mn = Ge.ref, kt(Ge, Ft));
        for (Wt in Ge)
          de.call(Ge, Wt) && !Me.hasOwnProperty(Wt) && (Pt[Wt] = Ge[Wt]);
        if (ye && ye.defaultProps) {
          var on = ye.defaultProps;
          for (Wt in on)
            Pt[Wt] === void 0 && (Pt[Wt] = on[Wt]);
        }
        if (It || mn) {
          var en = typeof ye == "function" ? ye.displayName || ye.name || "Unknown" : ye;
          It && Ve(Pt, en), mn && je(Pt, en);
        }
        return nt(ye, It, mn, Ft, yt, Oe.current, Pt);
      }
    }
    var Ct = K.ReactCurrentOwner, vt = K.ReactDebugCurrentFrame;
    function wt(ye) {
      if (ye) {
        var Ge = ye._owner, et = ie(ye.type, ye._source, Ge ? Ge.type : null);
        vt.setExtraStackFrame(et);
      } else
        vt.setExtraStackFrame(null);
    }
    var Dt;
    Dt = !1;
    function Tt(ye) {
      return typeof ye == "object" && ye !== null && ye.$$typeof === e;
    }
    function Xt() {
      {
        if (Ct.current) {
          var ye = pe(Ct.current.type);
          if (ye)
            return `

Check the render method of \`` + ye + "`.";
        }
        return "";
      }
    }
    function Mt(ye) {
      {
        if (ye !== void 0) {
          var Ge = ye.fileName.replace(/^.*[\\\/]/, ""), et = ye.lineNumber;
          return `

Check your code at ` + Ge + ":" + et + ".";
        }
        return "";
      }
    }
    var Ut = {};
    function Lt(ye) {
      {
        var Ge = Xt();
        if (!Ge) {
          var et = typeof ye == "string" ? ye : ye.displayName || ye.name;
          et && (Ge = `

Check the top-level render call using <` + et + ">.");
        }
        return Ge;
      }
    }
    function mr(ye, Ge) {
      {
        if (!ye._store || ye._store.validated || ye.key != null)
          return;
        ye._store.validated = !0;
        var et = Lt(Ge);
        if (Ut[et])
          return;
        Ut[et] = !0;
        var yt = "";
        ye && ye._owner && ye._owner !== Ct.current && (yt = " It was passed a child from " + pe(ye._owner.type) + "."), wt(ye), $('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', et, yt), wt(null);
      }
    }
    function Dr(ye, Ge) {
      {
        if (typeof ye != "object")
          return;
        if (_t(ye))
          for (var et = 0; et < ye.length; et++) {
            var yt = ye[et];
            Tt(yt) && mr(yt, Ge);
          }
        else if (Tt(ye))
          ye._store && (ye._store.validated = !0);
        else if (ye) {
          var Ft = P(ye);
          if (typeof Ft == "function" && Ft !== ye.entries)
            for (var Wt = Ft.call(ye), Pt; !(Pt = Wt.next()).done; )
              Tt(Pt.value) && mr(Pt.value, Ge);
        }
      }
    }
    function Wi(ye) {
      {
        var Ge = ye.type;
        if (Ge == null || typeof Ge == "string")
          return;
        var et;
        if (typeof Ge == "function")
          et = Ge.propTypes;
        else if (typeof Ge == "object" && (Ge.$$typeof === N || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Ge.$$typeof === O))
          et = Ge.propTypes;
        else
          return;
        if (et) {
          var yt = pe(Ge);
          Ye(et, ye.props, "prop", yt, ye);
        } else if (Ge.PropTypes !== void 0 && !Dt) {
          Dt = !0;
          var Ft = pe(Ge);
          $("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ft || "Unknown");
        }
        typeof Ge.getDefaultProps == "function" && !Ge.getDefaultProps.isReactClassApproved && $("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ys(ye) {
      {
        for (var Ge = Object.keys(ye.props), et = 0; et < Ge.length; et++) {
          var yt = Ge[et];
          if (yt !== "children" && yt !== "key") {
            wt(ye), $("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", yt), wt(null);
            break;
          }
        }
        ye.ref !== null && (wt(ye), $("Invalid attribute `ref` supplied to `React.Fragment`."), wt(null));
      }
    }
    function Ns(ye, Ge, et, yt, Ft, Wt) {
      {
        var Pt = G(ye);
        if (!Pt) {
          var It = "";
          (ye === void 0 || typeof ye == "object" && ye !== null && Object.keys(ye).length === 0) && (It += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var mn = Mt(Ft);
          mn ? It += mn : It += Xt();
          var on;
          ye === null ? on = "null" : _t(ye) ? on = "array" : ye !== void 0 && ye.$$typeof === e ? (on = "<" + (pe(ye.type) || "Unknown") + " />", It = " Did you accidentally export a JSX literal instead of a component?") : on = typeof ye, $("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", on, It);
        }
        var en = mt(ye, Ge, et, Ft, Wt);
        if (en == null)
          return en;
        if (Pt) {
          var Bn = Ge.children;
          if (Bn !== void 0)
            if (yt)
              if (_t(Bn)) {
                for (var yr = 0; yr < Bn.length; yr++)
                  Dr(Bn[yr], ye);
                Object.freeze && Object.freeze(Bn);
              } else
                $("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Dr(Bn, ye);
        }
        return ye === r ? ys(en) : Wi(en), en;
      }
    }
    function fn(ye, Ge, et) {
      return Ns(ye, Ge, et, !0);
    }
    function _r(ye, Ge, et) {
      return Ns(ye, Ge, et, !1);
    }
    var ti = _r, Cs = fn;
    Fl.Fragment = r, Fl.jsx = ti, Fl.jsxs = Cs;
  }()), Fl;
}
var Bl = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var sf;
function G_() {
  if (sf)
    return Bl;
  sf = 1;
  var t = dn, e = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, c = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, d = { key: !0, ref: !0, __self: !0, __source: !0 };
  function h(p, N, x) {
    var v, O = {}, M = null, A = null;
    x !== void 0 && (M = "" + x), N.key !== void 0 && (M = "" + N.key), N.ref !== void 0 && (A = N.ref);
    for (v in N)
      r.call(N, v) && !d.hasOwnProperty(v) && (O[v] = N[v]);
    if (p && p.defaultProps)
      for (v in N = p.defaultProps, N)
        O[v] === void 0 && (O[v] = N[v]);
    return { $$typeof: e, type: p, key: M, ref: A, props: O, _owner: c.current };
  }
  return Bl.Fragment = n, Bl.jsx = h, Bl.jsxs = h, Bl;
}
process.env.NODE_ENV === "production" ? Uu.exports = G_() : Uu.exports = z_();
var ht = Uu.exports;
function Y_(t) {
  switch (t) {
    case "AD":
    case "AM":
    case "AT":
    case "AX":
    case "AZ":
    case "BA":
    case "BY":
    case "CY":
    case "CZ":
    case "DK":
    case "DZ":
    case "EC":
    case "EH":
    case "ET":
    case "FI":
    case "FR":
    case "GE":
    case "GF":
    case "GI":
    case "GP":
    case "GW":
    case "HT":
    case "KE":
    case "KV":
    case "KW":
    case "LA":
    case "LU":
    case "MC":
    case "MD":
    case "ME":
    case "MG":
    case "MK":
    case "MQ":
    case "MZ":
    case "NC":
    case "NL":
    case "NO":
    case "PL":
    case "PT":
    case "PY":
    case "RE":
    case "RS":
    case "SA":
    case "SE":
    case "SJ":
    case "SM":
    case "SN":
    case "TC":
    case "TJ":
    case "TM":
    case "TN":
    case "TZ":
    case "UY":
    case "VG":
    case "ZM":
      return [["line1"], ["line2"], ["postalCode", "city"], ["countryCode"]];
    case "AF":
    case "IR":
      return [
        ["line1"],
        ["line2"],
        ["city"],
        ["region"],
        ["postalCode"],
        ["countryCode"]
      ];
    case "AG":
    case "AO":
    case "AW":
    case "BJ":
    case "BO":
    case "BS":
    case "BZ":
    case "CI":
    case "CW":
    case "DJ":
    case "FJ":
    case "GA":
    case "GH":
    case "GM":
    case "GY":
    case "JM":
    case "KI":
    case "LY":
    case "MW":
    case "NA":
    case "NR":
    case "PS":
    case "QA":
    case "RW":
    case "SC":
    case "SR":
    case "SX":
    case "TG":
    case "TT":
    case "UG":
    case "VU":
      return [["line1"], ["line2"], ["city"], ["countryCode"]];
    case "AL":
    case "EE":
    case "IS":
      return [["line1"], ["line2"], ["postalCode", "city"]];
    case "AR":
      return [
        ["line1"],
        ["line2"],
        ["postalCode", "city", ",", "region"],
        ["countryCode"]
      ];
    case "AS":
    case "BB":
    case "BD":
    case "BM":
    case "BN":
    case "BT":
    case "CR":
    case "DO":
    case "FK":
    case "FM":
    case "GR":
    case "GU":
    case "JO":
    case "KZ":
    case "LB":
    case "LK":
    case "LS":
    case "MA":
    case "MH":
    case "MM":
    case "MR":
    case "MT":
    case "MV":
    case "NG":
    case "PG":
    case "PK":
    case "PR":
    case "RO":
    case "SG":
    case "VC":
    case "WS":
      return [["line1"], ["line2"], ["city", "postalCode"], ["countryCode"]];
    case "AU":
    case "CA":
    case "SZ":
    case "US":
    case "VI":
      return [
        ["line1"],
        ["line2"],
        ["city", ",", "region", "postalCode"],
        ["countryCode"]
      ];
    case "BE":
    case "PE":
      return [
        ["line1"],
        ["line2"],
        ["postalCode", "sublocality", "city"],
        ["countryCode"]
      ];
    case "BF":
    case "BI":
    case "BQ":
    case "BW":
    case "CF":
    case "CG":
    case "CM":
    case "DM":
    case "ER":
    case "GQ":
    case "KM":
    case "ML":
    case "SY":
    case "TD":
    case "ZW":
      return [["line1"], ["line2"], ["city"], ["region"], ["countryCode"]];
    case "BG":
      return [["line1"], ["postalCode", "region"], ["countryCode"]];
    case "BH":
      return [["line1"], ["line2"], ["sublocality", "city"], ["countryCode"]];
    case "BR":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["city", "region"],
        ["postalCode"],
        ["countryCode"]
      ];
    case "CH":
    case "DE":
    case "GT":
    case "IT":
    case "LI":
    case "MY":
    case "NI":
    case "OM":
    case "SK":
    case "VA":
      return [
        ["line1"],
        ["line2"],
        ["postalCode", "city", "region"],
        ["countryCode"]
      ];
    case "CL":
    case "PF":
      return [
        ["line1"],
        ["line2"],
        ["city", "postalCode", "region"],
        ["countryCode"]
      ];
    case "CN":
      return [
        ["region", "city", "sublocality"],
        ["line1"],
        ["line2"],
        ["countryCode"]
      ];
    case "CO":
    case "ID":
    case "IQ":
    case "KH":
    case "MP":
    case "NP":
    case "PW":
    case "UA":
      return [
        ["line1"],
        ["line2"],
        ["city", "region", "postalCode"],
        ["countryCode"]
      ];
    case "EG":
      return [
        ["line1"],
        ["line2"],
        ["sublocality", "city", "region", "postalCode"],
        ["countryCode"]
      ];
    case "ES":
    case "IL":
      return [
        ["line1"],
        ["line2"],
        ["city", "postalCode"],
        ["region"],
        ["countryCode"]
      ];
    case "GB":
    case "MN":
    case "ZA":
      return [
        ["line1"],
        ["line2"],
        ["sublocality", "city", "postalCode"],
        ["countryCode"]
      ];
    case "GG":
    case "IM":
    case "JE":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["city"],
        ["postalCode"],
        ["countryCode"]
      ];
    case "GN":
      return [["line1", "line2", "city"], ["countryCode"]];
    case "HK":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["city"],
        ["region"],
        ["countryCode"]
      ];
    case "HR":
      return [["line1"], ["postalCode", "city", "region"], ["countryCode"]];
    case "HU":
    case "SI":
      return [["postalCode", "city"], ["line1"], ["line2"], ["countryCode"]];
    case "IE":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["city", "region", "postalCode"],
        ["countryCode"]
      ];
    case "IN":
    case "VE":
      return [
        ["line1"],
        ["line2"],
        ["city", "postalCode"],
        ["region"],
        ["countryCode"]
      ];
    case "JP":
      return [
        ["line2"],
        ["line1", "sublocality"],
        ["city", "region"],
        ["postalCode"],
        ["countryCode"]
      ];
    case "KR":
      return [
        ["countryCode"],
        ["region", "city", "sublocality", "line1"],
        ["line2"],
        ["postalCode"]
      ];
    case "KY":
      return [["line1"], ["line2"], ["postalCode"], ["countryCode"]];
    case "LT":
      return [
        ["line1"],
        ["postalCode", "city", "sublocality", "region"],
        ["countryCode"]
      ];
    case "LV":
      return [["line1"], ["city", ",", "postalCode"], ["countryCode"]];
    case "MO":
      return [["line1"], ["line2"], ["sublocality"], ["city"], ["countryCode"]];
    case "MU":
      return [
        ["line1"],
        ["line2"],
        ["city"],
        ["region", "postalCode"],
        ["countryCode"]
      ];
    case "MX":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["postalCode", "city", ",", "region"],
        ["countryCode"]
      ];
    case "NE":
    case "SD":
      return [
        ["line1"],
        ["line2"],
        ["postalCode"],
        ["city"],
        ["region"],
        ["countryCode"]
      ];
    case "NZ":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["city"],
        ["postalCode"],
        ["countryCode"]
      ];
    case "PH":
    case "TW":
    case "VN":
      return [
        ["line1"],
        ["line2"],
        ["sublocality", "city"],
        ["region", "postalCode"],
        ["countryCode"]
      ];
    case "RU":
      return [["line1"], ["line2"], ["city"], ["postalCode"], ["countryCode"]];
    case "SB":
    case "SL":
    case "ST":
    case "TL":
    case "TO":
    case "TV":
      return [["line1"], ["line2"], ["city", ",", "region"], ["countryCode"]];
    case "TH":
    case "TR":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["postalCode", "city"],
        ["countryCode"]
      ];
    case "UZ":
      return [["line1"], ["line2"], ["region", "postalCode"], ["countryCode"]];
  }
  return [
    ["line1", "line2"],
    ["city", "region", "postalCode"],
    ["countryCode"]
  ];
}
const V_ = {
  GOOGLEMYBUSINESS: "GOOGLEMYBUSINESS"
}, lf = {
  GOOGLE: "google",
  APPLE: "apple",
  BING: "bing"
}, j_ = (t, e) => {
  const r = {
    region: "localizedRegionName",
    countryCode: "localizedCountryName"
  }[t];
  return r && e[r];
}, eS = (t, e = [], n, r = {
  route: !1
}) => {
  const c = "Failed to construct query for maps service.";
  let d = t && af([
    t.line1,
    t.line2,
    t.city,
    t.region,
    t.postalCode,
    t.countryCode
  ]);
  switch (r.provider) {
    case lf.APPLE: {
      if (!d) {
        console.warn(
          `${c} Check that you've provided a valid Yext Address.`
        );
        break;
      }
      return q_(d, r.route);
    }
    case lf.BING: {
      if (d = t && af([
        t.line1,
        t.city,
        t.region,
        t.postalCode
      ]), !d) {
        console.warn(
          `${c} Check that you've provided a valid Yext Address.`
        );
        break;
      }
      return Z_(d, r.route);
    }
    default: {
      const h = e.find(
        (p) => {
          var N;
          return ((N = p == null ? void 0 : p.publisher) == null ? void 0 : N.toUpperCase()) === V_.GOOGLEMYBUSINESS;
        }
      );
      if (h != null && h.listingUrl)
        return h.listingUrl;
      if (n)
        return J_(n, d, r.route);
      if (!d) {
        console.warn(
          `${c} Check that you've provided a valid Yext Address, Yext ListingType, or Google Place ID.`
        );
        break;
      }
      return X_(d, r.route);
    }
  }
}, q_ = (t, e) => e ? `https://maps.apple.com/?daddr=${t}` : `https://maps.apple.com/?address=${t}`, Z_ = (t, e) => e ? `https://bing.com/maps/default.aspx?rtp=adr.${t}` : `https://bing.com/maps/default.aspx?where1=${t}`, J_ = (t, e, n) => {
  const r = e ? `&query=${e}` : "";
  return n ? `https://maps.google.com/maps/dir/?api=1${r}&destination_place_id=${t}&destination=direct` : r ? `https://maps.google.com/maps/search/?api=1${r}&query_place_id=${t}` : `https://maps.google.com/maps/dir/?api=1&destination_place_id=${t}&destination=direct`;
}, X_ = (t, e) => e ? `https://maps.google.com/maps/dir/?api=1&destination=${t}` : `https://maps.google.com/maps/search/?api=1&query=${t}`, af = (t = []) => {
  if (!t.length)
    return "";
  const e = t.filter(Boolean).join(", ");
  return encodeURI(e);
}, tS = ({
  address: t,
  lines: e,
  separator: n = ",",
  ...r
}) => {
  const c = (e || Y_(t.countryCode)).map(
    (d) => /* @__PURE__ */ ht.jsx(
      Q_,
      {
        address: t,
        line: d,
        separator: n
      },
      d.toString()
    )
  );
  return /* @__PURE__ */ W_("div", { ...r, key: t.toString() }, c);
}, Q_ = ({
  address: t,
  line: e,
  separator: n
}) => {
  const r = [];
  for (const c of e) {
    if (c === ",") {
      r.push(/* @__PURE__ */ ht.jsx("span", { children: n }, c));
      continue;
    }
    const d = t[c];
    if (!d)
      continue;
    const h = j_(c, t);
    if (h) {
      r.push(
        /* @__PURE__ */ ht.jsxs(H_.Fragment, { children: [
          " ",
          /* @__PURE__ */ ht.jsx("abbr", { title: h, children: d })
        ] }, c)
      );
      continue;
    }
    r.push(/* @__PURE__ */ ht.jsx("span", { children: " " + d }, c));
  }
  return /* @__PURE__ */ ht.jsx("div", { className: "address-line", children: r });
};
var nl = {};
Object.defineProperty(nl, "__esModule", {
  value: !0
});
var ey = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
  return typeof t;
} : function(t) {
  return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
}, ty = typeof window < "u" && typeof window.document < "u", ny = typeof process < "u" && process.versions != null && process.versions.node != null, ry = (typeof self > "u" ? "undefined" : ey(self)) === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope", iy = typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom")), oy = typeof Deno < "u" && typeof Deno.version < "u" && typeof Deno.version.deno < "u", cf = nl.isBrowser = ty;
nl.isWebWorker = ry;
var sy = nl.isNode = ny;
nl.isJsDom = iy;
var ly = nl.isDeno = oy;
class ay {
  constructor() {
    $n(this, "name");
    /**
     * Whether or not the current runtime is being executed server-side or client-side. If the runtime
     * is node or deno then isServerSide will be true. When the runtime is browser isServerSide is
     * false.
     */
    $n(this, "isServerSide");
    $n(this, "version");
    var e;
    ly ? (this.name = "deno", this.version = "", cf && (this.version = ((e = window.Deno) == null ? void 0 : e.version.deno) || ""), this.isServerSide = !0) : sy ? (this.name = "node", this.version = process.versions.node, this.isServerSide = !0) : cf ? (this.name = "browser", this.version = navigator.userAgent, this.isServerSide = !1) : (this.name = "unknown", this.version = "", this.isServerSide = !1);
  }
  getNodeMajorVersion() {
    if (this.name !== "node")
      throw new Error("Not running in Node.");
    return +this.version.split(".")[0];
  }
}
const el = () => new ay(), cy = (...t) => {
  var r;
  if (el().name !== "browser")
    return !1;
  const n = (r = window == null ? void 0 : window.location) == null ? void 0 : r.hostname;
  return t.length === 0 ? n !== "localhost" && !n.includes("preview.pagescdn.com") : t.some((c) => c == null ? void 0 : c.includes(n));
};
var zu = { exports: {} };
(function(t, e) {
  var n = typeof self < "u" ? self : Ku, r = function() {
    function d() {
      this.fetch = !1, this.DOMException = n.DOMException;
    }
    return d.prototype = n, new d();
  }();
  (function(d) {
    (function(h) {
      var p = {
        searchParams: "URLSearchParams" in d,
        iterable: "Symbol" in d && "iterator" in Symbol,
        blob: "FileReader" in d && "Blob" in d && function() {
          try {
            return new Blob(), !0;
          } catch {
            return !1;
          }
        }(),
        formData: "FormData" in d,
        arrayBuffer: "ArrayBuffer" in d
      };
      function N(J) {
        return J && DataView.prototype.isPrototypeOf(J);
      }
      if (p.arrayBuffer)
        var x = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ], v = ArrayBuffer.isView || function(J) {
          return J && x.indexOf(Object.prototype.toString.call(J)) > -1;
        };
      function O(J) {
        if (typeof J != "string" && (J = String(J)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(J))
          throw new TypeError("Invalid character in header field name");
        return J.toLowerCase();
      }
      function M(J) {
        return typeof J != "string" && (J = String(J)), J;
      }
      function A(J) {
        var ee = {
          next: function() {
            var F = J.shift();
            return { done: F === void 0, value: F };
          }
        };
        return p.iterable && (ee[Symbol.iterator] = function() {
          return ee;
        }), ee;
      }
      function T(J) {
        this.map = {}, J instanceof T ? J.forEach(function(ee, F) {
          this.append(F, ee);
        }, this) : Array.isArray(J) ? J.forEach(function(ee) {
          this.append(ee[0], ee[1]);
        }, this) : J && Object.getOwnPropertyNames(J).forEach(function(ee) {
          this.append(ee, J[ee]);
        }, this);
      }
      T.prototype.append = function(J, ee) {
        J = O(J), ee = M(ee);
        var F = this.map[J];
        this.map[J] = F ? F + ", " + ee : ee;
      }, T.prototype.delete = function(J) {
        delete this.map[O(J)];
      }, T.prototype.get = function(J) {
        return J = O(J), this.has(J) ? this.map[J] : null;
      }, T.prototype.has = function(J) {
        return this.map.hasOwnProperty(O(J));
      }, T.prototype.set = function(J, ee) {
        this.map[O(J)] = M(ee);
      }, T.prototype.forEach = function(J, ee) {
        for (var F in this.map)
          this.map.hasOwnProperty(F) && J.call(ee, this.map[F], F, this);
      }, T.prototype.keys = function() {
        var J = [];
        return this.forEach(function(ee, F) {
          J.push(F);
        }), A(J);
      }, T.prototype.values = function() {
        var J = [];
        return this.forEach(function(ee) {
          J.push(ee);
        }), A(J);
      }, T.prototype.entries = function() {
        var J = [];
        return this.forEach(function(ee, F) {
          J.push([F, ee]);
        }), A(J);
      }, p.iterable && (T.prototype[Symbol.iterator] = T.prototype.entries);
      function w(J) {
        if (J.bodyUsed)
          return Promise.reject(new TypeError("Already read"));
        J.bodyUsed = !0;
      }
      function P(J) {
        return new Promise(function(ee, F) {
          J.onload = function() {
            ee(J.result);
          }, J.onerror = function() {
            F(J.error);
          };
        });
      }
      function K(J) {
        var ee = new FileReader(), F = P(ee);
        return ee.readAsArrayBuffer(J), F;
      }
      function $(J) {
        var ee = new FileReader(), F = P(ee);
        return ee.readAsText(J), F;
      }
      function W(J) {
        for (var ee = new Uint8Array(J), F = new Array(ee.length), D = 0; D < ee.length; D++)
          F[D] = String.fromCharCode(ee[D]);
        return F.join("");
      }
      function H(J) {
        if (J.slice)
          return J.slice(0);
        var ee = new Uint8Array(J.byteLength);
        return ee.set(new Uint8Array(J)), ee.buffer;
      }
      function z() {
        return this.bodyUsed = !1, this._initBody = function(J) {
          this._bodyInit = J, J ? typeof J == "string" ? this._bodyText = J : p.blob && Blob.prototype.isPrototypeOf(J) ? this._bodyBlob = J : p.formData && FormData.prototype.isPrototypeOf(J) ? this._bodyFormData = J : p.searchParams && URLSearchParams.prototype.isPrototypeOf(J) ? this._bodyText = J.toString() : p.arrayBuffer && p.blob && N(J) ? (this._bodyArrayBuffer = H(J.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : p.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(J) || v(J)) ? this._bodyArrayBuffer = H(J) : this._bodyText = J = Object.prototype.toString.call(J) : this._bodyText = "", this.headers.get("content-type") || (typeof J == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : p.searchParams && URLSearchParams.prototype.isPrototypeOf(J) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, p.blob && (this.blob = function() {
          var J = w(this);
          if (J)
            return J;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }, this.arrayBuffer = function() {
          return this._bodyArrayBuffer ? w(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(K);
        }), this.text = function() {
          var J = w(this);
          if (J)
            return J;
          if (this._bodyBlob)
            return $(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(W(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, p.formData && (this.formData = function() {
          return this.text().then(q);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      var te = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function re(J) {
        var ee = J.toUpperCase();
        return te.indexOf(ee) > -1 ? ee : J;
      }
      function ue(J, ee) {
        ee = ee || {};
        var F = ee.body;
        if (J instanceof ue) {
          if (J.bodyUsed)
            throw new TypeError("Already read");
          this.url = J.url, this.credentials = J.credentials, ee.headers || (this.headers = new T(J.headers)), this.method = J.method, this.mode = J.mode, this.signal = J.signal, !F && J._bodyInit != null && (F = J._bodyInit, J.bodyUsed = !0);
        } else
          this.url = String(J);
        if (this.credentials = ee.credentials || this.credentials || "same-origin", (ee.headers || !this.headers) && (this.headers = new T(ee.headers)), this.method = re(ee.method || this.method || "GET"), this.mode = ee.mode || this.mode || null, this.signal = ee.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && F)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(F);
      }
      ue.prototype.clone = function() {
        return new ue(this, { body: this._bodyInit });
      };
      function q(J) {
        var ee = new FormData();
        return J.trim().split("&").forEach(function(F) {
          if (F) {
            var D = F.split("="), V = D.shift().replace(/\+/g, " "), ne = D.join("=").replace(/\+/g, " ");
            ee.append(decodeURIComponent(V), decodeURIComponent(ne));
          }
        }), ee;
      }
      function G(J) {
        var ee = new T(), F = J.replace(/\r?\n[\t ]+/g, " ");
        return F.split(/\r?\n/).forEach(function(D) {
          var V = D.split(":"), ne = V.shift().trim();
          if (ne) {
            var Y = V.join(":").trim();
            ee.append(ne, Y);
          }
        }), ee;
      }
      z.call(ue.prototype);
      function j(J, ee) {
        ee || (ee = {}), this.type = "default", this.status = ee.status === void 0 ? 200 : ee.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in ee ? ee.statusText : "OK", this.headers = new T(ee.headers), this.url = ee.url || "", this._initBody(J);
      }
      z.call(j.prototype), j.prototype.clone = function() {
        return new j(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new T(this.headers),
          url: this.url
        });
      }, j.error = function() {
        var J = new j(null, { status: 0, statusText: "" });
        return J.type = "error", J;
      };
      var _e = [301, 302, 303, 307, 308];
      j.redirect = function(J, ee) {
        if (_e.indexOf(ee) === -1)
          throw new RangeError("Invalid status code");
        return new j(null, { status: ee, headers: { location: J } });
      }, h.DOMException = d.DOMException;
      try {
        new h.DOMException();
      } catch {
        h.DOMException = function(ee, F) {
          this.message = ee, this.name = F;
          var D = Error(ee);
          this.stack = D.stack;
        }, h.DOMException.prototype = Object.create(Error.prototype), h.DOMException.prototype.constructor = h.DOMException;
      }
      function pe(J, ee) {
        return new Promise(function(F, D) {
          var V = new ue(J, ee);
          if (V.signal && V.signal.aborted)
            return D(new h.DOMException("Aborted", "AbortError"));
          var ne = new XMLHttpRequest();
          function Y() {
            ne.abort();
          }
          ne.onload = function() {
            var U = {
              status: ne.status,
              statusText: ne.statusText,
              headers: G(ne.getAllResponseHeaders() || "")
            };
            U.url = "responseURL" in ne ? ne.responseURL : U.headers.get("X-Request-URL");
            var Q = "response" in ne ? ne.response : ne.responseText;
            F(new j(Q, U));
          }, ne.onerror = function() {
            D(new TypeError("Network request failed"));
          }, ne.ontimeout = function() {
            D(new TypeError("Network request failed"));
          }, ne.onabort = function() {
            D(new h.DOMException("Aborted", "AbortError"));
          }, ne.open(V.method, V.url, !0), V.credentials === "include" ? ne.withCredentials = !0 : V.credentials === "omit" && (ne.withCredentials = !1), "responseType" in ne && p.blob && (ne.responseType = "blob"), V.headers.forEach(function(U, Q) {
            ne.setRequestHeader(Q, U);
          }), V.signal && (V.signal.addEventListener("abort", Y), ne.onreadystatechange = function() {
            ne.readyState === 4 && V.signal.removeEventListener("abort", Y);
          }), ne.send(typeof V._bodyInit > "u" ? null : V._bodyInit);
        });
      }
      return pe.polyfill = !0, d.fetch || (d.fetch = pe, d.Headers = T, d.Request = ue, d.Response = j), h.Headers = T, h.Request = ue, h.Response = j, h.fetch = pe, Object.defineProperty(h, "__esModule", { value: !0 }), h;
    })({});
  })(r), r.fetch.ponyfill = !0, delete r.fetch.polyfill;
  var c = r;
  e = c.fetch, e.default = c.fetch, e.fetch = c.fetch, e.Headers = c.Headers, e.Request = c.Request, e.Response = c.Response, t.exports = e;
})(zu, zu.exports);
var uy = zu.exports;
const uf = /* @__PURE__ */ sd(uy);
var dy = (
  /** @class */
  function() {
    function t() {
    }
    return t.prototype.post = function(e, n, r) {
      var c = JSON.stringify(n), d = {
        method: "POST",
        headers: r,
        body: c,
        keepalive: !0
      };
      return typeof window < "u" && window.fetch ? window.fetch(e, d) : uf(e, d);
    }, t.prototype.get = function(e) {
      var n = {
        method: "GET",
        mode: "no-cors",
        keepalive: !0
      };
      return typeof window < "u" && window.fetch ? window.fetch(e, n) : uf(e, n);
    }, t;
  }()
), fy = {
  US: {
    PRODUCTION: "https://us.yextevents.com",
    SANDBOX: "https://sbx.us.yextevents.com"
  },
  EU: {
    PRODUCTION: "https://eu.yextevents.com",
    SANDBOX: void 0
  }
}, hy = {
  US: {
    PRODUCTION: "https://realtimeanalytics.yext.com",
    SANDBOX: "https://sandbox-realtimeanalytics.yext.com"
  },
  EU: {
    PRODUCTION: void 0,
    SANDBOX: void 0
  }
};
function gy(t, e) {
  var n = e ? ld(t) : _y(t);
  return "".concat(n, "/store_pagespixel");
}
function py() {
  var t = ld("US", "PRODUCTION");
  return "".concat(t, "/conversiontracking/conversion");
}
function my() {
  var t = ld("US", "PRODUCTION");
  return "".concat(t, "/listings");
}
function ld(t, e) {
  return tp(hy, t, e, !0);
}
function _y(t, e) {
  return tp(fy, t, e);
}
function tp(t, e, n, r) {
  e === void 0 && (e = "US"), n === void 0 && (n = "PRODUCTION"), r === void 0 && (r = !1);
  var c = t[e][n];
  if (!c)
    throw Error('The combination of the environment: "'.concat(n, '", region: "').concat(e, '",') + 'and conversionTrackingEnabled: "'.concat(r, '" is unsupported.'));
  return c;
}
var df;
(function(t) {
  t.AllTabNavigation = "ALL_TAB_NAVIGATION", t.VerticalTabNavigation = "VERTICAL_TAB_NAVIGATION", t.ScrollToBottomOfPage = "SCROLL_TO_BOTTOM_OF_PAGE", t.QuestionFocus = "QUESTION_FOCUS", t.QuestionSubmit = "QUESTION_SUBMIT", t.RowExpand = "ROW_EXPAND", t.RowCollapse = "ROW_COLLAPSE", t.ThumbsUp = "THUMBS_UP", t.ThumbsDown = "THUMBS_DOWN", t.VoiceStart = "VOICE_START", t.VoiceStop = "VOICE_STOP", t.SearchBarImpression = "SEARCH_BAR_IMPRESSION", t.SearchClearButton = "SEARCH_CLEAR_BUTTON", t.Paginate = "PAGINATE", t.AutocompleteSelection = "AUTO_COMPLETE_SELECTION", t.VerticalViewAll = "VERTICAL_VIEW_ALL", t.CtaClick = "CTA_CLICK", t.TitleClick = "TITLE_CLICK", t.TapToCall = "TAP_TO_CALL", t.OrderNow = "ORDER_NOW", t.AddToCart = "ADD_TO_CART", t.ApplyNow = "APPLY_NOW", t.DrivingDirections = "DRIVING_DIRECTIONS", t.ViewWebsite = "VIEW_WEBSITE", t.Email = "EMAIL", t.BookAppointment = "BOOK_APPOINTMENT", t.Rsvp = "RSVP", t.ResultsHidden = "RESULTS_HIDDEN", t.ResultsUnhidden = "RESULTS_UNHIDDEN", t.FollowUpQuery = "FOLLOW_UP_QUERY";
})(df || (df = {}));
var ei;
(function(t) {
  t.PageView = "PAGE_VIEW", t.CTA = "CTA_CLICK", t.Website = "WEBSITE", t.DrivingDirection = "DRIVING_DIRECTIONS", t.PhoneCall = "CALL";
})(ei || (ei = {}));
ei.CTA;
ei.Website;
ei.DrivingDirection;
var yy = {
  eventType: ei.PageView
};
ei.PhoneCall;
var ff;
(function(t) {
  t.Production = "PRODUCTION", t.Sandbox = "SANDBOX";
})(ff || (ff = {}));
var hf;
(function(t) {
  t.US = "US", t.EU = "EU";
})(hf || (hf = {}));
var ql = "_yfpc", Yc = "__temp__", np = "y_source";
function rp() {
  return Date.now() + Math.floor(1e3 * Math.random());
}
var Vc = function(t, e, n, r) {
  function c(d) {
    return d instanceof n ? d : new n(function(h) {
      h(d);
    });
  }
  return new (n || (n = Promise))(function(d, h) {
    function p(v) {
      try {
        x(r.next(v));
      } catch (O) {
        h(O);
      }
    }
    function N(v) {
      try {
        x(r.throw(v));
      } catch (O) {
        h(O);
      }
    }
    function x(v) {
      v.done ? d(v.value) : c(v.value).then(p, N);
    }
    x((r = r.apply(t, e || [])).next());
  });
}, jc = function(t, e) {
  var n = { label: 0, sent: function() {
    if (d[0] & 1)
      throw d[1];
    return d[1];
  }, trys: [], ops: [] }, r, c, d, h;
  return h = { next: p(0), throw: p(1), return: p(2) }, typeof Symbol == "function" && (h[Symbol.iterator] = function() {
    return this;
  }), h;
  function p(x) {
    return function(v) {
      return N([x, v]);
    };
  }
  function N(x) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (r = 1, c && (d = x[0] & 2 ? c.return : x[0] ? c.throw || ((d = c.return) && d.call(c), 0) : c.next) && !(d = d.call(c, x[1])).done)
          return d;
        switch (c = 0, d && (x = [x[0] & 2, d.value]), x[0]) {
          case 0:
          case 1:
            d = x;
            break;
          case 4:
            return n.label++, { value: x[1], done: !1 };
          case 5:
            n.label++, c = x[1], x = [0];
            continue;
          case 7:
            x = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (d = n.trys, !(d = d.length > 0 && d[d.length - 1]) && (x[0] === 6 || x[0] === 2)) {
              n = 0;
              continue;
            }
            if (x[0] === 3 && (!d || x[1] > d[0] && x[1] < d[3])) {
              n.label = x[1];
              break;
            }
            if (x[0] === 6 && n.label < d[1]) {
              n.label = d[1], d = x;
              break;
            }
            if (d && n.label < d[2]) {
              n.label = d[2], n.ops.push(x);
              break;
            }
            d[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        x = e.call(t, n);
      } catch (v) {
        x = [6, v], c = 0;
      } finally {
        r = d = 0;
      }
    if (x[0] & 5)
      throw x[1];
    return { value: x[0] ? x[1] : void 0, done: !0 };
  }
}, Ny = (
  /** @class */
  function() {
    function t(e, n) {
      this.httpRequesterService = e, this.debug = n, this._debug = n, this._conversionTrackingEndpoint = py(), this._conversionTrackingListingsEndpoint = my();
    }
    return t.prototype.printEvent = function(e, n) {
      this._debug && console.log("%c[YextAnalytics]%c- Tracked ".concat(n, " event: ").concat(e), "background: white; color: blue;", "");
    }, t.prototype.handleRequest = function(e) {
      return Vc(this, void 0, void 0, function() {
        var n, r;
        return jc(this, function(c) {
          switch (c.label) {
            case 0:
              return [4, this.httpRequesterService.get(e.toString())];
            case 1:
              return n = c.sent(), n.status !== 200 && !(n.type === "opaqueredirect" || n.type === "opaque") ? [4, n.text()] : [3, 3];
            case 2:
              throw r = c.sent(), new Error(r);
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, t.formatBaseEvent = function(e, n) {
      n.set(ql, e.cookieId), e.referrer && n.set("referrer", e.referrer), n.set("v", rp().toString()), n.set("location", e.location);
    }, t.prototype.trackConversion = function(e) {
      return Vc(this, void 0, void 0, function() {
        var n, r;
        return jc(this, function(c) {
          switch (c.label) {
            case 0:
              return n = new URL(this._conversionTrackingEndpoint), r = new URLSearchParams(), r.set("cid", e.cid), e.cv && r.set("cv", e.cv), t.formatBaseEvent(e, r), n.search = r.toString(), [4, this.handleRequest(n.toString())];
            case 1:
              return c.sent(), this.printEvent(e.cid, "Conversion"), [
                2
                /*return*/
              ];
          }
        });
      });
    }, t.prototype.trackListings = function(e) {
      return Vc(this, void 0, void 0, function() {
        var n, r;
        return jc(this, function(c) {
          switch (c.label) {
            case 0:
              return n = new URL(this._conversionTrackingListingsEndpoint), r = new URLSearchParams(), r.set(np, e.source), t.formatBaseEvent(e, r), n.search = r.toString(), [4, this.handleRequest(n.toString())];
            case 1:
              return c.sent(), this.printEvent(e.source, "Listings Click"), [
                2
                /*return*/
              ];
          }
        });
      });
    }, t.prototype.setDebugEnabled = function(e) {
      this._debug = e;
    }, t;
  }()
), gf = function(t, e, n, r) {
  function c(d) {
    return d instanceof n ? d : new n(function(h) {
      h(d);
    });
  }
  return new (n || (n = Promise))(function(d, h) {
    function p(v) {
      try {
        x(r.next(v));
      } catch (O) {
        h(O);
      }
    }
    function N(v) {
      try {
        x(r.throw(v));
      } catch (O) {
        h(O);
      }
    }
    function x(v) {
      v.done ? d(v.value) : c(v.value).then(p, N);
    }
    x((r = r.apply(t, e || [])).next());
  });
}, pf = function(t, e) {
  var n = { label: 0, sent: function() {
    if (d[0] & 1)
      throw d[1];
    return d[1];
  }, trys: [], ops: [] }, r, c, d, h;
  return h = { next: p(0), throw: p(1), return: p(2) }, typeof Symbol == "function" && (h[Symbol.iterator] = function() {
    return this;
  }), h;
  function p(x) {
    return function(v) {
      return N([x, v]);
    };
  }
  function N(x) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (r = 1, c && (d = x[0] & 2 ? c.return : x[0] ? c.throw || ((d = c.return) && d.call(c), 0) : c.next) && !(d = d.call(c, x[1])).done)
          return d;
        switch (c = 0, d && (x = [x[0] & 2, d.value]), x[0]) {
          case 0:
          case 1:
            d = x;
            break;
          case 4:
            return n.label++, { value: x[1], done: !1 };
          case 5:
            n.label++, c = x[1], x = [0];
            continue;
          case 7:
            x = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (d = n.trys, !(d = d.length > 0 && d[d.length - 1]) && (x[0] === 6 || x[0] === 2)) {
              n = 0;
              continue;
            }
            if (x[0] === 3 && (!d || x[1] > d[0] && x[1] < d[3])) {
              n.label = x[1];
              break;
            }
            if (x[0] === 6 && n.label < d[1]) {
              n.label = d[1], d = x;
              break;
            }
            if (d && n.label < d[2]) {
              n.label = d[2], n.ops.push(x);
              break;
            }
            d[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        x = e.call(t, n);
      } catch (v) {
        x = [6, v], c = 0;
      } finally {
        r = d = 0;
      }
    if (x[0] & 5)
      throw x[1];
    return { value: x[0] ? x[1] : void 0, done: !0 };
  }
}, Cy = "sites", Mn;
(function(t) {
  t.BusinessId = "businessids", t.Product = "product", t.SiteId = "siteId", t.IsStaging = "isStaging", t.CacheBuster = "v", t.UrlPath = "pageurl", t.Referrer = "pagesReferrer", t.EventType = "eventType", t.PageSetId = "pageSetId", t.EntityInternalId = "ids", t.DirectoryId = "directoryId", t.SearchId = "searchId", t.StaticPageId = "staticPageId", t.PageType = "pageType", t.VisitorId = "visitorId", t.VisitorMethod = "visitorIdMethod", t.PageDomain = "pageDomain";
})(Mn || (Mn = {}));
var rl = /* @__PURE__ */ new Map();
rl.set(ei.PageView, "pageview");
rl.set(ei.CTA, "calltoactionclick");
rl.set(ei.PhoneCall, "phonecall");
rl.set(ei.DrivingDirection, "drivingdirection");
rl.set(ei.Website, "clicktowebsite");
function Ey(t) {
  var e = rl.get(t);
  return typeof e == "string" ? e : t;
}
var Ty = (
  /** @class */
  function() {
    function t(e, n) {
      this.config = e, this.httpRequesterService = n, this.setVisitor(e.visitor), this._debug = e.debug, this._conversionTracker = new Ny(this.httpRequesterService, this._debug), this._hasTrackedListings = !1, this._region = e.region;
      try {
        this._pageUrl = new URL(e.pageUrl);
      } catch {
        throw new Error("pageUrl property must be a valid URL, was: '".concat(e.pageUrl, "'"));
      }
      if (e.pageDomain)
        try {
          this._pageDomain = new URL(e.pageDomain);
        } catch {
          console.warn("pageDomain '".concat(e.pageDomain, "' is not a valid URL."), "It will not be included as a query param sent to the API.");
        }
    }
    return t.prototype.printEvent = function(e) {
      this._debug && console.log("%c[YextAnalytics]%c- Tracked Pages event: ".concat(e.eventType), "background: white; color: blue;", "");
    }, t.prototype.urlParameters = function(e) {
      var n = new URLSearchParams();
      return n.set(Mn.BusinessId, this.config.businessId.toString()), n.set(Mn.Product, Cy), n.set(Mn.SiteId, this.config.siteId.toString()), n.set(Mn.IsStaging, (!this.config.production).toString()), n.set(Mn.EventType, Ey(e.eventType)), n.set(Mn.PageType, this.config.pageType.name), this.config.pageType.name === "entity" ? (n.set(Mn.PageSetId, this.config.pageType.pageSetId), n.set(Mn.EntityInternalId, this.config.pageType.id.toString())) : this.config.pageType.name === "directory" ? (n.set(Mn.DirectoryId, this.config.pageType.directoryId), n.set(Mn.EntityInternalId, this.config.pageType.id.toString())) : this.config.pageType.name === "locator" ? n.set(Mn.SearchId, this.config.pageType.searchId) : Mn.StaticPageId in this.config.pageType && n.set(Mn.StaticPageId, this.config.pageType.staticPageId), n.set(Mn.CacheBuster, rp().toString()), n.set(Mn.UrlPath, this._pageUrl.pathname), n.set(Mn.Referrer, this.config.referrer), this._pageDomain && n.set(Mn.PageDomain, this._pageDomain.toString()), this._conversionTrackingEnabled && this._cookieID && n.set(ql, this._cookieID), this._visitor && (n.set(Mn.VisitorId, this._visitor.id), this._visitor.idMethod && n.set(Mn.VisitorMethod, this._visitor.idMethod)), n;
    }, t.prototype.pageView = function() {
      return gf(this, void 0, void 0, function() {
        var e;
        return pf(this, function(n) {
          switch (n.label) {
            case 0:
              return e = this._pageUrl.searchParams.get(np), this._conversionTrackingEnabled && this._cookieID && !this._hasTrackedListings && e ? [4, this._conversionTracker.trackListings({
                cookieId: this._cookieID,
                location: this._pageUrl.toString(),
                source: e
              })] : [3, 2];
            case 1:
              n.sent(), this._hasTrackedListings = !0, n.label = 2;
            case 2:
              return [2, this.track(yy)];
          }
        });
      });
    }, t.prototype.track = function(e, n) {
      return gf(this, void 0, void 0, function() {
        var r, c, d, h;
        return pf(this, function(p) {
          switch (p.label) {
            case 0:
              return r = gy(this._region, this._conversionTrackingEnabled), c = new URL(r), c.search = this.urlParameters(e).toString(), [4, this.httpRequesterService.get(c.toString())];
            case 1:
              return d = p.sent(), d.status !== 200 && !(d.type == "opaque" || d.type == "opaqueredirect") ? [4, d.text()] : [3, 3];
            case 2:
              throw h = p.sent(), new Error(h);
            case 3:
              return this.printEvent(e), this._conversionTrackingEnabled && this._cookieID && n ? [4, this._conversionTracker.trackConversion({
                cid: n.cid,
                cv: n.cv,
                cookieId: this._cookieID,
                location: this._pageUrl.toString()
              })] : [3, 5];
            case 4:
              p.sent(), p.label = 5;
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, t.prototype.setDebugEnabled = function(e) {
      this._debug = e, this._conversionTracker && this._conversionTracker.setDebugEnabled(e);
    }, t.prototype.setVisitor = function(e) {
      this._visitor = e;
    }, t.prototype.setConversionTrackingEnabled = function(e, n) {
      this._conversionTrackingEnabled = e, this._cookieID = n;
    }, t;
  }()
);
var xy = (
  /** @class */
  function() {
    function t(e, n) {
      e === void 0 && (e = window), n === void 0 && (n = document), this._outerWindow = e, this._outerDocument = n;
    }
    return t.prototype.setAndGetYextCookie = function() {
      var e = this.fetchCookie();
      return e || (e = t.generateRandomCookie().toString()), this.setCookieAndRemoveOldCookies(e), e;
    }, t.generateRandomCookie = function() {
      return Math.floor(Math.random() * (/* @__PURE__ */ new Date()).getTime());
    }, t.prototype.fetchCookie = function() {
      var e = this, n = "", r = function(c) {
        if (e.canSetCookieWithDomain(c)) {
          var d = e.removeCookieByDomain(c);
          return d && (n = d, e.setCookie(n, c)), !0;
        }
      };
      return this.forEachDomainIncreasingSpecificity(r), n || r(""), n;
    }, t.prototype.forEachDomainIncreasingSpecificity = function(e) {
      for (var n = !1, r = this._outerDocument.location.hostname.split(".").reverse(), c = "", d = 0; d < r.length; d++)
        if (c = "." + r[d] + c, e(c)) {
          n = !0;
          break;
        }
      n || e("");
    }, t.prototype.removeCookieByDomain = function(e) {
      var n = this.persistentCookies();
      this.clearCookie(e);
      var r = this.persistentCookies();
      return r.length < n.length && t.listDifference(n, r)[0] || "";
    }, t.listDifference = function(e, n) {
      for (var r = Array.from(e), c = 0; c < n.length; c++) {
        var d = r.indexOf(n[c]);
        d !== -1 && r.splice(d, 1);
      }
      return r;
    }, t.prototype.persistentCookies = function() {
      return this.allCookies().filter(function(e) {
        return e !== Yc;
      });
    }, t.prototype.allCookies = function() {
      var e = [];
      return this.forEachCookieNameValue(function(n, r) {
        n === ql && e.push(r);
      }), e;
    }, t.prototype.forEachCookieNameValue = function(e) {
      this._outerDocument.cookie.split(";").forEach(function(n) {
        var r = n.split("="), c = r[0], d = r[1];
        c && d && e(c.trim(), d.trim());
      });
    }, t.prototype.setCookieAndRemoveOldCookies = function(e) {
      var n = this, r = !1, c = this.allCookies().length, d = 0;
      this.forEachDomainIncreasingSpecificity(function(h) {
        if (r ? n.removeCookieByDomain(h) && d++ : n.canSetCookieWithDomain(h) && (n.removeCookieByDomain(h) && d++, n.setCookie(e, h), r = !0), d >= c && r)
          return !0;
      });
    }, t.prototype.canSetCookieWithDomain = function(e) {
      var n = this.removeCookieByDomain(e), r = this.allCookies();
      this.setCookie(Yc, e);
      var c = this.allCookies();
      return r.length < c.length ? (n ? this.setCookie(n, e) : this.clearCookie(e), !0) : !1;
    }, t.prototype.setCookie = function(e, n) {
      this._outerDocument.cookie = this.formatCookie(ql, e, n);
    }, t.prototype.formatCookie = function(e, n, r, c) {
      c === void 0 && (c = "/");
      var d = e + "=" + n, h = /* @__PURE__ */ new Date();
      return h.setTime(h.getTime() + 90 * 24 * 60 * 60 * 1e3), d += ";path=" + c, d += ";expires=" + h.toUTCString(), r && (d += ";domain=" + r), d += ";samesite=None;", this._outerWindow.location.protocol === "https:" && (d += " Secure "), d;
    }, t.prototype.clearCookie = function(e, n) {
      e === void 0 && (e = ""), n === void 0 && (n = "/");
      var r = /* @__PURE__ */ new Date(0), c = ql + "=" + Yc;
      c += ";path=" + n, c += ";expires=" + r.toUTCString(), e && (c += ";domain=" + e + ";"), c += ";samesite=None;", this._outerWindow.location.protocol === "https:" && (c += " Secure "), this._outerDocument.cookie = c;
    }, t;
  }()
);
function vy(t) {
  var e = new dy();
  return new Ty(t, e);
}
function ip(t) {
  return t.toLowerCase().trim().replace(/[^\w\s-]|[\s-]+/g, "");
}
function Gu(t, e) {
  return [t, e].filter((n) => !!n).map((n) => ip(n)).join("_");
}
class Sy {
  /**
   * Creates an Analytics instance, will fire a pageview event if requireOptin
   * is false
   *
   * @param templateData - template data object from the pages system
   * @param requireOptIn - boolean, set to true if you require user opt in before tracking analytics
   */
  constructor(e, n, r, c = []) {
    $n(this, "_optedIn");
    $n(this, "_conversionTrackingEnabled", !1);
    $n(this, "_cookieManager");
    $n(this, "_analyticsReporter");
    $n(this, "_pageViewFired", !1);
    $n(this, "_enableDebugging", !1);
    this.templateData = e, this.pageDomain = r, this.productionDomains = c, this._optedIn = !n, this.makeReporter(), this.pageView();
  }
  calculatePageType() {
    var c, d, h, p;
    const e = !!((d = (c = this.templateData.document) == null ? void 0 : c.__) != null && d.staticPage), n = !!((p = (h = this.templateData.document) == null ? void 0 : h.__) != null && p.entityPageSet);
    let r;
    if (e)
      r = {
        name: "static",
        staticPageId: this.templateData.document.__.name
      };
    else if (n)
      r = {
        name: "entity",
        pageSetId: this.templateData.document.__.name,
        id: this.templateData.document.uid
      };
    else
      throw new Error("invalid document type");
    return r;
  }
  makeReporter() {
    if (el().name !== "browser" || !this._optedIn)
      return;
    const e = cy(...this.productionDomains);
    this._analyticsReporter = vy({
      businessId: this.templateData.document.businessId,
      pageType: this.calculatePageType(),
      pageUrl: window.location.href,
      production: e,
      referrer: document.referrer,
      siteId: this.templateData.document.siteId,
      pageDomain: this.pageDomain
    }), this.setDebugEnabled(this._enableDebugging);
  }
  canTrack() {
    return el().name === "browser" && this._optedIn && !!this._analyticsReporter;
  }
  setupConversionTracking() {
    var e;
    this._cookieManager = new xy(), (e = this._analyticsReporter) == null || e.setConversionTrackingEnabled(
      !0,
      this._cookieManager.setAndGetYextCookie()
    );
  }
  /** {@inheritDoc AnalyticsMethods.enableConversionTracking} */
  enableTrackingCookie() {
    this._conversionTrackingEnabled = !0, this.canTrack() && this.setupConversionTracking();
  }
  /** {@inheritDoc AnalyticsMethods.identify} */
  identify(e) {
    var n;
    this.canTrack() && ((n = this._analyticsReporter) == null || n.setVisitor(e));
  }
  /** {@inheritDoc AnalyticsMethods.async} */
  async optIn() {
    this._optedIn = !0, this.makeReporter(), this._conversionTrackingEnabled && !this._cookieManager && this.setupConversionTracking(), this._pageViewFired || await this.pageView();
  }
  /** {@inheritDoc AnalyticsMethods.async} */
  async pageView() {
    var e;
    if (!this.canTrack())
      return Promise.resolve(void 0);
    await ((e = this._analyticsReporter) == null ? void 0 : e.pageView()), this._pageViewFired = !0;
  }
  /** {@inheritDoc AnalyticsMethods.track} */
  async track(e, n) {
    var r;
    if (!this.canTrack())
      return Promise.resolve();
    await ((r = this._analyticsReporter) == null ? void 0 : r.track(
      { eventType: ip(e) },
      n
    ));
  }
  /** {@inheritDoc AnalyticsMethods.setDebugEnabled} */
  setDebugEnabled(e) {
    var n;
    this._enableDebugging = e, (n = this._analyticsReporter) == null || n.setDebugEnabled(e);
  }
  /** {@inheritDoc AnalyticsMethods.trackClick} */
  trackClick(e, n) {
    return (r) => {
      if (!this.canTrack())
        return Promise.resolve();
      if (r.target === null || r.defaultPrevented)
        return this.track(e, n);
      const c = r.target;
      if (c.href === null || c.href === void 0)
        return this.track(e, n);
      const d = new URL(c.href);
      if (d.protocol === "mailto:" || d.protocol === "tel:" || // eslint-disable-next-line no-script-url
      d.protocol === "javascript:" || d.hostname === window.location.hostname)
        return this.track(e, n);
      if (c.target && !c.target.match(/^_(self|parent|top)$/i) || r.ctrlKey || r.shiftKey || r.metaKey)
        return this.track(e, n);
      r.preventDefault();
      const p = () => {
        window.location.assign(d);
      }, N = new Promise((x) => {
        setTimeout(() => {
          x();
        }, 1e3);
      });
      return Promise.race([this.track(e, n), N]).then(p).catch(p);
    };
  }
}
const op = pc(null), sp = pc({ name: "" }), lp = () => gs(sp).name;
function nS(t) {
  const e = lp(), [n] = dr({
    name: Gu(e, t.name)
  });
  return /* @__PURE__ */ ht.jsx(sp.Provider, { value: n, children: t.children });
}
function mc() {
  const t = gs(op);
  if (!t)
    return t;
  el().name === "browser" && !window.setAnalyticsOptIn && (window.setAnalyticsOptIn = async () => {
    await t.optIn();
  });
  const e = lp();
  return {
    trackClick(n, r) {
      return t.trackClick(Gu(e, n), r);
    },
    setDebugEnabled(n) {
      return t.setDebugEnabled(n);
    },
    enableTrackingCookie() {
      return t.enableTrackingCookie();
    },
    identify(n) {
      return t.identify(n);
    },
    optIn() {
      return t.optIn();
    },
    pageView() {
      return t.pageView();
    },
    track(n, r) {
      return t.track(Gu(e, n), r);
    }
  };
}
const rS = () => {
  var t;
  return (t = mc()) == null ? void 0 : t.track;
}, iS = () => {
  var t;
  return (t = mc()) == null ? void 0 : t.pageView;
}, oS = () => {
  var t;
  return (t = mc()) == null ? void 0 : t.identify;
};
function sS(t) {
  var O;
  const {
    children: e,
    requireOptIn: n,
    enableTrackingCookie: r,
    enableDebugging: c,
    templateData: d,
    pageDomain: h,
    productionDomains: p
  } = t, N = od(null);
  N.current === null && (N.current = new Sy(
    d,
    n,
    h,
    p
  ));
  const x = N.current;
  r && x.enableTrackingCookie();
  let v = wy();
  return el().name === "node" && (v = v || ((O = process.env) == null ? void 0 : O.NODE_ENV) === "development"), x.setDebugEnabled(c ?? v), /* @__PURE__ */ ht.jsx(op.Provider, { value: x, children: e });
}
function wy() {
  return el().name !== "browser" || typeof window === void 0 ? !1 : !!new URL(window.location.href).searchParams.get("xYextDebug");
}
const us = {
  /**
   * The the default layout if one is not specified. An image will be scaled down to fit the
   * container but not exceed the absolute size of the image.
   */
  INTRINSIC: "intrinsic",
  /**
   * Shows the image in a fixed size. `width` or `height` must be passed in. If both `width` and
   * `height` are passed in, but the aspect ratio does not match the aspect ratio of the image,
   * the image will be centered. This behavior can be adjusted using the `objectFit` and
   * `objectPosition` props of the `style` rpop.
   */
  FIXED: "fixed",
  /** Shows the image in a fixed aspect ratio. The `aspectRatio` prop must be provided. */
  ASPECT: "aspect",
  /** Always fills the image to 100% of the container's width. */
  FILL: "fill"
}, ap = /(https?:\/\/a.mktgcdn.com\/p(?<env>-sandbox|-qa|-dev)?\/)(?<uuid>.+)\/(.*)/, Oy = /(https?:\/\/a.eu.mktgcdn.com\/f(?<env>-qa)?\/[0-9]+\/)(?<uuid>.+)\.(.+)/, lS = ({
  image: t,
  className: e,
  width: n,
  height: r,
  aspectRatio: c,
  layout: d = us.INTRINSIC,
  placeholder: h,
  imgOverrides: p,
  style: N = {},
  loading: x = "lazy"
}) => {
  const v = od(null), [O, M] = dr(!1), A = "image" in t ? t.image : t;
  fr(() => {
    var q;
    (q = v.current) != null && q.complete && M(!0);
  }, []), Dy(
    d,
    A.width,
    A.height,
    n,
    r,
    c
  );
  const T = Math.abs(A.width);
  T || console.warn("Invalid image width.");
  const w = Math.abs(A.height);
  w || console.warn("Invalid image height.");
  const P = Ry(A.url);
  if (!P)
    return /* @__PURE__ */ ht.jsx(ht.Fragment, { children: h != null && h });
  const K = n && n > 0 ? n : void 0, $ = r && r > 0 ? r : void 0, { src: W, imgStyle: H, widths: z } = My(
    d,
    T,
    w,
    P,
    N,
    A.url,
    K,
    $,
    c
  ), te = z.map(
    (q) => `${Yu(
      P,
      q,
      w / T * q,
      A.url
    )} ${q}w`
  ).join(", "), re = [640, 768, 1024, 1280, 1536], ue = z.map(
    (q, G) => G === z.length - 1 ? `${q}px` : `(max-width: ${re[G]}px) ${q}px`
  ).join(", ");
  return /* @__PURE__ */ ht.jsxs(ht.Fragment, { children: [
    !O && h != null && h,
    /* @__PURE__ */ ht.jsx(
      "img",
      {
        ref: v,
        style: H,
        src: W,
        className: e,
        width: K,
        height: $,
        srcSet: te,
        sizes: ue,
        loading: x,
        alt: A.alternateText || "",
        ...p
      }
    )
  ] });
}, Dy = (t, e, n, r, c, d) => {
  if (e < 0 && console.warn(`Invalid image width: ${e}.`), n < 0 && console.warn(`Invalid image height: ${n}.`), t === us.FIXED) {
    if (!r && !c) {
      console.warn(
        "Using fixed layout but neither width nor height is passed as props."
      );
      return;
    }
    r && r < 0 && console.warn(`Using fixed layout but width is invalid: ${r}.`), c && c < 0 && console.warn(`Using fixed layout but height is invalid: ${c}.`);
    return;
  }
  (r || c) && console.warn(
    "Width or height is passed in but layout is not fixed. These will have no impact. If you want to have a fixed height or width then set layout to fixed."
  ), t === us.ASPECT && !d && console.warn(
    "Using aspect layout but aspectRatio is not passed as a prop."
  );
}, Ry = (t) => {
  var r, c;
  const e = t.match(ap);
  if ((r = e == null ? void 0 : e.groups) != null && r.uuid)
    return e.groups.uuid;
  const n = t.match(Oy);
  return (c = n == null ? void 0 : n.groups) != null && c.uuid ? n.groups.uuid : (console.error(`Invalid image url: ${t}.`), "");
}, by = (t) => {
  var n;
  const e = t.match(ap);
  return (n = e == null ? void 0 : e.groups) == null ? void 0 : n.env;
}, Yu = (t, e, n, r) => {
  const c = by(r);
  return `https://dynl.mktgcdn.com/${c ? `p${c}` : "p"}/${t}/${Math.round(
    e
  )}x${Math.round(n)}`;
}, My = (t, e, n, r, c, d, h, p, N) => {
  let x = [100, 320, 640, 960, 1280, 1920], v = Yu(r, 500, 500, d);
  const O = { ...c };
  switch (O.objectFit = O.objectFit || "cover", O.objectPosition = O.objectPosition || "center", t) {
    case us.INTRINSIC:
      O.maxWidth = e, O.width = "100%", O.aspectRatio = N ? `${N}` : `${e} / ${n}`;
      break;
    case us.FIXED: {
      const { fixedWidth: M, fixedHeight: A, fixedWidths: T } = Ay(
        e,
        n,
        x,
        h,
        p
      );
      O.width = M, O.height = A, x = T, v = Yu(r, M, A, d);
      break;
    }
    case us.ASPECT:
      O.aspectRatio = N ? `${N}` : `${e} / ${n}`;
      break;
    case us.FILL:
      O.width = "100%", O.aspectRatio = N ? `${N}` : `${e} / ${n}`;
      break;
    default:
      console.warn(`Unrecognized layout: ${t}.`);
      break;
  }
  return { src: v, imgStyle: O, widths: x };
}, Ay = (t, e, n, r, c) => r && c ? {
  fixedWidth: r,
  fixedHeight: c,
  fixedWidths: [r]
} : r ? {
  fixedWidth: r,
  fixedHeight: r * e / t,
  fixedWidths: [r]
} : c ? {
  fixedWidth: c / e * t,
  fixedHeight: c,
  fixedWidths: [c / e * t]
} : {
  fixedWidth: t,
  fixedHeight: e,
  fixedWidths: n
};
var cp = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(t) {
  (function() {
    var e = {}.hasOwnProperty;
    function n() {
      for (var r = [], c = 0; c < arguments.length; c++) {
        var d = arguments[c];
        if (d) {
          var h = typeof d;
          if (h === "string" || h === "number")
            r.push(d);
          else if (Array.isArray(d)) {
            if (d.length) {
              var p = n.apply(null, d);
              p && r.push(p);
            }
          } else if (h === "object") {
            if (d.toString !== Object.prototype.toString && !d.toString.toString().includes("[native code]")) {
              r.push(d.toString());
              continue;
            }
            for (var N in d)
              e.call(d, N) && d[N] && r.push(N);
          }
        }
      }
      return r.join(" ");
    }
    t.exports ? (n.default = n, t.exports = n) : window.classNames = n;
  })();
})(cp);
var ky = cp.exports;
const Xl = /* @__PURE__ */ sd(ky), Ly = (t) => t.linkType === "Email" || !t.linkType && up(t.link) ? `mailto:${t.link}` : t.linkType === "Phone" ? `tel:${t.link}` : t.link, up = (t) => /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(t), Iy = (t) => {
  let e = "";
  for (let n = t.length - 1; n >= 0; e += t[n--])
    ;
  return e;
}, Py = (t) => "href" in t, $y = dn.forwardRef(
  function(e, n) {
    const r = Py(e) ? { link: e.href } : e.cta, { children: c, onClick: d, className: h, eventName: p, cta: N, ...x } = e, v = p || (N ? "cta" : "link"), O = mc(), M = e.obfuscate || e.obfuscate !== !1 && up(r.link), [A, T] = dr(!1), w = async (H) => {
      if (T(!0), O !== null)
        try {
          await O.trackClick(v, e.conversionDetails)(H);
        } catch {
          console.error("Failed to report click Analytics Event");
        }
      d && d(H);
    }, P = !c && !r.label, K = !A && M, $ = {
      ...e.style,
      unicodeBidi: "bidi-override",
      direction: P && K ? "rtl" : "ltr"
    }, W = K ? Iy(r.link) : r.link;
    return /* @__PURE__ */ ht.jsx(
      "a",
      {
        className: Xl("Link", h),
        href: A || !M ? Ly(r) : "obfuscate",
        onClick: w,
        rel: e.target && !e.rel ? "noopener" : void 0,
        ref: n,
        style: $,
        ...x,
        children: c || r.label || W
      }
    );
  }
), aS = {
  URL: "URL",
  Email: "Email",
  Phone: "Phone"
}, un = Object.freeze({
  DEGREE: Symbol("deg"),
  KILOMETER: Symbol("km"),
  MILE: Symbol("mi"),
  RADIAN: Symbol("r")
}), Zr = Object.freeze({
  MERCATOR: Symbol("mercator"),
  SPHERICAL: Symbol("spherical")
}), qc = 3959, Zc = 6371, Fy = ["latitude", "lat"], By = ["longitude", "lon", "lng", "long"];
function mf(t, e) {
  for (const n of e)
    if (t[n] || t[n] === 0)
      return t[n];
}
function _f(t) {
  switch (typeof t) {
    case "string":
    case "number":
      const e = Number.parseFloat(t);
      if (Number.isNaN(e))
        throw new Error(`'${t}' must be convertible to a Number'`);
      return e;
    default:
      throw new Error(
        `typeof '${t}' must be a number or a string that can be converted to a number, is '${typeof t}'`
      );
  }
}
function ds(t) {
  return t * Math.PI / 180;
}
function eo(t) {
  return t / Math.PI * 180;
}
function Hy(t, e) {
  const n = ds(t.latitude), r = ds(e.latitude), c = r - n, d = ds(e.longitude - t.longitude), h = Math.pow(Math.sin(c / 2), 2) + Math.cos(n) * Math.cos(r) * Math.pow(Math.sin(d / 2), 2);
  return 2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h));
}
function Wy(t, e) {
  const n = Math.tan(Math.PI / 360 * (t + 90)), r = Math.tan(Math.PI / 360 * (e + 90));
  return Math.log(r / n);
}
function Ky(t, e) {
  const r = Math.tan(Math.PI / 360 * (t + 90)) * Math.pow(Math.E, e);
  return Math.atan(r) * 360 / Math.PI - 90;
}
class nn {
  /**
   * Constructor takes either 1 or 2 arguments.
   * 2 arguments: latitude and longitude.
   * 1 argument: an object with at least one {@link module:@yext/components-geo~Coordinate~LATITUDE_ALIASES latitude alias}
   * and one one {@link module:@yext/components-geo~CoordinateCoordinate~LONGITUDE_ALIASES longitude alias}.
   * @param {number|Object} latitudeOrObject
   * @param {number} [longitude] Optional only if the first argument is a {@link module:@yext/components-geo~Coordinate Coordinate}-like object
   */
  constructor(e, n) {
    let r = e;
    typeof e == "object" && (r = mf(e, Fy), n = mf(e, By), r = typeof r == "function" ? r() : r, n = typeof n == "function" ? n() : n), this.latitude = r, this.longitude = n;
  }
  /**
   * Degrees latitude in the range [-90, 90].
   * If setting a value outside this range, it will be set to -90 or 90, whichever is closer.
   * @type {number}
   */
  get latitude() {
    return this._lat;
  }
  /**
   * Degrees longitude in the range [-Infinity, Infinity].
   * @type {number}
   */
  get longitude() {
    return this._lon;
  }
  /**
   * Degrees longitude in the range [-180, 180).
   * If the coordinate's longitude is outside this range, the equivalent value within it is used.
   * Examples: 123 => 123, 270 => -90, -541 => 179
   * @type {number}
   */
  get normalLon() {
    return ((this._lon + 180) % 360 + 360) % 360 - 180;
  }
  set latitude(e) {
    this._lat = Math.max(-90, Math.min(_f(e), 90));
  }
  set longitude(e) {
    this._lon = _f(e);
  }
  /**
   * Add distance to the coordinate to change its position.
   * @param {number} latDist latitude distance
   * @param {number} lonDist longitude distance
   * @param {module:@yext/components-geo~Unit} [unit=Unit.DEGREE] The unit of latDist and lonDist
   * @param {module:@yext/components-geo~Projection} [projection=Projection.SPHERICAL] The projection of Earth (not relevant when using a physical distance unit, e.g. Mile)
   */
  add(e, n, r = un.DEGREE, c = Zr.SPHERICAL) {
    if (c === Zr.MERCATOR && (r === un.DEGREE || r === un.RADIAN)) {
      const d = r === un.DEGREE ? ds(e) : e, h = r === un.DEGREE ? n : eo(n);
      this.latitude = Ky(this.latitude, d), this.longitude += h;
    } else
      switch (r) {
        case un.DEGREE:
          this.latitude += e, this.longitude += n;
          break;
        case un.KILOMETER:
          this.latitude += eo(e) * Zc, this.longitude += eo(n) * Zc * Math.cos(ds(this.latitude));
          break;
        case un.MILE:
          this.latitude += eo(e) * qc, this.longitude += eo(n) * qc * Math.cos(ds(this.latitude));
          break;
        case un.RADIAN:
          this.latitude += eo(e), this.longitude += eo(n);
          break;
        default:
          throw new Error(`unit unhandled: ${r}`);
      }
  }
  /**
   * Calculate the distance from this coordinate to another coordinate.
   * @param {module:@yext/components-geo~Coordinate} coordinate
   * @param {module:@yext/components-geo~Unit} [unit=Unit.MILE] The unit of distance
   * @param {module:@yext/components-geo~Projection} [projection=Projection.SPHERICAL] The projection of Earth (not relevant when using a physical distance unit, e.g. Mile)
   * @returns {number} Distance in the requested unit
   */
  distanceTo(e, n = un.MILE, r = Zr.SPHERICAL) {
    if (r === Zr.MERCATOR && (n === un.DEGREE || n === un.RADIAN)) {
      const c = Wy(
        this.latitude,
        e.latitude
      ), d = Math.abs(e.normalLon - this.normalLon), h = ds(
        Math.min(d, 360 - d)
      ), p = Math.sqrt(Math.pow(c, 2) + Math.pow(h, 2));
      switch (n) {
        case un.DEGREE:
          return eo(p);
        case un.RADIAN:
          return p;
        default:
          throw new Error(`unit unhandled: ${n}`);
      }
    } else {
      const c = Hy(this, e);
      switch (n) {
        case un.DEGREE:
          return eo(c);
        case un.KILOMETER:
          return c * Zc;
        case un.MILE:
          return c * qc;
        case un.RADIAN:
          return c;
        default:
          throw new Error(`unit unhandled: ${n}`);
      }
    }
  }
  /**
   * Test if this coordinate has the same latitude and longitude as another.
   * @param {module:@yext/components-geo~Coordinate} coordinate
   * @returns {boolean}
   */
  equals(e) {
    return e && e.latitude === this.latitude && e.longitude === this.longitude;
  }
  /**
   * Get the coordinate as a string that can be used in a search query.
   * Example: {latitude: -45, longitude: 123} => '-45,123'
   * @returns {string}
   */
  searchQueryString() {
    return `${this.latitude},${this.longitude}`;
  }
}
function dp(t, e = () => null) {
  const n = document.createElement("script");
  n.async = !0, n.onload = e, n.src = t, document.head.appendChild(n);
}
const gr = {
  UNDEFINED: "undefined",
  NULL: "object",
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#null
  BOOLEAN: "boolean",
  NUMBER: "number",
  BIGINT: "bigint",
  STRING: "string",
  SYMBOL: "symbol",
  FUNCTION: "function",
  OBJECT: "object"
};
function Or(t, e) {
  if (typeof e != "string")
    throw new Error("Assertion error: 'type' must be a string");
  if (typeof t !== e)
    throw new Error(
      `Expected an object of type '${e}' but received '${typeof t}'`
    );
}
function pr(t, e) {
  let n;
  try {
    n = t instanceof e;
  } catch {
    throw new Error(
      "Assertion error: 'instanceClass' is not a valid constructor"
    );
  }
  if (!n)
    throw new Error(
      `Expected an instance of '${e.name}' but received '${t.constructor.name}'`
    );
}
class fp {
  /**
   * @param {module:@yext/components-maps~MapProvider} provider
   * @param {HTMLElement} wrapper The wrapper element that the map will be inserted into
   */
  constructor(e, n) {
    pr(e, ms), pr(n, HTMLElement), this.providerMapClass = e.getMapClass(), this.wrapper = n, this.controlEnabled = !0, this.panHandler = () => null, this.panStartHandler = () => null, this.providerOptions = {};
  }
  /**
   * @param {boolean} controlEnabled Whether the user can interact with the map
   * @returns {module:@yext/components-maps~ProviderMapOptions}
   */
  withControlEnabled(e) {
    return this.controlEnabled = e, this;
  }
  /**
   * @param {function} panHandler Function called after the map bounds change
   * @returns {module:@yext/components-maps~ProviderMapOptions}
   */
  withPanHandler(e) {
    return Or(e, gr.FUNCTION), this.panHandler = e, this;
  }
  /**
   * @param {function} panStartHandler Function called before the map bounds change
   * @returns {module:@yext/components-maps~ProviderMapOptions}
   */
  withPanStartHandler(e) {
    return Or(e, gr.FUNCTION), this.panStartHandler = e, this;
  }
  /**
   * @param {Object} providerOptions A free-form object used to set any additional provider-specific
   *   options, usually by passing the object to the map's constructor
   * @returns {module:@yext/components-maps~ProviderMapOptions}
   */
  withProviderOptions(e) {
    return this.providerOptions = e, this;
  }
  /**
   * @returns {module:@yext/components-maps~ProviderMap} An instance of a subclass of {@link module:@yext/components-maps~ProviderMap ProviderMap}
   *   for the given {@link module:@yext/components-maps~MapProvider MapProvider}
   */
  build() {
    const e = this.providerMapClass;
    return new e(this);
  }
}
class il {
  /**
   * The constructor creates a map instance using the provider's API and initializes it with all the
   * given options. See {@link module:@yext/components-maps~ProviderMapOptions ProviderMapOptions}
   * for the supported options.
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(e) {
    pr(e, fp), this._panHandler = e.panHandler, this._panStartHandler = e.panStartHandler;
  }
  /**
   * @returns {module:@yext/components-tsx-geo~Coordinate} The current center of the map
   */
  getCenter() {
    throw new Error("not implemented");
  }
  /**
   * Zoom level complies with the specifications in {@link module:@yext/components-maps~Map#getZoom Map#getZoom}
   * @returns {number} The current zoom level of the map
   */
  getZoom() {
    throw new Error("not implemented");
  }
  /**
   * @param {module:@yext/components-tsx-geo~Coordinate} coordinate The new center for the map
   * @param {boolean} animated Whether to transition smoothly to the new center
   */
  setCenter(e, n) {
    throw new Error("not implemented");
  }
  /**
   * Zoom level complies with the specifications in {@link module:@yext/components-maps~Map#getZoom Map#getZoom}
   * @param {number} zoom The new zoom level for the map
   * @param {boolean} animated Whether to transition smoothly to the new zoom
   */
  setZoom(e, n) {
    throw new Error("not implemented");
  }
  /**
   * @param {number} zoom
   * @param {Object} center Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @param {boolean} animated Whether to transition smoothly to the new bounds
   * @see module:@yext/components-maps~ProviderMap#setZoom
   * @see module:@yext/components-maps~ProviderMap#setCenter
   */
  setZoomCenter(e, n, r) {
    this.setZoom(e, r), this.setCenter(n, r);
  }
}
class hp {
  /**
   * @param {module:@yext/components-maps~MapProvider} provider
   */
  constructor(e) {
    pr(e, ms), this.providerPinClass = e.getPinClass(), this.clickHandler = () => null, this.focusHandler = (n) => null, this.hoverHandler = (n) => null, this.icons = {};
  }
  /**
   * @param {import('./mapPin.js').PinClickHandler} clickHandler Function called when the pin is clicked
   * @returns {module:@yext/components-maps~ProviderPinOptions}
   */
  withClickHandler(e) {
    return Or(e, gr.FUNCTION), this.clickHandler = e, this;
  }
  /**
   * @param {import('./mapPin.js').PinFocusHandler} focusHandler Function called when the pin becomes (un)focused
   * @returns {module:@yext/components-maps~ProviderPinOptions}
   */
  withFocusHandler(e) {
    return Or(e, gr.FUNCTION), this.focusHandler = e, this;
  }
  /**
   * @param {import('./mapPin.js').PinHoverHandler} hoverHandler Function called when the pin becomes (un)hovered
   * @returns {module:@yext/components-maps~ProviderPinOptions}
   */
  withHoverHandler(e) {
    return Or(e, gr.FUNCTION), this.hoverHandler = e, this;
  }
  /**
   * Similar to {@link module:@yext/components-maps~MapPinOptions#withIcon MapPinOptions#withIcon},
   * but all icons are given as a map of key => icon. If a provider pin instance needs an icon to be
   * a specialized class rather than a simple URL, the icons in this object can be converted in this
   * function and assigned back to the icons object instead of being recreated from the URL every
   * time the pin's icon changes.
   * @param {Object<string,string>} icons Map of a string key to the URL or data URI of an image
   * @returns {module:@yext/components-maps~ProviderPinOptions}
   */
  withIcons(e) {
    return this.icons = e, this;
  }
  /**
   * @returns {module:@yext/components-maps~ProviderPin} An instance of a subclass of {@link module:@yext/components-maps~ProviderPin ProviderPin}
   *   for the given {@link module:@yext/components-maps~MapProvider MapProvider}
   */
  build() {
    const e = this.providerPinClass;
    return new e(this);
  }
}
class ad {
  /**
   * The constructor creates a pin instance using the provider's API and initializes it with all the
   * given options. See {@link module:@yext/components-maps~ProviderPinOptions ProviderPinOptions}
   * for the supported options.
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(e) {
    pr(e, hp), this._clickHandler = e.clickHandler, this._focusHandler = e.focusHandler, this._hoverHandler = e.hoverHandler, this._icons = e.icons;
  }
  /**
   * @param {module:@yext/components-tsx-geo~Coordinate} coordinate The position of the pin
   */
  setCoordinate(e) {
    throw new Error("not implemented");
  }
  /**
   * Remove the pin from its current map and, if newMap is not null, add it to the new map.
   * @param {?module:@yext/components-maps~Map} newMap The new map -- if null, the pin will not be
   *   shown on any map
   * @param {?module:@yext/components-maps~Map} currentMap The current map -- if null, the pin is
   *   not shown on any map
   */
  setMap(e, n) {
    throw new Error("not implemented");
  }
  /**
   * Apply the given properties to modify the appearance of the pin.
   * @param {module:@yext/components-maps~PinProperties} pinProperties
   * @see module:@yext/components-maps~PinProperties
   */
  setProperties(e) {
    throw new Error("not implemented");
  }
}
const Uy = Object.freeze({
  backgroundPosition: "center",
  backgroundRepeat: "no-repeat",
  backgroundSize: "contain",
  left: "0",
  outline: "none",
  pointerEvents: "auto",
  position: "absolute",
  top: "0"
});
class _c extends ad {
  /**
   * This is the base style applied to pin elements. It is a map from CSS property to value, such
   * as 'position': 'absolute'
   * @type {Object}
   */
  static get baseStyle() {
    return Uy;
  }
  /**
   * After instatiating a {@link module:@yext/components-maps~ProviderPin ProviderPin}, this creates
   * a wrapper element and a default pin element.
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(e) {
    super(e), this._pinEl = document.createElement("button"), Object.assign(this._pinEl.style, this.constructor.baseStyle), this._pinAlt = document.createElement("span"), this._pinAlt.classList.add("sr-only"), this._pinEl.appendChild(this._pinAlt), this._wrapper = document.createElement("div"), this._wrapper.style.pointerEvents = "none", this._wrapper.appendChild(this._pinEl), this.addListeners();
  }
  /**
   * Adds click, hover, and focus event listeners to the wrapper element
   */
  addListeners() {
    this._wrapper.addEventListener("click", () => this._clickHandler()), this._wrapper.addEventListener("focusin", () => this._focusHandler(!0)), this._wrapper.addEventListener("focusout", () => this._focusHandler(!1)), this._wrapper.addEventListener("mouseover", () => this._hoverHandler(!0)), this._wrapper.addEventListener("mouseout", () => this._hoverHandler(!1));
  }
  /**
   * @returns {HTMLElement} HTML button element for pin element
   */
  getPinElement() {
    return this._pinEl;
  }
  /**
   * @returns {HTMLElement} HTML button element for wrapper element
   */
  getWrapperElement() {
    return this._wrapper;
  }
  /**
   * @param {module:@yext/components-maps~PinProperties} pinProperties
   * @see module:@yext/components-maps~ProviderPin#setProperties
   */
  setProperties(e) {
    this.setElementProperties(e);
    const n = e.getClass(), r = e.getElement() || this._pinEl, c = e.getZIndex();
    r.style.pointerEvents = "auto", this._wrapper && (this._wrapper.style.zIndex = c, this._wrapper.setAttribute("class", n), r !== this._wrapper.children[0] && (this._wrapper.children[0].style.pointerEvents = "", this._wrapper.removeChild(this._wrapper.children[0]), this._wrapper.appendChild(r)));
  }
  /**
   * Sets properties used specifically by the pin element
   * @param {module:@yext/components-maps~PinProperties} pinProperties
   */
  setElementProperties(e) {
    const n = e.getAnchorX(), r = e.getAnchorY(), c = e.getHeight(), d = this._icons[e.getIcon()], h = e.getSRText(), p = e.getWidth();
    Object.assign(this._pinEl.style, {
      backgroundImage: d ? `url("${d}")` : "",
      height: c + "px",
      transform: `translate(${-100 * n}%, ${-100 * r}%)`,
      width: p + "px"
    }), this._pinAlt.innerText = h;
  }
}
class ps {
  constructor() {
    this.loadFunction = (e, n, r, c) => e(), this.mapClass = il, this.pinClass = ad, this.providerName = "";
  }
  /**
   * @param {module:@yext/components-maps~ProviderLoadFunction} loadFunction
   * @returns {module:@yext/components-maps~MapProviderOptions}
   */
  withLoadFunction(e) {
    return Or(e, gr.FUNCTION), this.loadFunction = e, this;
  }
  /**
   * @param {module:@yext/components-maps~ProviderMap} mapClass Subclass of {@link module:@yext/components-maps~ProviderMap ProviderMap}
   *   for the provider
   * @returns {module:@yext/components-maps~MapProviderOptions}
   */
  withMapClass(e) {
    return this.mapClass = e, this;
  }
  /**
   * @param {module:@yext/components-maps~ProviderPin} pinClass Subclass of {@link module:@yext/components-maps~ProviderPin ProviderPin}
   *   for the provider
   * @returns {module:@yext/components-maps~MapProviderOptions}
   */
  withPinClass(e) {
    return this.pinClass = e, this;
  }
  /**
   * @param {string} providerName Name of the map provider
   * @returns {module:@yext/components-maps~MapProviderOptions}
   */
  withProviderName(e) {
    return this.providerName = e, this;
  }
  /**
   * @returns {module:@yext/components-maps~MapProvider}
   */
  build() {
    return new ms(this);
  }
}
class ms {
  /**
   * @param {module:@yext/components-maps~MapProviderOptions} options
   */
  constructor(e) {
    pr(e, ps), this._loadFunction = e.loadFunction, this._mapClass = e.mapClass, this._pinClass = e.pinClass, this._providerName = e.providerName, this._loadPromise = new Promise((n, r) => {
      this._resolveLoad = n, this._rejectLoad = r;
    }), this._apiKey = "", this._loadInvoked = !1, this._loaded = !1, this._options = {};
  }
  /**
   * Returns true if the map provider has been successfully loaded
   * @type {boolean}
   */
  get loaded() {
    return this._loaded;
  }
  /**
   * @returns {module:@yext/components-maps~ProviderMap}
   * @see module:@yext/components-maps~MapProviderOptions#withMapClass
   */
  getMapClass() {
    return this._mapClass;
  }
  /**
   * @returns {module:@yext/components-maps~ProviderPin}
   * @see module:@yext/components-maps~MapProviderOptions#withPinClass
   */
  getPinClass() {
    return this._pinClass;
  }
  /**
   * @returns {string}
   * @see module:@yext/components-maps~MapProviderOptions#withProviderName
   */
  getProviderName() {
    return this._providerName;
  }
  /**
   * Call {@link module:@yext/components-maps~MapPinOptions~loadFunction MapPinOptions~loadFunction}
   * and resolve or reject when loading succeeds or fails
   * @async
   * @param {string} [apiKey] Provider API key -- uses value from {@link module:@yext/components-maps~MapProvider#setLoadOptions MapProvider#setLoadOptions}
   *   if not passed
   * @param {Object} [options] Additional provider-specific options -- uses value from {@link module:@yext/components-maps~MapProvider#setLoadOptions MapProvider#setLoadOptions}
   *   if not passed
   */
  async load(e = this._apiKey, n = this._options) {
    this._loadInvoked || (this._loadInvoked = !0, this._loadFunction(this._resolveLoad, this._rejectLoad, e, n)), await this.ready(), this._loaded = !0;
  }
  /**
   * Resolves or rejects when the map provider has loaded successfully or unsuccessfully
   * @async
   */
  async ready() {
    await this._loadPromise;
  }
  /**
   * Set the API key and provider options used on load. Does nothing if load was already called.
   * @param {string} apiKey Provider API key
   * @param {?Object} [options=null] Additional provider-specific options
   */
  setLoadOptions(e, n = null) {
    this._loadInvoked || (this._apiKey = e, this._options = n || this._options);
  }
}
const yf = {
  GEOCODER: "geocoder",
  PLACES: "places"
};
class zy extends il {
  /**
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(e) {
    super(e), this.map = new google.maps.Map(e.wrapper, {
      disableDefaultUI: !e.controlEnabled,
      fullscreenControl: !1,
      gestureHandling: e.controlEnabled ? "auto" : "none",
      mapTypeControl: !1,
      rotateControl: !1,
      scaleControl: !1,
      streetViewControl: !1,
      zoomControl: e.controlEnabled,
      zoomControlOptions: {
        position: google.maps.ControlPosition.RIGHT_TOP
      },
      ...e.providerOptions
    }), this._moving = !1, google.maps.event.addListener(this.map, "bounds_changed", () => {
      this._moving || (this._moving = !0, this._panStartHandler());
    }), google.maps.event.addListener(this.map, "idle", () => {
      this._moving = !1, this._panHandler();
    });
  }
  /**
   * @inheritdoc
   */
  getCenter() {
    return new nn(this.map.getCenter());
  }
  /**
   * @inheritdoc
   */
  getZoom() {
    return this.map.getZoom();
  }
  /**
   * @inheritdoc
   */
  setCenter(e, n) {
    const r = new google.maps.LatLng(
      e.latitude,
      e.longitude
    );
    n ? this.map.panTo(r) : this.map.setCenter(r);
  }
  /**
   * @inheritdoc
   */
  setZoom(e, n) {
    this.map.setZoom(Math.floor(e));
  }
  /**
   * @inheritdoc
   */
  setZoomCenter(e, n, r) {
    this.setCenter(n, r), this.setZoom(e, r);
  }
}
class Gy extends _c {
  /**
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(e) {
    super(e), this._wrapper.style.position = "absolute", google.maps.OverlayView.preventMapHitsAndGesturesFrom(this._wrapper);
    const n = this;
    class r extends google.maps.OverlayView {
      draw() {
        var h;
        const d = (h = this.getProjection()) == null ? void 0 : h.fromLatLngToDivPixel(
          n._latLng
        );
        d && (n._wrapper.style.left = d.x + "px", n._wrapper.style.top = d.y + "px");
      }
      onAdd() {
        this.getPanes().floatPane.appendChild(n._wrapper);
      }
      onRemove() {
        var d;
        (d = n._wrapper.parentNode) == null || d.removeChild(n._wrapper);
      }
    }
    this.pin = new r();
  }
  /**
   * @inheritdoc
   */
  setCoordinate(e) {
    this._latLng = new google.maps.LatLng(
      e.latitude,
      e.longitude
    ), this.pin.draw();
  }
  /**
   * @inheritdoc
   */
  setMap(e, n) {
    this.pin.setMap(e ? e.getProviderMap().map : null);
  }
}
const Nf = "GoogleMapsCallback_b7d77ff2", Yy = "https://maps.googleapis.com/maps/api/js";
function Vy(t, e, n, {
  autocomplete: r = !1,
  channel: c = window.location.hostname,
  client: d,
  language: h,
  region: p,
  libraries: N = [],
  params: x = {}
} = {}) {
  window[Nf] = t, r && N.push(yf.GEOCODER, yf.PLACES);
  const v = {
    callback: Nf,
    channel: c,
    libraries: N.join(","),
    ...x
  };
  n && (v.key = n), d && (v.client = d), h && (v.language = h), p && (v.region = p), dp(
    Yy + "?" + Object.entries(v).map(([O, M]) => O + "=" + M).join("&")
  );
}
const gp = new ps().withLoadFunction(Vy).withMapClass(zy).withPinClass(Gy).withProviderName("Google").build();
class as {
  /**
   * Create a new {@link module:@yext/components-geo~GeoBounds GeoBounds} with minimal area that
   * contains all the given coordinates
   * @param {module:@yext/components-geo~Coordinate[]} coordinates
   * @returns {module:@yext/components-geo~GeoBounds}
   */
  static fit(e) {
    const n = e.map((x) => x.latitude), r = Math.max(...n), c = Math.min(...n), d = e.map((x) => x.normalLon).sort((x, v) => x - v), h = d.map((x, v) => ({ distance: (v < d.length - 1 ? d[v + 1] : d[0] + 360) - x, index: v })).reduce(
      (x, v) => v.distance > x.distance ? v : x
    ).index, p = d[h], N = d[(h + 1) % d.length];
    return new this(new nn(c, N), new nn(r, p));
  }
  /**
   * @param {module:@yext/components-geo~Coordinate} sw Southwest coordinate
   * @param {module:@yext/components-geo~Coordinate} ne Northeast coordinate
   */
  constructor(e, n) {
    this._ne = new nn(n), this._sw = new nn(e);
  }
  /**
   * Northeast coordinate
   * @type {module:@yext/components-geo~Coordinate}
   */
  get ne() {
    return this._ne;
  }
  /**
   * Southwest coordinate
   * @type {module:@yext/components-geo~Coordinate}
   */
  get sw() {
    return this._sw;
  }
  set ne(e) {
    this._ne = new nn(e);
  }
  set sw(e) {
    this._sw = new nn(e);
  }
  /**
   * Whether the coordinate lies within the region defined by the bounds.
   * {@link module:@yext/components-geo~Coordinate#normalLon Normalized longitudes} are used for the
   * bounds and the coordinate.
   * @param {module:@yext/components-geo~Coordinate} coordinate
   * @returns {boolean}
   */
  contains(e) {
    const n = this._sw.latitude <= e.latitude && e.latitude <= this._ne.latitude, r = this._ne.longitude - this._sw.longitude >= 360, c = this._sw.normalLon <= this._ne.normalLon ? this._sw.normalLon <= e.normalLon && e.normalLon <= this._ne.normalLon : this._sw.normalLon <= e.normalLon || e.normalLon <= this._ne.normalLon;
    return n && (r || c);
  }
  /**
   * Extend the bounds if necessary so that the coordinate is contained by them.
   * @param {module:@yext/components-geo~Coordinate} coordinate
   */
  extend(e) {
    if (this._ne.latitude = Math.max(this._ne.latitude, e.latitude), this._sw.latitude = Math.min(this._sw.latitude, e.latitude), !this.contains(e)) {
      const n = ((e.longitude - this._ne.longitude) % 360 + 360) % 360, r = ((this._sw.longitude - e.longitude) % 360 + 360) % 360;
      n < r ? this._ne.longitude += n : this._sw.longitude -= r;
    }
  }
  /**
   * Calculate the center of the bounds using the given projection.
   * To find the visual center on a Mercator map, use Projection.MERCATOR.
   * To find the center for geolocation or geosearch purposes, use Projection.SPHERICAL.
   * @param {module:@yext/components-geo~Projection} [projection=Projection.SPHERICAL]
   * @returns {module:@yext/components-geo~Coordinate}
   */
  getCenter(e = Zr.SPHERICAL) {
    const n = new nn(this._ne.latitude, this._sw.longitude), r = this._sw.distanceTo(n, un.DEGREE, e), c = (n.longitude + this._ne.longitude) / 2 + (this._ne.longitude < n.longitude ? 180 : 0);
    return n.add(-r / 2, 0, un.DEGREE, e), n.longitude = c, n;
  }
}
class jy {
  constructor() {
    this._anchorX = 0.5, this._anchorY = 1, this._height = 39, this._icon = "default", this._srText = "map pin", this._width = 33, this._zIndex = 0, this._class = "", this._element = null;
  }
  /**
   * @returns {number} The point in the pin that should be positioned over the coordinate, from 0
   *   (left edge) to 1 (right edge)
   */
  getAnchorX() {
    return this._anchorX;
  }
  /**
   * @returns {number} The point in the pin that should be positioned over the coordinate, from 0
   *   (top edge) to 1 (bottom edge)
   */
  getAnchorY() {
    return this._anchorY;
  }
  /**
   * {@link module:@yext/components-maps~HTMLProviderPin HTMLProviderPins} only
   * @returns {string} The class of the wrapper element for an HTML pin
   */
  getClass() {
    return this._class;
  }
  /**
   * {@link module:@yext/components-maps~HTMLProviderPin HTMLProviderPins} only
   * @returns {string} The HTML pin element
   */
  getElement() {
    return this._element;
  }
  /**
   * @returns {number} The pixel height of the pin
   */
  getHeight() {
    return this._height;
  }
  /**
   * This returns a string key that can be used with {@link module:@yext/components-maps~MapPin#getIcon MapPin#getIcon}
   * to get the icon image for a pin.
   * @returns {string} The unique name of the icon
   */
  getIcon() {
    return this._icon;
  }
  /**
   * @returns {string} The text that a screen reader reads when focused on the pin
   */
  getSRText() {
    return this._srText;
  }
  /**
   * @returns {number} The pixel width of the pin
   */
  getWidth() {
    return this._width;
  }
  /**
   * @returns {number} The z-index of the pin
   */
  getZIndex() {
    return this._zIndex;
  }
  /**
   * @param {number} anchorX
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getAnchorX
   */
  setAnchorX(e) {
    return this._anchorX = e, this;
  }
  /**
   * @param {number} anchorY
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getAnchorY
   */
  setAnchorY(e) {
    return this._anchorY = e, this;
  }
  /**
   * @param {string} className
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getClass
   */
  setClass(e) {
    return this._class = e, this;
  }
  /**
   * @param {HTMLElement} element
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getElement
   */
  setElement(e) {
    return this._element = e, this;
  }
  /**
   * @param {number} height
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getHeight
   */
  setHeight(e) {
    return this._height = e, this;
  }
  /**
   * @param {string} icon
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getIcon
   */
  setIcon(e) {
    return this._icon = e, this;
  }
  /**
   * @param {string} srText
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getSRText
   */
  setSRText(e) {
    return this._srText = e, this;
  }
  /**
   * @param {number} width
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getWidth
   */
  setWidth(e) {
    return this._width = e, this;
  }
  /**
   * @param {number} zIndex
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getZIndex
   */
  setZIndex(e) {
    return this._zIndex = e, this;
  }
}
class cd {
  /**
   * Initialize with default options
   */
  constructor() {
    this.coordinate = new nn(0, 0), this.hideOffscreen = !1, this.icons = {}, this.propertiesForStatus = (e) => new jy(), this.provider = null, this.type = "";
  }
  /**
   * @param {Object} coordinate Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withCoordinate(e) {
    return this.coordinate = new nn(e), this;
  }
  /**
   * @param {boolean} hideOffscreen If true, the pin will only be rendered if it's in the visible
   *   portion of the map to improve performance
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withHideOffscreen(e) {
    return this.hideOffscreen = e, this;
  }
  /**
   * @param {string} key The unique name for the icon, used in {@link module:@yext/components-maps~PinProperties#getIcon PinProperties#getIcon}
   *   and {@link module:@yext/components-maps~PinProperties#setIcon PinProperties#setIcon}
   * @param {string} icon The URL or data URI of the icon image
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withIcon(e, n) {
    return this.icons[e] = n, this;
  }
  /**
   * @param {module:@yext/components-maps~PinPropertiesForStatus} propertiesForStatus
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withPropertiesForStatus(e) {
    return Or(e, gr.FUNCTION), this.propertiesForStatus = e, this;
  }
  /**
   * @param {module:@yext/components-maps~MapProvider} provider
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withProvider(e) {
    return pr(e, ms), this.provider = e, this;
  }
  /**
   * @param {string} type A string describing the type of the pin
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withType(e) {
    return this.type = e, this;
  }
  /**
   * @returns {module:@yext/components-maps~MapPin}
   */
  build() {
    return new qy(this);
  }
}
class qy {
  /**
   * @param {module:@yext/components-maps~MapPinOptions} options
   */
  constructor(e) {
    if (pr(e, cd), pr(e.provider, ms), !e.provider.loaded)
      throw new Error(
        `MapProvider '${e.provider.getProviderName()}' is not loaded. The MapProvider must be loaded before calling MapPin constructor.`
      );
    this._coordinate = e.coordinate, this._hideOffscreen = e.hideOffscreen, this._icons = { ...e.icons }, this._propertiesForStatus = e.propertiesForStatus, this._type = e.type, this._clickHandler = () => null, this._focusHandler = (n) => this._hoverHandler(n), this._hoverHandler = (n) => null, this._hidden = !1, this._cancelHiddenUpdater = () => null, this._map = null, this._pin = new hp(e.provider).withIcons({ ...this._icons }).withClickHandler(() => this._clickHandler()).withFocusHandler((n) => this._focusHandler(n)).withHoverHandler((n) => this._hoverHandler(n)).build(), this._pin.setCoordinate(e.coordinate), this._status = {}, this.setStatus(this._status);
  }
  /**
   * @returns {module:@yext/components-tsx-geo~Coordinate} The coordinate of the pin
   */
  getCoordinate() {
    return this._coordinate;
  }
  /**
   * Get the icon for a string key, such as 'default', 'hovered', or 'selected'
   * @param {string} key The unique name of the icon
   * @returns {string} The URL or data URI of the icon image
   * @see module:@yext/components-maps~MapPinOptions#withIcon
   */
  getIcon(e) {
    return this._icons[e];
  }
  /**
   * @returns {module:@yext/components-maps~Map} The map that the pin is currently on, or null if
   * not on a map
   */
  getMap() {
    return this._map;
  }
  /**
   * Intended for internal use only
   * @returns {module:@yext/components-maps~ProviderPin} The pin's {@link module:@yext/components-maps~ProviderPin ProviderPin}
   *   instance
   */
  getProviderPin() {
    return this._pin;
  }
  /**
   * @returns {string} The string describing the type of pin
   */
  getType() {
    return this._type;
  }
  /**
   * Remove this pin from its current map, if on one.
   */
  remove() {
    this.setMap(null);
  }
  /**
   * Set a handler function for when the pin is clicked, replacing any previously set click handler.
   * @param {module:@yext/components-maps~PinClickHandler} clickHandler
   */
  setClickHandler(e) {
    Or(e, gr.FUNCTION), this._clickHandler = e;
  }
  /**
   * @param {Object} coordinate Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   */
  setCoordinate(e) {
    this._coordinate = new nn(e), this._pin.setCoordinate(this._coordinate), this._hideOffscreen && this._hideIfOffscreen();
  }
  /**
   * Set a handler function for when the pin is (un)focused, replacing any previously set focus handler.
   * @param {module:@yext/components-maps~PinFocusHandler} focusHandler
   */
  setFocusHandler(e) {
    Or(e, gr.FUNCTION), this._focusHandler = e;
  }
  /**
   * Set a handler function for when the pin is (un)hovered, replacing any previously set hover handler.
   * @param {module:@yext/components-maps~PinHoverHandler} hoverHandler
   */
  setHoverHandler(e) {
    Or(e, gr.FUNCTION), this._hoverHandler = e;
  }
  /**
   * Add the pin to a map, removing it from its current map if on one.
   * @param {?Map} map
   */
  setMap(e) {
    if (e !== this._map && (e !== null && pr(e, mp), this._pin.setMap(e, this._hidden ? null : this._map), this._map = e, this._hidden = !1, this._cancelHiddenUpdater(), e && this._hideOffscreen)) {
      let n = !1;
      const r = new Promise((c) => {
        this._cancelHiddenUpdater = () => {
          n = !0, c();
        };
      });
      (async () => {
        for (; !n; )
          this._hideIfOffscreen(), await Promise.race([r, e.moving()]), await Promise.race([r, e.idle()]);
      })();
    }
  }
  /**
   * Assign all properties in an object to the pin's status.
   * Example: if the pin's status is { a: true, b: true }, passing in { a: false, c: true } will
   * change the pin's status to { a: false, b: true, c: true }
   * @param {Object} status
   */
  setStatus(e) {
    Object.assign(this._status, e), this._pin.setProperties(this._propertiesForStatus(this._status));
  }
  /**
   * Add or remove the pin from the map based on whether its coordinate is within the current bounds
   * @protected
   */
  _hideIfOffscreen() {
    if (this._map) {
      const e = this._map.getBounds().contains(this._coordinate);
      this._hidden && e ? this._pin.setMap(this._map, null) : !this._hidden && !e && this._pin.setMap(null, this._map), this._hidden = !e;
    }
  }
}
const Oo = 0.98;
function Va(t, e) {
  return Math.max(typeof t == gr.FUNCTION ? t() : t || 0, 0) / e;
}
class pp {
  /**
   * Initialize with default options
   */
  constructor() {
    this.controlEnabled = !0, this.defaultCenter = new nn(39.83, -98.58), this.defaultZoom = 4, this.legendPins = [], this.padding = {
      bottom: () => 50,
      left: () => 50,
      right: () => 50,
      top: () => 50
    }, this.panHandler = (e, n) => null, this.panStartHandler = (e) => null, this.provider = null, this.providerOptions = {}, this.singlePinZoom = 14, this.wrapper = null;
  }
  /**
   * @param {boolean} controlEnabled Whether the user can move and zoom the map
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withControlEnabled(e) {
    return this.controlEnabled = e, this;
  }
  /**
   * @param {module:@yext/components-tsx-geo~Coordinate} defaultCenter The center on initial load and
   *   when calling {@link module:@yext/components-maps~Map#fitCoordinates Map#fitCoordinates} with an empty array
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withDefaultCenter(e) {
    return this.defaultCenter = new nn(e), this;
  }
  /**
   * @param {number} defaultZoom The zoom on initial load and when calling {@link module:@yext/components-maps~Map#fitCoordinates Map#fitCoordinates}
   *   with an empty array
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withDefaultZoom(e) {
    return this.defaultZoom = e, this;
  }
  /**
   * @todo GENERATOR TODO Map legend not yet implemented
   * @param {module:@yext/components-maps~MapPin[]} legendPins Pins used to construct the map legend
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withLegendPins(e) {
    return this.legendPins = Array.from(e), this;
  }
  /**
   * Padding is used by {@link module:@yext/components-maps~Map#fitCoordinates Map#fitCoordinates}.
   * Padding can either be constant values or funtions that return a padding value.
   * See {@link module:@yext/components-maps~Map#setPadding Map#setPadding} for more information.
   * @param {Object} padding
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.bottom Minimum number of
   *   pixels between the map's bottom edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.left Minimum number of
   *   pixels between the map's left edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.right Minimum number of
   *   pixels between the map's right edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.top Minimum number of
   *   pixels between the map's top edge and a pin
   * @returns {module:@yext/components-maps~MapOptions}
   * @see module:@yext/components-maps~Map#setPadding
   */
  withPadding(e) {
    return this.padding = e, this;
  }
  /**
   * @param {module:@yext/components-maps~PanHandler} panHandler
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withPanHandler(e) {
    return Or(e, gr.FUNCTION), this.panHandler = e, this;
  }
  /**
   * @param {module:@yext/components-maps~PanStartHandler} panStartHandler
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withPanStartHandler(e) {
    return Or(e, gr.FUNCTION), this.panStartHandler = e, this;
  }
  /**
   * The {@link module:@yext/components-maps~MapProvider MapProvider} must be loaded before
   * constructing the {@link module:@yext/components-maps~Map Map}.
   * @param {module:@yext/components-maps~MapProvider} provider
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withProvider(e) {
    return pr(e, ms), this.provider = e, this;
  }
  /**
   * @param {Object} providerOptions A free-form object used to set any additional provider-specific
   *   options in the {@link module:@yext/components-maps~ProviderMap ProviderMap}
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withProviderOptions(e) {
    return this.providerOptions = e, this;
  }
  /**
   * @param {number} singlePinZoom The zoom when calling {@link module:@yext/components-maps~Map#fitCoordinates Map#fitCoordinates}
   *   with an array containing one coordinate
   * @returns {MapOptions}
   */
  withSinglePinZoom(e) {
    return this.singlePinZoom = e, this;
  }
  /**
   * @param {HTMLElement} wrapper The wrapper element that the map will be inserted into. The
   *   existing contents of the element will be removed.
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withWrapper(e) {
    return pr(e, HTMLElement), this.wrapper = e, this;
  }
  /**
   * @returns {module:@yext/components-maps~Map}
   */
  build() {
    return new mp(this);
  }
}
let mp = class {
  /**
   * The {@link module:@yext/components-maps~MapProvider MapProvider} for the map must be loaded
   * before calling this constructor.
   * @param {module:@yext/components-maps~MapOptions} options
   */
  constructor(e) {
    if (pr(e, pp), pr(e.provider, ms), pr(e.wrapper, HTMLElement), !e.provider.loaded)
      throw new Error(
        `MapProvider '${e.provider.getProviderName()}' is not loaded. The MapProvider must be loaded before calling Map constructor.`
      );
    for (this._defaultCenter = e.defaultCenter, this._defaultZoom = e.defaultZoom, this._legendPins = e.legendPins, this._provider = e.provider, this._singlePinZoom = e.singlePinZoom, this._wrapper = e.wrapper, this._padding = {}, this.setPadding(e.padding), this._cachedBounds = null, this._resolveIdle = () => null, this._resolveMoving = () => null, this._idlePromise = Promise.resolve(), this._setIdle(), this.setPanHandler(e.panHandler), this.setPanStartHandler(e.panStartHandler); this._wrapper.firstChild; )
      this._wrapper.removeChild(this._wrapper.lastChild);
    this._panHandlerRunning = !1, this._panStartHandlerRunning = !1, this._map = new fp(e.provider, this._wrapper).withControlEnabled(e.controlEnabled).withPanHandler(() => this.panHandler()).withPanStartHandler(() => this.panStartHandler()).withProviderOptions(e.providerOptions).build(), this.setZoomCenter(this._defaultZoom, this._defaultCenter), this._currentBounds = this.getBounds();
  }
  /**
   * Set the map bounds so that all the given coordinates are within the {@link module:@yext/components-maps~MapOptions#withPadding padded}
   * view.
   * @param {module:@yext/components-tsx-geo~Coordinate[]} coordinates
   * @param {boolean} [animated=false] Whether to transition smoothly to the new bounds
   * @param {number} [maxZoom=singlePinZoom] The max zoom level after fitting. Uses {@link module:@yext/components-maps~MapOptions#withSinglePinZoom singlePinZoom}
   *   by default.
   */
  fitCoordinates(e, n = !1, r = this._singlePinZoom) {
    e.length ? this.setBounds(
      as.fit(e),
      n,
      this._padding,
      r
    ) : this.setZoomCenter(this._defaultZoom, this._defaultCenter, n);
  }
  /**
   * Get the current visible region of the map. If the map is zoomed out to show multiple copies of
   * the world, the longitude bounds will be outside [-180, 180) but the center will always be
   * within [-180, 180).
   * @returns {module:@yext/components-tsx-geo~GeoBounds}
   */
  getBounds() {
    if (!this._cachedBounds) {
      const e = this._wrapper.offsetHeight, n = this._wrapper.offsetWidth, r = this.getZoom(), c = this.getCenter(), d = 360 / Math.pow(2, r + 8), h = n * d, p = e * d;
      this._cachedBounds = new as(c, c), this._cachedBounds.ne.add(
        p / 2,
        h / 2,
        un.DEGREE,
        Zr.MERCATOR
      ), this._cachedBounds.sw.add(
        -p / 2,
        -h / 2,
        un.DEGREE,
        Zr.MERCATOR
      ), this.moving().then(() => this._cachedBounds = null);
    }
    return new as(this._cachedBounds.sw, this._cachedBounds.ne);
  }
  /**
   * @returns {module:@yext/components-tsx-geo~Coordinate} The center of the current visible region of
   *   the map
   */
  getCenter() {
    return this._map.getCenter();
  }
  /**
   * Intended for internal use only
   * @returns {module:@yext/components-maps~ProviderMap} The map's {@link module:@yext/components-maps~ProviderMap ProviderMap}
   *   instance
   */
  getProviderMap() {
    return this._map;
  }
  /**
   * To standardize zoom for all providers, zoom level is calculated with this formula:
   * zoom = log2(pixel width of equator) - 8.
   * At zoom = 0, the entire world is 256 pixels wide.
   * At zoom = 1, the entire world is 512 pixels wide.
   * Zoom 2  1024 pixels, zoom 3  2056 pixels, etc.
   * Negative and non-integer zoom levels are valid and follow the formula.
   * @returns {number} The current zoom level of the map
   */
  getZoom() {
    return this._map.getZoom();
  }
  /**
   * Returns when the map is not moving.
   * Use map.idle().then(callback) to run callback immediately if the map is currently idle or once
   * the map becomes idle if it's not.
   */
  async idle() {
    await this._idlePromise;
  }
  /**
   * Returns when the map is moving.
   * Use map.moving().then(callback) to run callback immediately if the map is currently moving or
   * once the map starts moving if it's not.
   */
  async moving() {
    await this._movingPromise;
  }
  /**
   * @returns {module:@yext/components-maps~MapPinOptions} A {@link module:@yext/components-maps~MapPinOptions MapPinOptions}
   *   instance with the same provider as this map
   */
  newPinOptions() {
    return new cd().withProvider(this._provider);
  }
  /**
   * Called when the map has finished moving, at most once per animation frame.
   * Passes the current and previous bounds to the custom pan handler given by {@link module:@yext/components-maps~MapOptions#withPanHandler MapOptions#withPanHandler}
   */
  panHandler() {
    this._panHandlerRunning || (this._panHandlerRunning = !0, requestAnimationFrame(() => {
      const e = this._currentBounds;
      this._currentBounds = this.getBounds(), this._panHandler(
        e,
        new as(
          new nn(this._currentBounds.sw),
          new nn(this._currentBounds.ne)
        )
      ), this._panHandlerRunning = !1;
    }), this._setIdle());
  }
  /**
   * Called when the map has started moving, at most once per animation frame.
   * Passes the current bounds to the custom pan handler given by {@link module:@yext/components-maps~MapOptions#withPanStartHandler MapOptions#withPanStartHandler}
   */
  panStartHandler() {
    this._panStartHandlerRunning || (this._panStartHandlerRunning = !0, requestAnimationFrame(() => {
      this._panStartHandler(
        new as(
          new nn(this._currentBounds.sw),
          new nn(this._currentBounds.ne)
        )
      ), this._panStartHandlerRunning = !1;
    }), this._setMoving());
  }
  /**
   * @param {Object} bounds
   * @param {Object} bounds.ne The northeast corner of the bounds -- must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @param {Object} bounds.sw The southwest corner of the bounds -- must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @param {boolean} [animated=false] Whether to transition smoothly to the new bounds
   * @param {Object} [padding={}]
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.bottom Minimum number of
   *   pixels between the map's bottom edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.left Minimum number of
   *   pixels between the map's left edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.right Minimum number of
   *   pixels between the map's right edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.top Minimum number of
   *   pixels between the map's top edge and a pin
   * @param {number} [maxZoom=Infinity]
   */
  setBounds({ ne: e, sw: n }, r = !1, c = {}, d = 1 / 0) {
    const h = this._wrapper.offsetHeight, p = this._wrapper.offsetWidth;
    if (!h || !p)
      return;
    let N = Va(c.bottom, h), x = Va(c.left, p), v = Va(c.right, p), O = Va(c.top, h), M = x + v, A = N + O;
    M > Oo && (x *= Oo / M, v *= Oo / M, M = Oo), A > Oo && (N *= Oo / A, O *= Oo / A, A = Oo);
    const T = h * (1 - A), w = p * (1 - M), P = new as(n, e), K = new nn(P.ne.latitude, P.sw.longitude), $ = P.sw.distanceTo(K, un.DEGREE, Zr.MERCATOR), W = (P.ne.longitude - K.longitude + 360) % 360;
    let H = Math.max($, W * T / w) / (1 - A), z = Math.max(W, $ * w / T) / (1 - M), te = Math.log2(p * 360 / z) - 8;
    te > d && (te = d, z = p * 360 / 2 ** (te + 8), H = z * h / p);
    const re = P.getCenter(Zr.MERCATOR), ue = (O - N) / 2 * H, q = (v - x) / 2 * z;
    re.add(ue, q, un.DEGREE, Zr.MERCATOR), this.setZoomCenter(te, re, r);
  }
  /**
   * @param {Object} coordinate Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @param {boolean} [animated=false] Whether to transition smoothly to the new center
   */
  setCenter(e, n = !1) {
    this._map.setCenter(new nn(e), n);
  }
  /**
   * Padding is used by {@link module:@yext/components-maps~Map#fitCoordinates Map#fitCoordinates}.
   * Padding can either be constant values or funtions that return a padding value.
   * Constant values are good if the map should always have the same padding on every breakpoint.
   * Functions are useful if the map should have different padding at different breakpoints/layouts.
   * The function can check window.innerWidth or any other condition before returning a number.
   * @param {Object} padding
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.bottom Minimum number of
   *   pixels between the map's bottom edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.left Minimum number of
   *   pixels between the map's left edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.right Minimum number of
   *   pixels between the map's right edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.top Minimum number of
   *   pixels between the map's top edge and a pin
   * @returns {module:@yext/components-maps~Map}
   */
  setPadding({
    bottom: e = this._padding.bottom,
    left: n = this._padding.left,
    right: r = this._padding.right,
    top: c = this._padding.top
  }) {
    return this._padding = { bottom: e, left: n, right: r, top: c }, this;
  }
  /**
   * @param {module:@yext/components-maps~Map~panHandler} panHandler
   */
  setPanHandler(e) {
    Or(e, gr.FUNCTION), this._panHandler = e;
  }
  /**
   * @param {module:@yext/components-maps~Map~panStartHandler} panStartHandler
   */
  setPanStartHandler(e) {
    Or(e, gr.FUNCTION), this._panStartHandler = e;
  }
  /**
   * @param {number} zoom
   * @param {boolean} [animated=false] Whether to transition smoothly to the new zoom
   * @see module:@yext/components-maps~Map#getZoom
   */
  setZoom(e, n = !1) {
    this._map.setZoom(e, n);
  }
  /**
   * @param {number} zoom
   * @param {Object} center Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @param {boolean} [animated=false] Whether to transition smoothly to the new bounds
   * @see module:@yext/components-maps~Map#setZoom
   * @see module:@yext/components-maps~Map#setCenter
   */
  setZoomCenter(e, n, r = !1) {
    this._map.setZoomCenter(e, n, r);
  }
  /**
   * Set the map state to idle
   * @protected
   */
  _setIdle() {
    this._resolveMoving(), this._movingPromise = new Promise(
      (e) => this._resolveMoving = e
    ), this._resolveIdle();
  }
  /**
   * Set the map state to moving
   * @protected
   */
  _setMoving() {
    this._resolveIdle(), this._idlePromise = new Promise((e) => this._resolveIdle = e), this._resolveMoving();
  }
};
const yc = pc(null);
function uS() {
  const t = gs(yc);
  if (!t || t.map === void 0)
    throw new Error("Attempted to call useMapContext() outside of <Map>.");
  return t.map;
}
const _p = ({
  apiKey: t,
  bounds: e,
  children: n,
  className: r,
  clientKey: c,
  controls: d,
  defaultCenter: h,
  defaultZoom: p,
  mapRef: N,
  padding: x,
  panStartHandler: v,
  panHandler: O,
  provider: M,
  providerOptions: A = {},
  singleZoom: T
}) => {
  const w = od(null), [P, K] = dr(h), [$, W] = dr(!1), [H, z] = dr(), [te, re] = dr(p), ue = (q, G) => {
    O(q, G), K(G.getCenter());
  };
  return fr(() => {
    !$ || !H || re(H.getZoom());
  }, [P]), fr(() => {
    if (!e || !$ || !H)
      return;
    const q = e.map((G) => new nn(G));
    H.fitCoordinates(q);
  }, [JSON.stringify(e), H]), fr(() => {
    if (!$ || H)
      return;
    const q = new pp().withControlEnabled(d).withDefaultCenter(P).withDefaultZoom(te).withPadding(x).withPanHandler(ue).withPanStartHandler(v).withProvider(M).withProviderOptions(A).withSinglePinZoom(T).withWrapper(w.current).build();
    z(q), N && (N.current = q);
  }, [$]), fr(() => {
    $ || H || !w.current || M.load(t, {
      ...A,
      ...c && { client: c }
    }).then(() => W(!0));
  }, []), /* @__PURE__ */ ht.jsx(
    "div",
    {
      className: Xl(
        {
          "is-loaded": $
        },
        r
      ),
      id: "map",
      ref: w,
      "data-testid": "map",
      children: H && /* @__PURE__ */ ht.jsx(yc.Provider, { value: { map: H, provider: M }, children: n })
    }
  );
};
_p.defaultProps = {
  controls: !0,
  defaultCenter: { latitude: 39.83, longitude: -98.58 },
  defaultZoom: 4,
  padding: { bottom: 50, left: 50, right: 50, top: 50 },
  panHandler: () => null,
  panStartHandler: () => null,
  provider: gp,
  providerOptions: {},
  singleZoom: 14
};
const Zy = ({ count: t }) => /* @__PURE__ */ ht.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "22",
    height: "22",
    viewBox: "0 0 22 22",
    children: /* @__PURE__ */ ht.jsxs("g", { fill: "none", fillRule: "evenodd", children: [
      /* @__PURE__ */ ht.jsx(
        "circle",
        {
          fill: "red",
          fillRule: "nonzero",
          stroke: "white",
          cx: "11",
          cy: "11",
          r: "11"
        }
      ),
      /* @__PURE__ */ ht.jsx(
        "text",
        {
          fill: "white",
          fontFamily: "Arial-BoldMT,Arial",
          fontSize: "12",
          fontWeight: "bold",
          children: /* @__PURE__ */ ht.jsx("tspan", { x: "50%", y: "15", textAnchor: "middle", children: t })
        }
      )
    ] })
  }
), ud = pc(
  null
);
function dS() {
  const t = gs(ud);
  if (!t)
    throw new Error(
      "Attempted to call useClustererContext() outside of <Clusterer>."
    );
  return t;
}
const fS = ({
  clusterRadius: t = 50,
  children: e,
  ClusterTemplate: n = Zy
}) => {
  const { map: r } = gs(yc), [c, d] = dr([]), [h, p] = dr(), [N, x] = dr([]), [v, O] = dr([]);
  return fr(() => {
    p(Jy(c, r.getZoom(), t));
  }, [c, r.getZoom()]), fr(() => {
    O(() => []), x(() => []), (h == null ? void 0 : h.length) !== 0 && (h == null || h.forEach((M) => {
      if (M.length === 1) {
        M[0].pin.setMap(r);
        return;
      }
      if (M.length > 1) {
        const A = as.fit(
          M.map((w) => w.pin.getCoordinate())
        ).getCenter(Zr.MERCATOR), T = `cluster-{${A._lat},${A._lon}}`;
        M.forEach((w) => w.pin.setMap(null)), x((w) => [...w, T]), O((w) => [
          ...w,
          /* @__PURE__ */ ht.jsx(
            dd,
            {
              coordinate: A,
              id: T,
              onClick: () => r.fitCoordinates(
                M.map((P) => P.pin.getCoordinate()),
                !0,
                1 / 0
              ),
              children: /* @__PURE__ */ ht.jsx(n, { count: M.length })
            },
            T
          )
        ]);
      }
    }));
  }, [h]), /* @__PURE__ */ ht.jsx(
    ud.Provider,
    {
      value: {
        clusters: h ?? [],
        clusterIds: N,
        setPinStore: d
      },
      children: /* @__PURE__ */ ht.jsxs(ht.Fragment, { children: [
        v.map((M, A) => /* @__PURE__ */ ht.jsx(K_, { children: M }, A)),
        e
      ] })
    }
  );
}, Jy = (t, e, n) => {
  const r = n * Math.PI / 2 ** (e + 7), c = t.map((p, N) => [N]), d = [];
  t.forEach((p, N) => {
    for (let x = N; x < t.length; x++)
      x !== N && new nn(p.pin.getCoordinate()).distanceTo(
        new nn(t[x].pin.getCoordinate()),
        un.RADIAN,
        Zr.MERCATOR
      ) <= r && (c[N].push(x), c[x].push(N));
  });
  let h = 1;
  for (; h; ) {
    h = 0;
    let p;
    if (c.forEach((v, O) => {
      v.length > h && (h = v.length, p = O);
    }), !h)
      break;
    const N = c[p ?? 0], x = [];
    c[p ?? 0] = [];
    for (const v of N) {
      const O = c[v];
      x.push(t[v]), c[v] = [], O.forEach(
        (M) => c[M].splice(
          c[M].indexOf(v),
          1
        )
      );
    }
    d.push(x);
  }
  return d;
}, Xy = /* @__PURE__ */ ht.jsx(
  "svg",
  {
    width: "30",
    height: "38",
    viewBox: "0 0 30 38",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ ht.jsx(
      "path",
      {
        d: "M30 15.0882C30 23.4212 23.3333 30.7353 15 38C7.22222 31.2941 0 23.4212 0 15.0882C0 6.75523 6.71573 0 15 0C23.2843 0 30 6.75523 30 15.0882Z",
        fill: "red"
      }
    )
  }
), dd = ({
  children: t,
  coordinate: e,
  hideOffscreen: n,
  id: r,
  icon: c,
  onClick: d,
  onFocus: h,
  onHover: p,
  zIndex: N
}) => {
  const { map: x, provider: v } = gs(yc), O = gs(ud), M = Qg(() => new cd().withCoordinate(e).withHideOffscreen(n).withProvider(v).build(), []);
  fr(() => {
    if (N !== 0 && !N)
      return;
    const T = M.getProviderPin().getWrapperElement();
    T && (T.style.zIndex = N.toString());
  }, [N]), fr(() => {
    M.setMap(x), M.setClickHandler(() => d(r)), M.setFocusHandler((w) => h(w, r)), M.setHoverHandler((w) => p(w, r));
    const T = O == null ? void 0 : O.clusterIds.includes(r);
    return O && !T && O.setPinStore((w) => [
      ...w,
      {
        pin: M,
        id: r
      }
    ]), () => {
      M.setMap(null), O && O.setPinStore(
        (w) => w.filter((P) => P.id !== r)
      );
    };
  }, []);
  const A = t || c;
  if (A) {
    const T = M.getProviderPin().getPinElement();
    return Object.assign(T.style, {
      height: "auto",
      width: "auto"
    }), U_(A, T);
  }
  return null;
};
dd.defaultProps = {
  hideOffscreen: !1,
  icon: Xy,
  onClick: () => null,
  onHover: () => null,
  onFocus: () => null
};
const Qy = ({
  children: t,
  coordinate: e,
  linkSameTab: n,
  pinUrl: r,
  onClick: c = () => null,
  onHover: d = () => null,
  onFocus: h = () => null,
  ...p
}) => /* @__PURE__ */ ht.jsx(_p, { bounds: [e], ...p, children: /* @__PURE__ */ ht.jsx(
  dd,
  {
    coordinate: e,
    id: "location-map-marker",
    onClick: c,
    onHover: d,
    onFocus: h,
    children: r ? /* @__PURE__ */ ht.jsx($y, { href: r, target: n ? "_self" : "_blank", children: t }) : t || void 0
  }
) });
Qy.defaultProps = {
  controls: !0,
  panHandler: () => null,
  provider: gp,
  singleZoom: 16
};
var Jc = {}, Hl = {}, Cf;
function eN() {
  if (Cf)
    return Hl;
  Cf = 1;
  var t = dn;
  function e(r) {
    let c = new URLSearchParams();
    c.append("code", r);
    for (let d = 1; d < arguments.length; d++)
      c.append("v", arguments[d]);
    throw Error(`Minified Lexical error #${r}; visit https://lexical.dev/docs/error?${c} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  let n = t.createContext(null);
  return Hl.LexicalComposerContext = n, Hl.createLexicalComposerContext = function(r, c) {
    let d = null;
    return r != null && (d = r[1]), { getTheme: function() {
      return c ?? (d != null ? d.getTheme() : null);
    } };
  }, Hl.useLexicalComposerContext = function() {
    let r = t.useContext(n);
    return r == null && e(8), r;
  }, Hl;
}
var Wl = {}, Ef;
function tN() {
  if (Ef)
    return Wl;
  Ef = 1;
  var t = dn;
  const e = /* @__PURE__ */ t.createContext(null);
  function n(c, d) {
    let h = null;
    c != null && (h = c[1]);
    function p() {
      return d ?? (h != null ? h.getTheme() : null);
    }
    return {
      getTheme: p
    };
  }
  function r() {
    const c = t.useContext(e);
    if (c == null)
      throw Error("LexicalComposerContext.useLexicalComposerContext: cannot find a LexicalComposerContext");
    return c;
  }
  return Wl.LexicalComposerContext = e, Wl.createLexicalComposerContext = n, Wl.useLexicalComposerContext = r, Wl;
}
var Xc, Tf;
function Yn() {
  return Tf || (Tf = 1, Xc = process.env.NODE_ENV === "development" ? tN() : eN()), Xc;
}
var Pe = {}, xf;
function nN() {
  if (xf)
    return Pe;
  xf = 1;
  let t = {}, e = {}, n = {}, r = {}, c = {}, d = {}, h = {}, p = {}, N = {}, x = {}, v = {}, O = {}, M = {}, A = {}, T = {}, w = {}, P = {}, K = {}, $ = {}, W = {}, H = {}, z = {}, te = {}, re = {}, ue = {}, q = {}, G = {}, j = {}, _e = {}, pe = {}, J = {}, ee = {}, F = {}, D = {}, V = {}, ne = {};
  function Y(l) {
    let i = new URLSearchParams();
    i.append("code", l);
    for (let s = 1; s < arguments.length; s++)
      i.append("v", arguments[s]);
    throw Error(`Minified Lexical error #${l}; visit https://lexical.dev/docs/error?${i} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  let U = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Q = U && "documentMode" in document ? document.documentMode : null, k = U && /Mac|iPod|iPhone|iPad/.test(navigator.platform), m = U && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), y = U && "InputEvent" in window && !Q ? "getTargetRanges" in new window.InputEvent("input") : !1, b = U && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), Z = U && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, ce = U && /Android/.test(navigator.userAgent), ge = U && /^(?=.*Chrome).*/i.test(navigator.userAgent), ae = U && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !ge, Te = b || Z || ae ? "" : "", Ae = m ? "" : Te, ze = /^[^A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02b8\u0300-\u0590\u0800-\u1fff\u200e\u2c00-\ufb1c\ufe00-\ufe6f\ufefd-\uffff]*[\u0591-\u07ff\ufb1d-\ufdfd\ufe70-\ufefc]/, oe = /^[^\u0591-\u07ff\ufb1d-\ufdfd\ufe70-\ufefc]*[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02b8\u0300-\u0590\u0800-\u1fff\u200e\u2c00-\ufb1c\ufe00-\ufe6f\ufefd-\uffff]/, ie = { bold: 1, code: 16, highlight: 128, italic: 2, strikethrough: 4, subscript: 32, superscript: 64, underline: 8 }, de = { directionless: 1, unmergeable: 2 }, we = { center: 2, end: 6, justify: 4, left: 1, right: 3, start: 5 }, ke = { 2: "center", 6: "end", 4: "justify", 1: "left", 3: "right", 5: "start" }, Be = { normal: 0, segmented: 2, token: 1 }, Ye = { 0: "normal", 2: "segmented", 1: "token" }, lt = !1, _t = 0;
  function ct(l) {
    _t = l.timeStamp;
  }
  function ve(l, i, s) {
    return i.__lexicalLineBreak === l || l[`__lexicalKey_${s._key}`] !== void 0;
  }
  function se(l) {
    return l.getEditorState().read(() => {
      let i = Vt();
      return i !== null ? i.clone() : null;
    });
  }
  function he(l, i, s) {
    lt = !0;
    let g = 100 < performance.now() - _t;
    try {
      lr(l, () => {
        let C = Vt() || se(l);
        var S = /* @__PURE__ */ new Map(), R = l.getRootElement(), X = l._editorState, me = l._blockCursorElement;
        let Se = !1, Fe = "";
        for (var Ke = 0; Ke < i.length; Ke++) {
          var Le = i[Ke], Re = Le.type, Xe = Le.target, at = Dr(Xe, X);
          if (!(at === null && Xe !== R || ln(at))) {
            if (Re === "characterData") {
              if (Le = g && dt(at))
                e: {
                  Le = C, Re = Xe;
                  var Et = at;
                  if (St(Le)) {
                    var Rt = Le.anchor.getNode();
                    if (Rt.is(Et) && Le.format !== Rt.getFormat()) {
                      Le = !1;
                      break e;
                    }
                  }
                  Le = Re.nodeType === 3 && Et.isAttached();
                }
              Le && (Et = $r(l._window), Re = Le = null, Et !== null && Et.anchorNode === Xe && (Le = Et.anchorOffset, Re = Et.focusOffset), Xe = Xe.nodeValue, Xe !== null && yt(at, Xe, Le, Re, !1));
            } else if (Re === "childList") {
              for (Se = !0, Re = Le.addedNodes, Et = 0; Et < Re.length; Et++) {
                Rt = Re[Et];
                var hn = mr(Rt), cr = Rt.parentNode;
                cr == null || Rt === me || hn !== null || Rt.nodeName === "BR" && ve(Rt, cr, l) || (m && (hn = Rt.innerText || Rt.nodeValue) && (Fe += hn), cr.removeChild(Rt));
              }
              if (Le = Le.removedNodes, Re = Le.length, 0 < Re) {
                for (Et = 0, Rt = 0; Rt < Re; Rt++)
                  cr = Le[Rt], (cr.nodeName === "BR" && ve(cr, Xe, l) || me === cr) && (Xe.appendChild(cr), Et++);
                Re !== Et && (Xe === R && (at = X._nodeMap.get("root")), S.set(Xe, at));
              }
            }
          }
        }
        if (0 < S.size)
          for (let [
            zr,
            ui
          ] of S)
            if (Ze(ui))
              for (S = ui.getChildrenKeys(), R = zr.firstChild, X = 0; X < S.length; X++)
                me = l.getElementByKey(S[X]), me !== null && (R == null ? (zr.appendChild(me), R = me) : R !== me && zr.replaceChild(me, R), R = R.nextSibling);
            else
              dt(ui) && ui.markDirty();
        if (S = s.takeRecords(), 0 < S.length) {
          for (R = 0; R < S.length; R++)
            for (me = S[R], X = me.addedNodes, me = me.target, Ke = 0; Ke < X.length; Ke++)
              at = X[Ke], Xe = at.parentNode, Xe == null || at.nodeName !== "BR" || ve(at, me, l) || Xe.removeChild(at);
          s.takeRecords();
        }
        C !== null && (Se && (C.dirty = !0, _r(C)), m && on(l) && C.insertRawText(Fe));
      });
    } finally {
      lt = !1;
    }
  }
  function Oe(l) {
    let i = l._observer;
    if (i !== null) {
      let s = i.takeRecords();
      he(l, s, i);
    }
  }
  function Me(l) {
    _t === 0 && Zn(l).addEventListener("textInput", ct, !0), l._observer = new MutationObserver((i, s) => {
      he(l, i, s);
    });
  }
  function De(l, i) {
    let s = l.__mode, g = l.__format;
    l = l.__style;
    let C = i.__mode, S = i.__format;
    return i = i.__style, (s === null || s === C) && (g === null || g === S) && (l === null || l === i);
  }
  function We(l, i) {
    let s = l.mergeWithSibling(i), g = sn()._normalizedNodes;
    return g.add(l.__key), g.add(i.__key), s;
  }
  function qe(l) {
    if (l.__text === "" && l.isSimpleText() && !l.isUnmergeable())
      l.remove();
    else {
      for (var i; (i = l.getPreviousSibling()) !== null && dt(i) && i.isSimpleText() && !i.isUnmergeable(); )
        if (i.__text === "")
          i.remove();
        else {
          De(i, l) && (l = We(i, l));
          break;
        }
      for (var s; (s = l.getNextSibling()) !== null && dt(s) && s.isSimpleText() && !s.isUnmergeable(); )
        if (s.__text === "")
          s.remove();
        else {
          De(l, s) && We(l, s);
          break;
        }
    }
  }
  function Qe(l) {
    return ut(l.anchor), ut(l.focus), l;
  }
  function ut(l) {
    for (; l.type === "element"; ) {
      var i = l.getNode(), s = l.offset;
      if (s === i.getChildrenSize() ? (i = i.getChildAtIndex(s - 1), s = !0) : (i = i.getChildAtIndex(s), s = !1), dt(i)) {
        l.set(i.__key, s ? i.getTextContentSize() : 0, "text");
        break;
      } else if (!Ze(i))
        break;
      l.set(i.__key, s ? i.getChildrenSize() : 0, "element");
    }
  }
  let kt = 1, Ve = typeof queueMicrotask == "function" ? queueMicrotask : (l) => {
    Promise.resolve().then(l);
  };
  function je(l) {
    let i = document.activeElement;
    if (i === null)
      return !1;
    let s = i.nodeName;
    return ln(Dr(l)) && (s === "INPUT" || s === "TEXTAREA" || i.contentEditable === "true" && i.__lexicalEditor == null);
  }
  function nt(l, i, s) {
    let g = l.getRootElement();
    try {
      return g !== null && g.contains(i) && g.contains(s) && i !== null && !je(i) && mt(i) === l;
    } catch {
      return !1;
    }
  }
  function mt(l) {
    for (; l != null; ) {
      let i = l.__lexicalEditor;
      if (i != null)
        return i;
      l = yr(l);
    }
    return null;
  }
  function Ct(l) {
    return l.isToken() || l.isSegmented();
  }
  function vt(l) {
    for (; l != null; ) {
      if (l.nodeType === 3)
        return l;
      l = l.firstChild;
    }
    return null;
  }
  function wt(l, i, s) {
    let g = ie[i];
    return s !== null && (l & g) === (s & g) || (l ^= g, i === "subscript" ? l &= ~ie.superscript : i === "superscript" && (l &= ~ie.subscript)), l;
  }
  function Dt(l, i) {
    if (i != null)
      l.__key = i;
    else {
      Xn(), 99 < No && Y(14), i = sn();
      var s = Er(), g = "" + kt++;
      s._nodeMap.set(g, l), Ze(l) ? i._dirtyElements.set(g, !0) : i._dirtyLeaves.add(g), i._cloneNotNeeded.add(g), i._dirtyType = 1, l.__key = g;
    }
  }
  function Tt(l) {
    var i = l.getParent();
    if (i !== null) {
      let C = l.getWritable();
      i = i.getWritable();
      var s = l.getPreviousSibling();
      if (l = l.getNextSibling(), s === null)
        if (l !== null) {
          var g = l.getWritable();
          i.__first = l.__key, g.__prev = null;
        } else
          i.__first = null;
      else {
        if (g = s.getWritable(), l !== null) {
          let S = l.getWritable();
          S.__prev = g.__key, g.__next = S.__key;
        } else
          g.__next = null;
        C.__prev = null;
      }
      l === null ? s !== null ? (l = s.getWritable(), i.__last = s.__key, l.__next = null) : i.__last = null : (l = l.getWritable(), s !== null ? (s = s.getWritable(), s.__next = l.__key, l.__prev = s.__key) : l.__prev = null, C.__next = null), i.__size--, C.__parent = null;
    }
  }
  function Xt(l) {
    99 < No && Y(14);
    var i = l.getLatest(), s = i.__parent, g = Er();
    let C = sn(), S = g._nodeMap;
    if (g = C._dirtyElements, s !== null)
      e:
        for (; s !== null; ) {
          if (g.has(s))
            break e;
          let R = S.get(s);
          if (R === void 0)
            break;
          g.set(s, !1), s = R.__parent;
        }
    i = i.__key, C._dirtyType = 1, Ze(l) ? g.set(i, !0) : C._dirtyLeaves.add(i);
  }
  function Mt(l) {
    Xn();
    var i = sn();
    let s = i._compositionKey;
    l !== s && (i._compositionKey = l, s !== null && (i = Lt(s), i !== null && i.getWritable()), l !== null && (l = Lt(l), l !== null && l.getWritable()));
  }
  function Ut() {
    return ci() ? null : sn()._compositionKey;
  }
  function Lt(l, i) {
    return l = (i || Er())._nodeMap.get(l), l === void 0 ? null : l;
  }
  function mr(l, i) {
    let s = sn();
    return l = l[`__lexicalKey_${s._key}`], l !== void 0 ? Lt(l, i) : null;
  }
  function Dr(l, i) {
    for (; l != null; ) {
      let s = mr(l, i);
      if (s !== null)
        return s;
      l = yr(l);
    }
    return null;
  }
  function Wi(l) {
    let i = Object.assign({}, l._decorators);
    return l._pendingDecorators = i;
  }
  function ys(l) {
    return l.read(() => fn().getTextContent());
  }
  function Ns(l, i) {
    lr(l, () => {
      var s = Er();
      if (!s.isEmpty())
        if (i === "root")
          fn().markDirty();
        else {
          s = s._nodeMap;
          for (let [, g] of s)
            g.markDirty();
        }
    }, l._pendingEditorState === null ? { tag: "history-merge" } : void 0);
  }
  function fn() {
    return Er()._nodeMap.get("root");
  }
  function _r(l) {
    Xn();
    let i = Er();
    l !== null && (l.dirty = !0, l.setCachedNodes(null)), i._selection = l;
  }
  function ti(l) {
    var i = sn(), s;
    e: {
      for (s = l; s != null; ) {
        let g = s[`__lexicalKey_${i._key}`];
        if (g !== void 0) {
          s = g;
          break e;
        }
        s = yr(s);
      }
      s = null;
    }
    return s === null ? (i = i.getRootElement(), l === i ? Lt("root") : null) : Lt(s);
  }
  function Cs(l) {
    return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(l);
  }
  function ye(l) {
    let i = [];
    for (; l !== null; )
      i.push(l), l = l._parentEditor;
    return i;
  }
  function Ge() {
    return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 5);
  }
  function et(l, i, s) {
    if (i = $r(i._window), i !== null) {
      var g = i.anchorNode, { anchorOffset: C, focusOffset: S } = i;
      if (g !== null && (i = g.nodeType === 3 ? g.nodeValue : null, g = Dr(g), i !== null && dt(g))) {
        if (i === Te && s) {
          let R = s.length;
          i = s, S = C = R;
        }
        i !== null && yt(g, i, C, S, l);
      }
    }
  }
  function yt(l, i, s, g, C) {
    let S = l;
    if (S.isAttached() && (C || !S.isDirty())) {
      let Se = S.isComposing(), Fe = i;
      if ((Se || C) && i[i.length - 1] === Te && (Fe = i.slice(0, -1)), i = S.getTextContent(), C || Fe !== i)
        if (Fe === "")
          if (Mt(null), b || Z || ae)
            S.remove();
          else {
            let Ke = sn();
            setTimeout(() => {
              Ke.update(() => {
                S.isAttached() && S.remove();
              });
            }, 20);
          }
        else {
          C = S.getParent(), i = Vi();
          var R = S.getTextContentSize(), X = Ut(), me = S.getKey();
          S.isToken() || X !== null && me === X && !Se || St(i) && (C !== null && !C.canInsertTextBefore() && i.anchor.offset === 0 || i.anchor.key === l.__key && i.anchor.offset === 0 && !S.canInsertTextBefore() || i.focus.key === l.__key && i.focus.offset === R && !S.canInsertTextAfter()) ? S.markDirty() : (l = Vt(), St(l) && s !== null && g !== null && (l.setTextNodeRange(S, s, S, g), S.isSegmented() && (s = S.getTextContent(), s = Wn(s), S.replace(s), S = s)), S.setTextContent(Fe));
        }
    }
  }
  function Ft(l, i) {
    if (i.isSegmented())
      return !0;
    if (!l.isCollapsed())
      return !1;
    l = l.anchor.offset;
    let s = i.getParentOrThrow(), g = i.isToken();
    return l === 0 ? ((l = !i.canInsertTextBefore() || !s.canInsertTextBefore() || g) || (i = i.getPreviousSibling(), l = (dt(i) || Ze(i) && i.isInline()) && !i.canInsertTextAfter()), l) : l === i.getTextContentSize() ? !i.canInsertTextAfter() || !s.canInsertTextAfter() || g : !1;
  }
  function Wt(l, i) {
    l.__lexicalClassNameCache === void 0 && (l.__lexicalClassNameCache = {});
    let s = l.__lexicalClassNameCache, g = s[i];
    return g !== void 0 ? g : (l = l[i], typeof l == "string" ? (l = l.split(" "), s[i] = l) : l);
  }
  function Pt(l, i, s, g, C) {
    s.size !== 0 && (s = g.__type, g = g.__key, i = i.get(s), i === void 0 && Y(33, s), s = i.klass, i = l.get(s), i === void 0 && (i = /* @__PURE__ */ new Map(), l.set(s, i)), l = i.get(g), s = l === "destroyed" && C === "created", (l === void 0 || s) && i.set(g, s ? "updated" : C));
  }
  function It(l, i, s) {
    let g = l.getParent(), C = s;
    return g !== null && (i && s === 0 ? (C = l.getIndexWithinParent(), l = g) : i || s !== l.getChildrenSize() || (C = l.getIndexWithinParent() + 1, l = g)), l.getChildAtIndex(i ? C - 1 : C);
  }
  function mn(l, i) {
    var s = l.offset;
    return l.type === "element" ? (l = l.getNode(), It(l, i, s)) : (l = l.getNode(), i && s === 0 || !i && s === l.getTextContentSize() ? (s = i ? l.getPreviousSibling() : l.getNextSibling(), s === null ? It(l.getParentOrThrow(), i, l.getIndexWithinParent() + (i ? 0 : 1)) : s) : null);
  }
  function on(l) {
    return l = (l = Zn(l).event) && l.inputType, l === "insertFromPaste" || l === "insertFromPasteAsQuotation";
  }
  function en(l) {
    return !nr(l) && !l.isLastChild() && !l.isInline();
  }
  function Bn(l, i) {
    return l = l._keyToDOMMap.get(i), l === void 0 && Y(75, i), l;
  }
  function yr(l) {
    return l = l.assignedSlot || l.parentElement, l !== null && l.nodeType === 11 ? l.host : l;
  }
  function Ni(l, i) {
    for (l = l.getParent(); l !== null; ) {
      if (l.is(i))
        return !0;
      l = l.getParent();
    }
    return !1;
  }
  function Zn(l) {
    return l = l._window, l === null && Y(78), l;
  }
  function ul(l) {
    for (l = l.getParentOrThrow(); l !== null && !ni(l); )
      l = l.getParentOrThrow();
    return l;
  }
  function ni(l) {
    return nr(l) || Ze(l) && l.isShadowRoot();
  }
  function dl(l) {
    return l = l.constructor.clone(l), Dt(l, null), l;
  }
  function Ki(l) {
    var i = sn();
    let s = l.constructor.getType();
    return i = i._nodes.get(s), i === void 0 && Y(97), i = i.replace, i !== null ? (i = i(l), i instanceof l.constructor || Y(98), i) : l;
  }
  function Es(l, i) {
    l = l.getParent(), !nr(l) || Ze(i) || ln(i) || Y(99);
  }
  function fl(l) {
    return (ln(l) || Ze(l) && !l.canBeEmpty()) && !l.isInline();
  }
  function hl(l, i, s) {
    s.style.removeProperty("caret-color"), i._blockCursorElement = null, i = l.parentElement, i !== null && i.removeChild(l);
  }
  function $r(l) {
    return U ? (l || window).getSelection() : null;
  }
  function Ts(l, i) {
    for (; l !== fn() && l != null; ) {
      if (i(l))
        return l;
      l = l.getParent();
    }
    return null;
  }
  function wc(l) {
    let i = [], s = [l];
    for (; 0 < s.length; ) {
      let g = s.pop();
      g === void 0 && Y(112), Ze(g) && s.unshift(...g.getChildren()), g !== l && i.push(g);
    }
    return i;
  }
  function lo(l) {
    return l.nodeType === 1;
  }
  function ri(l) {
    if (ln(l) && !l.isInline())
      return !0;
    if (!Ze(l) || ni(l))
      return !1;
    var i = l.getFirstChild();
    return i = i === null || vi(i) || dt(i) || i.isInline(), !l.isInline() && l.canBeEmpty() !== !1 && i;
  }
  function Io(l, i) {
    for (; l !== null && l.getParent() !== null && !i(l); )
      l = l.getParentOrThrow();
    return i(l) ? l : null;
  }
  function aa(l, i, s, g, C, S) {
    for (l = l.getFirstChild(); l !== null; ) {
      let R = l.__key;
      l.__parent === i && (Ze(l) && aa(l, R, s, g, C, S), s.has(R) || S.delete(R), C.push(R)), l = l.getNextSibling();
    }
  }
  function gl(l, i, s, g) {
    l = l._nodeMap, i = i._nodeMap;
    let C = [];
    for (let [S] of g) {
      let R = i.get(S);
      R === void 0 || R.isAttached() || (Ze(R) && aa(R, S, l, i, C, g), l.has(S) || g.delete(S), C.push(S));
    }
    for (let S of C)
      i.delete(S);
    for (let S of s)
      g = i.get(S), g === void 0 || g.isAttached() || (l.has(S) || s.delete(S), i.delete(S));
  }
  let On = "", Ln = "", Rr = "", Ci, Hn, Po, Ei = !1, ao = !1, xs, _n = null, Fr, En, Ti, Nr, vs, co;
  function Ss(l, i) {
    let s = Ti.get(l);
    if (i !== null) {
      let g = ml(l);
      g.parentNode === i && i.removeChild(g);
    }
    Nr.has(l) || Hn._keyToDOMMap.delete(l), Ze(s) && (l = $o(s, Ti), Jn(l, 0, l.length - 1, null)), s !== void 0 && Pt(co, Po, xs, s, "destroyed");
  }
  function Jn(l, i, s, g) {
    for (; i <= s; ++i) {
      let C = l[i];
      C !== void 0 && Ss(C, g);
    }
  }
  function xi(l, i) {
    l.setProperty("text-align", i);
  }
  function br(l, i) {
    var s = Ci.theme.indent;
    if (typeof s == "string") {
      let g = l.classList.contains(s);
      0 < i && !g ? l.classList.add(s) : 1 > i && g && l.classList.remove(s);
    }
    s = getComputedStyle(l).getPropertyValue("--lexical-indent-base-value") || "40px", l.style.setProperty("padding-inline-start", i === 0 ? "" : `calc(${i} * ${s})`);
  }
  function ca(l, i) {
    l = l.style, i === 0 ? xi(l, "") : i === 1 ? xi(l, "left") : i === 2 ? xi(l, "center") : i === 3 ? xi(l, "right") : i === 4 ? xi(l, "justify") : i === 5 ? xi(l, "start") : i === 6 && xi(l, "end");
  }
  function ii(l, i, s) {
    let g = Nr.get(l);
    g === void 0 && Y(60);
    let C = g.createDOM(Ci, Hn);
    var S = Hn._keyToDOMMap;
    if (C["__lexicalKey_" + Hn._key] = l, S.set(l, C), dt(g) ? C.setAttribute("data-lexical-text", "true") : ln(g) && C.setAttribute("data-lexical-decorator", "true"), Ze(g)) {
      if (l = g.__indent, S = g.__size, l !== 0 && br(C, l), S !== 0) {
        --S, l = $o(g, Nr);
        var R = Ln;
        Ln = "", ws(l, g, 0, S, C, null), Os(g, C), Ln = R;
      }
      l = g.__format, l !== 0 && ca(C, l), g.isInline() || pl(null, g, C), en(g) && (On += `

`, Rr += `

`);
    } else
      S = g.getTextContent(), ln(g) ? (R = g.decorate(Hn, Ci), R !== null && Ds(l, R), C.contentEditable = "false") : dt(g) && (g.isDirectionless() || (Ln += S)), On += S, Rr += S;
    return i !== null && (s != null ? i.insertBefore(C, s) : (s = i.__lexicalLineBreak, s != null ? i.insertBefore(C, s) : i.appendChild(C))), Pt(co, Po, xs, g, "created"), C;
  }
  function ws(l, i, s, g, C, S) {
    let R = On;
    for (On = ""; s <= g; ++s)
      ii(l[s], C, S);
    en(i) && (On += `

`), C.__lexicalTextContent = On, On = R + On;
  }
  function ua(l, i) {
    return l = i.get(l), vi(l) || ln(l) && l.isInline();
  }
  function pl(l, i, s) {
    l = l !== null && (l.__size === 0 || ua(l.__last, Ti)), i = i.__size === 0 || ua(i.__last, Nr), l ? i || (i = s.__lexicalLineBreak, i != null && s.removeChild(i), s.__lexicalLineBreak = null) : i && (i = document.createElement("br"), s.__lexicalLineBreak = i, s.appendChild(i));
  }
  function Os(l, i) {
    var s = i.__lexicalDir;
    if (i.__lexicalDirTextContent !== Ln || s !== _n) {
      let S = Ln === "";
      if (S)
        var g = _n;
      else
        g = Ln, g = ze.test(g) ? "rtl" : oe.test(g) ? "ltr" : null;
      if (g !== s) {
        let R = i.classList, X = Ci.theme;
        var C = s !== null ? X[s] : void 0;
        let me = g !== null ? X[g] : void 0;
        C !== void 0 && (typeof C == "string" && (C = C.split(" "), C = X[s] = C), R.remove(...C)), g === null || S && g === "ltr" ? i.removeAttribute("dir") : (me !== void 0 && (typeof me == "string" && (s = me.split(" "), me = X[g] = s), me !== void 0 && R.add(...me)), i.dir = g), ao || (l.getWritable().__dir = g);
      }
      _n = g, i.__lexicalDirTextContent = Ln, i.__lexicalDir = g;
    }
  }
  function $o(l, i) {
    let s = [];
    for (l = l.__first; l !== null; ) {
      let g = i.get(l);
      g === void 0 && Y(101), s.push(l), l = g.__next;
    }
    return s;
  }
  function uo(l, i) {
    var s = Ti.get(l), g = Nr.get(l);
    s !== void 0 && g !== void 0 || Y(61);
    var C = Ei || En.has(l) || Fr.has(l);
    let S = Bn(Hn, l);
    if (s === g && !C)
      return Ze(s) ? (g = S.__lexicalTextContent, g !== void 0 && (On += g, Rr += g), g = S.__lexicalDirTextContent, g !== void 0 && (Ln += g)) : (g = s.getTextContent(), dt(s) && !s.isDirectionless() && (Ln += g), Rr += g, On += g), S;
    if (s !== g && C && Pt(co, Po, xs, g, "updated"), g.updateDOM(s, S, Ci))
      return g = ii(l, null, null), i === null && Y(62), i.replaceChild(g, S), Ss(l, null), g;
    if (Ze(s) && Ze(g)) {
      if (l = g.__indent, l !== s.__indent && br(S, l), l = g.__format, l !== s.__format && ca(S, l), C) {
        l = g, C = Ln, Ln = "", i = On;
        var R = s.__size, X = l.__size;
        if (On = "", R === 1 && X === 1) {
          var me = s.__first, Se = l.__first;
          if (me === Se)
            uo(me, S);
          else {
            var Fe = ml(me);
            Se = ii(Se, null, null), S.replaceChild(Se, Fe), Ss(me, null);
          }
        } else {
          Se = $o(s, Ti);
          var Ke = $o(l, Nr);
          if (R === 0)
            X !== 0 && ws(Ke, l, 0, X - 1, S, null);
          else if (X === 0)
            R !== 0 && (me = S.__lexicalLineBreak == null, Jn(Se, 0, R - 1, me ? null : S), me && (S.textContent = ""));
          else {
            var Le = Se;
            Se = Ke, Ke = R - 1, R = X - 1;
            let Xe = S.firstChild, at = 0;
            for (X = 0; at <= Ke && X <= R; ) {
              var Re = Le[at];
              let Et = Se[X];
              if (Re === Et)
                Xe = Fo(uo(Et, S)), at++, X++;
              else {
                me === void 0 && (me = new Set(Le)), Fe === void 0 && (Fe = new Set(Se));
                let Rt = Fe.has(Re), hn = me.has(Et);
                Rt ? (hn ? (Re = Bn(Hn, Et), Re === Xe ? Xe = Fo(uo(Et, S)) : (Xe != null ? S.insertBefore(Re, Xe) : S.appendChild(Re), uo(Et, S)), at++) : ii(Et, S, Xe), X++) : (Xe = Fo(ml(Re)), Ss(Re, S), at++);
              }
            }
            me = at > Ke, Fe = X > R, me && !Fe ? (me = Se[R + 1], me = me === void 0 ? null : Hn.getElementByKey(me), ws(Se, l, X, R, S, me)) : Fe && !me && Jn(Le, at, Ke, S);
          }
        }
        en(l) && (On += `

`), S.__lexicalTextContent = On, On = i + On, Os(l, S), Ln = C, nr(g) || g.isInline() || pl(s, g, S);
      }
      en(g) && (On += `

`, Rr += `

`);
    } else
      s = g.getTextContent(), ln(g) ? (C = g.decorate(
        Hn,
        Ci
      ), C !== null && Ds(l, C)) : dt(g) && !g.isDirectionless() && (Ln += s), On += s, Rr += s;
    return !ao && nr(g) && g.__cachedText !== Rr && (g = g.getWritable(), g.__cachedText = Rr), S;
  }
  function Ds(l, i) {
    let s = Hn._pendingDecorators, g = Hn._decorators;
    if (s === null) {
      if (g[l] === i)
        return;
      s = Wi(Hn);
    }
    s[l] = i;
  }
  function Fo(l) {
    return l = l.nextSibling, l !== null && l === Hn._blockCursorElement && (l = l.nextSibling), l;
  }
  function ml(l) {
    let i = vs.get(l);
    return i === void 0 && Y(75, l), i;
  }
  let oi = Object.freeze({}), _l = [["keydown", Ac], ["pointerdown", Dc], ["compositionstart", bc], ["compositionend", Mc], ["input", Rc], ["click", Oc], ["cut", oi], ["copy", oi], ["dragstart", oi], ["dragover", oi], ["dragend", oi], ["paste", oi], ["focus", oi], ["blur", oi], ["drop", oi]];
  y && _l.push(["beforeinput", (l, i) => Na(l, i)]);
  let Bo = 0, da = 0, fa = 0, fo = null, Ho = 0, yl = !1, Nl = !1, Wo = !1, Ko = !1, ha = [0, "", 0, "root", 0];
  function ga(l, i, s, g, C) {
    let S = l.anchor, R = l.focus, X = S.getNode();
    var me = sn();
    let Se = $r(me._window), Fe = Se !== null ? Se.anchorNode : null, Ke = S.key;
    me = me.getElementByKey(Ke);
    let Le = s.length;
    return Ke !== R.key || !dt(X) || (!C && (!y || fa < g + 50) || X.isDirty() && 2 > Le || Cs(s)) && S.offset !== R.offset && !X.isComposing() || Ct(X) || X.isDirty() && 1 < Le || (C || !y) && me !== null && !X.isComposing() && Fe !== vt(me) || Se !== null && i !== null && (!i.collapsed || i.startContainer !== Se.anchorNode || i.startOffset !== Se.anchorOffset) || X.getFormat() !== l.format || X.getStyle() !== l.style || Ft(l, X);
  }
  function pa(l, i) {
    return l !== null && l.nodeValue !== null && l.nodeType === 3 && i !== 0 && i !== l.nodeValue.length;
  }
  function ma(l, i, s) {
    let { anchorNode: g, anchorOffset: C, focusNode: S, focusOffset: R } = l;
    yl && (yl = !1, pa(g, C) && pa(S, R)) || lr(i, () => {
      if (!s)
        _r(null);
      else if (nt(i, g, S)) {
        var X = Vt();
        if (St(X)) {
          var me = X.anchor, Se = me.getNode();
          if (X.isCollapsed()) {
            l.type === "Range" && l.anchorNode === l.focusNode && (X.dirty = !0);
            var Fe = Zn(i).event;
            Fe = Fe ? Fe.timeStamp : performance.now();
            let [Le, Re, Xe, at, Et] = ha;
            var Ke = fn();
            Ke = i.isComposing() === !1 && Ke.getTextContent() === "", Fe < Et + 200 && me.offset === Xe && me.key === at ? (X.format = Le, X.style = Re) : me.type === "text" ? (X.format = Se.getFormat(), X.style = Se.getStyle()) : me.type !== "element" || Ke || (X.format = 0, X.style = "");
          } else {
            me = 255, Se = !1, Fe = X.getNodes(), Ke = Fe.length;
            for (let Le = 0; Le < Ke; Le++) {
              let Re = Fe[Le];
              if (dt(Re) && (Se = !0, me &= Re.getFormat(), me === 0))
                break;
            }
            X.format = Se ? me : 0;
          }
        }
        it(i, t, void 0);
      }
    });
  }
  function Oc(l, i) {
    lr(i, () => {
      let s = Vt();
      var g = $r(i._window);
      let C = Vi();
      if (g)
        if (St(s)) {
          let R = s.anchor;
          var S = R.getNode();
          R.type === "element" && R.offset === 0 && s.isCollapsed() && !nr(S) && fn().getChildrenSize() === 1 && S.getTopLevelElementOrThrow().isEmpty() && C !== null && s.is(C) ? (g.removeAllRanges(), s.dirty = !0) : l.detail !== 3 || s.isCollapsed() || (g = s.focus.getNode(), S !== g && (Ze(S) ? S.select(0) : S.getParentOrThrow().select(0)));
        } else
          l.pointerType === "touch" && (S = g.anchorNode, S !== null && (S = S.nodeType, S === 1 || S === 3)) && (g = Kn(C, g, i), _r(g));
      it(i, e, l);
    });
  }
  function Dc(l, i) {
    let s = l.target;
    l = l.pointerType, s instanceof Node && l !== "touch" && lr(i, () => {
      ln(Dr(s)) || (Nl = !0);
    });
  }
  function _a(l) {
    return l.getTargetRanges ? (l = l.getTargetRanges(), l.length === 0 ? null : l[0]) : null;
  }
  function ya(l, i) {
    return l !== i || Ze(l) || Ze(i) || !l.isToken() || !i.isToken();
  }
  function Na(l, i) {
    let s = l.inputType, g = _a(l);
    s === "deleteCompositionText" || m && on(i) || s !== "insertCompositionText" && lr(i, () => {
      let C = Vt();
      if (s === "deleteContentBackward") {
        if (C === null) {
          var S = Vi();
          if (!St(S))
            return;
          _r(S.clone());
        }
        if (St(C)) {
          ce && Mt(C.anchor.key), da === 229 && l.timeStamp < Bo + 30 && i.isComposing() && C.anchor.key === C.focus.key ? (Mt(null), Bo = 0, setTimeout(() => {
            lr(i, () => {
              Mt(null);
            });
          }, 30), St(C) && (S = C.anchor.getNode(), S.markDirty(), C.format = S.getFormat(), C.style = S.getStyle()), 1 >= C.anchor.getNode().getTextContent().length && (l.preventDefault(), it(i, n, !0))) : (l.preventDefault(), it(i, n, !0));
          return;
        }
      }
      if (St(C)) {
        S = l.data, fo !== null && et(!1, i, fo), C.dirty && fo === null || !C.isCollapsed() || nr(C.anchor.getNode()) || g === null || C.applyDOMRange(g), fo = null;
        var R = C.focus, X = C.anchor.getNode();
        if (R = R.getNode(), s === "insertText" || s === "insertTranspose")
          S === `
` ? (l.preventDefault(), it(i, r, !1)) : S === `

` ? (l.preventDefault(), it(i, c, void 0)) : S == null && l.dataTransfer ? (S = l.dataTransfer.getData("text/plain"), l.preventDefault(), C.insertRawText(S)) : S != null && ga(C, g, S, l.timeStamp, !0) ? (l.preventDefault(), it(i, d, S)) : fo = S, fa = l.timeStamp;
        else
          switch (l.preventDefault(), s) {
            case "insertFromYank":
            case "insertFromDrop":
            case "insertReplacementText":
              it(i, d, l);
              break;
            case "insertFromComposition":
              Mt(null), it(i, d, l);
              break;
            case "insertLineBreak":
              Mt(null), it(i, r, !1);
              break;
            case "insertParagraph":
              Mt(null), Wo && !Z ? (Wo = !1, it(i, r, !1)) : it(i, c, void 0);
              break;
            case "insertFromPaste":
            case "insertFromPasteAsQuotation":
              it(i, h, l);
              break;
            case "deleteByComposition":
              ya(X, R) && it(i, p, l);
              break;
            case "deleteByDrag":
            case "deleteByCut":
              it(i, p, l);
              break;
            case "deleteContent":
              it(i, n, !1);
              break;
            case "deleteWordBackward":
              it(i, N, !0);
              break;
            case "deleteWordForward":
              it(i, N, !1);
              break;
            case "deleteHardLineBackward":
            case "deleteSoftLineBackward":
              it(i, x, !0);
              break;
            case "deleteContentForward":
            case "deleteHardLineForward":
            case "deleteSoftLineForward":
              it(i, x, !1);
              break;
            case "formatStrikeThrough":
              it(i, v, "strikethrough");
              break;
            case "formatBold":
              it(i, v, "bold");
              break;
            case "formatItalic":
              it(i, v, "italic");
              break;
            case "formatUnderline":
              it(i, v, "underline");
              break;
            case "historyUndo":
              it(i, O, void 0);
              break;
            case "historyRedo":
              it(i, M, void 0);
          }
      }
    });
  }
  function Rc(l, i) {
    l.stopPropagation(), lr(i, () => {
      var s = Vt(), g = l.data, C = _a(l);
      if (g != null && St(s) && ga(s, C, g, l.timeStamp, !1)) {
        Ko && (Cl(i, g), Ko = !1);
        var S = s.anchor, R = S.getNode();
        if (C = $r(i._window), C === null)
          return;
        let X = S.offset;
        (S = y && !s.isCollapsed() && dt(R) && C.anchorNode !== null) && (R = R.getTextContent().slice(0, X) + g + R.getTextContent().slice(X + s.focus.offset), C = C.anchorNode, S = R === (C.nodeType === 3 ? C.nodeValue : null)), S || it(i, d, g), g = g.length, m && 1 < g && l.inputType === "insertCompositionText" && !i.isComposing() && (s.anchor.offset -= g), b || Z || ae || !i.isComposing() || (Bo = 0, Mt(null));
      } else
        et(!1, i, g !== null ? g : void 0), Ko && (Cl(i, g || void 0), Ko = !1);
      Xn(), s = sn(), Oe(s);
    }), fo = null;
  }
  function bc(l, i) {
    lr(i, () => {
      let s = Vt();
      if (St(s) && !i.isComposing()) {
        let g = s.anchor, C = s.anchor.getNode();
        Mt(g.key), (l.timeStamp < Bo + 30 || g.type === "element" || !s.isCollapsed() || C.getFormat() !== s.format || C.getStyle() !== s.style) && it(i, d, Ae);
      }
    });
  }
  function Cl(l, i) {
    var s = l._compositionKey;
    if (Mt(null), s !== null && i != null) {
      if (i === "") {
        i = Lt(s), l = vt(l.getElementByKey(s)), l !== null && l.nodeValue !== null && dt(i) && yt(i, l.nodeValue, null, null, !0);
        return;
      }
      if (i[i.length - 1] === `
` && (s = Vt(), St(s))) {
        i = s.focus, s.anchor.set(i.key, i.offset, i.type), it(l, H, null);
        return;
      }
    }
    et(!0, l, i);
  }
  function Mc(l, i) {
    m ? Ko = !0 : lr(i, () => {
      Cl(i, l.data);
    });
  }
  function Ac(l, i) {
    if (Bo = l.timeStamp, da = l.keyCode, !i.isComposing()) {
      var { keyCode: s, shiftKey: g, ctrlKey: C, metaKey: S, altKey: R } = l;
      if (!it(i, A, l)) {
        if (s !== 39 || C || S || R)
          if (s !== 39 || R || g || !C && !S)
            if (s !== 37 || C || S || R)
              if (s !== 37 || R || g || !C && !S)
                if (s !== 38 || C || S)
                  if (s !== 40 || C || S)
                    if (s === 13 && g)
                      Wo = !0, it(i, H, l);
                    else if (s === 32)
                      it(i, z, l);
                    else if (k && C && s === 79)
                      l.preventDefault(), Wo = !0, it(i, r, !0);
                    else if (s !== 13 || g) {
                      var X = k ? R || S ? !1 : s === 8 || s === 72 && C : C || R || S ? !1 : s === 8;
                      X ? s === 8 ? it(i, te, l) : (l.preventDefault(), it(i, n, !0)) : s === 27 ? it(
                        i,
                        re,
                        l
                      ) : (X = k ? g || R || S ? !1 : s === 46 || s === 68 && C : C || R || S ? !1 : s === 46, X ? s === 46 ? it(i, ue, l) : (l.preventDefault(), it(i, n, !1)) : s === 8 && (k ? R : C) ? (l.preventDefault(), it(i, N, !0)) : s === 46 && (k ? R : C) ? (l.preventDefault(), it(i, N, !1)) : k && S && s === 8 ? (l.preventDefault(), it(i, x, !0)) : k && S && s === 46 ? (l.preventDefault(), it(i, x, !1)) : s === 66 && !R && (k ? S : C) ? (l.preventDefault(), it(i, v, "bold")) : s === 85 && !R && (k ? S : C) ? (l.preventDefault(), it(i, v, "underline")) : s === 73 && !R && (k ? S : C) ? (l.preventDefault(), it(i, v, "italic")) : s !== 9 || R || C || S ? s === 90 && !g && (k ? S : C) ? (l.preventDefault(), it(i, O, void 0)) : (X = k ? s === 90 && S && g : s === 89 && C || s === 90 && C && g, X ? (l.preventDefault(), it(i, M, void 0)) : Vo(i._editorState._selection) ? (X = g ? !1 : s === 67 ? k ? S : C : !1, X ? (l.preventDefault(), it(i, J, l)) : (X = g ? !1 : s === 88 ? k ? S : C : !1, X ? (l.preventDefault(), it(i, ee, l)) : s === 65 && (k ? S : C) && (l.preventDefault(), it(i, F, l)))) : !m && s === 65 && (k ? S : C) && (l.preventDefault(), it(i, F, l))) : it(i, q, l));
                    } else
                      Wo = !1, it(i, H, l);
                  else
                    it(i, W, l);
                else
                  it(i, $, l);
              else
                it(i, K, l);
            else
              it(i, P, l);
          else
            it(i, w, l);
        else
          it(i, T, l);
        (C || g || R || S) && it(i, ne, l);
      }
    }
  }
  function Ca(l) {
    let i = l.__lexicalEventHandles;
    return i === void 0 && (i = [], l.__lexicalEventHandles = i), i;
  }
  let ho = /* @__PURE__ */ new Map();
  function Ea(l) {
    l = l.target;
    let i = $r(l == null ? null : l.nodeType === 9 ? l.defaultView : l.ownerDocument.defaultView);
    if (i !== null) {
      var s = mt(i.anchorNode);
      if (s !== null) {
        Nl && (Nl = !1, lr(s, () => {
          var R = Vi(), X = i.anchorNode;
          X !== null && (X = X.nodeType, X === 1 || X === 3) && (R = Kn(R, i, s), _r(R));
        })), l = ye(s), l = l[l.length - 1];
        var g = l._key, C = ho.get(g), S = C || l;
        S !== s && ma(i, S, !1), ma(i, s, !0), s !== l ? ho.set(g, s) : C && ho.delete(g);
      }
    }
  }
  function kc(l, i) {
    Ho === 0 && l.ownerDocument.addEventListener("selectionchange", Ea), Ho++, l.__lexicalEditor = i;
    let s = Ca(l);
    for (let g = 0; g < _l.length; g++) {
      let [C, S] = _l[g], R = typeof S == "function" ? (X) => {
        X._lexicalHandled !== !0 && (X._lexicalHandled = !0, i.isEditable() && S(X, i));
      } : (X) => {
        if (X._lexicalHandled !== !0 && (X._lexicalHandled = !0, i.isEditable()))
          switch (C) {
            case "cut":
              return it(i, ee, X);
            case "copy":
              return it(i, J, X);
            case "paste":
              return it(i, h, X);
            case "dragstart":
              return it(i, j, X);
            case "dragover":
              return it(i, _e, X);
            case "dragend":
              return it(
                i,
                pe,
                X
              );
            case "focus":
              return it(i, D, X);
            case "blur":
              return it(i, V, X);
            case "drop":
              return it(i, G, X);
          }
      };
      l.addEventListener(C, R), s.push(() => {
        l.removeEventListener(C, R);
      });
    }
  }
  function El(l, i, s) {
    Xn();
    var g = l.__key;
    let C = l.getParent();
    if (C !== null) {
      var S = Vt();
      if (St(S) && Ze(l)) {
        var { anchor: R, focus: X } = S, me = R.getNode(), Se = X.getNode();
        Ni(me, l) && R.set(l.__key, 0, "element"), Ni(Se, l) && X.set(l.__key, 0, "element");
      }
      if (me = S, Se = !1, St(me) && i) {
        S = me.anchor;
        let Fe = me.focus;
        S.key === g && (yo(S, l, C, l.getPreviousSibling(), l.getNextSibling()), Se = !0), Fe.key === g && (yo(Fe, l, C, l.getPreviousSibling(), l.getNextSibling()), Se = !0);
      } else
        Vo(me) && i && l.isSelected() && l.selectPrevious();
      St(me) && i && !Se ? (g = l.getIndexWithinParent(), Tt(l), _o(me, C, g, -1)) : Tt(l), s || ni(C) || C.canBeEmpty() || !C.isEmpty() || El(C, i), i && nr(C) && C.isEmpty() && C.selectEnd();
    }
  }
  class si {
    static getType() {
      Y(64, this.name);
    }
    static clone() {
      Y(65, this.name);
    }
    constructor(i) {
      this.__type = this.constructor.getType(), this.__next = this.__prev = this.__parent = null, Dt(this, i);
    }
    getType() {
      return this.__type;
    }
    isAttached() {
      for (var i = this.__key; i !== null; ) {
        if (i === "root")
          return !0;
        if (i = Lt(i), i === null)
          break;
        i = i.__parent;
      }
      return !1;
    }
    isSelected(i) {
      if (i = i || Vt(), i == null)
        return !1;
      let s = i.getNodes().some((g) => g.__key === this.__key);
      return dt(this) ? s : St(i) && i.anchor.type === "element" && i.focus.type === "element" && i.anchor.key === i.focus.key && i.anchor.offset === i.focus.offset ? !1 : s;
    }
    getKey() {
      return this.__key;
    }
    getIndexWithinParent() {
      var i = this.getParent();
      if (i === null)
        return -1;
      i = i.getFirstChild();
      let s = 0;
      for (; i !== null; ) {
        if (this.is(i))
          return s;
        s++, i = i.getNextSibling();
      }
      return -1;
    }
    getParent() {
      let i = this.getLatest().__parent;
      return i === null ? null : Lt(i);
    }
    getParentOrThrow() {
      let i = this.getParent();
      return i === null && Y(66, this.__key), i;
    }
    getTopLevelElement() {
      let i = this;
      for (; i !== null; ) {
        let s = i.getParent();
        if (ni(s))
          return i;
        i = s;
      }
      return null;
    }
    getTopLevelElementOrThrow() {
      let i = this.getTopLevelElement();
      return i === null && Y(67, this.__key), i;
    }
    getParents() {
      let i = [], s = this.getParent();
      for (; s !== null; )
        i.push(s), s = s.getParent();
      return i;
    }
    getParentKeys() {
      let i = [], s = this.getParent();
      for (; s !== null; )
        i.push(s.__key), s = s.getParent();
      return i;
    }
    getPreviousSibling() {
      let i = this.getLatest().__prev;
      return i === null ? null : Lt(i);
    }
    getPreviousSiblings() {
      let i = [];
      var s = this.getParent();
      if (s === null)
        return i;
      for (s = s.getFirstChild(); s !== null && !s.is(this); )
        i.push(s), s = s.getNextSibling();
      return i;
    }
    getNextSibling() {
      let i = this.getLatest().__next;
      return i === null ? null : Lt(i);
    }
    getNextSiblings() {
      let i = [], s = this.getNextSibling();
      for (; s !== null; )
        i.push(s), s = s.getNextSibling();
      return i;
    }
    getCommonAncestor(i) {
      let s = this.getParents();
      var g = i.getParents();
      Ze(this) && s.unshift(this), Ze(i) && g.unshift(i), i = s.length;
      var C = g.length;
      if (i === 0 || C === 0 || s[i - 1] !== g[C - 1])
        return null;
      for (g = new Set(g), C = 0; C < i; C++) {
        let S = s[C];
        if (g.has(S))
          return S;
      }
      return null;
    }
    is(i) {
      return i == null ? !1 : this.__key === i.__key;
    }
    isBefore(i) {
      if (this === i)
        return !1;
      if (i.isParentOf(this))
        return !0;
      if (this.isParentOf(i))
        return !1;
      var s = this.getCommonAncestor(i);
      let g = this;
      for (; ; ) {
        var C = g.getParentOrThrow();
        if (C === s) {
          C = g.getIndexWithinParent();
          break;
        }
        g = C;
      }
      for (g = i; ; ) {
        if (i = g.getParentOrThrow(), i === s) {
          s = g.getIndexWithinParent();
          break;
        }
        g = i;
      }
      return C < s;
    }
    isParentOf(i) {
      let s = this.__key;
      if (s === i.__key)
        return !1;
      for (; i !== null; ) {
        if (i.__key === s)
          return !0;
        i = i.getParent();
      }
      return !1;
    }
    getNodesBetween(i) {
      let s = this.isBefore(i), g = [], C = /* @__PURE__ */ new Set();
      for (var S = this; ; ) {
        var R = S.__key;
        if (C.has(R) || (C.add(R), g.push(S)), S === i)
          break;
        if (R = Ze(S) ? s ? S.getFirstChild() : S.getLastChild() : null, R !== null)
          S = R;
        else if (R = s ? S.getNextSibling() : S.getPreviousSibling(), R !== null)
          S = R;
        else {
          if (S = S.getParentOrThrow(), C.has(S.__key) || g.push(S), S === i)
            break;
          R = S;
          do
            R === null && Y(68), S = s ? R.getNextSibling() : R.getPreviousSibling(), R = R.getParent(), R !== null && (S !== null || C.has(R.__key) || g.push(R));
          while (S === null);
        }
      }
      return s || g.reverse(), g;
    }
    isDirty() {
      let i = sn()._dirtyLeaves;
      return i !== null && i.has(this.__key);
    }
    getLatest() {
      let i = Lt(this.__key);
      return i === null && Y(113), i;
    }
    getWritable() {
      Xn();
      var i = Er(), s = sn();
      i = i._nodeMap;
      let g = this.__key, C = this.getLatest(), S = C.__parent;
      s = s._cloneNotNeeded;
      var R = Vt();
      return wl(R) && R.setCachedNodes(null), s.has(g) ? (Xt(C), C) : (R = C.constructor.clone(C), R.__parent = S, R.__next = C.__next, R.__prev = C.__prev, Ze(C) && Ze(R) ? (R.__first = C.__first, R.__last = C.__last, R.__size = C.__size, R.__indent = C.__indent, R.__format = C.__format, R.__dir = C.__dir) : dt(C) && dt(R) && (R.__format = C.__format, R.__style = C.__style, R.__mode = C.__mode, R.__detail = C.__detail), s.add(g), R.__key = g, Xt(R), i.set(g, R), R);
    }
    getTextContent() {
      return "";
    }
    getTextContentSize() {
      return this.getTextContent().length;
    }
    createDOM() {
      Y(70);
    }
    updateDOM() {
      Y(71);
    }
    exportDOM(i) {
      return { element: this.createDOM(i._config, i) };
    }
    exportJSON() {
      Y(72);
    }
    static importJSON() {
      Y(18, this.name);
    }
    static transform() {
      return null;
    }
    remove(i) {
      El(this, !0, i);
    }
    replace(i, s) {
      Xn();
      var g = Vt();
      g !== null && (g = g.clone()), Es(this, i);
      let C = this.getLatest(), S = this.__key, R = i.__key, X = i.getWritable();
      i = this.getParentOrThrow().getWritable();
      let me = i.__size;
      Tt(X);
      let Se = C.getPreviousSibling(), Fe = C.getNextSibling(), Ke = C.__prev, Le = C.__next, Re = C.__parent;
      return El(C, !1, !0), Se === null ? i.__first = R : Se.getWritable().__next = R, X.__prev = Ke, Fe === null ? i.__last = R : Fe.getWritable().__prev = R, X.__next = Le, X.__parent = Re, i.__size = me, s && this.getChildren().forEach((Xe) => {
        X.append(Xe);
      }), St(g) && (_r(g), s = g.anchor, g = g.focus, s.key === S && vl(s, X), g.key === S && vl(g, X)), Ut() === S && Mt(R), X;
    }
    insertAfter(i, s = !0) {
      Xn(), Es(this, i);
      var g = this.getWritable();
      let C = i.getWritable();
      var S = C.getParent();
      let R = Vt();
      var X = !1, me = !1;
      if (S !== null) {
        var Se = i.getIndexWithinParent();
        Tt(C), St(R) && (me = S.__key, X = R.anchor, S = R.focus, X = X.type === "element" && X.key === me && X.offset === Se + 1, me = S.type === "element" && S.key === me && S.offset === Se + 1);
      }
      S = this.getNextSibling(), Se = this.getParentOrThrow().getWritable();
      let Fe = C.__key, Ke = g.__next;
      return S === null ? Se.__last = Fe : S.getWritable().__prev = Fe, Se.__size++, g.__next = Fe, C.__next = Ke, C.__prev = g.__key, C.__parent = g.__parent, s && St(R) && (s = this.getIndexWithinParent(), _o(R, Se, s + 1), g = Se.__key, X && R.anchor.set(g, s + 2, "element"), me && R.focus.set(g, s + 2, "element")), i;
    }
    insertBefore(i, s = !0) {
      Xn(), Es(this, i);
      var g = this.getWritable();
      let C = i.getWritable(), S = C.__key;
      Tt(C);
      let R = this.getPreviousSibling(), X = this.getParentOrThrow().getWritable(), me = g.__prev, Se = this.getIndexWithinParent();
      return R === null ? X.__first = S : R.getWritable().__next = S, X.__size++, g.__prev = S, C.__prev = me, C.__next = g.__key, C.__parent = g.__parent, g = Vt(), s && St(g) && (s = this.getParentOrThrow(), _o(g, s, Se)), i;
    }
    isParentRequired() {
      return !1;
    }
    createParentElementNode() {
      return ar();
    }
    selectStart() {
      return this.selectPrevious();
    }
    selectEnd() {
      return this.selectNext(
        0,
        0
      );
    }
    selectPrevious(i, s) {
      Xn();
      let g = this.getPreviousSibling(), C = this.getParentOrThrow();
      return g === null ? C.select(0, 0) : Ze(g) ? g.select() : dt(g) ? g.select(i, s) : (i = g.getIndexWithinParent() + 1, C.select(i, i));
    }
    selectNext(i, s) {
      Xn();
      let g = this.getNextSibling(), C = this.getParentOrThrow();
      return g === null ? C.select() : Ze(g) ? g.select(0, 0) : dt(g) ? g.select(i, s) : (i = g.getIndexWithinParent(), C.select(i, i));
    }
    markDirty() {
      this.getWritable();
    }
  }
  function Ta(l, i, s) {
    s = s || i.getParentOrThrow().getLastChild();
    let g = i;
    for (i = [i]; g !== s; ) {
      if (!g.getNextSibling())
        throw Error("insertRangeAfter: lastToInsert must be a later sibling of firstToInsert");
      g = g.getNextSibling(), i.push(g);
    }
    for (let C of i)
      l = l.insertAfter(C);
  }
  class Br extends si {
    static getType() {
      return "linebreak";
    }
    static clone(i) {
      return new Br(i.__key);
    }
    constructor(i) {
      super(i);
    }
    getTextContent() {
      return `
`;
    }
    createDOM() {
      return document.createElement("br");
    }
    updateDOM() {
      return !1;
    }
    static importDOM() {
      return { br: (i) => {
        let s = i.parentElement, g, C;
        return s !== null && ((g = s.firstChild) === i || g.nextSibling === i && g.nodeType === 3 && (g.textContent || "").match(/^( |\t|\r?\n)+$/) !== null) && ((C = s.lastChild) === i || C.previousSibling === i && C.nodeType === 3 && (C.textContent || "").match(/^( |\t|\r?\n)+$/) !== null) ? null : { conversion: Lc, priority: 0 };
      } };
    }
    static importJSON() {
      return Hr();
    }
    exportJSON() {
      return { type: "linebreak", version: 1 };
    }
  }
  function Lc() {
    return { node: Hr() };
  }
  function Hr() {
    return Ki(new Br());
  }
  function vi(l) {
    return l instanceof Br;
  }
  function Tl(l, i) {
    return i & 16 ? "code" : i & 128 ? "mark" : i & 32 ? "sub" : i & 64 ? "sup" : null;
  }
  function Ui(l, i) {
    return i & 1 ? "strong" : i & 2 ? "em" : "span";
  }
  function Uo(l, i, s, g, C) {
    l = g.classList, g = Wt(C, "base"), g !== void 0 && l.add(...g), g = Wt(C, "underlineStrikethrough");
    let S = !1, R = i & 8 && i & 4;
    var X = s & 8 && s & 4;
    g !== void 0 && (X ? (S = !0, R || l.add(...g)) : R && l.remove(...g));
    for (let me in ie)
      X = ie[me], g = Wt(C, me), g !== void 0 && (s & X ? !S || me !== "underline" && me !== "strikethrough" ? (!(i & X) || R && me === "underline" || me === "strikethrough") && l.add(...g) : i & X && l.remove(...g) : i & X && l.remove(...g));
  }
  function xl(l, i, s) {
    let g = i.firstChild;
    if (s = s.isComposing(), l += s ? Te : "", g == null)
      i.textContent = l;
    else if (i = g.nodeValue, i !== l)
      if (s || m) {
        s = i.length;
        let C = l.length, S = 0, R = 0;
        for (; S < s && S < C && i[S] === l[S]; )
          S++;
        for (; R + S < s && R + S < C && i[s - R - 1] === l[C - R - 1]; )
          R++;
        l = [S, s - S - R, l.slice(S, C - R)];
        let [X, me, Se] = l;
        me !== 0 && g.deleteData(X, me), g.insertData(X, Se);
      } else
        g.nodeValue = l;
  }
  function zo(l, i) {
    return i = document.createElement(i), i.appendChild(l), i;
  }
  class li extends si {
    static getType() {
      return "text";
    }
    static clone(i) {
      return new li(i.__text, i.__key);
    }
    constructor(i, s) {
      super(s), this.__text = i, this.__format = 0, this.__style = "", this.__detail = this.__mode = 0;
    }
    getFormat() {
      return this.getLatest().__format;
    }
    getDetail() {
      return this.getLatest().__detail;
    }
    getMode() {
      let i = this.getLatest();
      return Ye[i.__mode];
    }
    getStyle() {
      return this.getLatest().__style;
    }
    isToken() {
      return this.getLatest().__mode === 1;
    }
    isComposing() {
      return this.__key === Ut();
    }
    isSegmented() {
      return this.getLatest().__mode === 2;
    }
    isDirectionless() {
      return (this.getLatest().__detail & 1) !== 0;
    }
    isUnmergeable() {
      return (this.getLatest().__detail & 2) !== 0;
    }
    hasFormat(i) {
      return i = ie[i], (this.getFormat() & i) !== 0;
    }
    isSimpleText() {
      return this.__type === "text" && this.__mode === 0;
    }
    getTextContent() {
      return this.getLatest().__text;
    }
    getFormatFlags(i, s) {
      let g = this.getLatest().__format;
      return wt(g, i, s);
    }
    createDOM(i) {
      var s = this.__format, g = Tl(this, s);
      let C = Ui(this, s), S = document.createElement(g === null ? C : g), R = S;
      return this.hasFormat("code") && S.setAttribute("spellcheck", "false"), g !== null && (R = document.createElement(C), S.appendChild(R)), g = R, xl(this.__text, g, this), i = i.theme.text, i !== void 0 && Uo(C, 0, s, g, i), s = this.__style, s !== "" && (S.style.cssText = s), S;
    }
    updateDOM(i, s, g) {
      let C = this.__text;
      var S = i.__format, R = this.__format, X = Tl(this, S);
      let me = Tl(this, R);
      var Se = Ui(this, S);
      let Fe = Ui(this, R);
      return (X === null ? Se : X) !== (me === null ? Fe : me) ? !0 : X === me && Se !== Fe ? (S = s.firstChild, S == null && Y(48), i = X = document.createElement(Fe), xl(C, i, this), g = g.theme.text, g !== void 0 && Uo(Fe, 0, R, i, g), s.replaceChild(X, S), !1) : (Se = s, me !== null && X !== null && (Se = s.firstChild, Se == null && Y(49)), xl(C, Se, this), g = g.theme.text, g !== void 0 && S !== R && Uo(Fe, S, R, Se, g), R = this.__style, i.__style !== R && (s.style.cssText = R), !1);
    }
    static importDOM() {
      return {
        "#text": () => ({ conversion: Rs, priority: 0 }),
        b: () => ({ conversion: ot, priority: 0 }),
        code: () => ({ conversion: Si, priority: 0 }),
        em: () => ({ conversion: Si, priority: 0 }),
        i: () => ({ conversion: Si, priority: 0 }),
        s: () => ({ conversion: Si, priority: 0 }),
        span: () => ({ conversion: xa, priority: 0 }),
        strong: () => ({ conversion: Si, priority: 0 }),
        sub: () => ({ conversion: Si, priority: 0 }),
        sup: () => ({ conversion: Si, priority: 0 }),
        u: () => ({ conversion: Si, priority: 0 })
      };
    }
    static importJSON(i) {
      let s = Wn(i.text);
      return s.setFormat(i.format), s.setDetail(i.detail), s.setMode(i.mode), s.setStyle(i.style), s;
    }
    exportDOM(i) {
      return { element: i } = super.exportDOM(i), i !== null && lo(i) || Y(132), i.style.whiteSpace = "pre-wrap", this.hasFormat("bold") && (i = zo(i, "b")), this.hasFormat("italic") && (i = zo(i, "i")), this.hasFormat("strikethrough") && (i = zo(i, "s")), this.hasFormat("underline") && (i = zo(i, "u")), { element: i };
    }
    exportJSON() {
      return {
        detail: this.getDetail(),
        format: this.getFormat(),
        mode: this.getMode(),
        style: this.getStyle(),
        text: this.getTextContent(),
        type: "text",
        version: 1
      };
    }
    selectionTransform() {
    }
    setFormat(i) {
      let s = this.getWritable();
      return s.__format = typeof i == "string" ? ie[i] : i, s;
    }
    setDetail(i) {
      let s = this.getWritable();
      return s.__detail = typeof i == "string" ? de[i] : i, s;
    }
    setStyle(i) {
      let s = this.getWritable();
      return s.__style = i, s;
    }
    toggleFormat(i) {
      let s = this.getFormat();
      return i = wt(s, i, null), this.setFormat(i);
    }
    toggleDirectionless() {
      let i = this.getWritable();
      return i.__detail ^= 1, i;
    }
    toggleUnmergeable() {
      let i = this.getWritable();
      return i.__detail ^= 2, i;
    }
    setMode(i) {
      if (i = Be[i], this.__mode === i)
        return this;
      let s = this.getWritable();
      return s.__mode = i, s;
    }
    setTextContent(i) {
      if (this.__text === i)
        return this;
      let s = this.getWritable();
      return s.__text = i, s;
    }
    select(i, s) {
      Xn();
      let g = Vt();
      var C = this.getTextContent();
      let S = this.__key;
      if (typeof C == "string" ? (C = C.length, i === void 0 && (i = C), s === void 0 && (s = C)) : s = i = 0, St(g))
        C = Ut(), C !== g.anchor.key && C !== g.focus.key || Mt(S), g.setTextNodeRange(this, i, this, s);
      else
        return Vn(S, i, S, s, "text", "text");
      return g;
    }
    selectStart() {
      return this.select(0, 0);
    }
    selectEnd() {
      let i = this.getTextContentSize();
      return this.select(i, i);
    }
    spliceText(i, s, g, C) {
      let S = this.getWritable(), R = S.__text, X = g.length, me = i;
      0 > me && (me = X + me, 0 > me && (me = 0));
      let Se = Vt();
      return C && St(Se) && (i += X, Se.setTextNodeRange(S, i, S, i)), s = R.slice(0, me) + g + R.slice(me + s), S.__text = s, S;
    }
    canInsertTextBefore() {
      return !0;
    }
    canInsertTextAfter() {
      return !0;
    }
    splitText(...i) {
      Xn();
      var s = this.getLatest(), g = s.getTextContent(), C = s.__key, S = Ut(), R = new Set(i);
      i = [];
      for (var X = g.length, me = "", Se = 0; Se < X; Se++)
        me !== "" && R.has(Se) && (i.push(me), me = ""), me += g[Se];
      if (me !== "" && i.push(me), R = i.length, R === 0)
        return [];
      if (i[0] === g)
        return [s];
      var Fe = i[0];
      g = s.getParentOrThrow(), Se = s.getFormat();
      let Ke = s.getStyle(), Le = s.__detail;
      X = !1, s.isSegmented() ? (me = Wn(Fe), me.__format = Se, me.__style = Ke, me.__detail = Le, X = !0) : (me = s.getWritable(), me.__text = Fe), s = Vt(), me = [me], Fe = Fe.length;
      for (let at = 1; at < R; at++) {
        var Re = i[at], Xe = Re.length;
        Re = Wn(Re).getWritable(), Re.__format = Se, Re.__style = Ke, Re.__detail = Le;
        let Et = Re.__key;
        if (Xe = Fe + Xe, St(s)) {
          let Rt = s.anchor, hn = s.focus;
          Rt.key === C && Rt.type === "text" && Rt.offset > Fe && Rt.offset <= Xe && (Rt.key = Et, Rt.offset -= Fe, s.dirty = !0), hn.key === C && hn.type === "text" && hn.offset > Fe && hn.offset <= Xe && (hn.key = Et, hn.offset -= Fe, s.dirty = !0);
        }
        S === C && Mt(Et), Fe = Xe, me.push(Re);
      }
      return C = this.getPreviousSibling(), S = this.getNextSibling(), C !== null && Xt(C), S !== null && Xt(S), C = g.getWritable(), S = this.getIndexWithinParent(), X ? (C.splice(S, 0, me), this.remove()) : C.splice(S, 1, me), St(s) && _o(s, g, S, R - 1), me;
    }
    mergeWithSibling(i) {
      var s = i === this.getPreviousSibling();
      s || i === this.getNextSibling() || Y(50);
      var g = this.__key;
      let C = i.__key, S = this.__text, R = S.length;
      Ut() === C && Mt(g);
      let X = Vt();
      if (St(X)) {
        let me = X.anchor, Se = X.focus;
        me !== null && me.key === C && (Ls(me, s, g, i, R), X.dirty = !0), Se !== null && Se.key === C && (Ls(Se, s, g, i, R), X.dirty = !0);
      }
      return g = i.__text, this.setTextContent(s ? g + S : S + g), s = this.getWritable(), i.remove(), s;
    }
    isTextEntity() {
      return !1;
    }
  }
  function xa(l) {
    let i = l.style.fontWeight === "700", s = l.style.textDecoration === "line-through", g = l.style.fontStyle === "italic", C = l.style.textDecoration === "underline", S = l.style.verticalAlign;
    return { forChild: (R) => (dt(R) && (i && R.toggleFormat("bold"), s && R.toggleFormat("strikethrough"), g && R.toggleFormat("italic"), C && R.toggleFormat("underline"), S === "sub" && R.toggleFormat("subscript"), S === "super" && R.toggleFormat("superscript")), R), node: null };
  }
  function ot(l) {
    let i = l.style.fontWeight === "normal";
    return { forChild: (s) => (dt(s) && !i && s.toggleFormat("bold"), s), node: null };
  }
  let Go = /* @__PURE__ */ new WeakMap();
  function Rs(l) {
    l.parentElement === null && Y(129);
    for (var i = l.textContent || "", s, g = l.parentNode, C = [l]; g !== null && (s = Go.get(g)) === void 0 && !(g.nodeName === "PRE" || g.nodeType === 1 && g.style !== void 0 && g.style.whiteSpace !== void 0 && g.style.whiteSpace.startsWith("pre")); )
      C.push(g), g = g.parentNode;
    for (s = s === void 0 ? g : s, g = 0; g < C.length; g++)
      Go.set(C[g], s);
    if (s !== null) {
      for (i = i.split(/(\r?\n|\t)/), l = [], C = i.length, s = 0; s < C; s++)
        g = i[s], g === `
` || g === `\r
` ? l.push(Hr()) : g === "	" ? l.push(zi()) : g !== "" && l.push(Wn(g));
      return { node: l };
    }
    if (i = i.replace(/\r/g, "").replace(/[ \t\n]+/g, " "), i === "")
      return { node: null };
    if (i[0] === " ") {
      for (C = l, s = !0; C !== null && (C = va(C, !1)) !== null; )
        if (g = C.textContent || "", 0 < g.length) {
          /[ \t\n]$/.test(g) && (i = i.slice(1)), s = !1;
          break;
        }
      s && (i = i.slice(1));
    }
    if (i[i.length - 1] === " ") {
      for (C = !0; l !== null && (l = va(l, !0)) !== null; )
        if (0 < (l.textContent || "").replace(/^( |\t|\r?\n)+/, "").length) {
          C = !1;
          break;
        }
      C && (i = i.slice(0, i.length - 1));
    }
    return i === "" ? { node: null } : { node: Wn(i) };
  }
  let bs = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/, "i");
  function va(l, i) {
    for (; ; ) {
      for (var s = void 0; (s = i ? l.nextSibling : l.previousSibling) === null; )
        if (l = l.parentElement, l === null)
          return null;
      if (l = s, l.nodeType === 1 && (s = l.style.display, s === "" && l.nodeName.match(bs) === null || s !== "" && !s.startsWith("inline")))
        return null;
      for (; (s = i ? l.firstChild : l.lastChild) !== null; )
        l = s;
      if (l.nodeType === 3)
        return l;
      if (l.nodeName === "BR")
        return null;
    }
  }
  let Ic = { code: "code", em: "italic", i: "italic", s: "strikethrough", strong: "bold", sub: "subscript", sup: "superscript", u: "underline" };
  function Si(l) {
    let i = Ic[l.nodeName.toLowerCase()];
    return i === void 0 ? { node: null } : { forChild: (s) => (dt(s) && !s.hasFormat(i) && s.toggleFormat(i), s), node: null };
  }
  function Wn(l = "") {
    return Ki(new li(l));
  }
  function dt(l) {
    return l instanceof li;
  }
  class go extends li {
    static getType() {
      return "tab";
    }
    static clone(i) {
      let s = new go(i.__key);
      return s.__text = i.__text, s.__format = i.__format, s.__style = i.__style, s;
    }
    constructor(i) {
      super("	", i), this.__detail = 2;
    }
    static importDOM() {
      return null;
    }
    static importJSON(i) {
      let s = zi();
      return s.setFormat(i.format), s.setStyle(i.style), s;
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "tab", version: 1 };
    }
    setTextContent() {
      Y(126);
    }
    setDetail() {
      Y(127);
    }
    setMode() {
      Y(128);
    }
    canInsertTextBefore() {
      return !1;
    }
    canInsertTextAfter() {
      return !1;
    }
  }
  function zi() {
    return Ki(new go());
  }
  function Sa(l) {
    return l instanceof go;
  }
  class Mr {
    constructor(i, s, g) {
      this._selection = null, this.key = i, this.offset = s, this.type = g;
    }
    is(i) {
      return this.key === i.key && this.offset === i.offset && this.type === i.type;
    }
    isBefore(i) {
      let s = this.getNode(), g = i.getNode(), C = this.offset;
      if (i = i.offset, Ze(s)) {
        var S = s.getDescendantByIndex(C);
        s = S ?? s;
      }
      return Ze(g) && (S = g.getDescendantByIndex(i), g = S ?? g), s === g ? C < i : s.isBefore(g);
    }
    getNode() {
      let i = Lt(this.key);
      return i === null && Y(20), i;
    }
    set(i, s, g) {
      let C = this._selection, S = this.key;
      this.key = i, this.offset = s, this.type = g, ci() || (Ut() === S && Mt(i), C !== null && (C.setCachedNodes(null), C.dirty = !0));
    }
  }
  function Wr(l, i) {
    let s = i.__key, g = l.offset, C = "element";
    if (dt(i))
      C = "text", i = i.getTextContentSize(), g > i && (g = i);
    else if (!Ze(i)) {
      var S = i.getNextSibling();
      dt(S) ? (s = S.__key, g = 0, C = "text") : (S = i.getParent()) && (s = S.__key, g = i.getIndexWithinParent() + 1);
    }
    l.set(s, g, C);
  }
  function vl(l, i) {
    if (Ze(i)) {
      let s = i.getLastDescendant();
      Ze(s) || dt(s) ? Wr(l, s) : Wr(l, i);
    } else
      Wr(l, i);
  }
  function po(l, i, s, g) {
    let C = l.getNode(), S = C.getChildAtIndex(l.offset), R = Wn(), X = nr(C) ? ar().append(R) : R;
    R.setFormat(s), R.setStyle(g), S === null ? C.append(X) : S.insertBefore(X), l.is(i) && i.set(R.__key, 0, "text"), l.set(R.__key, 0, "text");
  }
  function Kr(l, i, s, g) {
    l.key = i, l.offset = s, l.type = g;
  }
  class Sl {
    constructor(i, s) {
      this.anchor = i, this.focus = s, i._selection = this, s._selection = this, this._cachedNodes = null, this.dirty = !1;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(i) {
      this._cachedNodes = i;
    }
    is(i) {
      return wl(i) ? this.anchor.is(i.anchor) && this.focus.is(i.focus) : !1;
    }
    isCollapsed() {
      return !1;
    }
    extract() {
      return this.getNodes();
    }
    isBackward() {
      return this.focus.isBefore(this.anchor);
    }
    getCharacterOffsets() {
      return Yi(this);
    }
  }
  class mo {
    constructor(i) {
      this.dirty = !1, this._nodes = i, this._cachedNodes = null;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(i) {
      this._cachedNodes = i;
    }
    is(i) {
      if (!Vo(i))
        return !1;
      let s = this._nodes, g = i._nodes;
      return s.size === g.size && Array.from(s).every((C) => g.has(C));
    }
    add(i) {
      this.dirty = !0, this._nodes.add(i), this._cachedNodes = null;
    }
    delete(i) {
      this.dirty = !0, this._nodes.delete(i), this._cachedNodes = null;
    }
    clear() {
      this.dirty = !0, this._nodes.clear(), this._cachedNodes = null;
    }
    has(i) {
      return this._nodes.has(i);
    }
    clone() {
      return new mo(new Set(this._nodes));
    }
    extract() {
      return this.getNodes();
    }
    insertRawText() {
    }
    insertText() {
    }
    insertNodes(i) {
      let s = this.getNodes(), g = s.length;
      var C = s[g - 1];
      if (dt(C))
        C = C.select();
      else {
        let S = C.getIndexWithinParent() + 1;
        C = C.getParentOrThrow().select(S, S);
      }
      for (C.insertNodes(i), i = 0; i < g; i++)
        s[i].remove();
    }
    getNodes() {
      var i = this._cachedNodes;
      if (i !== null)
        return i;
      var s = this._nodes;
      i = [];
      for (let g of s)
        s = Lt(g), s !== null && i.push(s);
      return ci() || (this._cachedNodes = i), i;
    }
    getTextContent() {
      let i = this.getNodes(), s = "";
      for (let g = 0; g < i.length; g++)
        s += i[g].getTextContent();
      return s;
    }
  }
  function St(l) {
    return l instanceof Gi;
  }
  function wl(l) {
    return l instanceof Sl;
  }
  function Cr(l) {
    let [i, , s] = ai(l);
    l = s.getChildren();
    let g = l.length;
    var C = l[0].getChildren().length;
    let S = Array(g);
    for (var R = 0; R < g; R++)
      S[R] = Array(C);
    for (C = 0; C < g; C++) {
      R = l[C].getChildren();
      let X = 0;
      for (let me = 0; me < R.length; me++) {
        for (; S[C][X]; )
          X++;
        let Se = R[me], Fe = Se.__rowSpan || 1, Ke = Se.__colSpan || 1;
        for (let Le = 0; Le < Fe; Le++)
          for (let Re = 0; Re < Ke; Re++)
            S[C + Le][X + Re] = Se;
        if (i === Se)
          return { colSpan: Ke, columnIndex: X, rowIndex: C, rowSpan: Fe };
        X += Ke;
      }
    }
    return null;
  }
  class Ms extends Sl {
    constructor(i, s, g) {
      super(s, g), this.gridKey = i;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(i) {
      this._cachedNodes = i;
    }
    is(i) {
      return Yo(i) ? this.gridKey === i.gridKey && this.anchor.is(i.anchor) && this.focus.is(i.focus) : !1;
    }
    set(i, s, g) {
      this.dirty = !0, this.gridKey = i, this.anchor.key = s, this.focus.key = g, this._cachedNodes = null;
    }
    clone() {
      return new Ms(this.gridKey, this.anchor, this.focus);
    }
    isCollapsed() {
      return !1;
    }
    extract() {
      return this.getNodes();
    }
    insertRawText() {
    }
    insertText() {
    }
    insertNodes(i) {
      let s = this.focus.getNode();
      Qe(s.select(0, s.getChildrenSize())).insertNodes(i);
    }
    getShape() {
      var i = Lt(this.anchor.key);
      if (Tr(i) || Y(103), i = Cr(i), i === null)
        throw Error("getCellRect: expected to find AnchorNode");
      var s = Lt(this.focus.key);
      Tr(s) || Y(104);
      let g = Cr(s);
      if (g === null)
        throw Error("getCellRect: expected to find focusCellNode");
      s = Math.min(i.columnIndex, g.columnIndex);
      let C = Math.max(i.columnIndex, g.columnIndex), S = Math.min(i.rowIndex, g.rowIndex);
      return i = Math.max(i.rowIndex, g.rowIndex), { fromX: Math.min(s, C), fromY: Math.min(
        S,
        i
      ), toX: Math.max(s, C), toY: Math.max(S, i) };
    }
    getNodes() {
      function i(Et) {
        let { cell: Rt, startColumn: hn, startRow: cr } = Et;
        Se = Math.min(Se, hn), Fe = Math.min(Fe, cr), Ke = Math.max(Ke, hn + Rt.__colSpan - 1), Le = Math.max(Le, cr + Rt.__rowSpan - 1);
      }
      var s = this._cachedNodes;
      if (s !== null)
        return s;
      var g = this.anchor.getNode();
      s = this.focus.getNode();
      var C = Ts(g, Tr);
      g = Ts(s, Tr), Tr(C) || Y(103), Tr(g) || Y(104), s = C.getParent(), Qo(s) || Y(105), s = s.getParent(), Fs(s) || Y(106);
      var S = g.getParents()[1];
      if (S !== s) {
        if (s.isParentOf(g)) {
          if (s = S.getParent(), s == null)
            throw Error("Expected focusCellParent to have a parent");
          this.set(this.gridKey, g.getKey(), s.getKey());
        } else {
          if (s = s.getParent(), s == null)
            throw Error("Expected gridParent to have a parent");
          this.set(this.gridKey, s.getKey(), g.getKey());
        }
        return this.getNodes();
      }
      let [R, X, me] = Oi(s, C, g), Se = Math.min(X.startColumn, me.startColumn), Fe = Math.min(X.startRow, me.startRow), Ke = Math.max(X.startColumn + X.cell.__colSpan - 1, me.startColumn + me.cell.__colSpan - 1), Le = Math.max(X.startRow + X.cell.__rowSpan - 1, me.startRow + me.cell.__rowSpan - 1);
      g = Se, C = Fe, S = Se;
      for (var Re = Fe; Se < g || Fe < C || Ke > S || Le > Re; ) {
        if (Se < g) {
          var Xe = Re - C;
          --g;
          for (var at = 0; at <= Xe; at++)
            i(R[C + at][g]);
        }
        if (Fe < C)
          for (Xe = S - g, --C, at = 0; at <= Xe; at++)
            i(R[C][g + at]);
        if (Ke > S)
          for (Xe = Re - C, S += 1, at = 0; at <= Xe; at++)
            i(R[C + at][S]);
        if (Le > Re)
          for (Xe = S - g, Re += 1, at = 0; at <= Xe; at++)
            i(R[Re][g + at]);
      }
      for (s = [s], g = null, C = Fe; C <= Le; C++)
        for (S = Se; S <= Ke; S++)
          ({ cell: Re } = R[C][S]), Xe = Re.getParent(), Qo(Xe) || Y(107), Xe !== g && s.push(Xe), s.push(Re, ...wc(Re)), g = Xe;
      return ci() || (this._cachedNodes = s), s;
    }
    getTextContent() {
      let i = this.getNodes(), s = "";
      for (let g = 0; g < i.length; g++)
        s += i[g].getTextContent();
      return s;
    }
  }
  function Yo(l) {
    return l instanceof Ms;
  }
  class Gi extends Sl {
    constructor(i, s, g, C) {
      super(i, s), this.format = g, this.style = C;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(i) {
      this._cachedNodes = i;
    }
    is(i) {
      return St(i) ? this.anchor.is(i.anchor) && this.focus.is(i.focus) && this.format === i.format && this.style === i.style : !1;
    }
    isCollapsed() {
      return this.anchor.is(this.focus);
    }
    getNodes() {
      var i = this._cachedNodes;
      if (i !== null)
        return i;
      i = this.anchor;
      var s = this.focus, g = i.isBefore(s), C = g ? i : s;
      g = g ? s : i, i = C.getNode(), s = g.getNode();
      let S = C.offset;
      return C = g.offset, Ze(i) && (g = i.getDescendantByIndex(S), i = g ?? i), Ze(s) && (g = s.getDescendantByIndex(C), g !== null && g !== i && s.getChildAtIndex(C) === g && (g = g.getPreviousSibling()), s = g ?? s), i = i.is(s) ? Ze(i) && 0 < i.getChildrenSize() ? [] : [i] : i.getNodesBetween(s), ci() || (this._cachedNodes = i), i;
    }
    setTextNodeRange(i, s, g, C) {
      Kr(this.anchor, i.__key, s, "text"), Kr(this.focus, g.__key, C, "text"), this._cachedNodes = null, this.dirty = !0;
    }
    getTextContent() {
      let i = this.getNodes();
      if (i.length === 0)
        return "";
      let s = i[0], g = i[i.length - 1], C = this.anchor, S = this.focus, R = C.isBefore(S), [X, me] = Yi(this), Se = "", Fe = !0;
      for (let Ke = 0; Ke < i.length; Ke++) {
        let Le = i[Ke];
        if (Ze(Le) && !Le.isInline())
          Fe || (Se += `
`), Fe = !Le.isEmpty();
        else if (Fe = !1, dt(Le)) {
          let Re = Le.getTextContent();
          Le === s ? Le === g ? (C.type !== "element" || S.type !== "element" || S.offset === C.offset) && (Re = X < me ? Re.slice(X, me) : Re.slice(me, X)) : Re = R ? Re.slice(X) : Re.slice(me) : Le === g && (Re = R ? Re.slice(0, me) : Re.slice(0, X)), Se += Re;
        } else
          !ln(Le) && !vi(Le) || Le === g && this.isCollapsed() || (Se += Le.getTextContent());
      }
      return Se;
    }
    applyDOMRange(i) {
      let s = sn(), g = s.getEditorState()._selection;
      if (i = Tn(i.startContainer, i.startOffset, i.endContainer, i.endOffset, s, g), i !== null) {
        var [C, S] = i;
        Kr(this.anchor, C.key, C.offset, C.type), Kr(this.focus, S.key, S.offset, S.type), this._cachedNodes = null;
      }
    }
    clone() {
      let i = this.anchor, s = this.focus;
      return new Gi(new Mr(i.key, i.offset, i.type), new Mr(s.key, s.offset, s.type), this.format, this.style);
    }
    toggleFormat(i) {
      this.format = wt(this.format, i, null), this.dirty = !0;
    }
    setStyle(i) {
      this.style = i, this.dirty = !0;
    }
    hasFormat(i) {
      return (this.format & ie[i]) !== 0;
    }
    insertRawText(i) {
      i = i.split(/(\r?\n|\t)/);
      let s = [], g = i.length;
      for (let C = 0; C < g; C++) {
        let S = i[C];
        S === `
` || S === `\r
` ? s.push(Hr()) : S === "	" ? s.push(zi()) : s.push(Wn(S));
      }
      this.insertNodes(s);
    }
    insertText(i) {
      var s = this.anchor, g = this.focus, C = this.isCollapsed() || s.isBefore(g), S = this.format, R = this.style;
      C && s.type === "element" ? po(s, g, S, R) : C || g.type !== "element" || po(g, s, S, R);
      var X = this.getNodes(), me = X.length, Se = C ? g : s;
      g = (C ? s : g).offset;
      var Fe = Se.offset;
      s = X[0], dt(s) || Y(26), C = s.getTextContent().length;
      var Ke = s.getParentOrThrow(), Le = X[me - 1];
      if (this.isCollapsed() && g === C && (s.isSegmented() || s.isToken() || !s.canInsertTextAfter() || !Ke.canInsertTextAfter() && s.getNextSibling() === null)) {
        var Re = s.getNextSibling();
        if (dt(Re) && Re.canInsertTextBefore() && !Ct(Re) || (Re = Wn(), Re.setFormat(S), Ke.canInsertTextAfter() ? s.insertAfter(Re) : Ke.insertAfter(Re)), Re.select(0, 0), s = Re, i !== "") {
          this.insertText(i);
          return;
        }
      } else if (this.isCollapsed() && g === 0 && (s.isSegmented() || s.isToken() || !s.canInsertTextBefore() || !Ke.canInsertTextBefore() && s.getPreviousSibling() === null)) {
        if (Re = s.getPreviousSibling(), (!dt(Re) || Ct(Re)) && (Re = Wn(), Re.setFormat(S), Ke.canInsertTextBefore() ? s.insertBefore(Re) : Ke.insertBefore(Re)), Re.select(), s = Re, i !== "") {
          this.insertText(i);
          return;
        }
      } else if (s.isSegmented() && g !== C)
        Ke = Wn(s.getTextContent()), Ke.setFormat(S), s.replace(Ke), s = Ke;
      else if (!(this.isCollapsed() || i === "" || (Re = Le.getParent(), Ke.canInsertTextBefore() && Ke.canInsertTextAfter() && (!Ze(Re) || Re.canInsertTextBefore() && Re.canInsertTextAfter())))) {
        this.insertText(""), Oa(this.anchor, this.focus, null), this.insertText(i);
        return;
      }
      if (me === 1)
        if (s.isToken())
          i = Wn(i), i.select(), s.replace(i);
        else {
          if (X = s.getFormat(), me = s.getStyle(), g === Fe && (X !== S || me !== R))
            if (s.getTextContent() === "")
              s.setFormat(S), s.setStyle(R);
            else {
              X = Wn(i), X.setFormat(S), X.setStyle(R), X.select(), g === 0 ? s.insertBefore(X, !1) : ([me] = s.splitText(g), me.insertAfter(X, !1)), X.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= i.length);
              return;
            }
          else if (Sa(s)) {
            i = Wn(i), i.setFormat(S), i.setStyle(R), i.select(), s.replace(i);
            return;
          }
          s = s.spliceText(g, Fe - g, i, !0), s.getTextContent() === "" ? s.remove() : this.anchor.type === "text" && (s.isComposing() ? this.anchor.offset -= i.length : (this.format = X, this.style = me));
        }
      else {
        if (S = /* @__PURE__ */ new Set([...s.getParentKeys(), ...Le.getParentKeys()]), Re = Ze(s) ? s : s.getParentOrThrow(), R = Ze(Le) ? Le : Le.getParentOrThrow(), Ke = Le, !Re.is(R) && R.isInline())
          do
            Ke = R, R = R.getParentOrThrow();
          while (R.isInline());
        if (Se.type === "text" && (Fe !== 0 || Le.getTextContent() === "") || Se.type === "element" && Le.getIndexWithinParent() < Fe)
          if (dt(Le) && !Le.isToken() && Fe !== Le.getTextContentSize()) {
            if (Le.isSegmented()) {
              var Xe = Wn(Le.getTextContent());
              Le.replace(Xe), Le = Xe;
            }
            nr(Se.getNode()) || Se.type !== "text" || (Le = Le.spliceText(0, Fe, "")), S.add(Le.__key);
          } else
            Se = Le.getParentOrThrow(), Se.canBeEmpty() || Se.getChildrenSize() !== 1 ? Le.remove() : Se.remove();
        else
          S.add(Le.__key);
        for (Se = R.getChildren(), Fe = new Set(X), Le = Re.is(R), Re = Re.isInline() && s.getNextSibling() === null ? Re : s, Xe = Se.length - 1; 0 <= Xe; Xe--) {
          let at = Se[Xe];
          if (at.is(s) || Ze(at) && at.isParentOf(s))
            break;
          at.isAttached() && (!Fe.has(at) || at.is(Ke) ? Le || Re.insertAfter(at, !1) : at.remove());
        }
        if (!Le)
          for (Se = R, R = null; Se !== null; )
            Fe = Se.getChildren(), Le = Fe.length, (Le === 0 || Fe[Le - 1].is(R)) && (S.delete(Se.__key), R = Se), Se = Se.getParent();
        for (s.isToken() ? g === C ? s.select() : (i = Wn(i), i.select(), s.replace(i)) : (s = s.spliceText(g, C - g, i, !0), s.getTextContent() === "" ? s.remove() : s.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= i.length)), i = 1; i < me; i++)
          s = X[i], S.has(s.__key) || s.remove();
      }
    }
    removeText() {
      this.insertText("");
    }
    formatText(i) {
      if (this.isCollapsed())
        this.toggleFormat(i), Mt(null);
      else {
        var s = this.getNodes(), g = [];
        for (var C of s)
          dt(C) && g.push(C);
        var S = g.length;
        if (S === 0)
          this.toggleFormat(i), Mt(null);
        else {
          C = this.anchor;
          var R = this.focus, X = this.isBackward();
          s = X ? R : C, C = X ? C : R;
          var me = 0, Se = g[0];
          if (R = s.type === "element" ? 0 : s.offset, s.type === "text" && R === Se.getTextContentSize() && (me = 1, Se = g[1], R = 0), Se != null) {
            X = Se.getFormatFlags(i, null);
            var Fe = S - 1, Ke = g[Fe];
            if (S = C.type === "text" ? C.offset : Ke.getTextContentSize(), Se.is(Ke))
              R !== S && (R === 0 && S === Se.getTextContentSize() ? Se.setFormat(X) : (i = Se.splitText(R, S), i = R === 0 ? i[0] : i[1], i.setFormat(X), s.type === "text" && s.set(i.__key, 0, "text"), C.type === "text" && C.set(i.__key, S - R, "text")), this.format = X);
            else {
              R !== 0 && ([, Se] = Se.splitText(R), R = 0), Se.setFormat(X);
              var Le = Ke.getFormatFlags(i, X);
              for (0 < S && (S !== Ke.getTextContentSize() && ([Ke] = Ke.splitText(S)), Ke.setFormat(Le)), me += 1; me < Fe; me++) {
                let Re = g[me];
                if (!Re.isToken()) {
                  let Xe = Re.getFormatFlags(i, Le);
                  Re.setFormat(Xe);
                }
              }
              s.type === "text" && s.set(Se.__key, R, "text"), C.type === "text" && C.set(Ke.__key, S, "text"), this.format = X | Le;
            }
          }
        }
      }
    }
    insertNodes(i) {
      if (i.length !== 0) {
        if (this.anchor.key === "root") {
          this.insertParagraph();
          var s = Vt();
          if (!St(s))
            throw Error("Expected RangeSelection after insertParagraph");
          return s.insertNodes(i);
        }
        var g = Io(this.anchor.getNode(), ri);
        if (s = i[i.length - 1], "__language" in g)
          if ("__language" in i[0])
            this.insertText(i[0].getTextContent());
          else {
            var C = Zo(this);
            g.splice(C, 0, i), s.selectEnd();
          }
        else if (i.some((X) => (Ze(X) || ln(X)) && !X.isInline())) {
          s = Jo(i), i = s.getLastDescendant();
          var S = s.getChildren();
          s = Ze(g) && g.isEmpty() ? null : this.insertParagraph(), C = S[S.length - 1];
          var R = S[0];
          ((X) => Ze(X) && ri(X) && !X.isEmpty() && Ze(g) && (!g.isEmpty() || "__value" in g && "__checked" in g))(R) && (g.append(...R.getChildren()), R = S[1]), R && Ta(g, R), S = Io(i, ri), s && Ze(S) && ("__value" in s && "__checked" in s || ri(C)) && (S.append(...s.getChildren()), s.remove()), Ze(g) && g.isEmpty() && g.remove(), i.selectEnd(), i = Ze(g) ? g.getLastChild() : null, vi(i) && S !== g && i.remove();
        } else
          C = Zo(this), g.splice(C, 0, i), s.selectEnd();
      }
    }
    insertParagraph() {
      if (this.anchor.key === "root") {
        var i = ar();
        return fn().splice(this.anchor.offset, 0, [i]), i.select(), i;
      }
      var s = Zo(this);
      return i = Io(this.anchor.getNode(), ri), s = (s = i.getChildAtIndex(s)) ? [s, ...s.getNextSiblings()] : [], (i = i.insertNewAfter(this, !1)) ? (i.append(...s), i.selectStart(), i) : null;
    }
    insertLineBreak(i) {
      var s = Hr();
      this.insertNodes([s]), i && (i = s.getParentOrThrow(), s = s.getIndexWithinParent(), i.select(s, s));
    }
    extract() {
      var i = this.getNodes(), s = i.length, g = s - 1, C = this.anchor;
      let S = this.focus;
      var R = i[0];
      let X = i[g], [me, Se] = Yi(this);
      return s === 0 ? [] : s === 1 ? dt(R) && !this.isCollapsed() ? (i = me > Se ? Se : me, g = R.splitText(i, me > Se ? me : Se), i = i === 0 ? g[0] : g[1], i != null ? [i] : []) : [R] : (s = C.isBefore(S), dt(R) && (C = s ? me : Se, C === R.getTextContentSize() ? i.shift() : C !== 0 && ([, R] = R.splitText(C), i[0] = R)), dt(X) && (R = X.getTextContent().length, s = s ? Se : me, s === 0 ? i.pop() : s !== R && ([X] = X.splitText(s), i[g] = X)), i);
    }
    modify(i, s, g) {
      var C = this.focus, S = this.anchor, R = i === "move", X = mn(C, s);
      if (ln(X) && !X.isIsolated())
        R && X.isKeyboardSelectable() ? (s = Ar(), s.add(X.__key), _r(s)) : (i = s ? X.getPreviousSibling() : X.getNextSibling(), dt(i) ? (X = i.__key, s = s ? i.getTextContent().length : 0, C.set(X, s, "text"), R && S.set(X, s, "text")) : (g = X.getParentOrThrow(), Ze(i) ? (g = i.__key, X = s ? i.getChildrenSize() : 0) : (X = X.getIndexWithinParent(), g = g.__key, s || X++), C.set(g, X, "element"), R && S.set(g, X, "element")));
      else if (S = sn(), C = $r(S._window)) {
        var me = S._blockCursorElement, Se = S._rootElement;
        if (Se === null || me === null || !Ze(X) || X.isInline() || X.canBeEmpty() || hl(me, S, Se), C.modify(i, s ? "backward" : "forward", g), 0 < C.rangeCount && (X = C.getRangeAt(0), S = this.anchor.getNode(), S = nr(S) ? S : ul(S), this.applyDOMRange(X), this.dirty = !0, !R)) {
          for (R = this.getNodes(), i = [], g = !1, me = 0; me < R.length; me++)
            Se = R[me], Ni(Se, S) ? i.push(Se) : g = !0;
          g && 0 < i.length && (s ? (s = i[0], Ze(s) ? s.selectStart() : s.getParentOrThrow().selectStart()) : (s = i[i.length - 1], Ze(s) ? s.selectEnd() : s.getParentOrThrow().selectEnd())), (C.anchorNode !== X.startContainer || C.anchorOffset !== X.startOffset) && (s = this.focus, R = this.anchor, C = R.key, X = R.offset, S = R.type, Kr(R, s.key, s.offset, s.type), Kr(s, C, X, S), this._cachedNodes = null);
        }
      }
    }
    deleteCharacter(i) {
      let s = this.isCollapsed();
      if (this.isCollapsed()) {
        var g = this.anchor, C = this.focus, S = g.getNode();
        if (!i && (g.type === "element" && Ze(S) && g.offset === S.getChildrenSize() || g.type === "text" && g.offset === S.getTextContentSize())) {
          var R = S.getParent();
          if (R = S.getNextSibling() || (R === null ? null : R.getNextSibling()), Ze(R) && R.isShadowRoot())
            return;
        }
        if (R = mn(C, i), ln(R) && !R.isIsolated()) {
          R.isKeyboardSelectable() && Ze(S) && S.getChildrenSize() === 0 ? (S.remove(), i = Ar(), i.add(R.__key), _r(i)) : (R.remove(), sn().dispatchCommand(t, void 0));
          return;
        }
        if (!i && Ze(R) && Ze(S) && S.isEmpty()) {
          S.remove(), R.selectStart();
          return;
        }
        if (this.modify("extend", i, "character"), this.isCollapsed()) {
          if (i && g.offset === 0 && (g.type === "element" ? g.getNode() : g.getNode().getParentOrThrow()).collapseAtStart(this))
            return;
        } else {
          if (R = C.type === "text" ? C.getNode() : null, S = g.type === "text" ? g.getNode() : null, R !== null && R.isSegmented()) {
            if (g = C.offset, C = R.getTextContentSize(), R.is(S) || i && g !== C || !i && g !== 0) {
              As(R, i, g);
              return;
            }
          } else if (S !== null && S.isSegmented() && (g = g.offset, C = S.getTextContentSize(), S.is(R) || i && g !== 0 || !i && g !== C)) {
            As(S, i, g);
            return;
          }
          if (S = this.anchor, R = this.focus, g = S.getNode(), C = R.getNode(), g === C && S.type === "text" && R.type === "text") {
            var X = S.offset, me = R.offset;
            let Se = X < me;
            C = Se ? X : me, me = Se ? me : X, X = me - 1, C !== X && (g = g.getTextContent().slice(C, me), Cs(g) || (i ? R.offset = X : S.offset = X));
          }
        }
      }
      this.removeText(), i && !s && this.isCollapsed() && this.anchor.type === "element" && this.anchor.offset === 0 && (i = this.anchor.getNode(), i.isEmpty() && nr(i.getParent()) && i.getIndexWithinParent() === 0 && i.collapseAtStart(this));
    }
    deleteLine(i) {
      this.isCollapsed() && (this.anchor.type === "text" && this.modify("extend", i, "lineboundary"), (i ? this.focus : this.anchor).offset === 0 && this.modify("extend", i, "character")), this.removeText();
    }
    deleteWord(i) {
      this.isCollapsed() && this.modify("extend", i, "word"), this.removeText();
    }
  }
  function Vo(l) {
    return l instanceof mo;
  }
  function jo(l) {
    let i = l.offset;
    return l.type === "text" ? i : (l = l.getNode(), i === l.getChildrenSize() ? l.getTextContent().length : 0);
  }
  function Yi(l) {
    let i = l.anchor;
    return l = l.focus, i.type === "element" && l.type === "element" && i.key === l.key && i.offset === l.offset ? [0, 0] : [jo(i), jo(l)];
  }
  function As(l, i, s) {
    let g = l.getTextContent().split(/(?=\s)/g), C = g.length, S = 0, R = 0;
    for (let X = 0; X < C; X++) {
      let me = g[X], Se = X === C - 1;
      if (R = S, S += me.length, i && S === s || S > s || Se) {
        g.splice(X, 1), Se && (R = void 0);
        break;
      }
    }
    i = g.join("").trim(), i === "" ? l.remove() : (l.setTextContent(i), l.select(R, R));
  }
  function wa(l, i, s, g) {
    var C = i;
    if (l.nodeType === 1) {
      let X = !1;
      var S = l.childNodes, R = S.length;
      C === R && (X = !0, C = R - 1);
      let me = S[C];
      if (R = !1, me === g._blockCursorElement ? (me = S[C + 1], R = !0) : g._blockCursorElement !== null && C--, g = ti(me), dt(g))
        C = X ? g.getTextContentSize() : 0;
      else {
        if (S = ti(l), S === null)
          return null;
        if (Ze(S) ? (l = S.getChildAtIndex(C), (i = Ze(l)) && (i = l.getParent(), i = s === null || i === null || !i.canBeEmpty() || i !== s.getNode()), i && (s = X ? l.getLastDescendant() : l.getFirstDescendant(), s === null ? (S = l, C = 0) : (l = s, S = Ze(l) ? l : l.getParentOrThrow())), dt(l) ? (g = l, S = null, C = X ? l.getTextContentSize() : 0) : l !== S && X && !R && C++) : (C = S.getIndexWithinParent(), C = i === 0 && ln(S) && ti(l) === S ? C : C + 1, S = S.getParentOrThrow()), Ze(S))
          return new Mr(S.__key, C, "element");
      }
    } else
      g = ti(l);
    return dt(g) ? new Mr(g.__key, C, "text") : null;
  }
  function Ol(l, i, s) {
    var g = l.offset, C = l.getNode();
    g === 0 ? (g = C.getPreviousSibling(), C = C.getParent(), i ? (s || !i) && g === null && Ze(C) && C.isInline() && (i = C.getPreviousSibling(), dt(i) && (l.key = i.__key, l.offset = i.getTextContent().length)) : Ze(g) && !s && g.isInline() ? (l.key = g.__key, l.offset = g.getChildrenSize(), l.type = "element") : dt(g) && (l.key = g.__key, l.offset = g.getTextContent().length)) : g === C.getTextContent().length && (g = C.getNextSibling(), C = C.getParent(), i && Ze(g) && g.isInline() ? (l.key = g.__key, l.offset = 0, l.type = "element") : (s || i) && g === null && Ze(C) && C.isInline() && !C.canInsertTextAfter() && (i = C.getNextSibling(), dt(i) && (l.key = i.__key, l.offset = 0)));
  }
  function Oa(l, i, s) {
    if (l.type === "text" && i.type === "text") {
      var g = l.isBefore(i);
      let C = l.is(i);
      Ol(l, g, C), Ol(i, !g, C), C && (i.key = l.key, i.offset = l.offset, i.type = l.type), g = sn(), g.isComposing() && g._compositionKey !== l.key && St(s) && (g = s.anchor, s = s.focus, Kr(l, g.key, g.offset, g.type), Kr(i, s.key, s.offset, s.type));
    }
  }
  function Tn(l, i, s, g, C, S) {
    return l === null || s === null || !nt(C, l, s) || (i = wa(l, i, St(S) ? S.anchor : null, C), i === null) || (g = wa(s, g, St(S) ? S.focus : null, C), g === null || i.type === "element" && g.type === "element" && (l = ti(l), s = ti(s), ln(l) && ln(s))) ? null : (Oa(i, g, S), [i, g]);
  }
  function Vn(l, i, s, g, C, S) {
    let R = Er();
    return l = new Gi(new Mr(l, i, C), new Mr(s, g, S), 0, ""), l.dirty = !0, R._selection = l;
  }
  function Ar() {
    return new mo(/* @__PURE__ */ new Set());
  }
  function wi(l) {
    let i = l.getEditorState()._selection, s = $r(l._window);
    return St(i) || i == null ? Kn(i, s, l) : i.clone();
  }
  function Kn(l, i, s) {
    var g = s._window;
    if (g === null)
      return null;
    var C = g.event, S = C ? C.type : void 0;
    g = S === "selectionchange", C = !lt && (g || S === "beforeinput" || S === "compositionstart" || S === "compositionend" || S === "click" && C && C.detail === 3 || S === "drop" || S === void 0);
    let R;
    if (!St(l) || C) {
      if (i === null)
        return null;
      if (C = i.anchorNode, S = i.focusNode, R = i.anchorOffset, i = i.focusOffset, g && St(l) && !nt(s, C, S))
        return l.clone();
    } else
      return l.clone();
    if (s = Tn(C, R, S, i, s, l), s === null)
      return null;
    let [X, me] = s;
    return new Gi(X, me, St(l) ? l.format : 0, St(l) ? l.style : "");
  }
  function Vt() {
    return Er()._selection;
  }
  function Vi() {
    return sn()._editorState._selection;
  }
  function _o(l, i, s, g = 1) {
    var C = l.anchor, S = l.focus, R = C.getNode(), X = S.getNode();
    if (i.is(R) || i.is(X)) {
      if (R = i.__key, l.isCollapsed())
        i = C.offset, (s <= i && 0 < g || s < i && 0 > g) && (s = Math.max(0, i + g), C.set(R, s, "element"), S.set(R, s, "element"), qo(l));
      else {
        let Se = l.isBackward();
        X = Se ? S : C;
        var me = X.getNode();
        C = Se ? C : S, S = C.getNode(), i.is(me) && (me = X.offset, (s <= me && 0 < g || s < me && 0 > g) && X.set(R, Math.max(0, me + g), "element")), i.is(S) && (i = C.offset, (s <= i && 0 < g || s < i && 0 > g) && C.set(R, Math.max(0, i + g), "element"));
      }
      qo(l);
    }
  }
  function qo(l) {
    var i = l.anchor, s = i.offset;
    let g = l.focus;
    var C = g.offset, S = i.getNode(), R = g.getNode();
    if (l.isCollapsed())
      Ze(S) && (R = S.getChildrenSize(), R = (C = s >= R) ? S.getChildAtIndex(R - 1) : S.getChildAtIndex(s), dt(R) && (s = 0, C && (s = R.getTextContentSize()), i.set(R.__key, s, "text"), g.set(R.__key, s, "text")));
    else {
      if (Ze(S)) {
        let X = S.getChildrenSize();
        s = (l = s >= X) ? S.getChildAtIndex(X - 1) : S.getChildAtIndex(s), dt(s) && (S = 0, l && (S = s.getTextContentSize()), i.set(s.__key, S, "text"));
      }
      Ze(R) && (s = R.getChildrenSize(), C = (i = C >= s) ? R.getChildAtIndex(s - 1) : R.getChildAtIndex(C), dt(C) && (R = 0, i && (R = C.getTextContentSize()), g.set(C.__key, R, "text")));
    }
  }
  function ks(l, i) {
    if (i = i.getEditorState()._selection, l = l._selection, St(l)) {
      var s = l.anchor;
      let g = l.focus, C;
      s.type === "text" && (C = s.getNode(), C.selectionTransform(i, l)), g.type === "text" && (s = g.getNode(), C !== s && s.selectionTransform(i, l));
    }
  }
  function yo(l, i, s, g, C) {
    let S = null, R = 0, X = null;
    g !== null ? (S = g.__key, dt(g) ? (R = g.getTextContentSize(), X = "text") : Ze(g) && (R = g.getChildrenSize(), X = "element")) : C !== null && (S = C.__key, dt(C) ? X = "text" : Ze(C) && (X = "element")), S !== null && X !== null ? l.set(S, R, X) : (R = i.getIndexWithinParent(), R === -1 && (R = s.getChildrenSize()), l.set(s.__key, R, "element"));
  }
  function Ls(l, i, s, g, C) {
    l.type === "text" ? (l.key = s, i || (l.offset += C)) : l.offset > g.getIndexWithinParent() && --l.offset;
  }
  function Oi(l, i, s) {
    let g = [], C = null, S = null;
    l = l.getChildren();
    for (let Fe = 0; Fe < l.length; Fe++) {
      var R = l[Fe];
      Qo(R) || Y(108);
      var X = R.getChildren();
      R = 0;
      for (let Ke of X) {
        for (Tr(Ke) || Y(109); g[Fe] !== void 0 && g[Fe][R] !== void 0; )
          R++;
        X = Fe;
        var me = R, Se = Ke;
        let Le = { cell: Se, startColumn: me, startRow: X }, Re = Se.__rowSpan, Xe = Se.__colSpan;
        for (let at = 0; at < Re; at++) {
          g[X + at] === void 0 && (g[X + at] = []);
          for (let Et = 0; Et < Xe; Et++)
            g[X + at][me + Et] = Le;
        }
        i.is(Se) && (C = Le), s.is(Se) && (S = Le), R += Ke.__colSpan;
      }
    }
    return C === null && Y(110), S === null && Y(111), [g, C, S];
  }
  function ai(l) {
    l instanceof $s || (l instanceof si ? (l = Ts(l, Tr), Tr(l) || Y(114)) : (l = Ts(l.getNode(), Tr), Tr(l) || Y(114)));
    let i = l.getParent();
    Qo(i) || Y(115);
    let s = i.getParent();
    return Fs(s) || Y(116), [l, i, s];
  }
  function Zo(l) {
    l.isCollapsed() || l.removeText();
    var i = l.anchor, s = i.getNode();
    if (!dt(s))
      return i.offset;
    let g = s.getParent();
    return g ? (s = s.splitText(i.offset), s.length === 0 ? 0 : (i = i.offset === 0 ? 0 : 1, s = s[0].getIndexWithinParent() + i, !g.isInline() || s === 0 ? s : ((s = g.getChildAtIndex(s)) && g.insertNewAfter(l).append(s, ...s.getNextSiblings()), g.getIndexWithinParent() + i))) : (l = ar(), fn().append(l), l.select(), 0);
  }
  function Jo(l) {
    let i = ar(), s = null;
    for (let g = 0; g < l.length; g++) {
      let C = l[g], S = vi(C);
      if (S || ln(C) && C.isInline() || Ze(C) && C.isInline() || dt(C) || C.isParentRequired()) {
        if (s === null && (s = C.createParentElementNode(), i.append(s), S))
          continue;
        s !== null && s.append(C);
      } else
        i.append(C), s = null;
    }
    return i;
  }
  let yn = null, xn = null, vn = !1, Dl = !1, No = 0, Rl = { characterData: !0, childList: !0, subtree: !0 };
  function ci() {
    return vn || yn !== null && yn._readOnly;
  }
  function Xn() {
    vn && Y(13);
  }
  function Er() {
    return yn === null && Y(15), yn;
  }
  function sn() {
    return xn === null && Y(16), xn;
  }
  function bl(l, i, s) {
    var g = i.__type;
    let C = l._nodes.get(g);
    for (C === void 0 && Y(30, g), l = s.get(g), l === void 0 && (l = Array.from(C.transforms), s.set(g, l)), s = l.length, g = 0; g < s && (l[g](i), i.isAttached()); g++)
      ;
  }
  function Da(l, i) {
    i = i._dirtyLeaves, l = l._nodeMap;
    for (let s of i)
      i = l.get(s), dt(i) && i.isAttached() && i.isSimpleText() && !i.isUnmergeable() && qe(i);
  }
  function Pc(l, i) {
    let s = i._dirtyLeaves, g = i._dirtyElements;
    l = l._nodeMap;
    let C = Ut(), S = /* @__PURE__ */ new Map();
    var R = s;
    let X = R.size;
    for (var me = g, Se = me.size; 0 < X || 0 < Se; ) {
      if (0 < X) {
        i._dirtyLeaves = /* @__PURE__ */ new Set();
        for (let Fe of R)
          R = l.get(Fe), dt(R) && R.isAttached() && R.isSimpleText() && !R.isUnmergeable() && qe(R), R !== void 0 && R !== void 0 && R.__key !== C && R.isAttached() && bl(i, R, S), s.add(Fe);
        if (R = i._dirtyLeaves, X = R.size, 0 < X) {
          No++;
          continue;
        }
      }
      i._dirtyLeaves = /* @__PURE__ */ new Set(), i._dirtyElements = /* @__PURE__ */ new Map();
      for (let Fe of me)
        me = Fe[0], Se = Fe[1], (me === "root" || Se) && (R = l.get(me), R !== void 0 && R !== void 0 && R.__key !== C && R.isAttached() && bl(i, R, S), g.set(me, Se));
      R = i._dirtyLeaves, X = R.size, me = i._dirtyElements, Se = me.size, No++;
    }
    i._dirtyLeaves = s, i._dirtyElements = g;
  }
  function Co(l, i) {
    var s = l.type, g = i.get(s);
    if (g === void 0 && Y(17, s), s = g.klass, l.type !== s.getType() && Y(18, s.name), s = s.importJSON(l), l = l.children, Ze(s) && Array.isArray(l))
      for (g = 0; g < l.length; g++) {
        let C = Co(l[g], i);
        s.append(C);
      }
    return s;
  }
  function Ra(l, i) {
    let s = yn, g = vn, C = xn;
    yn = l, vn = !0, xn = null;
    try {
      return i();
    } finally {
      yn = s, vn = g, xn = C;
    }
  }
  function kr(l, i) {
    let s = l._pendingEditorState, g = l._rootElement, C = l._headless || g === null;
    if (s !== null) {
      var S = l._editorState, R = S._selection, X = s._selection, me = l._dirtyType !== 0, Se = yn, Fe = vn, Ke = xn, Le = l._updating, Re = l._observer, Xe = null;
      if (l._pendingEditorState = null, l._editorState = s, !C && me && Re !== null) {
        xn = l, yn = s, vn = !1, l._updating = !0;
        try {
          let tn = l._dirtyType, In = l._dirtyElements, gt = l._dirtyLeaves;
          Re.disconnect();
          var at = tn, Et = In, Rt = gt;
          Ln = Rr = On = "", Ei = at === 2, _n = null, Hn = l, Ci = l._config, Po = l._nodes, xs = Hn._listeners.mutation, Fr = Et, En = Rt, Ti = S._nodeMap, Nr = s._nodeMap, ao = s._readOnly, vs = new Map(l._keyToDOMMap);
          let xr = /* @__PURE__ */ new Map();
          co = xr, uo("root", null), co = vs = Ci = Nr = Ti = En = Fr = Po = Hn = void 0, Xe = xr;
        } catch (tn) {
          if (tn instanceof Error && l._onError(tn), Dl)
            throw tn;
          Ml(l, null, g, s), Me(l), l._dirtyType = 2, Dl = !0, kr(l, S), Dl = !1;
          return;
        } finally {
          Re.observe(g, Rl), l._updating = Le, yn = Se, vn = Fe, xn = Ke;
        }
      }
      s._readOnly || (s._readOnly = !0);
      var hn = l._dirtyLeaves, cr = l._dirtyElements, zr = l._normalizedNodes, ui = l._updateTags, bi = l._deferred;
      me && (l._dirtyType = 0, l._cloneNotNeeded.clear(), l._dirtyLeaves = /* @__PURE__ */ new Set(), l._dirtyElements = /* @__PURE__ */ new Map(), l._normalizedNodes = /* @__PURE__ */ new Set(), l._updateTags = /* @__PURE__ */ new Set());
      var Mi = l._decorators, vo = l._pendingDecorators || Mi, Al = s._nodeMap, Bs;
      for (Bs in vo)
        Al.has(Bs) || (vo === Mi && (vo = Wi(l)), delete vo[Bs]);
      var Gr = C ? null : $r(l._window);
      if (l._editable && Gr !== null && (me || X === null || X.dirty)) {
        xn = l, yn = s;
        try {
          if (Re !== null && Re.disconnect(), me || X === null || X.dirty) {
            let tn = l._blockCursorElement;
            tn !== null && hl(tn, l, g);
            e: {
              let In = Gr.anchorNode, gt = Gr.focusNode, xr = Gr.anchorOffset, Zi = Gr.focusOffset, er = document.activeElement;
              if (!(ui.has("collaboration") && er !== g || er !== null && je(er)))
                if (St(X)) {
                  var So = X.anchor, Hs = X.focus, es = So.key, ji = Hs.key, $a = Bn(l, es), Fa = Bn(l, ji), ts = So.offset, Ba = Hs.offset, kl = X.format, Ll = X.style, Ha = X.isCollapsed(), wo = $a, Ws = Fa, Yr = !1;
                  if (So.type === "text") {
                    wo = vt($a);
                    let ur = So.getNode();
                    Yr = ur.getFormat() !== kl || ur.getStyle() !== Ll;
                  } else
                    St(R) && R.anchor.type === "text" && (Yr = !0);
                  if (Hs.type === "text" && (Ws = vt(Fa)), wo !== null && Ws !== null) {
                    if (Ha && (R === null || Yr || St(R) && (R.format !== kl || R.style !== Ll))) {
                      var Un = performance.now();
                      ha = [kl, Ll, ts, es, Un];
                    }
                    if (xr === ts && Zi === Ba && In === wo && gt === Ws && (Gr.type !== "Range" || !Ha) && (er !== null && g.contains(er) || g.focus({ preventScroll: !0 }), So.type !== "element"))
                      break e;
                    try {
                      Gr.setBaseAndExtent(wo, ts, Ws, Ba);
                    } catch {
                    }
                    if (!ui.has("skip-scroll-into-view") && X.isCollapsed() && g !== null && g === document.activeElement) {
                      let ur = X instanceof Gi && X.anchor.type === "element" ? wo.childNodes[ts] || null : 0 < Gr.rangeCount ? Gr.getRangeAt(0) : null;
                      if (ur !== null) {
                        let Pn;
                        if (ur instanceof Text) {
                          let tr = document.createRange();
                          tr.selectNode(ur), Pn = tr.getBoundingClientRect();
                        } else
                          Pn = ur.getBoundingClientRect();
                        let vr = g.ownerDocument, Li = vr.defaultView;
                        if (Li !== null)
                          for (var { top: ft, bottom: Ai } = Pn, qi, ns, ki = g; ki !== null; ) {
                            let tr = ki === vr.body;
                            if (tr)
                              qi = 0, ns = Zn(l).innerHeight;
                            else {
                              let Ks = ki.getBoundingClientRect();
                              qi = Ks.top, ns = Ks.bottom;
                            }
                            let Ji = 0;
                            if (ft < qi ? Ji = -(qi - ft) : Ai > ns && (Ji = Ai - ns), Ji !== 0)
                              if (tr)
                                Li.scrollBy(0, Ji);
                              else {
                                let Ks = ki.scrollTop;
                                ki.scrollTop += Ji;
                                let Ka = ki.scrollTop - Ks;
                                ft -= Ka, Ai -= Ka;
                              }
                            if (tr)
                              break;
                            ki = yr(ki);
                          }
                      }
                    }
                    yl = !0;
                  }
                } else
                  R !== null && nt(l, In, gt) && Gr.removeAllRanges();
            }
          }
          e: {
            let tn = l._blockCursorElement;
            if (St(X) && X.isCollapsed() && X.anchor.type === "element" && g.contains(document.activeElement)) {
              let In = X.anchor, gt = In.getNode(), xr = In.offset, Zi = gt.getChildrenSize(), er = !1, ur = null;
              if (xr === Zi) {
                let Pn = gt.getChildAtIndex(xr - 1);
                fl(Pn) && (er = !0);
              } else {
                let Pn = gt.getChildAtIndex(xr);
                if (fl(Pn)) {
                  let vr = Pn.getPreviousSibling();
                  (vr === null || fl(vr)) && (er = !0, ur = l.getElementByKey(Pn.__key));
                }
              }
              if (er) {
                let Pn = l.getElementByKey(gt.__key);
                if (tn === null) {
                  let vr = l._config.theme, Li = document.createElement("div");
                  Li.contentEditable = "false", Li.setAttribute("data-lexical-cursor", "true");
                  let tr = vr.blockCursor;
                  if (tr !== void 0) {
                    if (typeof tr == "string") {
                      let Ji = tr.split(" ");
                      tr = vr.blockCursor = Ji;
                    }
                    tr !== void 0 && Li.classList.add(...tr);
                  }
                  l._blockCursorElement = tn = Li;
                }
                g.style.caretColor = "transparent", ur === null ? Pn.appendChild(tn) : Pn.insertBefore(tn, ur);
                break e;
              }
            }
            tn !== null && hl(tn, l, g);
          }
          Re !== null && Re.observe(g, Rl);
        } finally {
          xn = Ke, yn = Se;
        }
      }
      if (Xe !== null) {
        var Vr = Xe;
        let tn = Array.from(l._listeners.mutation), In = tn.length;
        for (let gt = 0; gt < In; gt++) {
          let [xr, Zi] = tn[gt], er = Vr.get(Zi);
          er !== void 0 && xr(er, { dirtyLeaves: hn, prevEditorState: S, updateTags: ui });
        }
      }
      St(X) || X === null || R !== null && R.is(X) || l.dispatchCommand(t, void 0);
      var rs = l._pendingDecorators;
      rs !== null && (l._decorators = rs, l._pendingDecorators = null, Eo("decorator", l, !0, rs));
      var Wa = ys(i || S), Il = ys(s);
      if (Wa !== Il && Eo("textcontent", l, !0, Il), Eo("update", l, !0, { dirtyElements: cr, dirtyLeaves: hn, editorState: s, normalizedNodes: zr, prevEditorState: i || S, tags: ui }), l._deferred = [], bi.length !== 0) {
        let tn = l._updating;
        l._updating = !0;
        try {
          for (let In = 0; In < bi.length; In++)
            bi[In]();
        } finally {
          l._updating = tn;
        }
      }
      var di = l._updates;
      if (di.length !== 0) {
        let tn = di.shift();
        if (tn) {
          let [In, gt] = tn;
          ba(l, In, gt);
        }
      }
    }
  }
  function Eo(l, i, s, ...g) {
    let C = i._updating;
    i._updating = s;
    try {
      let S = Array.from(i._listeners[l]);
      for (l = 0; l < S.length; l++)
        S[l].apply(null, g);
    } finally {
      i._updating = C;
    }
  }
  function it(l, i, s) {
    if (l._updating === !1 || xn !== l) {
      let S = !1;
      return l.update(() => {
        S = it(l, i, s);
      }), S;
    }
    let g = ye(l);
    for (let S = 4; 0 <= S; S--)
      for (let R = 0; R < g.length; R++) {
        var C = g[R]._commands.get(i);
        if (C !== void 0 && (C = C[S], C !== void 0)) {
          C = Array.from(C);
          let X = C.length;
          for (let me = 0; me < X; me++)
            if (C[me](s, l) === !0)
              return !0;
        }
      }
    return !1;
  }
  function Is(l, i) {
    let s = l._updates;
    for (i = i || !1; s.length !== 0; ) {
      var g = s.shift();
      if (g) {
        let [C, S] = g, R;
        S !== void 0 && (g = S.onUpdate, R = S.tag, S.skipTransforms && (i = !0), g && l._deferred.push(g), R && l._updateTags.add(R)), C();
      }
    }
    return i;
  }
  function ba(l, i, s) {
    let g = l._updateTags;
    var C, S = C = !1;
    if (s !== void 0) {
      var R = s.onUpdate;
      C = s.tag, C != null && g.add(C), C = s.skipTransforms || !1, S = s.discrete || !1;
    }
    R && l._deferred.push(R), s = l._editorState, R = l._pendingEditorState;
    let X = !1;
    (R === null || R._readOnly) && (R = l._pendingEditorState = new xo(new Map((R || s)._nodeMap)), X = !0), R._flushSync = S, S = yn;
    let me = vn, Se = xn, Fe = l._updating;
    yn = R, vn = !1, l._updating = !0, xn = l;
    try {
      X && (l._headless ? s._selection != null && (R._selection = s._selection.clone()) : R._selection = wi(l));
      let Ke = l._compositionKey;
      i(), C = Is(l, C), ks(R, l), l._dirtyType !== 0 && (C ? Da(R, l) : Pc(R, l), Is(l), gl(s, R, l._dirtyLeaves, l._dirtyElements)), Ke !== l._compositionKey && (R._flushSync = !0);
      let Le = R._selection;
      if (St(Le)) {
        let Re = R._nodeMap, Xe = Le.focus.key;
        Re.get(Le.anchor.key) !== void 0 && Re.get(Xe) !== void 0 || Y(19);
      } else
        Vo(Le) && Le._nodes.size === 0 && (R._selection = null);
    } catch (Ke) {
      Ke instanceof Error && l._onError(Ke), l._pendingEditorState = s, l._dirtyType = 2, l._cloneNotNeeded.clear(), l._dirtyLeaves = /* @__PURE__ */ new Set(), l._dirtyElements.clear(), kr(l);
      return;
    } finally {
      yn = S, vn = me, xn = Se, l._updating = Fe, No = 0;
    }
    l._dirtyType !== 0 || Aa(R, l) ? R._flushSync ? (R._flushSync = !1, kr(l)) : X && Ve(() => {
      kr(l);
    }) : (R._flushSync = !1, X && (g.clear(), l._deferred = [], l._pendingEditorState = null));
  }
  function lr(l, i, s) {
    l._updating ? l._updates.push([i, s]) : ba(l, i, s);
  }
  class Ma extends si {
    constructor(i) {
      super(i);
    }
    decorate() {
      Y(47);
    }
    isIsolated() {
      return !1;
    }
    isInline() {
      return !0;
    }
    isKeyboardSelectable() {
      return !0;
    }
  }
  function ln(l) {
    return l instanceof Ma;
  }
  class Qn extends si {
    constructor(i) {
      super(i), this.__last = this.__first = null, this.__indent = this.__format = this.__size = 0, this.__dir = null;
    }
    getFormat() {
      return this.getLatest().__format;
    }
    getFormatType() {
      let i = this.getFormat();
      return ke[i] || "";
    }
    getIndent() {
      return this.getLatest().__indent;
    }
    getChildren() {
      let i = [], s = this.getFirstChild();
      for (; s !== null; )
        i.push(s), s = s.getNextSibling();
      return i;
    }
    getChildrenKeys() {
      let i = [], s = this.getFirstChild();
      for (; s !== null; )
        i.push(s.__key), s = s.getNextSibling();
      return i;
    }
    getChildrenSize() {
      return this.getLatest().__size;
    }
    isEmpty() {
      return this.getChildrenSize() === 0;
    }
    isDirty() {
      let i = sn()._dirtyElements;
      return i !== null && i.has(this.__key);
    }
    isLastChild() {
      let i = this.getLatest(), s = this.getParentOrThrow().getLastChild();
      return s !== null && s.is(i);
    }
    getAllTextNodes() {
      let i = [], s = this.getFirstChild();
      for (; s !== null; ) {
        if (dt(s) && i.push(s), Ze(s)) {
          let g = s.getAllTextNodes();
          i.push(...g);
        }
        s = s.getNextSibling();
      }
      return i;
    }
    getFirstDescendant() {
      let i = this.getFirstChild();
      for (; i !== null; ) {
        if (Ze(i)) {
          let s = i.getFirstChild();
          if (s !== null) {
            i = s;
            continue;
          }
        }
        break;
      }
      return i;
    }
    getLastDescendant() {
      let i = this.getLastChild();
      for (; i !== null; ) {
        if (Ze(i)) {
          let s = i.getLastChild();
          if (s !== null) {
            i = s;
            continue;
          }
        }
        break;
      }
      return i;
    }
    getDescendantByIndex(i) {
      let s = this.getChildren(), g = s.length;
      return i >= g ? (i = s[g - 1], Ze(i) && i.getLastDescendant() || i || null) : (i = s[i], Ze(i) && i.getFirstDescendant() || i || null);
    }
    getFirstChild() {
      let i = this.getLatest().__first;
      return i === null ? null : Lt(i);
    }
    getFirstChildOrThrow() {
      let i = this.getFirstChild();
      return i === null && Y(45, this.__key), i;
    }
    getLastChild() {
      let i = this.getLatest().__last;
      return i === null ? null : Lt(i);
    }
    getLastChildOrThrow() {
      let i = this.getLastChild();
      return i === null && Y(96, this.__key), i;
    }
    getChildAtIndex(i) {
      var s = this.getChildrenSize();
      let g;
      if (i < s / 2) {
        for (g = this.getFirstChild(), s = 0; g !== null && s <= i; ) {
          if (s === i)
            return g;
          g = g.getNextSibling(), s++;
        }
        return null;
      }
      for (g = this.getLastChild(), --s; g !== null && s >= i; ) {
        if (s === i)
          return g;
        g = g.getPreviousSibling(), s--;
      }
      return null;
    }
    getTextContent() {
      let i = "", s = this.getChildren(), g = s.length;
      for (let C = 0; C < g; C++) {
        let S = s[C];
        i += S.getTextContent(), Ze(S) && C !== g - 1 && !S.isInline() && (i += `

`);
      }
      return i;
    }
    getTextContentSize() {
      let i = 0, s = this.getChildren(), g = s.length;
      for (let C = 0; C < g; C++) {
        let S = s[C];
        i += S.getTextContentSize(), Ze(S) && C !== g - 1 && !S.isInline() && (i += 2);
      }
      return i;
    }
    getDirection() {
      return this.getLatest().__dir;
    }
    hasFormat(i) {
      return i !== "" ? (i = we[i], (this.getFormat() & i) !== 0) : !1;
    }
    select(i, s) {
      Xn();
      let g = Vt(), C = i, S = s;
      var R = this.getChildrenSize();
      if (!this.canBeEmpty()) {
        if (i === 0 && s === 0) {
          if (i = this.getFirstChild(), dt(i) || Ze(i))
            return i.select(0, 0);
        } else if (!(i !== void 0 && i !== R || s !== void 0 && s !== R) && (i = this.getLastChild(), dt(i) || Ze(i)))
          return i.select();
      }
      if (C === void 0 && (C = R), S === void 0 && (S = R), R = this.__key, St(g))
        g.anchor.set(R, C, "element"), g.focus.set(R, S, "element"), g.dirty = !0;
      else
        return Vn(R, C, R, S, "element", "element");
      return g;
    }
    selectStart() {
      let i = this.getFirstDescendant();
      return i ? i.selectStart() : this.select();
    }
    selectEnd() {
      let i = this.getLastDescendant();
      return i ? i.selectEnd() : this.select();
    }
    clear() {
      let i = this.getWritable();
      return this.getChildren().forEach((s) => s.remove()), i;
    }
    append(...i) {
      return this.splice(
        this.getChildrenSize(),
        0,
        i
      );
    }
    setDirection(i) {
      let s = this.getWritable();
      return s.__dir = i, s;
    }
    setFormat(i) {
      return this.getWritable().__format = i !== "" ? we[i] : 0, this;
    }
    setIndent(i) {
      return this.getWritable().__indent = i, this;
    }
    splice(i, s, g) {
      let C = g.length, S = this.getChildrenSize(), R = this.getWritable(), X = R.__key;
      var me = [], Se = [];
      let Fe = this.getChildAtIndex(i + s), Ke = null, Le = S - s + C;
      if (i !== 0)
        if (i === S)
          Ke = this.getLastChild();
        else {
          var Re = this.getChildAtIndex(i);
          Re !== null && (Ke = Re.getPreviousSibling());
        }
      if (0 < s) {
        var Xe = Ke === null ? this.getFirstChild() : Ke.getNextSibling();
        for (Re = 0; Re < s; Re++) {
          Xe === null && Y(100);
          var at = Xe.getNextSibling(), Et = Xe.__key;
          Xe = Xe.getWritable(), Tt(Xe), Se.push(Et), Xe = at;
        }
      }
      for (Re = Ke, at = 0; at < C; at++) {
        Et = g[at], Re !== null && Et.is(Re) && (Ke = Re = Re.getPreviousSibling()), Xe = Et.getWritable(), Xe.__parent === X && Le--, Tt(Xe);
        let Rt = Et.__key;
        Re === null ? (R.__first = Rt, Xe.__prev = null) : (Re = Re.getWritable(), Re.__next = Rt, Xe.__prev = Re.__key), Et.__key === X && Y(76), Xe.__parent = X, me.push(Rt), Re = Et;
      }
      if (i + s === S ? Re !== null && (Re.getWritable().__next = null, R.__last = Re.__key) : Fe !== null && (i = Fe.getWritable(), Re !== null ? (s = Re.getWritable(), i.__prev = Re.__key, s.__next = Fe.__key) : i.__prev = null), R.__size = Le, Se.length && (i = Vt(), St(i))) {
        Se = new Set(Se), me = new Set(me);
        let { anchor: Rt, focus: hn } = i;
        Ps(Rt, Se, me) && yo(Rt, Rt.getNode(), this, Ke, Fe), Ps(hn, Se, me) && yo(hn, hn.getNode(), this, Ke, Fe), Le !== 0 || this.canBeEmpty() || ni(this) || this.remove();
      }
      return R;
    }
    exportJSON() {
      return { children: [], direction: this.getDirection(), format: this.getFormatType(), indent: this.getIndent(), type: "element", version: 1 };
    }
    insertNewAfter() {
      return null;
    }
    canIndent() {
      return !0;
    }
    collapseAtStart() {
      return !1;
    }
    excludeFromCopy() {
      return !1;
    }
    canExtractContents() {
      return !0;
    }
    canReplaceWith() {
      return !0;
    }
    canInsertAfter() {
      return !0;
    }
    canBeEmpty() {
      return !0;
    }
    canInsertTextBefore() {
      return !0;
    }
    canInsertTextAfter() {
      return !0;
    }
    isInline() {
      return !1;
    }
    isShadowRoot() {
      return !1;
    }
    canMergeWith() {
      return !1;
    }
    extractWithChild() {
      return !1;
    }
  }
  function Ze(l) {
    return l instanceof Qn;
  }
  function Ps(l, i, s) {
    for (l = l.getNode(); l; ) {
      let g = l.__key;
      if (i.has(g) && !s.has(g))
        return !0;
      l = l.getParent();
    }
    return !1;
  }
  class Ur extends Qn {
    static getType() {
      return "root";
    }
    static clone() {
      return new Ur();
    }
    constructor() {
      super("root"), this.__cachedText = null;
    }
    getTopLevelElementOrThrow() {
      Y(51);
    }
    getTextContent() {
      let i = this.__cachedText;
      return !ci() && sn()._dirtyType !== 0 || i === null ? super.getTextContent() : i;
    }
    remove() {
      Y(52);
    }
    replace() {
      Y(53);
    }
    insertBefore() {
      Y(54);
    }
    insertAfter() {
      Y(55);
    }
    updateDOM() {
      return !1;
    }
    append(...i) {
      for (let s = 0; s < i.length; s++) {
        let g = i[s];
        Ze(g) || ln(g) || Y(56);
      }
      return super.append(...i);
    }
    static importJSON(i) {
      let s = fn();
      return s.setFormat(i.format), s.setIndent(i.indent), s.setDirection(i.direction), s;
    }
    exportJSON() {
      return { children: [], direction: this.getDirection(), format: this.getFormatType(), indent: this.getIndent(), type: "root", version: 1 };
    }
    collapseAtStart() {
      return !0;
    }
  }
  function nr(l) {
    return l instanceof Ur;
  }
  function Aa(l, i) {
    if (i = i.getEditorState()._selection, l = l._selection, l !== null) {
      if (l.dirty || !l.is(i))
        return !0;
    } else if (i !== null)
      return !0;
    return !1;
  }
  function Di() {
    return new xo(/* @__PURE__ */ new Map([["root", new Ur()]]));
  }
  function To(l) {
    let i = l.exportJSON();
    var s = l.constructor;
    i.type !== s.getType() && Y(130, s.name);
    let g = i.children;
    if (Ze(l))
      for (Array.isArray(g) || Y(59, s.name), l = l.getChildren(), s = 0; s < l.length; s++) {
        let C = To(l[s]);
        g.push(C);
      }
    return i;
  }
  class xo {
    constructor(i, s) {
      this._nodeMap = i, this._selection = s || null, this._readOnly = this._flushSync = !1;
    }
    isEmpty() {
      return this._nodeMap.size === 1 && this._selection === null;
    }
    read(i) {
      return Ra(this, i);
    }
    clone(i) {
      return i = new xo(this._nodeMap, i === void 0 ? this._selection : i), i._readOnly = !0, i;
    }
    toJSON() {
      return Ra(this, () => ({ root: To(fn()) }));
    }
  }
  class Ri extends Qn {
    static getType() {
      return "paragraph";
    }
    static clone(i) {
      return new Ri(i.__key);
    }
    createDOM(i) {
      let s = document.createElement("p");
      return i = Wt(i.theme, "paragraph"), i !== void 0 && s.classList.add(...i), s;
    }
    updateDOM() {
      return !1;
    }
    static importDOM() {
      return { p: () => ({ conversion: Xo, priority: 0 }) };
    }
    exportDOM(i) {
      if ({ element: i } = super.exportDOM(i), i && lo(i)) {
        this.isEmpty() && i.append(document.createElement("br"));
        var s = this.getFormatType();
        i.style.textAlign = s, (s = this.getDirection()) && (i.dir = s), s = this.getIndent(), 0 < s && (i.style.textIndent = `${20 * s}px`);
      }
      return { element: i };
    }
    static importJSON(i) {
      let s = ar();
      return s.setFormat(i.format), s.setIndent(i.indent), s.setDirection(i.direction), s;
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "paragraph", version: 1 };
    }
    insertNewAfter(i, s) {
      i = ar();
      let g = this.getDirection();
      return i.setDirection(g), this.insertAfter(i, s), i;
    }
    collapseAtStart() {
      let i = this.getChildren();
      if (i.length === 0 || dt(i[0]) && i[0].getTextContent().trim() === "") {
        if (this.getNextSibling() !== null)
          return this.selectNext(), this.remove(), !0;
        if (this.getPreviousSibling() !== null)
          return this.selectPrevious(), this.remove(), !0;
      }
      return !1;
    }
  }
  function Xo(l) {
    let i = ar();
    return l.style && (i.setFormat(l.style.textAlign), l = parseInt(l.style.textIndent, 10) / 20, 0 < l && i.setIndent(l)), { node: i };
  }
  function ar() {
    return Ki(new Ri());
  }
  function Ml(l, i, s, g) {
    let C = l._keyToDOMMap;
    C.clear(), l._editorState = Di(), l._pendingEditorState = g, l._compositionKey = null, l._dirtyType = 0, l._cloneNotNeeded.clear(), l._dirtyLeaves = /* @__PURE__ */ new Set(), l._dirtyElements.clear(), l._normalizedNodes = /* @__PURE__ */ new Set(), l._updateTags = /* @__PURE__ */ new Set(), l._updates = [], l._blockCursorElement = null, g = l._observer, g !== null && (g.disconnect(), l._observer = null), i !== null && (i.textContent = ""), s !== null && (s.textContent = "", C.set("root", s));
  }
  function ka(l, i) {
    let s = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Set(), C = (S) => {
      Object.keys(S).forEach((R) => {
        let X = s.get(R);
        X === void 0 && (X = [], s.set(R, X)), X.push(S[R]);
      });
    };
    return l.forEach((S) => {
      S = S.klass.importDOM != null ? S.klass.importDOM.bind(S.klass) : null, S == null || g.has(S) || (g.add(S), S = S(), S !== null && C(S));
    }), i && C(i), s;
  }
  class La {
    constructor(i, s, g, C, S, R, X) {
      this._parentEditor = s, this._rootElement = null, this._editorState = i, this._compositionKey = this._pendingEditorState = null, this._deferred = [], this._keyToDOMMap = /* @__PURE__ */ new Map(), this._updates = [], this._updating = !1, this._listeners = { decorator: /* @__PURE__ */ new Set(), editable: /* @__PURE__ */ new Set(), mutation: /* @__PURE__ */ new Map(), root: /* @__PURE__ */ new Set(), textcontent: /* @__PURE__ */ new Set(), update: /* @__PURE__ */ new Set() }, this._commands = /* @__PURE__ */ new Map(), this._config = C, this._nodes = g, this._decorators = {}, this._pendingDecorators = null, this._dirtyType = 0, this._cloneNotNeeded = /* @__PURE__ */ new Set(), this._dirtyLeaves = /* @__PURE__ */ new Set(), this._dirtyElements = /* @__PURE__ */ new Map(), this._normalizedNodes = /* @__PURE__ */ new Set(), this._updateTags = /* @__PURE__ */ new Set(), this._observer = null, this._key = Ge(), this._onError = S, this._htmlConversions = R, this._editable = X, this._headless = s !== null && s._headless, this._blockCursorElement = this._window = null;
    }
    isComposing() {
      return this._compositionKey != null;
    }
    registerUpdateListener(i) {
      let s = this._listeners.update;
      return s.add(i), () => {
        s.delete(i);
      };
    }
    registerEditableListener(i) {
      let s = this._listeners.editable;
      return s.add(i), () => {
        s.delete(i);
      };
    }
    registerDecoratorListener(i) {
      let s = this._listeners.decorator;
      return s.add(i), () => {
        s.delete(i);
      };
    }
    registerTextContentListener(i) {
      let s = this._listeners.textcontent;
      return s.add(i), () => {
        s.delete(i);
      };
    }
    registerRootListener(i) {
      let s = this._listeners.root;
      return i(this._rootElement, null), s.add(i), () => {
        i(null, this._rootElement), s.delete(i);
      };
    }
    registerCommand(i, s, g) {
      g === void 0 && Y(35);
      let C = this._commands;
      C.has(i) || C.set(i, [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()]);
      let S = C.get(i);
      S === void 0 && Y(36, String(i));
      let R = S[g];
      return R.add(s), () => {
        R.delete(s), S.every((X) => X.size === 0) && C.delete(i);
      };
    }
    registerMutationListener(i, s) {
      this._nodes.get(i.getType()) === void 0 && Y(37, i.name);
      let g = this._listeners.mutation;
      return g.set(s, i), () => {
        g.delete(s);
      };
    }
    registerNodeTransformToKlass(i, s) {
      var g = i.getType();
      return g = this._nodes.get(g), g === void 0 && Y(37, i.name), g.transforms.add(s), g;
    }
    registerNodeTransform(i, s) {
      var g = this.registerNodeTransformToKlass(i, s);
      let C = [g];
      return g = g.replaceWithKlass, g != null && (g = this.registerNodeTransformToKlass(g, s), C.push(g)), Ns(this, i.getType()), () => {
        C.forEach((S) => S.transforms.delete(s));
      };
    }
    hasNode(i) {
      return this._nodes.has(i.getType());
    }
    hasNodes(i) {
      return i.every(this.hasNode.bind(this));
    }
    dispatchCommand(i, s) {
      return it(this, i, s);
    }
    getDecorators() {
      return this._decorators;
    }
    getRootElement() {
      return this._rootElement;
    }
    getKey() {
      return this._key;
    }
    setRootElement(i) {
      let s = this._rootElement;
      if (i !== s) {
        let R = Wt(this._config.theme, "root");
        var g = this._pendingEditorState || this._editorState;
        if (this._rootElement = i, Ml(this, s, i, g), s !== null) {
          if (!this._config.disableEvents) {
            Ho !== 0 && (Ho--, Ho === 0 && s.ownerDocument.removeEventListener("selectionchange", Ea));
            var C = s.__lexicalEditor;
            if (C != null) {
              if (C._parentEditor !== null) {
                var S = ye(C);
                S = S[S.length - 1]._key, ho.get(S) === C && ho.delete(S);
              } else
                ho.delete(C._key);
              s.__lexicalEditor = null;
            }
            for (C = Ca(s), S = 0; S < C.length; S++)
              C[S]();
            s.__lexicalEventHandles = [];
          }
          R != null && s.classList.remove(...R);
        }
        i !== null ? (g = (g = i.ownerDocument) && g.defaultView || null, C = i.style, C.userSelect = "text", C.whiteSpace = "pre-wrap", C.wordBreak = "break-word", i.setAttribute(
          "data-lexical-editor",
          "true"
        ), this._window = g, this._dirtyType = 2, Me(this), this._updateTags.add("history-merge"), kr(this), this._config.disableEvents || kc(i, this), R != null && i.classList.add(...R)) : (this._editorState = g, this._window = this._pendingEditorState = null), Eo("root", this, !1, i, s);
      }
    }
    getElementByKey(i) {
      return this._keyToDOMMap.get(i) || null;
    }
    getEditorState() {
      return this._editorState;
    }
    setEditorState(i, s) {
      i.isEmpty() && Y(38), Oe(this);
      let g = this._pendingEditorState, C = this._updateTags;
      s = s !== void 0 ? s.tag : null, g === null || g.isEmpty() || (s != null && C.add(s), kr(this)), this._pendingEditorState = i, this._dirtyType = 2, this._dirtyElements.set("root", !1), this._compositionKey = null, s != null && C.add(s), kr(this);
    }
    parseEditorState(i, s) {
      i = typeof i == "string" ? JSON.parse(i) : i;
      let g = Di(), C = yn, S = vn, R = xn, X = this._dirtyElements, me = this._dirtyLeaves, Se = this._cloneNotNeeded, Fe = this._dirtyType;
      this._dirtyElements = /* @__PURE__ */ new Map(), this._dirtyLeaves = /* @__PURE__ */ new Set(), this._cloneNotNeeded = /* @__PURE__ */ new Set(), this._dirtyType = 0, yn = g, vn = !1, xn = this;
      try {
        Co(i.root, this._nodes), s && s(), g._readOnly = !0;
      } catch (Ke) {
        Ke instanceof Error && this._onError(Ke);
      } finally {
        this._dirtyElements = X, this._dirtyLeaves = me, this._cloneNotNeeded = Se, this._dirtyType = Fe, yn = C, vn = S, xn = R;
      }
      return g;
    }
    update(i, s) {
      lr(this, i, s);
    }
    focus(i, s = {}) {
      let g = this._rootElement;
      g !== null && (g.setAttribute("autocapitalize", "off"), lr(this, () => {
        let C = Vt(), S = fn();
        C !== null ? C.dirty = !0 : S.getChildrenSize() !== 0 && (s.defaultSelection === "rootStart" ? S.selectStart() : S.selectEnd());
      }, { onUpdate: () => {
        g.removeAttribute("autocapitalize"), i && i();
      }, tag: "focus" }), this._pendingEditorState === null && g.removeAttribute("autocapitalize"));
    }
    blur() {
      var i = this._rootElement;
      i !== null && i.blur(), i = $r(this._window), i !== null && i.removeAllRanges();
    }
    isEditable() {
      return this._editable;
    }
    setEditable(i) {
      this._editable !== i && (this._editable = i, Eo("editable", this, !0, i));
    }
    toJSON() {
      return { editorState: this._editorState.toJSON() };
    }
  }
  class $s extends Qn {
    constructor(i, s) {
      super(s), this.__colSpan = i, this.__rowSpan = 1;
    }
    exportJSON() {
      return { ...super.exportJSON(), colSpan: this.__colSpan, rowSpan: this.__rowSpan };
    }
    getColSpan() {
      return this.__colSpan;
    }
    setColSpan(i) {
      return this.getWritable().__colSpan = i, this;
    }
    getRowSpan() {
      return this.__rowSpan;
    }
    setRowSpan(i) {
      return this.getWritable().__rowSpan = i, this;
    }
  }
  function Tr(l) {
    return l instanceof $s;
  }
  class Ia extends Qn {
  }
  function Fs(l) {
    return l instanceof Ia;
  }
  class Pa extends Qn {
  }
  function Qo(l) {
    return l instanceof Pa;
  }
  return Pe.$INTERNAL_isPointSelection = wl, Pe.$addUpdateTag = function(l) {
    Xn(), sn()._updateTags.add(l);
  }, Pe.$applyNodeReplacement = Ki, Pe.$copyNode = dl, Pe.$createLineBreakNode = Hr, Pe.$createNodeSelection = Ar, Pe.$createParagraphNode = ar, Pe.$createRangeSelection = function() {
    let l = new Mr("root", 0, "element"), i = new Mr("root", 0, "element");
    return new Gi(l, i, 0, "");
  }, Pe.$createTabNode = zi, Pe.$createTextNode = Wn, Pe.$getAdjacentNode = mn, Pe.$getNearestNodeFromDOMNode = Dr, Pe.$getNearestRootOrShadowRoot = ul, Pe.$getNodeByKey = Lt, Pe.$getPreviousSelection = Vi, Pe.$getRoot = fn, Pe.$getSelection = Vt, Pe.$getTextContent = function() {
    let l = Vt();
    return l === null ? "" : l.getTextContent();
  }, Pe.$hasAncestor = Ni, Pe.$hasUpdateTag = function(l) {
    return sn()._updateTags.has(l);
  }, Pe.$insertNodes = function(l) {
    let i = Vt() || Vi();
    i === null && (i = fn().selectEnd()), i.insertNodes(l);
  }, Pe.$isBlockElementNode = function(l) {
    return Ze(l) && !l.isInline();
  }, Pe.$isDecoratorNode = ln, Pe.$isElementNode = Ze, Pe.$isInlineElementOrDecoratorNode = function(l) {
    return Ze(l) && l.isInline() || ln(l) && l.isInline();
  }, Pe.$isLeafNode = function(l) {
    return dt(l) || vi(l) || ln(l);
  }, Pe.$isLineBreakNode = vi, Pe.$isNodeSelection = Vo, Pe.$isParagraphNode = function(l) {
    return l instanceof Ri;
  }, Pe.$isRangeSelection = St, Pe.$isRootNode = nr, Pe.$isRootOrShadowRoot = ni, Pe.$isTabNode = Sa, Pe.$isTextNode = dt, Pe.$nodesOfType = function(l) {
    var i = Er();
    let s = i._readOnly, g = l.getType();
    i = i._nodeMap;
    let C = [];
    for (let [, S] of i)
      S instanceof l && S.__type === g && (s || S.isAttached()) && C.push(S);
    return C;
  }, Pe.$normalizeSelection__EXPERIMENTAL = Qe, Pe.$parseSerializedNode = function(l) {
    return Co(l, sn()._nodes);
  }, Pe.$selectAll = function() {
    var l = fn();
    l = l.select(0, l.getChildrenSize()), _r(Qe(l));
  }, Pe.$setCompositionKey = Mt, Pe.$setSelection = _r, Pe.$splitNode = function(l, i) {
    let s = l.getChildAtIndex(i);
    s == null && (s = l), ni(l) && Y(102);
    let g = (R) => {
      const X = R.getParentOrThrow(), me = ni(X), Se = R !== s || me ? dl(R) : R;
      if (me)
        return R.insertAfter(Se), [R, Se, Se];
      const [Fe, Ke, Le] = g(X);
      return R = R.getNextSiblings(), Le.append(Se, ...R), [Fe, Ke, Se];
    }, [C, S] = g(s);
    return [C, S];
  }, Pe.BLUR_COMMAND = V, Pe.CAN_REDO_COMMAND = {}, Pe.CAN_UNDO_COMMAND = {}, Pe.CLEAR_EDITOR_COMMAND = {}, Pe.CLEAR_HISTORY_COMMAND = {}, Pe.CLICK_COMMAND = e, Pe.COMMAND_PRIORITY_CRITICAL = 4, Pe.COMMAND_PRIORITY_EDITOR = 0, Pe.COMMAND_PRIORITY_HIGH = 3, Pe.COMMAND_PRIORITY_LOW = 1, Pe.COMMAND_PRIORITY_NORMAL = 2, Pe.CONTROLLED_TEXT_INSERTION_COMMAND = d, Pe.COPY_COMMAND = J, Pe.CUT_COMMAND = ee, Pe.DELETE_CHARACTER_COMMAND = n, Pe.DELETE_LINE_COMMAND = x, Pe.DELETE_WORD_COMMAND = N, Pe.DEPRECATED_$computeGridMap = Oi, Pe.DEPRECATED_$createGridSelection = function() {
    let l = new Mr("root", 0, "element"), i = new Mr("root", 0, "element");
    return new Ms("root", l, i);
  }, Pe.DEPRECATED_$getGridCellNodeRect = Cr, Pe.DEPRECATED_$getNodeTriplet = ai, Pe.DEPRECATED_$isGridCellNode = Tr, Pe.DEPRECATED_$isGridNode = Fs, Pe.DEPRECATED_$isGridRowNode = Qo, Pe.DEPRECATED_$isGridSelection = Yo, Pe.DEPRECATED_GridCellNode = $s, Pe.DEPRECATED_GridNode = Ia, Pe.DEPRECATED_GridRowNode = Pa, Pe.DRAGEND_COMMAND = pe, Pe.DRAGOVER_COMMAND = _e, Pe.DRAGSTART_COMMAND = j, Pe.DROP_COMMAND = G, Pe.DecoratorNode = Ma, Pe.ElementNode = Qn, Pe.FOCUS_COMMAND = D, Pe.FORMAT_ELEMENT_COMMAND = {}, Pe.FORMAT_TEXT_COMMAND = v, Pe.INDENT_CONTENT_COMMAND = {}, Pe.INSERT_LINE_BREAK_COMMAND = r, Pe.INSERT_PARAGRAPH_COMMAND = c, Pe.INSERT_TAB_COMMAND = {}, Pe.KEY_ARROW_DOWN_COMMAND = W, Pe.KEY_ARROW_LEFT_COMMAND = P, Pe.KEY_ARROW_RIGHT_COMMAND = T, Pe.KEY_ARROW_UP_COMMAND = $, Pe.KEY_BACKSPACE_COMMAND = te, Pe.KEY_DELETE_COMMAND = ue, Pe.KEY_DOWN_COMMAND = A, Pe.KEY_ENTER_COMMAND = H, Pe.KEY_ESCAPE_COMMAND = re, Pe.KEY_MODIFIER_COMMAND = ne, Pe.KEY_SPACE_COMMAND = z, Pe.KEY_TAB_COMMAND = q, Pe.LineBreakNode = Br, Pe.MOVE_TO_END = w, Pe.MOVE_TO_START = K, Pe.OUTDENT_CONTENT_COMMAND = {}, Pe.PASTE_COMMAND = h, Pe.ParagraphNode = Ri, Pe.REDO_COMMAND = M, Pe.REMOVE_TEXT_COMMAND = p, Pe.RootNode = Ur, Pe.SELECTION_CHANGE_COMMAND = t, Pe.SELECT_ALL_COMMAND = F, Pe.TabNode = go, Pe.TextNode = li, Pe.UNDO_COMMAND = O, Pe.createCommand = function() {
    return {};
  }, Pe.createEditor = function(l) {
    var i = l || {}, s = xn, g = i.theme || {};
    let C = l === void 0 ? s : i.parentEditor || null, S = i.disableEvents || !1, R = Di(), X = i.namespace || (C !== null ? C._config.namespace : Ge()), me = i.editorState, Se = [Ur, li, Br, go, Ri, ...i.nodes || []], { onError: Fe, html: Ke } = i;
    if (i = i.editable !== void 0 ? i.editable : !0, l === void 0 && s !== null)
      l = s._nodes;
    else
      for (l = /* @__PURE__ */ new Map(), s = 0; s < Se.length; s++) {
        let Re = Se[s], Xe = null;
        var Le = null;
        typeof Re != "function" && (Le = Re, Re = Le.replace, Xe = Le.with, Le = Le.withKlass || null);
        let at = Re.getType(), Et = Re.transform(), Rt = /* @__PURE__ */ new Set();
        Et !== null && Rt.add(Et), l.set(at, { exportDOM: Ke && Ke.export ? Ke.export.get(Re) : void 0, klass: Re, replace: Xe, replaceWithKlass: Le, transforms: Rt });
      }
    return g = new La(R, C, l, { disableEvents: S, namespace: X, theme: g }, Fe || console.error, ka(l, Ke ? Ke.import : void 0), i), me !== void 0 && (g._pendingEditorState = me, g._dirtyType = 2), g;
  }, Pe.getNearestEditorFromDOMNode = mt, Pe.isHTMLAnchorElement = function(l) {
    return lo(l) && l.tagName === "A";
  }, Pe.isHTMLElement = lo, Pe.isSelectionCapturedInDecoratorInput = je, Pe.isSelectionWithinEditor = nt, Pe;
}
var $e = {}, vf;
function rN() {
  if (vf)
    return $e;
  vf = 1;
  function t(u) {
    return {
      type: u
    };
  }
  const e = t("SELECTION_CHANGE_COMMAND"), n = t("CLICK_COMMAND"), r = t("DELETE_CHARACTER_COMMAND"), c = t("INSERT_LINE_BREAK_COMMAND"), d = t("INSERT_PARAGRAPH_COMMAND"), h = t("CONTROLLED_TEXT_INSERTION_COMMAND"), p = t("PASTE_COMMAND"), N = t("REMOVE_TEXT_COMMAND"), x = t("DELETE_WORD_COMMAND"), v = t("DELETE_LINE_COMMAND"), O = t("FORMAT_TEXT_COMMAND"), M = t("UNDO_COMMAND"), A = t("REDO_COMMAND"), T = t("KEYDOWN_COMMAND"), w = t("KEY_ARROW_RIGHT_COMMAND"), P = t("MOVE_TO_END"), K = t("KEY_ARROW_LEFT_COMMAND"), $ = t("MOVE_TO_START"), W = t("KEY_ARROW_UP_COMMAND"), H = t("KEY_ARROW_DOWN_COMMAND"), z = t("KEY_ENTER_COMMAND"), te = t("KEY_SPACE_COMMAND"), re = t("KEY_BACKSPACE_COMMAND"), ue = t("KEY_ESCAPE_COMMAND"), q = t("KEY_DELETE_COMMAND"), G = t("KEY_TAB_COMMAND"), j = t("INSERT_TAB_COMMAND"), _e = t("INDENT_CONTENT_COMMAND"), pe = t("OUTDENT_CONTENT_COMMAND"), J = t("DROP_COMMAND"), ee = t("FORMAT_ELEMENT_COMMAND"), F = t("DRAGSTART_COMMAND"), D = t("DRAGOVER_COMMAND"), V = t("DRAGEND_COMMAND"), ne = t("COPY_COMMAND"), Y = t("CUT_COMMAND"), U = t("SELECT_ALL_COMMAND"), Q = t("CLEAR_EDITOR_COMMAND"), k = t("CLEAR_HISTORY_COMMAND"), m = t("CAN_REDO_COMMAND"), y = t("CAN_UNDO_COMMAND"), b = t("FOCUS_COMMAND"), Z = t("BLUR_COMMAND"), ce = t("KEY_MODIFIER_COMMAND"), ge = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", ae = ge && "documentMode" in document ? document.documentMode : null, Te = ge && /Mac|iPod|iPhone|iPad/.test(navigator.platform), Ae = ge && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), ze = ge && "InputEvent" in window && !ae ? "getTargetRanges" in new window.InputEvent("input") : !1, oe = ge && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), ie = ge && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, de = ge && /Android/.test(navigator.userAgent), we = ge && /^(?=.*Chrome).*/i.test(navigator.userAgent), ke = ge && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !we, Be = 1, Ye = 3, lt = 0, _t = 1, ct = 2, ve = 0, se = 1, he = 2, Oe = 1, Me = 2, De = 4, We = 8, qe = 16, Qe = 32, ut = 64, kt = 128, Ve = Oe | Me | De | We | qe | Qe | ut | kt, je = 1, nt = 2, mt = 1, Ct = 2, vt = 3, wt = 4, Dt = 5, Tt = 6, Xt = "", Ut = oe || ie || ke ? Xt : "", Lt = `

`, mr = Ae ? Xt : Ut, Dr = "---", Wi = "A-Za-z--------", ys = new RegExp("^[^" + Wi + "]*[" + Dr + "]"), Ns = new RegExp("^[^" + Dr + "]*[" + Wi + "]"), fn = {
    bold: Oe,
    code: qe,
    highlight: kt,
    italic: Me,
    strikethrough: De,
    subscript: Qe,
    superscript: ut,
    underline: We
  }, _r = {
    directionless: je,
    unmergeable: nt
  }, ti = {
    center: Ct,
    end: Tt,
    justify: wt,
    left: mt,
    right: vt,
    start: Dt
  }, Cs = {
    [Ct]: "center",
    [Tt]: "end",
    [wt]: "justify",
    [mt]: "left",
    [vt]: "right",
    [Dt]: "start"
  }, ye = {
    normal: ve,
    segmented: he,
    token: se
  }, Ge = {
    [ve]: "normal",
    [he]: "segmented",
    [se]: "token"
  }, et = 100;
  let yt = !1, Ft = 0;
  function Wt() {
    return yt;
  }
  function Pt(u) {
    Ft = u.timeStamp;
  }
  function It(u) {
    Ft === 0 && zi(u).addEventListener("textInput", Pt, !0);
  }
  function mn(u, o, a) {
    return (
      // @ts-expect-error: internal field
      o.__lexicalLineBreak === u || // @ts-ignore We intentionally add this to the Node.
      u[`__lexicalKey_${a._key}`] !== void 0
    );
  }
  function on(u) {
    return u.getEditorState().read(() => {
      const o = an();
      return o !== null ? o.clone() : null;
    });
  }
  function en(u, o, a) {
    const f = Cr(a._window);
    let _ = null, E = null;
    f !== null && f.anchorNode === u && (_ = f.anchorOffset, E = f.focusOffset);
    const I = u.nodeValue;
    I !== null && Fo(o, I, _, E, !1);
  }
  function Bn(u, o, a) {
    if (gt(u)) {
      const f = u.anchor.getNode();
      if (f.is(a) && u.format !== f.getFormat())
        return !1;
    }
    return o.nodeType === Ye && a.isAttached();
  }
  function yr(u, o, a) {
    yt = !0;
    const f = performance.now() - Ft > et;
    try {
      Lr(u, () => {
        const _ = an() || on(u), E = /* @__PURE__ */ new Map(), I = u.getRootElement(), B = u._editorState, le = u._blockCursorElement;
        let fe = !1, Ne = "";
        for (let xe = 0; xe < o.length; xe++) {
          const Ce = o[xe], He = Ce.type, Ie = Ce.target;
          let be = Nr(Ie, B);
          if (!(be === null && Ie !== I || Sn(be))) {
            if (He === "characterData")
              f && ft(be) && Bn(_, Ie, be) && en(
                // nodeType === DOM_TEXT_TYPE is a Text DOM node
                Ie,
                be,
                u
              );
            else if (He === "childList") {
              fe = !0;
              const pt = Ce.addedNodes;
              for (let $t = 0; $t < pt.length; $t++) {
                const bt = pt[$t], Nt = Ti(bt), xt = bt.parentNode;
                if (xt != null && bt !== le && Nt === null && (bt.nodeName !== "BR" || !mn(bt, xt, u))) {
                  if (Ae) {
                    const Ht = bt.innerText || bt.nodeValue;
                    Ht && (Ne += Ht);
                  }
                  xt.removeChild(bt);
                }
              }
              const Ue = Ce.removedNodes, tt = Ue.length;
              if (tt > 0) {
                let $t = 0;
                for (let bt = 0; bt < tt; bt++) {
                  const Nt = Ue[bt];
                  (Nt.nodeName === "BR" && mn(Nt, Ie, u) || le === Nt) && (Ie.appendChild(Nt), $t++);
                }
                tt !== $t && (Ie === I && (be = xi(B)), E.set(Ie, be));
              }
            }
          }
        }
        if (E.size > 0)
          for (const [xe, Ce] of E)
            if (Je(Ce)) {
              const He = Ce.getChildrenKeys();
              let Ie = xe.firstChild;
              for (let be = 0; be < He.length; be++) {
                const pt = He[be], Ue = u.getElementByKey(pt);
                Ue !== null && (Ie == null ? (xe.appendChild(Ue), Ie = Ue) : Ie !== Ue && xe.replaceChild(Ue, Ie), Ie = Ie.nextSibling);
              }
            } else
              ft(Ce) && Ce.markDirty();
        const Ee = a.takeRecords();
        if (Ee.length > 0) {
          for (let xe = 0; xe < Ee.length; xe++) {
            const Ce = Ee[xe], He = Ce.addedNodes, Ie = Ce.target;
            for (let be = 0; be < He.length; be++) {
              const pt = He[be], Ue = pt.parentNode;
              Ue != null && pt.nodeName === "BR" && !mn(pt, Ie, u) && Ue.removeChild(pt);
            }
          }
          a.takeRecords();
        }
        _ !== null && (fe && (_.dirty = !0, br(_)), Ae && xa(u) && _.insertRawText(Ne));
      });
    } finally {
      yt = !1;
    }
  }
  function Ni(u) {
    const o = u._observer;
    if (o !== null) {
      const a = o.takeRecords();
      yr(u, a, o);
    }
  }
  function Zn(u) {
    It(u), u._observer = new MutationObserver((o, a) => {
      yr(u, o, a);
    });
  }
  function ul(u, o) {
    const a = u.__mode, f = u.__format, _ = u.__style, E = o.__mode, I = o.__format, B = o.__style;
    return (a === null || a === E) && (f === null || f === I) && (_ === null || _ === B);
  }
  function ni(u, o) {
    const a = u.mergeWithSibling(o), f = gn()._normalizedNodes;
    return f.add(u.__key), f.add(o.__key), a;
  }
  function dl(u) {
    let o = u;
    if (o.__text === "" && o.isSimpleText() && !o.isUnmergeable()) {
      o.remove();
      return;
    }
    let a;
    for (; (a = o.getPreviousSibling()) !== null && ft(a) && a.isSimpleText() && !a.isUnmergeable(); )
      if (a.__text === "")
        a.remove();
      else if (ul(a, o)) {
        o = ni(a, o);
        break;
      } else
        break;
    let f;
    for (; (f = o.getNextSibling()) !== null && ft(f) && f.isSimpleText() && !f.isUnmergeable(); )
      if (f.__text === "")
        f.remove();
      else if (ul(o, f)) {
        o = ni(o, f);
        break;
      } else
        break;
  }
  function Ki(u) {
    return Es(u.anchor), Es(u.focus), u;
  }
  function Es(u) {
    for (; u.type === "element"; ) {
      const o = u.getNode(), a = u.offset;
      let f, _;
      if (a === o.getChildrenSize() ? (f = o.getChildAtIndex(a - 1), _ = !0) : (f = o.getChildAtIndex(a), _ = !1), ft(f)) {
        u.set(f.__key, _ ? f.getTextContentSize() : 0, "text");
        break;
      } else if (!Je(f))
        break;
      u.set(f.__key, _ ? f.getChildrenSize() : 0, "element");
    }
  }
  let fl = 1;
  function hl() {
    return "" + fl++;
  }
  function $r(u, o) {
    const a = u._nodes.get(o);
    if (a === void 0)
      throw Error(`registeredNode: Type ${o} not found`);
    return a;
  }
  const Ts = typeof queueMicrotask == "function" ? queueMicrotask : (u) => {
    Promise.resolve().then(u);
  };
  function wc(u) {
    return Sn(Nr(u));
  }
  function lo(u) {
    const o = document.activeElement;
    if (o === null)
      return !1;
    const a = o.nodeName;
    return Sn(Nr(u)) && (a === "INPUT" || a === "TEXTAREA" || o.contentEditable === "true" && // @ts-ignore iternal field
    o.__lexicalEditor == null);
  }
  function ri(u, o, a) {
    const f = u.getRootElement();
    try {
      return f !== null && f.contains(o) && f.contains(a) && // Ignore if selection is within nested editor
      o !== null && !lo(o) && Io(o) === u;
    } catch {
      return !1;
    }
  }
  function Io(u) {
    let o = u;
    for (; o != null; ) {
      const a = o.__lexicalEditor;
      if (a != null)
        return a;
      o = bs(o);
    }
    return null;
  }
  function aa(u) {
    return ys.test(u) ? "rtl" : Ns.test(u) ? "ltr" : null;
  }
  function gl(u) {
    return u.isToken() || u.isSegmented();
  }
  function On(u) {
    return u.nodeType === Ye;
  }
  function Ln(u) {
    let o = u;
    for (; o != null; ) {
      if (On(o))
        return o;
      o = o.firstChild;
    }
    return null;
  }
  function Rr(u, o, a) {
    const f = fn[o];
    if (a !== null && (u & f) === (a & f))
      return u;
    let _ = u ^ f;
    return o === "subscript" ? _ &= ~fn.superscript : o === "superscript" && (_ &= ~fn.subscript), _;
  }
  function Ci(u) {
    return ft(u) || Mi(u) || Sn(u);
  }
  function Hn(u, o) {
    if (o != null) {
      u.__key = o;
      return;
    }
    rr(), Gd();
    const a = gn(), f = Ii(), _ = hl();
    f._nodeMap.set(_, u), Je(u) ? a._dirtyElements.set(_, !0) : a._dirtyLeaves.add(_), a._cloneNotNeeded.add(_), a._dirtyType = _t, u.__key = _;
  }
  function Po(u, o, a) {
    let f = u;
    for (; f !== null; ) {
      if (a.has(f))
        return;
      const _ = o.get(f);
      if (_ === void 0)
        break;
      a.set(f, !1), f = _.__parent;
    }
  }
  function Ei(u) {
    const o = u.getParent();
    if (o !== null) {
      const a = u.getWritable(), f = o.getWritable(), _ = u.getPreviousSibling(), E = u.getNextSibling();
      if (_ === null)
        if (E !== null) {
          const I = E.getWritable();
          f.__first = E.__key, I.__prev = null;
        } else
          f.__first = null;
      else {
        const I = _.getWritable();
        if (E !== null) {
          const B = E.getWritable();
          B.__prev = I.__key, I.__next = B.__key;
        } else
          I.__next = null;
        a.__prev = null;
      }
      if (E === null)
        if (_ !== null) {
          const I = _.getWritable();
          f.__last = _.__key, I.__next = null;
        } else
          f.__last = null;
      else {
        const I = E.getWritable();
        if (_ !== null) {
          const B = _.getWritable();
          B.__next = I.__key, I.__prev = B.__key;
        } else
          I.__prev = null;
        a.__next = null;
      }
      f.__size--, a.__parent = null;
    }
  }
  function ao(u) {
    Gd();
    const o = u.getLatest(), a = o.__parent, f = Ii(), _ = gn(), E = f._nodeMap, I = _._dirtyElements;
    a !== null && Po(a, E, I);
    const B = o.__key;
    _._dirtyType = _t, Je(u) ? I.set(B, !0) : _._dirtyLeaves.add(B);
  }
  function xs(u) {
    const o = u.getPreviousSibling(), a = u.getNextSibling();
    o !== null && ao(o), a !== null && ao(a);
  }
  function _n(u) {
    rr();
    const o = gn(), a = o._compositionKey;
    if (u !== a) {
      if (o._compositionKey = u, a !== null) {
        const f = En(a);
        f !== null && f.getWritable();
      }
      if (u !== null) {
        const f = En(u);
        f !== null && f.getWritable();
      }
    }
  }
  function Fr() {
    return zs() ? null : gn()._compositionKey;
  }
  function En(u, o) {
    const f = (o || Ii())._nodeMap.get(u);
    return f === void 0 ? null : f;
  }
  function Ti(u, o) {
    const a = gn(), f = u[`__lexicalKey_${a._key}`];
    return f !== void 0 ? En(f, o) : null;
  }
  function Nr(u, o) {
    let a = u;
    for (; a != null; ) {
      const f = Ti(a, o);
      if (f !== null)
        return f;
      a = bs(a);
    }
    return null;
  }
  function vs(u) {
    const o = u._decorators, a = Object.assign({}, o);
    return u._pendingDecorators = a, a;
  }
  function co(u) {
    return u.read(() => Jn().getTextContent());
  }
  function Ss(u, o) {
    Lr(u, () => {
      const a = Ii();
      if (a.isEmpty())
        return;
      if (o === "root") {
        Jn().markDirty();
        return;
      }
      const f = a._nodeMap;
      for (const [, _] of f)
        _.markDirty();
    }, u._pendingEditorState === null ? {
      tag: "history-merge"
    } : void 0);
  }
  function Jn() {
    return xi(Ii());
  }
  function xi(u) {
    return u._nodeMap.get("root");
  }
  function br(u) {
    rr();
    const o = Ii();
    if (u !== null) {
      if (Object.isFrozen(u))
        throw Error("$setSelection called on frozen selection object. Ensure selection is cloned before passing in.");
      u.dirty = !0, u.setCachedNodes(null);
    }
    o._selection = u;
  }
  function ca() {
    rr();
    const u = gn();
    Ni(u);
  }
  function ii(u) {
    const o = gn(), a = ua(u, o);
    if (a === null) {
      const f = o.getRootElement();
      return u === f ? En("root") : null;
    }
    return En(a);
  }
  function ws(u, o) {
    return o ? u.getTextContentSize() : 0;
  }
  function ua(u, o) {
    let a = u;
    for (; a != null; ) {
      const f = a[`__lexicalKey_${o._key}`];
      if (f !== void 0)
        return f;
      a = bs(a);
    }
    return null;
  }
  function pl(u) {
    return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(u);
  }
  function Os(u) {
    const o = [];
    let a = u;
    for (; a !== null; )
      o.push(a), a = a._parentEditor;
    return o;
  }
  function $o() {
    return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 5);
  }
  function uo(u) {
    return u.nodeType === Ye ? u.nodeValue : null;
  }
  function Ds(u, o, a) {
    const f = Cr(o._window);
    if (f === null)
      return;
    const _ = f.anchorNode;
    let {
      anchorOffset: E,
      focusOffset: I
    } = f;
    if (_ !== null) {
      let B = uo(_);
      const le = Nr(_);
      if (B !== null && ft(le)) {
        if (B === Ut && a) {
          const fe = a.length;
          B = a, E = fe, I = fe;
        }
        B !== null && Fo(le, B, E, I, u);
      }
    }
  }
  function Fo(u, o, a, f, _) {
    let E = u;
    if (E.isAttached() && (_ || !E.isDirty())) {
      const I = E.isComposing();
      let B = o;
      (I || _) && o[o.length - 1] === Ut && (B = o.slice(0, -1));
      const le = E.getTextContent();
      if (_ || B !== le) {
        if (B === "") {
          if (_n(null), !oe && !ie && !ke) {
            const Ie = gn();
            setTimeout(() => {
              Ie.update(() => {
                E.isAttached() && E.remove();
              });
            }, 20);
          } else
            E.remove();
          return;
        }
        const fe = E.getParent(), Ne = Us(), Ee = E.getTextContentSize(), xe = Fr(), Ce = E.getKey();
        if (E.isToken() || xe !== null && Ce === xe && !I || // Check if character was added at the start or boundaries when not insertable, and we need
        // to clear this input from occurring as that action wasn't permitted.
        gt(Ne) && (fe !== null && !fe.canInsertTextBefore() && Ne.anchor.offset === 0 || Ne.anchor.key === u.__key && Ne.anchor.offset === 0 && !E.canInsertTextBefore() || Ne.focus.key === u.__key && Ne.focus.offset === Ee && !E.canInsertTextAfter())) {
          E.markDirty();
          return;
        }
        const He = an();
        if (!gt(He) || a === null || f === null) {
          E.setTextContent(B);
          return;
        }
        if (He.setTextNodeRange(E, a, E, f), E.isSegmented()) {
          const Ie = E.getTextContent(), be = Un(Ie);
          E.replace(be), E = be;
        }
        E.setTextContent(B);
      }
    }
  }
  function ml(u) {
    const o = u.getPreviousSibling();
    return (ft(o) || Je(o) && o.isInline()) && !o.canInsertTextAfter();
  }
  function oi(u, o) {
    if (o.isSegmented())
      return !0;
    if (!u.isCollapsed())
      return !1;
    const a = u.anchor.offset, f = o.getParentOrThrow(), _ = o.isToken();
    return a === 0 ? !o.canInsertTextBefore() || !f.canInsertTextBefore() || _ || ml(o) : a === o.getTextContentSize() ? !o.canInsertTextAfter() || !f.canInsertTextAfter() || _ : !1;
  }
  function _l(u, o, a, f) {
    return u === 9 && !o && !a && !f;
  }
  function Bo(u, o, a, f) {
    return u === 66 && !o && si(a, f);
  }
  function da(u, o, a, f) {
    return u === 73 && !o && si(a, f);
  }
  function fa(u, o, a, f) {
    return u === 85 && !o && si(a, f);
  }
  function fo(u, o) {
    return Ta(u) && !o;
  }
  function Ho(u, o) {
    return Ta(u) && o;
  }
  function yl(u, o) {
    return Te && o && u === 79;
  }
  function Nl(u, o, a) {
    return Br(u) && (Te ? o : a);
  }
  function Wo(u, o, a) {
    return Hr(u) && (Te ? o : a);
  }
  function Ko(u, o) {
    return Te && o && Br(u);
  }
  function ha(u, o) {
    return Te && o && Hr(u);
  }
  function ga(u, o, a, f) {
    return Te ? o || a ? !1 : Br(u) || u === 72 && f : f || o || a ? !1 : Br(u);
  }
  function pa(u, o, a, f, _) {
    return Te ? a || f || _ ? !1 : Hr(u) || u === 68 && o : o || f || _ ? !1 : Hr(u);
  }
  function ma(u, o, a, f) {
    return u === 90 && !o && si(a, f);
  }
  function Oc(u, o, a, f) {
    return Te ? u === 90 && a && o : u === 89 && f || u === 90 && f && o;
  }
  function Dc(u, o, a, f) {
    return o ? !1 : u === 67 ? Te ? a : f : !1;
  }
  function _a(u, o, a, f) {
    return o ? !1 : u === 88 ? Te ? a : f : !1;
  }
  function ya(u) {
    return u === 37;
  }
  function Na(u) {
    return u === 39;
  }
  function Rc(u) {
    return u === 38;
  }
  function bc(u) {
    return u === 40;
  }
  function Cl(u, o, a, f) {
    return ya(u) && !o && !f && !a;
  }
  function Mc(u, o, a, f, _) {
    return ya(u) && !f && !a && (o || _);
  }
  function Ac(u, o, a, f) {
    return Na(u) && !o && !f && !a;
  }
  function Ca(u, o, a, f, _) {
    return Na(u) && !f && !a && (o || _);
  }
  function ho(u, o, a) {
    return Rc(u) && !o && !a;
  }
  function Ea(u, o, a) {
    return bc(u) && !o && !a;
  }
  function kc(u, o, a, f) {
    return u || o || a || f;
  }
  function El(u) {
    return u === 32;
  }
  function si(u, o) {
    return Te ? u : o;
  }
  function Ta(u) {
    return u === 13;
  }
  function Br(u) {
    return u === 8;
  }
  function Lc(u) {
    return u === 27;
  }
  function Hr(u) {
    return u === 46;
  }
  function vi(u, o, a) {
    return u === 65 && si(o, a);
  }
  function Tl() {
    const u = Jn(), o = u.select(0, u.getChildrenSize());
    br(Ki(o));
  }
  function Ui(u, o) {
    u.__lexicalClassNameCache === void 0 && (u.__lexicalClassNameCache = {});
    const a = u.__lexicalClassNameCache, f = a[o];
    if (f !== void 0)
      return f;
    const _ = u[o];
    if (typeof _ == "string") {
      const E = _.split(" ");
      return a[o] = E, E;
    }
    return _;
  }
  function Uo(u, o, a, f, _) {
    if (a.size === 0)
      return;
    const E = f.__type, I = f.__key, B = o.get(E);
    if (B === void 0)
      throw Error(`Type ${E} not in registeredNodes`);
    const le = B.klass;
    let fe = u.get(le);
    fe === void 0 && (fe = /* @__PURE__ */ new Map(), u.set(le, fe));
    const Ne = fe.get(I), Ee = Ne === "destroyed" && _ === "created";
    (Ne === void 0 || Ee) && fe.set(I, Ee ? "updated" : _);
  }
  function xl(u) {
    const o = Ii(), a = o._readOnly, f = u.getType(), _ = o._nodeMap, E = [];
    for (const [, I] of _)
      I instanceof u && I.__type === f && (a || I.isAttached()) && E.push(I);
    return E;
  }
  function zo(u, o, a) {
    const f = u.getParent();
    let _ = a, E = u;
    return f !== null && (o && a === 0 ? (_ = E.getIndexWithinParent(), E = f) : !o && a === E.getChildrenSize() && (_ = E.getIndexWithinParent() + 1, E = f)), E.getChildAtIndex(o ? _ - 1 : _);
  }
  function li(u, o) {
    const a = u.offset;
    if (u.type === "element") {
      const f = u.getNode();
      return zo(f, o, a);
    } else {
      const f = u.getNode();
      if (o && a === 0 || !o && a === f.getTextContentSize()) {
        const _ = o ? f.getPreviousSibling() : f.getNextSibling();
        return _ === null ? zo(f.getParentOrThrow(), o, f.getIndexWithinParent() + (o ? 0 : 1)) : _;
      }
    }
    return null;
  }
  function xa(u) {
    const o = zi(u).event, a = o && o.inputType;
    return a === "insertFromPaste" || a === "insertFromPasteAsQuotation";
  }
  function ot(u, o, a) {
    return Zd(u, o, a);
  }
  function Go(u) {
    return !Ir(u) && !u.isLastChild() && !u.isInline();
  }
  function Rs(u, o) {
    const a = u._keyToDOMMap.get(o);
    if (a === void 0)
      throw Error(`Reconciliation: could not find DOM element for node key ${o}`);
    return a;
  }
  function bs(u) {
    const o = u.assignedSlot || u.parentElement;
    return o !== null && o.nodeType === 11 ? o.host : o;
  }
  function va(u, o, a) {
    const f = a.ownerDocument, _ = f.defaultView;
    if (_ === null)
      return;
    let {
      top: E,
      bottom: I
    } = o, B = 0, le = 0, fe = a;
    for (; fe !== null; ) {
      const Ne = fe === f.body;
      if (Ne)
        B = 0, le = zi(u).innerHeight;
      else {
        const xe = fe.getBoundingClientRect();
        B = xe.top, le = xe.bottom;
      }
      let Ee = 0;
      if (E < B ? Ee = -(B - E) : I > le && (Ee = I - le), Ee !== 0)
        if (Ne)
          _.scrollBy(0, Ee);
        else {
          const xe = fe.scrollTop;
          fe.scrollTop += Ee;
          const Ce = fe.scrollTop - xe;
          E -= Ce, I -= Ce;
        }
      if (Ne)
        break;
      fe = bs(fe);
    }
  }
  function Ic(u) {
    return gn()._updateTags.has(u);
  }
  function Si(u) {
    rr(), gn()._updateTags.add(u);
  }
  function Wn(u) {
    const o = an();
    if (!gt(o) || !Je(u))
      return o;
    const {
      anchor: a,
      focus: f
    } = o, _ = a.getNode(), E = f.getNode();
    return dt(_, u) && a.set(u.__key, 0, "element"), dt(E, u) && f.set(u.__key, 0, "element"), o;
  }
  function dt(u, o) {
    let a = u.getParent();
    for (; a !== null; ) {
      if (a.is(o))
        return !0;
      a = a.getParent();
    }
    return !1;
  }
  function go(u) {
    const o = u.ownerDocument;
    return o && o.defaultView || null;
  }
  function zi(u) {
    const o = u._window;
    if (o === null)
      throw Error("window object not found");
    return o;
  }
  function Sa(u) {
    return Je(u) && u.isInline() || Sn(u) && u.isInline();
  }
  function Mr(u) {
    let o = u.getParentOrThrow();
    for (; o !== null; ) {
      if (Wr(o))
        return o;
      o = o.getParentOrThrow();
    }
    return o;
  }
  function Wr(u) {
    return Ir(u) || Je(u) && u.isShadowRoot();
  }
  function vl(u) {
    const o = u.constructor.clone(u);
    return Hn(o, null), o;
  }
  function po(u) {
    const o = gn(), a = u.constructor.getType(), f = o._nodes.get(a);
    if (f === void 0)
      throw Error('$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the "nodes" array in the editor config.');
    const _ = f.replace;
    if (_ !== null) {
      const E = _(u);
      if (!(E instanceof u.constructor))
        throw Error("$initializeNode failed. Ensure replacement node is a subclass of the original node.");
      return E;
    }
    return u;
  }
  function Kr(u, o) {
    const a = u.getParent();
    if (Ir(a) && !Je(o) && !Sn(o))
      throw Error("Only element or decorator nodes can be inserted in to the root node");
  }
  function Sl(u) {
    const o = u.theme, a = document.createElement("div");
    a.contentEditable = "false", a.setAttribute("data-lexical-cursor", "true");
    let f = o.blockCursor;
    if (f !== void 0) {
      if (typeof f == "string") {
        const _ = f.split(" ");
        f = o.blockCursor = _;
      }
      f !== void 0 && a.classList.add(...f);
    }
    return a;
  }
  function mo(u) {
    return (Sn(u) || Je(u) && !u.canBeEmpty()) && !u.isInline();
  }
  function St(u, o, a) {
    a.style.removeProperty("caret-color"), o._blockCursorElement = null;
    const f = u.parentElement;
    f !== null && f.removeChild(u);
  }
  function wl(u, o, a) {
    let f = u._blockCursorElement;
    if (gt(a) && a.isCollapsed() && a.anchor.type === "element" && o.contains(document.activeElement)) {
      const _ = a.anchor, E = _.getNode(), I = _.offset, B = E.getChildrenSize();
      let le = !1, fe = null;
      if (I === B) {
        const Ne = E.getChildAtIndex(I - 1);
        mo(Ne) && (le = !0);
      } else {
        const Ne = E.getChildAtIndex(I);
        if (mo(Ne)) {
          const Ee = Ne.getPreviousSibling();
          (Ee === null || mo(Ee)) && (le = !0, fe = u.getElementByKey(Ne.__key));
        }
      }
      if (le) {
        const Ne = u.getElementByKey(E.__key);
        f === null && (u._blockCursorElement = f = Sl(u._config)), o.style.caretColor = "transparent", fe === null ? Ne.appendChild(f) : Ne.insertBefore(f, fe);
        return;
      }
    }
    f !== null && St(f, u, o);
  }
  function Cr(u) {
    return ge ? (u || window).getSelection() : null;
  }
  function Ms(u, o) {
    let a = u.getChildAtIndex(o);
    if (a == null && (a = u), Wr(u))
      throw Error("Can not call $splitNode() on root element");
    const f = (I) => {
      const B = I.getParentOrThrow(), le = Wr(B), fe = I === a && !le ? I : vl(I);
      if (le)
        return I.insertAfter(fe), [I, fe, fe];
      {
        const [Ne, Ee, xe] = f(B), Ce = I.getNextSiblings();
        return xe.append(fe, ...Ce), [Ne, Ee, fe];
      }
    }, [_, E] = f(a);
    return [_, E];
  }
  function Yo(u, o) {
    let a = u;
    for (; a !== Jn() && a != null; ) {
      if (o(a))
        return a;
      a = a.getParent();
    }
    return null;
  }
  function Gi(u) {
    const o = [], a = [u];
    for (; a.length > 0; ) {
      const f = a.pop();
      if (f === void 0)
        throw Error("Stack.length > 0; can't be undefined");
      Je(f) && a.unshift(...f.getChildren()), f !== u && o.push(f);
    }
    return o;
  }
  function Vo(u) {
    return jo(u) && u.tagName === "A";
  }
  function jo(u) {
    return u.nodeType === 1;
  }
  function Yi(u) {
    if (Sn(u) && !u.isInline())
      return !0;
    if (!Je(u) || Wr(u))
      return !1;
    const o = u.getFirstChild(), a = o === null || Mi(o) || ft(o) || o.isInline();
    return !u.isInline() && u.canBeEmpty() !== !1 && a;
  }
  function As(u, o) {
    let a = u;
    for (; a !== null && a.getParent() !== null && !o(a); )
      a = a.getParentOrThrow();
    return o(a) ? a : null;
  }
  function wa(u, o) {
    const a = u._decorators;
    let _ = u._pendingDecorators || a;
    const E = o._nodeMap;
    let I;
    for (I in _)
      E.has(I) || (_ === a && (_ = vs(u)), delete _[I]);
  }
  function Ol(u, o, a, f, _, E) {
    let I = u.getFirstChild();
    for (; I !== null; ) {
      const B = I.__key;
      I.__parent === o && (Je(I) && Ol(I, B, a, f, _, E), a.has(B) || E.delete(B), _.push(B)), I = I.getNextSibling();
    }
  }
  function Oa(u, o, a, f) {
    const _ = u._nodeMap, E = o._nodeMap, I = [];
    for (const [B] of f) {
      const le = E.get(B);
      le !== void 0 && (le.isAttached() || (Je(le) && Ol(le, B, _, E, I, f), _.has(B) || f.delete(B), I.push(B)));
    }
    for (const B of I)
      E.delete(B);
    for (const B of a) {
      const le = E.get(B);
      le !== void 0 && !le.isAttached() && (_.has(B) || a.delete(B), E.delete(B));
    }
  }
  let Tn = "", Vn = "", Ar = "", wi, Kn, Vt, Vi = !1, _o = !1, qo, ks = null, yo, Ls, Oi, ai, Zo, Jo;
  function yn(u, o) {
    const a = Oi.get(u);
    if (o !== null) {
      const f = ln(u);
      f.parentNode === o && o.removeChild(f);
    }
    if (ai.has(u) || Kn._keyToDOMMap.delete(u), Je(a)) {
      const f = Co(a, Oi);
      xn(f, 0, f.length - 1, null);
    }
    a !== void 0 && Uo(Jo, Vt, qo, a, "destroyed");
  }
  function xn(u, o, a, f) {
    let _ = o;
    for (; _ <= a; ++_) {
      const E = u[_];
      E !== void 0 && yn(E, f);
    }
  }
  function vn(u, o) {
    u.setProperty("text-align", o);
  }
  const Dl = "40px";
  function No(u, o) {
    const a = wi.theme.indent;
    if (typeof a == "string") {
      const _ = u.classList.contains(a);
      o > 0 && !_ ? u.classList.add(a) : o < 1 && _ && u.classList.remove(a);
    }
    const f = getComputedStyle(u).getPropertyValue("--lexical-indent-base-value") || Dl;
    u.style.setProperty("padding-inline-start", o === 0 ? "" : `calc(${o} * ${f})`);
  }
  function Rl(u, o) {
    const a = u.style;
    o === 0 ? vn(a, "") : o === mt ? vn(a, "left") : o === Ct ? vn(a, "center") : o === vt ? vn(a, "right") : o === wt ? vn(a, "justify") : o === Dt ? vn(a, "start") : o === Tt && vn(a, "end");
  }
  function ci(u, o, a) {
    const f = ai.get(u);
    if (f === void 0)
      throw Error("createNode: node does not exist in nodeMap");
    const _ = f.createDOM(wi, Kn);
    if (Ma(u, _, Kn), ft(f) ? _.setAttribute("data-lexical-text", "true") : Sn(f) && _.setAttribute("data-lexical-decorator", "true"), Je(f)) {
      const E = f.__indent, I = f.__size;
      if (E !== 0 && No(_, E), I !== 0) {
        const le = I - 1, fe = Co(f, ai);
        Xn(fe, le, f, _);
      }
      const B = f.__format;
      B !== 0 && Rl(_, B), f.isInline() || bl(null, f, _), Go(f) && (Tn += Lt, Ar += Lt);
    } else {
      const E = f.getTextContent();
      if (Sn(f)) {
        const I = f.decorate(Kn, wi);
        I !== null && Eo(u, I), _.contentEditable = "false";
      } else
        ft(f) && (f.isDirectionless() || (Vn += E));
      Tn += E, Ar += E;
    }
    if (o !== null)
      if (a != null)
        o.insertBefore(_, a);
      else {
        const E = o.__lexicalLineBreak;
        E != null ? o.insertBefore(_, E) : o.appendChild(_);
      }
    return Object.freeze(f), Uo(Jo, Vt, qo, f, "created"), _;
  }
  function Xn(u, o, a, f) {
    const _ = Vn;
    Vn = "", Er(u, a, 0, o, f, null), Da(a, f), Vn = _;
  }
  function Er(u, o, a, f, _, E) {
    const I = Tn;
    Tn = "";
    let B = a;
    for (; B <= f; ++B)
      ci(u[B], _, E);
    Go(o) && (Tn += Lt), _.__lexicalTextContent = Tn, Tn = I + Tn;
  }
  function sn(u, o) {
    const a = o.get(u);
    return Mi(a) || Sn(a) && a.isInline();
  }
  function bl(u, o, a) {
    const f = u !== null && (u.__size === 0 || sn(u.__last, Oi)), _ = o.__size === 0 || sn(o.__last, ai);
    if (f) {
      if (!_) {
        const E = a.__lexicalLineBreak;
        E != null && a.removeChild(E), a.__lexicalLineBreak = null;
      }
    } else if (_) {
      const E = document.createElement("br");
      a.__lexicalLineBreak = E, a.appendChild(E);
    }
  }
  function Da(u, o) {
    const a = (
      // @ts-expect-error: internal field
      o.__lexicalDirTextContent
    ), f = o.__lexicalDir;
    if (a !== Vn || f !== ks) {
      const _ = Vn === "", E = _ ? ks : aa(Vn);
      if (E !== f) {
        const I = o.classList, B = wi.theme;
        let le = f !== null ? B[f] : void 0, fe = E !== null ? B[E] : void 0;
        if (le !== void 0) {
          if (typeof le == "string") {
            const Ne = le.split(" ");
            le = B[f] = Ne;
          }
          I.remove(...le);
        }
        if (E === null || _ && E === "ltr")
          o.removeAttribute("dir");
        else {
          if (fe !== void 0) {
            if (typeof fe == "string") {
              const Ne = fe.split(" ");
              fe = B[E] = Ne;
            }
            fe !== void 0 && I.add(...fe);
          }
          o.dir = E;
        }
        if (!_o) {
          const Ne = u.getWritable();
          Ne.__dir = E;
        }
      }
      ks = E, o.__lexicalDirTextContent = Vn, o.__lexicalDir = E;
    }
  }
  function Pc(u, o, a) {
    const f = Vn;
    Vn = "", Ra(u, o, a), Da(o, a), Vn = f;
  }
  function Co(u, o) {
    const a = [];
    let f = u.__first;
    for (; f !== null; ) {
      const _ = o.get(f);
      if (_ === void 0)
        throw Error("createChildrenArray: node does not exist in nodeMap");
      a.push(f), f = _.__next;
    }
    return a;
  }
  function Ra(u, o, a) {
    const f = Tn, _ = u.__size, E = o.__size;
    if (Tn = "", _ === 1 && E === 1) {
      const I = u.__first, B = o.__first;
      if (I === B)
        kr(I, a);
      else {
        const le = ln(I), fe = ci(B, null, null);
        a.replaceChild(fe, le), yn(I, null);
      }
    } else {
      const I = Co(u, Oi), B = Co(o, ai);
      if (_ === 0)
        E !== 0 && Er(B, o, 0, E - 1, a, null);
      else if (E === 0) {
        if (_ !== 0) {
          const fe = a.__lexicalLineBreak == null;
          xn(I, 0, _ - 1, fe ? null : a), fe && (a.textContent = "");
        }
      } else
        ba(o, I, B, _, E, a);
    }
    Go(o) && (Tn += Lt), a.__lexicalTextContent = Tn, Tn = f + Tn;
  }
  function kr(u, o) {
    const a = Oi.get(u);
    let f = ai.get(u);
    if (a === void 0 || f === void 0)
      throw Error("reconcileNode: prevNode or nextNode does not exist in nodeMap");
    const _ = Vi || Ls.has(u) || yo.has(u), E = Rs(Kn, u);
    if (a === f && !_) {
      if (Je(a)) {
        const I = E.__lexicalTextContent;
        I !== void 0 && (Tn += I, Ar += I);
        const B = E.__lexicalDirTextContent;
        B !== void 0 && (Vn += B);
      } else {
        const I = a.getTextContent();
        ft(a) && !a.isDirectionless() && (Vn += I), Ar += I, Tn += I;
      }
      return E;
    }
    if (a !== f && _ && Uo(Jo, Vt, qo, f, "updated"), f.updateDOM(a, E, wi)) {
      const I = ci(u, null, null);
      if (o === null)
        throw Error("reconcileNode: parentDOM is null");
      return o.replaceChild(I, E), yn(u, null), I;
    }
    if (Je(a) && Je(f)) {
      const I = f.__indent;
      I !== a.__indent && No(E, I);
      const B = f.__format;
      B !== a.__format && Rl(E, B), _ && (Pc(a, f, E), !Ir(f) && !f.isInline() && bl(a, f, E)), Go(f) && (Tn += Lt, Ar += Lt);
    } else {
      const I = f.getTextContent();
      if (Sn(f)) {
        const B = f.decorate(Kn, wi);
        B !== null && Eo(u, B);
      } else
        ft(f) && !f.isDirectionless() && (Vn += I);
      Tn += I, Ar += I;
    }
    return !_o && Ir(f) && f.__cachedText !== Ar && (f = f.getWritable(), f.__cachedText = Ar), Object.freeze(f), E;
  }
  function Eo(u, o) {
    let a = Kn._pendingDecorators;
    const f = Kn._decorators;
    if (a === null) {
      if (f[u] === o)
        return;
      a = vs(Kn);
    }
    a[u] = o;
  }
  function it(u) {
    return u.firstChild;
  }
  function Is(u) {
    let o = u.nextSibling;
    return o !== null && o === Kn._blockCursorElement && (o = o.nextSibling), o;
  }
  function ba(u, o, a, f, _, E) {
    const I = f - 1, B = _ - 1;
    let le, fe, Ne = it(E), Ee = 0, xe = 0;
    for (; Ee <= I && xe <= B; ) {
      const Ie = o[Ee], be = a[xe];
      if (Ie === be)
        Ne = Is(kr(be, E)), Ee++, xe++;
      else {
        le === void 0 && (le = new Set(o)), fe === void 0 && (fe = new Set(a));
        const pt = fe.has(Ie), Ue = le.has(be);
        if (!pt)
          Ne = Is(ln(Ie)), yn(Ie, E), Ee++;
        else if (!Ue)
          ci(be, E, Ne), xe++;
        else {
          const tt = Rs(Kn, be);
          tt === Ne ? Ne = Is(kr(be, E)) : (Ne != null ? E.insertBefore(tt, Ne) : E.appendChild(tt), kr(be, E)), Ee++, xe++;
        }
      }
    }
    const Ce = Ee > I, He = xe > B;
    if (Ce && !He) {
      const Ie = a[B + 1], be = Ie === void 0 ? null : Kn.getElementByKey(Ie);
      Er(a, u, xe, B, E, be);
    } else
      He && !Ce && xn(o, Ee, I, E);
  }
  function lr(u, o, a, f, _, E) {
    Tn = "", Ar = "", Vn = "", Vi = f === ct, ks = null, Kn = a, wi = a._config, Vt = a._nodes, qo = Kn._listeners.mutation, yo = _, Ls = E, Oi = u._nodeMap, ai = o._nodeMap, _o = o._readOnly, Zo = new Map(a._keyToDOMMap);
    const I = /* @__PURE__ */ new Map();
    return Jo = I, kr("root", null), Kn = void 0, Vt = void 0, yo = void 0, Ls = void 0, Oi = void 0, ai = void 0, wi = void 0, Zo = void 0, Jo = void 0, I;
  }
  function Ma(u, o, a) {
    const f = a._keyToDOMMap;
    o["__lexicalKey_" + a._key] = u, f.set(u, o);
  }
  function ln(u) {
    const o = Zo.get(u);
    if (o === void 0)
      throw Error(`Reconciliation: could not find DOM element for node key ${u}`);
    return o;
  }
  const Qn = Object.freeze({}), Ze = 30, Ps = [["keydown", S], ["pointerdown", Ia], ["compositionstart", s], ["compositionend", C], ["input", i], ["click", Tr], ["cut", Qn], ["copy", Qn], ["dragstart", Qn], ["dragover", Qn], ["dragend", Qn], ["paste", Qn], ["focus", Qn], ["blur", Qn], ["drop", Qn]];
  ze && Ps.push(["beforeinput", (u, o) => l(u, o)]);
  let Ur = 0, nr = 0, Aa = 0, Di = null, To = 0, xo = !1, Ri = !1, Xo = !1, ar = !1, Ml = [0, "", 0, "root", 0];
  function ka(u, o, a, f, _) {
    const E = u.anchor, I = u.focus, B = E.getNode(), le = gn(), fe = Cr(le._window), Ne = fe !== null ? fe.anchorNode : null, Ee = E.key, xe = le.getElementByKey(Ee), Ce = a.length;
    return Ee !== I.key || // If we're working with a non-text node.
    !ft(B) || // If we are replacing a range with a single character or grapheme, and not composing.
    (!_ && (!ze || // We check to see if there has been
    // a recent beforeinput event for "textInput". If there has been one in the last
    // 50ms then we proceed as normal. However, if there is not, then this is likely
    // a dangling `input` event caused by execCommand('insertText').
    Aa < f + 50) || B.isDirty() && Ce < 2 || pl(a)) && E.offset !== I.offset && !B.isComposing() || // Any non standard text node.
    gl(B) || // If the text length is more than a single character and we're either
    // dealing with this in "beforeinput" or where the node has already recently
    // been changed (thus is dirty).
    B.isDirty() && Ce > 1 || // If the DOM selection element is not the same as the backing node during beforeinput.
    (_ || !ze) && xe !== null && !B.isComposing() && Ne !== Ln(xe) || // If TargetRange is not the same as the DOM selection; browser trying to edit random parts
    // of the editor.
    fe !== null && o !== null && (!o.collapsed || o.startContainer !== fe.anchorNode || o.startOffset !== fe.anchorOffset) || // Check if we're changing from bold to italics, or some other format.
    B.getFormat() !== u.format || B.getStyle() !== u.style || // One last set of heuristics to check against.
    oi(u, B);
  }
  function La(u, o) {
    return u !== null && u.nodeValue !== null && u.nodeType === Ye && o !== 0 && o !== u.nodeValue.length;
  }
  function $s(u, o, a) {
    const {
      anchorNode: f,
      anchorOffset: _,
      focusNode: E,
      focusOffset: I
    } = u;
    xo && (xo = !1, La(f, _) && La(E, I)) || Lr(o, () => {
      if (!a) {
        br(null);
        return;
      }
      if (!ri(o, f, E))
        return;
      const B = an();
      if (gt(B)) {
        const le = B.anchor, fe = le.getNode();
        if (B.isCollapsed()) {
          u.type === "Range" && u.anchorNode === u.focusNode && (B.dirty = !0);
          const Ne = zi(o).event, Ee = Ne ? Ne.timeStamp : performance.now(), [xe, Ce, He, Ie, be] = Ml, pt = Jn(), Ue = o.isComposing() === !1 && pt.getTextContent() === "";
          Ee < be + 200 && le.offset === He && le.key === Ie ? (B.format = xe, B.style = Ce) : le.type === "text" ? (B.format = fe.getFormat(), B.style = fe.getStyle()) : le.type === "element" && !Ue && (B.format = 0, B.style = "");
        } else {
          let Ne = Ve, Ee = !1;
          const xe = B.getNodes(), Ce = xe.length;
          for (let He = 0; He < Ce; He++) {
            const Ie = xe[He];
            if (ft(Ie) && (Ee = !0, Ne &= Ie.getFormat(), Ne === 0))
              break;
          }
          B.format = Ee ? Ne : 0;
        }
      }
      ot(o, e, void 0);
    });
  }
  function Tr(u, o) {
    Lr(o, () => {
      const a = an(), f = Cr(o._window), _ = Us();
      if (f) {
        if (gt(a)) {
          const E = a.anchor, I = E.getNode();
          if (E.type === "element" && E.offset === 0 && a.isCollapsed() && !Ir(I) && Jn().getChildrenSize() === 1 && I.getTopLevelElementOrThrow().isEmpty() && _ !== null && a.is(_))
            f.removeAllRanges(), a.dirty = !0;
          else if (u.detail === 3 && !a.isCollapsed()) {
            const le = a.focus.getNode();
            I !== le && (Je(I) ? I.select(0) : I.getParentOrThrow().select(0));
          }
        } else if (u.pointerType === "touch") {
          const E = f.anchorNode;
          if (E !== null) {
            const I = E.nodeType;
            if (I === Be || I === Ye) {
              const B = Fc(_, f, o);
              br(B);
            }
          }
        }
      }
      ot(o, n, u);
    });
  }
  function Ia(u, o) {
    const a = u.target, f = u.pointerType;
    a instanceof Node && f !== "touch" && Lr(o, () => {
      wc(a) || (Ri = !0);
    });
  }
  function Fs(u) {
    if (!u.getTargetRanges)
      return null;
    const o = u.getTargetRanges();
    return o.length === 0 ? null : o[0];
  }
  function Pa(u, o) {
    return u !== o || Je(u) || Je(o) || !u.isToken() || !o.isToken();
  }
  function Qo(u) {
    return nr === 229 && u < Ur + Ze;
  }
  function l(u, o) {
    const a = u.inputType, f = Fs(u);
    a === "deleteCompositionText" || // If we're pasting in FF, we shouldn't get this event
    // as the `paste` event should have triggered, unless the
    // user has dom.event.clipboardevents.enabled disabled in
    // about:config. In that case, we need to process the
    // pasted content in the DOM mutation phase.
    Ae && xa(o) || a !== "insertCompositionText" && Lr(o, () => {
      const _ = an();
      if (a === "deleteContentBackward") {
        if (_ === null) {
          const Ne = Us();
          if (!gt(Ne))
            return;
          br(Ne.clone());
        }
        if (gt(_)) {
          if (de && _n(_.anchor.key), Qo(u.timeStamp) && o.isComposing() && _.anchor.key === _.focus.key) {
            if (_n(null), Ur = 0, setTimeout(() => {
              Lr(o, () => {
                _n(null);
              });
            }, Ze), gt(_)) {
              const Ee = _.anchor.getNode();
              Ee.markDirty(), _.format = Ee.getFormat(), _.style = Ee.getStyle();
            }
            _.anchor.getNode().getTextContent().length <= 1 && (u.preventDefault(), ot(o, r, !0));
          } else
            u.preventDefault(), ot(o, r, !0);
          return;
        }
      }
      if (!gt(_))
        return;
      const E = u.data;
      Di !== null && Ds(!1, o, Di), (!_.dirty || Di !== null) && _.isCollapsed() && !Ir(_.anchor.getNode()) && f !== null && _.applyDOMRange(f), Di = null;
      const I = _.anchor, B = _.focus, le = I.getNode(), fe = B.getNode();
      if (a === "insertText" || a === "insertTranspose") {
        if (E === `
`)
          u.preventDefault(), ot(o, c, !1);
        else if (E === Lt)
          u.preventDefault(), ot(o, d, void 0);
        else if (E == null && u.dataTransfer) {
          const Ne = u.dataTransfer.getData("text/plain");
          u.preventDefault(), _.insertRawText(Ne);
        } else
          E != null && ka(_, f, E, u.timeStamp, !0) ? (u.preventDefault(), ot(o, h, E)) : Di = E;
        Aa = u.timeStamp;
        return;
      }
      switch (u.preventDefault(), a) {
        case "insertFromYank":
        case "insertFromDrop":
        case "insertReplacementText": {
          ot(o, h, u);
          break;
        }
        case "insertFromComposition": {
          _n(null), ot(o, h, u);
          break;
        }
        case "insertLineBreak": {
          _n(null), ot(o, c, !1);
          break;
        }
        case "insertParagraph": {
          _n(null), Xo && !ie ? (Xo = !1, ot(o, c, !1)) : ot(o, d, void 0);
          break;
        }
        case "insertFromPaste":
        case "insertFromPasteAsQuotation": {
          ot(o, p, u);
          break;
        }
        case "deleteByComposition": {
          Pa(le, fe) && ot(o, N, u);
          break;
        }
        case "deleteByDrag":
        case "deleteByCut": {
          ot(o, N, u);
          break;
        }
        case "deleteContent": {
          ot(o, r, !1);
          break;
        }
        case "deleteWordBackward": {
          ot(o, x, !0);
          break;
        }
        case "deleteWordForward": {
          ot(o, x, !1);
          break;
        }
        case "deleteHardLineBackward":
        case "deleteSoftLineBackward": {
          ot(o, v, !0);
          break;
        }
        case "deleteContentForward":
        case "deleteHardLineForward":
        case "deleteSoftLineForward": {
          ot(o, v, !1);
          break;
        }
        case "formatStrikeThrough": {
          ot(o, O, "strikethrough");
          break;
        }
        case "formatBold": {
          ot(o, O, "bold");
          break;
        }
        case "formatItalic": {
          ot(o, O, "italic");
          break;
        }
        case "formatUnderline": {
          ot(o, O, "underline");
          break;
        }
        case "historyUndo": {
          ot(o, M, void 0);
          break;
        }
        case "historyRedo": {
          ot(o, A, void 0);
          break;
        }
      }
    });
  }
  function i(u, o) {
    u.stopPropagation(), Lr(o, () => {
      const a = an(), f = u.data, _ = Fs(u);
      if (f != null && gt(a) && ka(a, _, f, u.timeStamp, !1)) {
        ar && (g(o, f), ar = !1);
        const E = a.anchor, I = E.getNode(), B = Cr(o._window);
        if (B === null)
          return;
        const le = E.offset;
        (!ze || a.isCollapsed() || !ft(I) || B.anchorNode === null || I.getTextContent().slice(0, le) + f + I.getTextContent().slice(le + a.focus.offset) !== uo(B.anchorNode)) && ot(o, h, f);
        const fe = f.length;
        Ae && fe > 1 && u.inputType === "insertCompositionText" && !o.isComposing() && (a.anchor.offset -= fe), !oe && !ie && !ke && o.isComposing() && (Ur = 0, _n(null));
      } else
        Ds(!1, o, f !== null ? f : void 0), ar && (g(o, f || void 0), ar = !1);
      ca();
    }), Di = null;
  }
  function s(u, o) {
    Lr(o, () => {
      const a = an();
      if (gt(a) && !o.isComposing()) {
        const f = a.anchor, _ = a.anchor.getNode();
        _n(f.key), // If it has been 30ms since the last keydown, then we should
        // apply the empty space heuristic. We can't do this for Safari,
        // as the keydown fires after composition start.
        (u.timeStamp < Ur + Ze || // FF has issues around composing multibyte characters, so we also
        // need to invoke the empty space heuristic below.
        f.type === "element" || !a.isCollapsed() || _.getFormat() !== a.format || _.getStyle() !== a.style) && ot(o, h, mr);
      }
    });
  }
  function g(u, o) {
    const a = u._compositionKey;
    if (_n(null), a !== null && o != null) {
      if (o === "") {
        const f = En(a), _ = Ln(u.getElementByKey(a));
        _ !== null && _.nodeValue !== null && ft(f) && Fo(f, _.nodeValue, null, null, !0);
        return;
      }
      if (o[o.length - 1] === `
`) {
        const f = an();
        if (gt(f)) {
          const _ = f.focus;
          f.anchor.set(_.key, _.offset, _.type), ot(u, z, null);
          return;
        }
      }
    }
    Ds(!0, u, o);
  }
  function C(u, o) {
    Ae ? ar = !0 : Lr(o, () => {
      g(o, u.data);
    });
  }
  function S(u, o) {
    if (Ur = u.timeStamp, nr = u.keyCode, o.isComposing())
      return;
    const {
      keyCode: a,
      shiftKey: f,
      ctrlKey: _,
      metaKey: E,
      altKey: I
    } = u;
    if (!ot(o, T, u)) {
      if (Ac(a, _, I, E))
        ot(o, w, u);
      else if (Ca(a, _, f, I, E))
        ot(o, P, u);
      else if (Cl(a, _, I, E))
        ot(o, K, u);
      else if (Mc(a, _, f, I, E))
        ot(o, $, u);
      else if (ho(a, _, E))
        ot(o, W, u);
      else if (Ea(a, _, E))
        ot(o, H, u);
      else if (Ho(a, f))
        Xo = !0, ot(o, z, u);
      else if (El(a))
        ot(o, te, u);
      else if (yl(a, _))
        u.preventDefault(), Xo = !0, ot(o, c, !0);
      else if (fo(a, f))
        Xo = !1, ot(o, z, u);
      else if (ga(a, I, E, _))
        Br(a) ? ot(o, re, u) : (u.preventDefault(), ot(o, r, !0));
      else if (Lc(a))
        ot(o, ue, u);
      else if (pa(a, _, f, I, E))
        Hr(a) ? ot(o, q, u) : (u.preventDefault(), ot(o, r, !1));
      else if (Nl(a, I, _))
        u.preventDefault(), ot(o, x, !0);
      else if (Wo(a, I, _))
        u.preventDefault(), ot(o, x, !1);
      else if (Ko(a, E))
        u.preventDefault(), ot(o, v, !0);
      else if (ha(a, E))
        u.preventDefault(), ot(o, v, !1);
      else if (Bo(a, I, E, _))
        u.preventDefault(), ot(o, O, "bold");
      else if (fa(a, I, E, _))
        u.preventDefault(), ot(o, O, "underline");
      else if (da(a, I, E, _))
        u.preventDefault(), ot(o, O, "italic");
      else if (_l(a, I, _, E))
        ot(o, G, u);
      else if (ma(a, f, E, _))
        u.preventDefault(), ot(o, M, void 0);
      else if (Oc(a, f, E, _))
        u.preventDefault(), ot(o, A, void 0);
      else {
        const B = o._editorState._selection;
        vr(B) ? Dc(a, f, E, _) ? (u.preventDefault(), ot(o, ne, u)) : _a(a, f, E, _) ? (u.preventDefault(), ot(o, Y, u)) : vi(a, E, _) && (u.preventDefault(), ot(o, U, u)) : !Ae && vi(a, E, _) && (u.preventDefault(), ot(o, U, u));
      }
      kc(_, f, I, E) && ot(o, ce, u);
    }
  }
  function R(u) {
    let o = u.__lexicalEventHandles;
    return o === void 0 && (o = [], u.__lexicalEventHandles = o), o;
  }
  const X = /* @__PURE__ */ new Map();
  function me(u) {
    const o = u.target, a = o == null ? null : o.nodeType === 9 ? o.defaultView : o.ownerDocument.defaultView, f = Cr(a);
    if (f === null)
      return;
    const _ = Io(f.anchorNode);
    if (_ === null)
      return;
    Ri && (Ri = !1, Lr(_, () => {
      const Ne = Us(), Ee = f.anchorNode;
      if (Ee === null)
        return;
      const xe = Ee.nodeType;
      if (xe !== Be && xe !== Ye)
        return;
      const Ce = Fc(Ne, f, _);
      br(Ce);
    }));
    const E = Os(_), I = E[E.length - 1], B = I._key, le = X.get(B), fe = le || I;
    fe !== _ && $s(f, fe, !1), $s(f, _, !0), _ !== I ? X.set(B, _) : le && X.delete(B);
  }
  function Se(u) {
    u._lexicalHandled = !0;
  }
  function Fe(u) {
    return u._lexicalHandled === !0;
  }
  function Ke(u, o) {
    To === 0 && u.ownerDocument.addEventListener("selectionchange", me), To++, u.__lexicalEditor = o;
    const a = R(u);
    for (let f = 0; f < Ps.length; f++) {
      const [_, E] = Ps[f], I = typeof E == "function" ? (B) => {
        Fe(B) || (Se(B), o.isEditable() && E(B, o));
      } : (B) => {
        if (!Fe(B) && (Se(B), o.isEditable()))
          switch (_) {
            case "cut":
              return ot(o, Y, B);
            case "copy":
              return ot(o, ne, B);
            case "paste":
              return ot(o, p, B);
            case "dragstart":
              return ot(o, F, B);
            case "dragover":
              return ot(o, D, B);
            case "dragend":
              return ot(o, V, B);
            case "focus":
              return ot(o, b, B);
            case "blur":
              return ot(o, Z, B);
            case "drop":
              return ot(o, J, B);
          }
      };
      u.addEventListener(_, I), a.push(() => {
        u.removeEventListener(_, I);
      });
    }
  }
  function Le(u) {
    To !== 0 && (To--, To === 0 && u.ownerDocument.removeEventListener("selectionchange", me));
    const o = u.__lexicalEditor;
    o != null && (Re(o), u.__lexicalEditor = null);
    const a = R(u);
    for (let f = 0; f < a.length; f++)
      a[f]();
    u.__lexicalEventHandles = [];
  }
  function Re(u) {
    if (u._parentEditor !== null) {
      const o = Os(u), f = o[o.length - 1]._key;
      X.get(f) === u && X.delete(f);
    } else
      X.delete(u._key);
  }
  function Xe() {
    xo = !0;
  }
  function at(u, o, a, f, _) {
    Ml = [u, o, a, f, _];
  }
  function Et(u, o, a) {
    rr();
    const f = u.__key, _ = u.getParent();
    if (_ === null)
      return;
    const E = Wn(u);
    let I = !1;
    if (gt(E) && o) {
      const B = E.anchor, le = E.focus;
      B.key === f && (za(B, u, _, u.getPreviousSibling(), u.getNextSibling()), I = !0), le.key === f && (za(le, u, _, u.getPreviousSibling(), u.getNextSibling()), I = !0);
    } else
      vr(E) && o && u.isSelected() && u.selectPrevious();
    if (gt(E) && o && !I) {
      const B = u.getIndexWithinParent();
      Ei(u), Ua(E, _, B, -1);
    } else
      Ei(u);
    !a && !Wr(_) && !_.canBeEmpty() && _.isEmpty() && Et(_, o), o && Ir(_) && _.isEmpty() && _.selectEnd();
  }
  class Rt {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    /** @internal */
    /** @internal */
    //@ts-ignore We set the key in the constructor.
    /** @internal */
    /** @internal */
    /** @internal */
    // Flow doesn't support abstract classes unfortunately, so we can't _force_
    // subclasses of Node to implement statics. All subclasses of Node should have
    // a static getType and clone method though. We define getType and clone here so we can call it
    // on any  Node, and we throw this error by default since the subclass should provide
    // their own implementation.
    /**
     * Returns the string type of this node. Every node must
     * implement this and it MUST BE UNIQUE amongst nodes registered
     * on the editor.
     *
     */
    static getType() {
      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);
    }
    /**
     * Clones this node, creating a new node with a different key
     * and adding it to the EditorState (but not attaching it anywhere!). All nodes must
     * implement this method.
     *
     */
    static clone(o) {
      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);
    }
    constructor(o) {
      this.__type = this.constructor.getType(), this.__parent = null, this.__prev = null, this.__next = null, Hn(this, o), this.__type !== "root" && (rr(), hn(
        this.__type,
        // @ts-expect-error
        this.constructor
      ));
    }
    // Getters and Traversers
    /**
     * Returns the string type of this node.
     */
    getType() {
      return this.__type;
    }
    /**
     * Returns true if there is a path between this node and the RootNode, false otherwise.
     * This is a way of determining if the node is "attached" EditorState. Unattached nodes
     * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.
     */
    isAttached() {
      let o = this.__key;
      for (; o !== null; ) {
        if (o === "root")
          return !0;
        const a = En(o);
        if (a === null)
          break;
        o = a.__parent;
      }
      return !1;
    }
    /**
     * Returns true if this node is contained within the provided Selection., false otherwise.
     * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine
     * what's included.
     *
     * @param selection - The selection that we want to determine if the node is in.
     */
    isSelected(o) {
      const a = o || an();
      if (a == null)
        return !1;
      const f = a.getNodes().some((_) => _.__key === this.__key);
      return ft(this) ? f : gt(a) && a.anchor.type === "element" && a.focus.type === "element" && a.anchor.key === a.focus.key && a.anchor.offset === a.focus.offset ? !1 : f;
    }
    /**
     * Returns this nodes key.
     */
    getKey() {
      return this.__key;
    }
    /**
     * Returns the zero-based index of this node within the parent.
     */
    getIndexWithinParent() {
      const o = this.getParent();
      if (o === null)
        return -1;
      let a = o.getFirstChild(), f = 0;
      for (; a !== null; ) {
        if (this.is(a))
          return f;
        f++, a = a.getNextSibling();
      }
      return -1;
    }
    /**
     * Returns the parent of this node, or null if none is found.
     */
    getParent() {
      const o = this.getLatest().__parent;
      return o === null ? null : En(o);
    }
    /**
     * Returns the parent of this node, or throws if none is found.
     */
    getParentOrThrow() {
      const o = this.getParent();
      if (o === null)
        throw Error(`Expected node ${this.__key} to have a parent.`);
      return o;
    }
    /**
     * Returns the highest (in the EditorState tree)
     * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}
     * for more information on which Elements comprise "roots".
     */
    getTopLevelElement() {
      let o = this;
      for (; o !== null; ) {
        const a = o.getParent();
        if (Wr(a))
          return o;
        o = a;
      }
      return null;
    }
    /**
     * Returns the highest (in the EditorState tree)
     * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}
     * for more information on which Elements comprise "roots".
     */
    getTopLevelElementOrThrow() {
      const o = this.getTopLevelElement();
      if (o === null)
        throw Error(`Expected node ${this.__key} to have a top parent element.`);
      return o;
    }
    /**
     * Returns a list of the every ancestor of this node,
     * all the way up to the RootNode.
     *
     */
    getParents() {
      const o = [];
      let a = this.getParent();
      for (; a !== null; )
        o.push(a), a = a.getParent();
      return o;
    }
    /**
     * Returns a list of the keys of every ancestor of this node,
     * all the way up to the RootNode.
     *
     */
    getParentKeys() {
      const o = [];
      let a = this.getParent();
      for (; a !== null; )
        o.push(a.__key), a = a.getParent();
      return o;
    }
    /**
     * Returns the "previous" siblings - that is, the node that comes
     * before this one in the same parent.
     *
     */
    getPreviousSibling() {
      const a = this.getLatest().__prev;
      return a === null ? null : En(a);
    }
    /**
     * Returns the "previous" siblings - that is, the nodes that come between
     * this one and the first child of it's parent, inclusive.
     *
     */
    getPreviousSiblings() {
      const o = [], a = this.getParent();
      if (a === null)
        return o;
      let f = a.getFirstChild();
      for (; f !== null && !f.is(this); )
        o.push(f), f = f.getNextSibling();
      return o;
    }
    /**
     * Returns the "next" siblings - that is, the node that comes
     * after this one in the same parent
     *
     */
    getNextSibling() {
      const a = this.getLatest().__next;
      return a === null ? null : En(a);
    }
    /**
     * Returns all "next" siblings - that is, the nodes that come between this
     * one and the last child of it's parent, inclusive.
     *
     */
    getNextSiblings() {
      const o = [];
      let a = this.getNextSibling();
      for (; a !== null; )
        o.push(a), a = a.getNextSibling();
      return o;
    }
    /**
     * Returns the closest common ancestor of this node and the provided one or null
     * if one cannot be found.
     *
     * @param node - the other node to find the common ancestor of.
     */
    getCommonAncestor(o) {
      const a = this.getParents(), f = o.getParents();
      Je(this) && a.unshift(this), Je(o) && f.unshift(o);
      const _ = a.length, E = f.length;
      if (_ === 0 || E === 0 || a[_ - 1] !== f[E - 1])
        return null;
      const I = new Set(f);
      for (let B = 0; B < _; B++) {
        const le = a[B];
        if (I.has(le))
          return le;
      }
      return null;
    }
    /**
     * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.
     * Always use this instead of referential equality.
     *
     * @param object - the node to perform the equality comparison on.
     */
    is(o) {
      return o == null ? !1 : this.__key === o.__key;
    }
    /**
     * Returns true if this node logical precedes the target node in the editor state.
     *
     * @param targetNode - the node we're testing to see if it's after this one.
     */
    isBefore(o) {
      if (this === o)
        return !1;
      if (o.isParentOf(this))
        return !0;
      if (this.isParentOf(o))
        return !1;
      const a = this.getCommonAncestor(o);
      let f = 0, _ = 0, E = this;
      for (; ; ) {
        const I = E.getParentOrThrow();
        if (I === a) {
          f = E.getIndexWithinParent();
          break;
        }
        E = I;
      }
      for (E = o; ; ) {
        const I = E.getParentOrThrow();
        if (I === a) {
          _ = E.getIndexWithinParent();
          break;
        }
        E = I;
      }
      return f < _;
    }
    /**
     * Returns true if this node is the parent of the target node, false otherwise.
     *
     * @param targetNode - the would-be child node.
     */
    isParentOf(o) {
      const a = this.__key;
      if (a === o.__key)
        return !1;
      let f = o;
      for (; f !== null; ) {
        if (f.__key === a)
          return !0;
        f = f.getParent();
      }
      return !1;
    }
    // TO-DO: this function can be simplified a lot
    /**
     * Returns a list of nodes that are between this node and
     * the target node in the EditorState.
     *
     * @param targetNode - the node that marks the other end of the range of nodes to be returned.
     */
    getNodesBetween(o) {
      const a = this.isBefore(o), f = [], _ = /* @__PURE__ */ new Set();
      let E = this;
      for (; ; ) {
        const I = E.__key;
        if (_.has(I) || (_.add(I), f.push(E)), E === o)
          break;
        const B = Je(E) ? a ? E.getFirstChild() : E.getLastChild() : null;
        if (B !== null) {
          E = B;
          continue;
        }
        const le = a ? E.getNextSibling() : E.getPreviousSibling();
        if (le !== null) {
          E = le;
          continue;
        }
        const fe = E.getParentOrThrow();
        if (_.has(fe.__key) || f.push(fe), fe === o)
          break;
        let Ne = null, Ee = fe;
        do {
          if (Ee === null)
            throw Error("getNodesBetween: ancestor is null");
          Ne = a ? Ee.getNextSibling() : Ee.getPreviousSibling(), Ee = Ee.getParent(), Ee !== null && Ne === null && !_.has(Ee.__key) && f.push(Ee);
        } while (Ne === null);
        E = Ne;
      }
      return a || f.reverse(), f;
    }
    /**
     * Returns true if this node has been marked dirty during this update cycle.
     *
     */
    isDirty() {
      const a = gn()._dirtyLeaves;
      return a !== null && a.has(this.__key);
    }
    /**
     * Returns the latest version of the node from the active EditorState.
     * This is used to avoid getting values from stale node references.
     *
     */
    getLatest() {
      const o = En(this.__key);
      if (o === null)
        throw Error("Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.");
      return o;
    }
    /**
     * Returns a mutable version of the node. Will throw an error if
     * called outside of a Lexical Editor {@link LexicalEditor.update} callback.
     *
     */
    getWritable() {
      rr();
      const o = Ii(), a = gn(), f = o._nodeMap, _ = this.__key, E = this.getLatest(), I = E.__parent, B = a._cloneNotNeeded, le = an();
      if (xr(le) && le.setCachedNodes(null), B.has(_))
        return ao(E), E;
      const Ne = E.constructor.clone(E);
      return Ne.__parent = I, Ne.__next = E.__next, Ne.__prev = E.__prev, Je(E) && Je(Ne) ? (Ne.__first = E.__first, Ne.__last = E.__last, Ne.__size = E.__size, Ne.__indent = E.__indent, Ne.__format = E.__format, Ne.__dir = E.__dir) : ft(E) && ft(Ne) && (Ne.__format = E.__format, Ne.__style = E.__style, Ne.__mode = E.__mode, Ne.__detail = E.__detail), B.add(_), Ne.__key = _, ao(Ne), f.set(_, Ne), Ne;
    }
    /**
     * Returns the text content of the node. Override this for
     * custom nodes that should have a representation in plain text
     * format (for copy + paste, for example)
     *
     */
    getTextContent() {
      return "";
    }
    /**
     * Returns the length of the string produced by calling getTextContent on this node.
     *
     */
    getTextContentSize() {
      return this.getTextContent().length;
    }
    // View
    /**
     * Called during the reconciliation process to determine which nodes
     * to insert into the DOM for this Lexical Node.
     *
     * This method must return exactly one HTMLElement. Nested elements are not supported.
     *
     * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.
     *
     * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.
     * @param _editor - allows access to the editor for context during reconciliation.
     *
     * */
    createDOM(o, a) {
      throw Error("createDOM: base method not extended");
    }
    /**
     * Called when a node changes and should update the DOM
     * in whatever way is necessary to make it align with any changes that might
     * have happened during the update.
     *
     * Returning "true" here will cause lexical to unmount and recreate the DOM node
     * (by calling createDOM). You would need to do this if the element tag changes,
     * for instance.
     *
     * */
    updateDOM(o, a, f) {
      throw Error("updateDOM: base method not extended");
    }
    /**
     * Controls how the this node is serialized to HTML. This is important for
     * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,
     * in which case the primary transfer format is HTML. It's also important if you're serializing
     * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could
     * also use this method to build your own HTML renderer.
     *
     * */
    exportDOM(o) {
      return {
        element: this.createDOM(o._config, o)
      };
    }
    /**
     * Controls how the this node is serialized to JSON. This is important for
     * copy and paste between Lexical editors sharing the same namespace. It's also important
     * if you're serializing to JSON for persistent storage somewhere.
     * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).
     *
     * */
    exportJSON() {
      throw Error("exportJSON: base method not extended");
    }
    /**
     * Controls how the this node is deserialized from JSON. This is usually boilerplate,
     * but provides an abstraction between the node implementation and serialized interface that can
     * be important if you ever make breaking changes to a node schema (by adding or removing properties).
     * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).
     *
     * */
    static importJSON(o) {
      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);
    }
    /**
     * @experimental
     *
     * Registers the returned function as a transform on the node during
     * Editor initialization. Most such use cases should be addressed via
     * the {@link LexicalEditor.registerNodeTransform} API.
     *
     * Experimental - use at your own risk.
     */
    static transform() {
      return null;
    }
    // Setters and mutators
    /**
     * Removes this LexicalNode from the EditorState. If the node isn't re-inserted
     * somewhere, the Lexical garbage collector will eventually clean it up.
     *
     * @param preserveEmptyParent - If falsy, the node's parent will be removed if
     * it's empty after the removal operation. This is the default behavior, subject to
     * other node heuristics such as {@link ElementNode#canBeEmpty}
     * */
    remove(o) {
      Et(this, !0, o);
    }
    /**
     * Replaces this LexicalNode with the provided node, optionally transferring the children
     * of the replaced node to the replacing node.
     *
     * @param replaceWith - The node to replace this one with.
     * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.
     * */
    replace(o, a) {
      rr();
      let f = an();
      f !== null && (f = f.clone()), Kr(this, o);
      const _ = this.getLatest(), E = this.__key, I = o.__key, B = o.getWritable(), le = this.getParentOrThrow().getWritable(), fe = le.__size;
      Ei(B);
      const Ne = _.getPreviousSibling(), Ee = _.getNextSibling(), xe = _.__prev, Ce = _.__next, He = _.__parent;
      if (Et(_, !1, !0), Ne === null)
        le.__first = I;
      else {
        const Ie = Ne.getWritable();
        Ie.__next = I;
      }
      if (B.__prev = xe, Ee === null)
        le.__last = I;
      else {
        const Ie = Ee.getWritable();
        Ie.__prev = I;
      }
      if (B.__next = Ce, B.__parent = He, le.__size = fe, a && this.getChildren().forEach((Ie) => {
        B.append(Ie);
      }), gt(f)) {
        br(f);
        const Ie = f.anchor, be = f.focus;
        Ie.key === E && Wa(Ie, B), be.key === E && Wa(be, B);
      }
      return Fr() === E && _n(I), B;
    }
    /**
     * Inserts a node after this LexicalNode (as the next sibling).
     *
     * @param nodeToInsert - The node to insert after this one.
     * @param restoreSelection - Whether or not to attempt to resolve the
     * selection to the appropriate place after the operation is complete.
     * */
    insertAfter(o, a = !0) {
      rr(), Kr(this, o);
      const f = this.getWritable(), _ = o.getWritable(), E = _.getParent(), I = an();
      let B = !1, le = !1;
      if (E !== null) {
        const Ce = o.getIndexWithinParent();
        if (Ei(_), gt(I)) {
          const He = E.__key, Ie = I.anchor, be = I.focus;
          B = Ie.type === "element" && Ie.key === He && Ie.offset === Ce + 1, le = be.type === "element" && be.key === He && be.offset === Ce + 1;
        }
      }
      const fe = this.getNextSibling(), Ne = this.getParentOrThrow().getWritable(), Ee = _.__key, xe = f.__next;
      if (fe === null)
        Ne.__last = Ee;
      else {
        const Ce = fe.getWritable();
        Ce.__prev = Ee;
      }
      if (Ne.__size++, f.__next = Ee, _.__next = xe, _.__prev = f.__key, _.__parent = f.__parent, a && gt(I)) {
        const Ce = this.getIndexWithinParent();
        Ua(I, Ne, Ce + 1);
        const He = Ne.__key;
        B && I.anchor.set(He, Ce + 2, "element"), le && I.focus.set(He, Ce + 2, "element");
      }
      return o;
    }
    /**
     * Inserts a node before this LexicalNode (as the previous sibling).
     *
     * @param nodeToInsert - The node to insert after this one.
     * @param restoreSelection - Whether or not to attempt to resolve the
     * selection to the appropriate place after the operation is complete.
     * */
    insertBefore(o, a = !0) {
      rr(), Kr(this, o);
      const f = this.getWritable(), _ = o.getWritable(), E = _.__key;
      Ei(_);
      const I = this.getPreviousSibling(), B = this.getParentOrThrow().getWritable(), le = f.__prev, fe = this.getIndexWithinParent();
      if (I === null)
        B.__first = E;
      else {
        const Ee = I.getWritable();
        Ee.__next = E;
      }
      B.__size++, f.__prev = E, _.__prev = le, _.__next = f.__key, _.__parent = f.__parent;
      const Ne = an();
      if (a && gt(Ne)) {
        const Ee = this.getParentOrThrow();
        Ua(Ne, Ee, fe);
      }
      return o;
    }
    /**
     * Whether or not this node has a required parent. Used during copy + paste operations
     * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without
     * a ListNode parent or TextNodes with a ParagraphNode parent.
     *
     * */
    isParentRequired() {
      return !1;
    }
    /**
     * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.
     *
     * */
    createParentElementNode() {
      return Xi();
    }
    selectStart() {
      return this.selectPrevious();
    }
    selectEnd() {
      return this.selectNext(0, 0);
    }
    /**
     * Moves selection to the previous sibling of this node, at the specified offsets.
     *
     * @param anchorOffset - The anchor offset for selection.
     * @param focusOffset -  The focus offset for selection
     * */
    selectPrevious(o, a) {
      rr();
      const f = this.getPreviousSibling(), _ = this.getParentOrThrow();
      if (f === null)
        return _.select(0, 0);
      if (Je(f))
        return f.select();
      if (!ft(f)) {
        const E = f.getIndexWithinParent() + 1;
        return _.select(E, E);
      }
      return f.select(o, a);
    }
    /**
     * Moves selection to the next sibling of this node, at the specified offsets.
     *
     * @param anchorOffset - The anchor offset for selection.
     * @param focusOffset -  The focus offset for selection
     * */
    selectNext(o, a) {
      rr();
      const f = this.getNextSibling(), _ = this.getParentOrThrow();
      if (f === null)
        return _.select();
      if (Je(f))
        return f.select(0, 0);
      if (!ft(f)) {
        const E = f.getIndexWithinParent();
        return _.select(E, E);
      }
      return f.select(o, a);
    }
    /**
     * Marks a node dirty, triggering transforms and
     * forcing it to be reconciled during the update cycle.
     *
     * */
    markDirty() {
      this.getWritable();
    }
  }
  function hn(u, o) {
    const a = gn()._nodes.get(u);
    if (a === void 0)
      throw Error(`Create node: Attempted to create node ${o.name} that was not configured to be used on the editor.`);
    const f = a.klass;
    if (f !== o)
      throw Error(`Create node: Type ${u} in node ${o.name} does not match registered node ${f.name} with the same type`);
  }
  function cr(u, o, a) {
    const f = a || o.getParentOrThrow().getLastChild();
    let _ = o;
    const E = [o];
    for (; _ !== f; ) {
      if (!_.getNextSibling())
        throw Error("insertRangeAfter: lastToInsert must be a later sibling of firstToInsert");
      _ = _.getNextSibling(), E.push(_);
    }
    let I = u;
    for (const B of E)
      I = I.insertAfter(B);
  }
  class zr extends Rt {
    static getType() {
      return "linebreak";
    }
    static clone(o) {
      return new zr(o.__key);
    }
    constructor(o) {
      super(o);
    }
    getTextContent() {
      return `
`;
    }
    createDOM() {
      return document.createElement("br");
    }
    updateDOM() {
      return !1;
    }
    static importDOM() {
      return {
        br: (o) => {
          const a = o.parentElement;
          let f, _;
          return a !== null && ((f = a.firstChild) === o || f.nextSibling === o && f.nodeType === Ye && (f.textContent || "").match(/^( |\t|\r?\n)+$/) !== null) && ((_ = a.lastChild) === o || _.previousSibling === o && _.nodeType === Ye && (_.textContent || "").match(/^( |\t|\r?\n)+$/) !== null) ? null : {
            conversion: ui,
            priority: 0
          };
        }
      };
    }
    static importJSON(o) {
      return bi();
    }
    exportJSON() {
      return {
        type: "linebreak",
        version: 1
      };
    }
  }
  function ui(u) {
    return {
      node: bi()
    };
  }
  function bi() {
    return po(new zr());
  }
  function Mi(u) {
    return u instanceof zr;
  }
  function vo(u, o) {
    return o & qe ? "code" : o & kt ? "mark" : o & Qe ? "sub" : o & ut ? "sup" : null;
  }
  function Al(u, o) {
    return o & Oe ? "strong" : o & Me ? "em" : "span";
  }
  function Bs(u, o, a, f, _) {
    const E = f.classList;
    let I = Ui(_, "base");
    I !== void 0 && E.add(...I), I = Ui(_, "underlineStrikethrough");
    let B = !1;
    const le = o & We && o & De, fe = a & We && a & De;
    I !== void 0 && (fe ? (B = !0, le || E.add(...I)) : le && E.remove(...I));
    for (const Ne in fn) {
      const xe = fn[Ne];
      if (I = Ui(_, Ne), I !== void 0)
        if (a & xe) {
          if (B && (Ne === "underline" || Ne === "strikethrough")) {
            o & xe && E.remove(...I);
            continue;
          }
          (!(o & xe) || le && Ne === "underline" || Ne === "strikethrough") && E.add(...I);
        } else
          o & xe && E.remove(...I);
    }
  }
  function Gr(u, o) {
    const a = u.length, f = o.length;
    let _ = 0, E = 0;
    for (; _ < a && _ < f && u[_] === o[_]; )
      _++;
    for (; E + _ < a && E + _ < f && u[a - E - 1] === o[f - E - 1]; )
      E++;
    return [_, a - _ - E, o.slice(_, f - E)];
  }
  function So(u, o, a) {
    const f = o.firstChild, _ = a.isComposing(), I = u + (_ ? Ut : "");
    if (f == null)
      o.textContent = I;
    else {
      const B = f.nodeValue;
      if (B !== I)
        if (_ || Ae) {
          const [le, fe, Ne] = Gr(B, I);
          fe !== 0 && f.deleteData(le, fe), f.insertData(le, Ne);
        } else
          f.nodeValue = I;
    }
  }
  function Hs(u, o, a, f, _, E) {
    So(_, u, o);
    const B = E.theme.text;
    B !== void 0 && Bs(a, 0, f, u, B);
  }
  function es(u, o) {
    const a = document.createElement(o);
    return a.appendChild(u), a;
  }
  class ji extends Rt {
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    static getType() {
      return "text";
    }
    static clone(o) {
      return new ji(o.__text, o.__key);
    }
    constructor(o, a) {
      super(a), this.__text = o, this.__format = 0, this.__style = "", this.__mode = 0, this.__detail = 0;
    }
    /**
     * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the
     * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.
     *
     * @returns a number representing the format of the text node.
     */
    getFormat() {
      return this.getLatest().__format;
    }
    /**
     * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the
     * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless
     * or TextNode.isUnmergeable instead.
     *
     * @returns a number representing the detail of the text node.
     */
    getDetail() {
      return this.getLatest().__detail;
    }
    /**
     * Returns the mode (TextModeType) of the TextNode, which may be "normal", "token", or "segmented"
     *
     * @returns TextModeType.
     */
    getMode() {
      const o = this.getLatest();
      return Ge[o.__mode];
    }
    /**
     * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.
     *
     * @returns CSSText-like string of styles applied to the underlying DOM node.
     */
    getStyle() {
      return this.getLatest().__style;
    }
    /**
     * Returns whether or not the node is in "token" mode. TextNodes in token mode can be navigated through character-by-character
     * with a RangeSelection, but are deleted as a single entity (not invdividually by character).
     *
     * @returns true if the node is in token mode, false otherwise.
     */
    isToken() {
      return this.getLatest().__mode === se;
    }
    /**
     *
     * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to
     * mutate the TextNode, false otherwise.
     */
    isComposing() {
      return this.__key === Fr();
    }
    /**
     * Returns whether or not the node is in "segemented" mode. TextNodes in segemented mode can be navigated through character-by-character
     * with a RangeSelection, but are deleted in space-delimited "segments".
     *
     * @returns true if the node is in segmented mode, false otherwise.
     */
    isSegmented() {
      return this.getLatest().__mode === he;
    }
    /**
     * Returns whether or not the node is "directionless". Directionless nodes don't respect changes between RTL and LTR modes.
     *
     * @returns true if the node is directionless, false otherwise.
     */
    isDirectionless() {
      return (this.getLatest().__detail & je) !== 0;
    }
    /**
     * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge
     * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.
     *
     * @returns true if the node is unmergeable, false otherwise.
     */
    isUnmergeable() {
      return (this.getLatest().__detail & nt) !== 0;
    }
    /**
     * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType
     * string values to get the format of a TextNode.
     *
     * @param type - the TextFormatType to check for.
     *
     * @returns true if the node has the provided format, false otherwise.
     */
    hasFormat(o) {
      const a = fn[o];
      return (this.getFormat() & a) !== 0;
    }
    /**
     * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type "text"
     * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).
     *
     * @returns true if the node is simple text, false otherwise.
     */
    isSimpleText() {
      return this.__type === "text" && this.__mode === 0;
    }
    /**
     * Returns the text content of the node as a string.
     *
     * @returns a string representing the text content of the node.
     */
    getTextContent() {
      return this.getLatest().__text;
    }
    /**
     * Returns the format flags applied to the node as a 32-bit integer.
     *
     * @returns a number representing the TextFormatTypes applied to the node.
     */
    getFormatFlags(o, a) {
      const _ = this.getLatest().__format;
      return Rr(_, o, a);
    }
    // View
    createDOM(o) {
      const a = this.__format, f = vo(this, a), _ = Al(this, a), E = f === null ? _ : f, I = document.createElement(E);
      let B = I;
      this.hasFormat("code") && I.setAttribute("spellcheck", "false"), f !== null && (B = document.createElement(_), I.appendChild(B));
      const le = this.__text;
      Hs(B, this, _, a, le, o);
      const fe = this.__style;
      return fe !== "" && (I.style.cssText = fe), I;
    }
    updateDOM(o, a, f) {
      const _ = this.__text, E = o.__format, I = this.__format, B = vo(this, E), le = vo(this, I), fe = Al(this, E), Ne = Al(this, I);
      if ((B === null ? fe : B) !== (le === null ? Ne : le))
        return !0;
      if (B === le && fe !== Ne) {
        const Ue = a.firstChild;
        if (Ue == null)
          throw Error("updateDOM: prevInnerDOM is null or undefined");
        const tt = document.createElement(Ne);
        return Hs(tt, this, Ne, I, _, f), a.replaceChild(tt, Ue), !1;
      }
      let Ce = a;
      if (le !== null && B !== null && (Ce = a.firstChild, Ce == null))
        throw Error("updateDOM: innerDOM is null or undefined");
      So(_, Ce, this);
      const Ie = f.theme.text;
      Ie !== void 0 && E !== I && Bs(Ne, E, I, Ce, Ie);
      const be = o.__style, pt = this.__style;
      return be !== pt && (a.style.cssText = pt), !1;
    }
    static importDOM() {
      return {
        "#text": () => ({
          conversion: Ll,
          priority: 0
        }),
        b: () => ({
          conversion: Fa,
          priority: 0
        }),
        code: () => ({
          conversion: Yr,
          priority: 0
        }),
        em: () => ({
          conversion: Yr,
          priority: 0
        }),
        i: () => ({
          conversion: Yr,
          priority: 0
        }),
        s: () => ({
          conversion: Yr,
          priority: 0
        }),
        span: () => ({
          conversion: $a,
          priority: 0
        }),
        strong: () => ({
          conversion: Yr,
          priority: 0
        }),
        sub: () => ({
          conversion: Yr,
          priority: 0
        }),
        sup: () => ({
          conversion: Yr,
          priority: 0
        }),
        u: () => ({
          conversion: Yr,
          priority: 0
        })
      };
    }
    static importJSON(o) {
      const a = Un(o.text);
      return a.setFormat(o.format), a.setDetail(o.detail), a.setMode(o.mode), a.setStyle(o.style), a;
    }
    // This improves Lexical's basic text output in copy+paste plus
    // for headless mode where people might use Lexical to generate
    // HTML content and not have the ability to use CSS classes.
    exportDOM(o) {
      let {
        element: a
      } = super.exportDOM(o);
      if (!(a !== null && jo(a)))
        throw Error("Expected TextNode createDOM to always return a HTMLElement");
      return a.style.whiteSpace = "pre-wrap", this.hasFormat("bold") && (a = es(a, "b")), this.hasFormat("italic") && (a = es(a, "i")), this.hasFormat("strikethrough") && (a = es(a, "s")), this.hasFormat("underline") && (a = es(a, "u")), {
        element: a
      };
    }
    exportJSON() {
      return {
        detail: this.getDetail(),
        format: this.getFormat(),
        mode: this.getMode(),
        style: this.getStyle(),
        text: this.getTextContent(),
        type: "text",
        version: 1
      };
    }
    // Mutators
    selectionTransform(o, a) {
    }
    /**
     * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType
     * version of the argument can only specify one format and doing so will remove all other formats that
     * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}
     *
     * @param format - TextFormatType or 32-bit integer representing the node format.
     *
     * @returns this TextNode.
     * // TODO 0.12 This should just be a `string`.
     */
    setFormat(o) {
      const a = this.getWritable();
      return a.__format = typeof o == "string" ? fn[o] : o, a;
    }
    /**
     * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType
     * version of the argument can only specify one detail value and doing so will remove all other detail values that
     * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}
     * or {@link TextNode.togglerUnmergeable}
     *
     * @param detail - TextDetailType or 32-bit integer representing the node detail.
     *
     * @returns this TextNode.
     * // TODO 0.12 This should just be a `string`.
     */
    setDetail(o) {
      const a = this.getWritable();
      return a.__detail = typeof o == "string" ? _r[o] : o, a;
    }
    /**
     * Sets the node style to the provided CSSText-like string. Set this property as you
     * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.
     *
     * @param style - CSSText to be applied to the underlying HTMLElement.
     *
     * @returns this TextNode.
     */
    setStyle(o) {
      const a = this.getWritable();
      return a.__style = o, a;
    }
    /**
     * Applies the provided format to this TextNode if it's not present. Removes it if it's present.
     * The subscript and superscript formats are mutually exclusive.
     * Prefer using this method to turn specific formats on and off.
     *
     * @param type - TextFormatType to toggle.
     *
     * @returns this TextNode.
     */
    toggleFormat(o) {
      const a = this.getFormat(), f = Rr(a, o, null);
      return this.setFormat(f);
    }
    /**
     * Toggles the directionless detail value of the node. Prefer using this method over setDetail.
     *
     * @returns this TextNode.
     */
    toggleDirectionless() {
      const o = this.getWritable();
      return o.__detail ^= je, o;
    }
    /**
     * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.
     *
     * @returns this TextNode.
     */
    toggleUnmergeable() {
      const o = this.getWritable();
      return o.__detail ^= nt, o;
    }
    /**
     * Sets the mode of the node.
     *
     * @returns this TextNode.
     */
    setMode(o) {
      const a = ye[o];
      if (this.__mode === a)
        return this;
      const f = this.getWritable();
      return f.__mode = a, f;
    }
    /**
     * Sets the text content of the node.
     *
     * @param text - the string to set as the text value of the node.
     *
     * @returns this TextNode.
     */
    setTextContent(o) {
      if (this.__text === o)
        return this;
      const a = this.getWritable();
      return a.__text = o, a;
    }
    /**
     * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.
     *
     * @param _anchorOffset - the offset at which the Selection anchor will be placed.
     * @param _focusOffset - the offset at which the Selection focus will be placed.
     *
     * @returns the new RangeSelection.
     */
    select(o, a) {
      rr();
      let f = o, _ = a;
      const E = an(), I = this.getTextContent(), B = this.__key;
      if (typeof I == "string") {
        const le = I.length;
        f === void 0 && (f = le), _ === void 0 && (_ = le);
      } else
        f = 0, _ = 0;
      if (gt(E)) {
        const le = Fr();
        (le === E.anchor.key || le === E.focus.key) && _n(B), E.setTextNodeRange(this, f, this, _);
      } else
        return Bd(B, f, B, _, "text", "text");
      return E;
    }
    selectStart() {
      return this.select(0, 0);
    }
    selectEnd() {
      const o = this.getTextContentSize();
      return this.select(o, o);
    }
    /**
     * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters
     * specified. Can optionally calculate a new selection after the operation is complete.
     *
     * @param offset - the offset at which the splice operation should begin.
     * @param delCount - the number of characters to delete, starting from the offset.
     * @param newText - the text to insert into the TextNode at the offset.
     * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.
     *
     * @returns this TextNode.
     */
    spliceText(o, a, f, _) {
      const E = this.getWritable(), I = E.__text, B = f.length;
      let le = o;
      le < 0 && (le = B + le, le < 0 && (le = 0));
      const fe = an();
      if (_ && gt(fe)) {
        const Ee = o + B;
        fe.setTextNodeRange(E, Ee, E, Ee);
      }
      const Ne = I.slice(0, le) + f + I.slice(le + a);
      return E.__text = Ne, E;
    }
    /**
     * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
     * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt
     * to insert text into this node. If false, it will insert the text in a new sibling node.
     *
     * @returns true if text can be inserted before the node, false otherwise.
     */
    canInsertTextBefore() {
      return !0;
    }
    /**
     * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
     * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt
     * to insert text into this node. If false, it will insert the text in a new sibling node.
     *
     * @returns true if text can be inserted after the node, false otherwise.
     */
    canInsertTextAfter() {
      return !0;
    }
    /**
     * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings
     * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.
     *
     * @param splitOffsets - rest param of the text content character offsets at which this node should be split.
     *
     * @returns an Array containing the newly-created TextNodes.
     */
    splitText(...o) {
      rr();
      const a = this.getLatest(), f = a.getTextContent(), _ = a.__key, E = Fr(), I = new Set(o), B = [], le = f.length;
      let fe = "";
      for (let xt = 0; xt < le; xt++)
        fe !== "" && I.has(xt) && (B.push(fe), fe = ""), fe += f[xt];
      fe !== "" && B.push(fe);
      const Ne = B.length;
      if (Ne === 0)
        return [];
      if (B[0] === f)
        return [a];
      const Ee = B[0], xe = a.getParentOrThrow();
      let Ce;
      const He = a.getFormat(), Ie = a.getStyle(), be = a.__detail;
      let pt = !1;
      a.isSegmented() ? (Ce = Un(Ee), Ce.__format = He, Ce.__style = Ie, Ce.__detail = be, pt = !0) : (Ce = a.getWritable(), Ce.__text = Ee);
      const Ue = an(), tt = [Ce];
      let $t = Ee.length;
      for (let xt = 1; xt < Ne; xt++) {
        const Ht = B[xt], qt = Ht.length, pn = Un(Ht).getWritable();
        pn.__format = He, pn.__style = Ie, pn.__detail = be;
        const jt = pn.__key, Dn = $t + qt;
        if (gt(Ue)) {
          const fi = Ue.anchor, Qi = Ue.focus;
          fi.key === _ && fi.type === "text" && fi.offset > $t && fi.offset <= Dn && (fi.key = jt, fi.offset -= $t, Ue.dirty = !0), Qi.key === _ && Qi.type === "text" && Qi.offset > $t && Qi.offset <= Dn && (Qi.key = jt, Qi.offset -= $t, Ue.dirty = !0);
        }
        E === _ && _n(jt), $t = Dn, tt.push(pn);
      }
      xs(this);
      const bt = xe.getWritable(), Nt = this.getIndexWithinParent();
      return pt ? (bt.splice(Nt, 0, tt), this.remove()) : bt.splice(Nt, 1, tt), gt(Ue) && Ua(Ue, xe, Nt, Ne - 1), tt;
    }
    /**
     * Merges the target TextNode into this TextNode, removing the target node.
     *
     * @param target - the TextNode to merge into this one.
     *
     * @returns this TextNode.
     */
    mergeWithSibling(o) {
      const a = o === this.getPreviousSibling();
      if (!a && o !== this.getNextSibling())
        throw Error("mergeWithSibling: sibling must be a previous or next sibling");
      const f = this.__key, _ = o.__key, E = this.__text, I = E.length;
      Fr() === _ && _n(f);
      const le = an();
      if (gt(le)) {
        const xe = le.anchor, Ce = le.focus;
        xe !== null && xe.key === _ && (Wd(xe, a, f, o, I), le.dirty = !0), Ce !== null && Ce.key === _ && (Wd(Ce, a, f, o, I), le.dirty = !0);
      }
      const fe = o.__text, Ne = a ? fe + E : E + fe;
      this.setTextContent(Ne);
      const Ee = this.getWritable();
      return o.remove(), Ee;
    }
    /**
     * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
     * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the
     * node class that you create and replace matched text with should return true from this method.
     *
     * @returns true if the node is to be treated as a "text entity", false otherwise.
     */
    isTextEntity() {
      return !1;
    }
  }
  function $a(u) {
    const o = u, a = o.style.fontWeight === "700", f = o.style.textDecoration === "line-through", _ = o.style.fontStyle === "italic", E = o.style.textDecoration === "underline", I = o.style.verticalAlign;
    return {
      forChild: (B) => (ft(B) && (a && B.toggleFormat("bold"), f && B.toggleFormat("strikethrough"), _ && B.toggleFormat("italic"), E && B.toggleFormat("underline"), I === "sub" && B.toggleFormat("subscript"), I === "super" && B.toggleFormat("superscript")), B),
      node: null
    };
  }
  function Fa(u) {
    const a = u.style.fontWeight === "normal";
    return {
      forChild: (f) => (ft(f) && !a && f.toggleFormat("bold"), f),
      node: null
    };
  }
  const ts = /* @__PURE__ */ new WeakMap();
  function Ba(u) {
    return u.nodeName === "PRE" || u.nodeType === Be && u.style !== void 0 && u.style.whiteSpace !== void 0 && u.style.whiteSpace.startsWith("pre");
  }
  function kl(u) {
    let o, a = u.parentNode;
    const f = [u];
    for (; a !== null && (o = ts.get(a)) === void 0 && !Ba(a); )
      f.push(a), a = a.parentNode;
    const _ = o === void 0 ? a : o;
    for (let E = 0; E < f.length; E++)
      ts.set(f[E], _);
    return _;
  }
  function Ll(u) {
    const o = u;
    if (u.parentElement === null)
      throw Error("Expected parentElement of Text not to be null");
    let f = o.textContent || "";
    if (kl(o) !== null) {
      const _ = f.split(/(\r?\n|\t)/), E = [], I = _.length;
      for (let B = 0; B < I; B++) {
        const le = _[B];
        le === `
` || le === `\r
` ? E.push(bi()) : le === "	" ? E.push(qi()) : le !== "" && E.push(Un(le));
      }
      return {
        node: E
      };
    }
    if (f = f.replace(/\r/g, "").replace(/[ \t\n]+/g, " "), f === "")
      return {
        node: null
      };
    if (f[0] === " ") {
      let _ = o, E = !0;
      for (; _ !== null && (_ = wo(_, !1)) !== null; ) {
        const I = _.textContent || "";
        if (I.length > 0) {
          /[ \t\n]$/.test(I) && (f = f.slice(1)), E = !1;
          break;
        }
      }
      E && (f = f.slice(1));
    }
    if (f[f.length - 1] === " ") {
      let _ = o, E = !0;
      for (; _ !== null && (_ = wo(_, !0)) !== null; )
        if ((_.textContent || "").replace(/^( |\t|\r?\n)+/, "").length > 0) {
          E = !1;
          break;
        }
      E && (f = f.slice(0, f.length - 1));
    }
    return f === "" ? {
      node: null
    } : {
      node: Un(f)
    };
  }
  const Ha = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/, "i");
  function wo(u, o) {
    let a = u;
    for (; ; ) {
      let f;
      for (; (f = o ? a.nextSibling : a.previousSibling) === null; ) {
        const E = a.parentElement;
        if (E === null)
          return null;
        a = E;
      }
      if (a = f, a.nodeType === Be) {
        const E = a.style.display;
        if (E === "" && a.nodeName.match(Ha) === null || E !== "" && !E.startsWith("inline"))
          return null;
      }
      let _ = a;
      for (; (_ = o ? a.firstChild : a.lastChild) !== null; )
        a = _;
      if (a.nodeType === Ye)
        return a;
      if (a.nodeName === "BR")
        return null;
    }
  }
  const Ws = {
    code: "code",
    em: "italic",
    i: "italic",
    s: "strikethrough",
    strong: "bold",
    sub: "subscript",
    sup: "superscript",
    u: "underline"
  };
  function Yr(u) {
    const o = Ws[u.nodeName.toLowerCase()];
    return o === void 0 ? {
      node: null
    } : {
      forChild: (a) => (ft(a) && !a.hasFormat(o) && a.toggleFormat(o), a),
      node: null
    };
  }
  function Un(u = "") {
    return po(new ji(u));
  }
  function ft(u) {
    return u instanceof ji;
  }
  class Ai extends ji {
    static getType() {
      return "tab";
    }
    static clone(o) {
      const a = new Ai(o.__key);
      return a.__text = o.__text, a.__format = o.__format, a.__style = o.__style, a;
    }
    constructor(o) {
      super("	", o), this.__detail = nt;
    }
    static importDOM() {
      return null;
    }
    static importJSON(o) {
      const a = qi();
      return a.setFormat(o.format), a.setStyle(o.style), a;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "tab",
        version: 1
      };
    }
    setTextContent(o) {
      throw Error("TabNode does not support setTextContent");
    }
    setDetail(o) {
      throw Error("TabNode does not support setDetail");
    }
    setMode(o) {
      throw Error("TabNode does not support setMode");
    }
    canInsertTextBefore() {
      return !1;
    }
    canInsertTextAfter() {
      return !1;
    }
  }
  function qi() {
    return po(new Ai());
  }
  function ns(u) {
    return u instanceof Ai;
  }
  class ki {
    constructor(o, a, f) {
      this._selection = null, this.key = o, this.offset = a, this.type = f;
    }
    is(o) {
      return this.key === o.key && this.offset === o.offset && this.type === o.type;
    }
    isBefore(o) {
      let a = this.getNode(), f = o.getNode();
      const _ = this.offset, E = o.offset;
      if (Je(a)) {
        const I = a.getDescendantByIndex(_);
        a = I ?? a;
      }
      if (Je(f)) {
        const I = f.getDescendantByIndex(E);
        f = I ?? f;
      }
      return a === f ? _ < E : a.isBefore(f);
    }
    getNode() {
      const o = this.key, a = En(o);
      if (a === null)
        throw Error("Point.getNode: node not found");
      return a;
    }
    set(o, a, f) {
      const _ = this._selection, E = this.key;
      this.key = o, this.offset = a, this.type = f, zs() || (Fr() === E && _n(o), _ !== null && (_.setCachedNodes(null), _.dirty = !0));
    }
  }
  function Vr(u, o, a) {
    return new ki(u, o, a);
  }
  function rs(u, o) {
    let a = o.__key, f = u.offset, _ = "element";
    if (ft(o)) {
      _ = "text";
      const E = o.getTextContentSize();
      f > E && (f = E);
    } else if (!Je(o)) {
      const E = o.getNextSibling();
      if (ft(E))
        a = E.__key, f = 0, _ = "text";
      else {
        const I = o.getParent();
        I && (a = I.__key, f = o.getIndexWithinParent() + 1);
      }
    }
    u.set(a, f, _);
  }
  function Wa(u, o) {
    if (Je(o)) {
      const a = o.getLastDescendant();
      Je(a) || ft(a) ? rs(u, a) : rs(u, o);
    } else
      rs(u, o);
  }
  function Il(u, o, a, f) {
    const _ = u.getNode(), E = _.getChildAtIndex(u.offset), I = Un(), B = Ir(_) ? Xi().append(I) : I;
    I.setFormat(a), I.setStyle(f), E === null ? _.append(B) : E.insertBefore(B), u.is(o) && o.set(I.__key, 0, "text"), u.set(I.__key, 0, "text");
  }
  function di(u, o, a, f) {
    u.key = o, u.offset = a, u.type = f;
  }
  class tn {
    constructor(o, a) {
      this.anchor = o, this.focus = a, o._selection = this, a._selection = this, this._cachedNodes = null, this.dirty = !1;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(o) {
      this._cachedNodes = o;
    }
    is(o) {
      return xr(o) ? this.anchor.is(o.anchor) && this.focus.is(o.focus) : !1;
    }
    isCollapsed() {
      return !1;
    }
    extract() {
      return this.getNodes();
    }
    /**
     * Returns whether the Selection is "backwards", meaning the focus
     * logically precedes the anchor in the EditorState.
     * @returns true if the Selection is backwards, false otherwise.
     */
    isBackward() {
      return this.focus.isBefore(this.anchor);
    }
    /**
     * Returns the character-based offsets of the Selection, accounting for non-text Points
     * by using the children size or text content.
     *
     * @returns the character offsets for the Selection
     */
    getCharacterOffsets() {
      return tr(this);
    }
  }
  class In {
    constructor(o) {
      this.dirty = !1, this._nodes = o, this._cachedNodes = null;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(o) {
      this._cachedNodes = o;
    }
    is(o) {
      if (!vr(o))
        return !1;
      const a = this._nodes, f = o._nodes;
      return a.size === f.size && Array.from(a).every((_) => f.has(_));
    }
    add(o) {
      this.dirty = !0, this._nodes.add(o), this._cachedNodes = null;
    }
    delete(o) {
      this.dirty = !0, this._nodes.delete(o), this._cachedNodes = null;
    }
    clear() {
      this.dirty = !0, this._nodes.clear(), this._cachedNodes = null;
    }
    has(o) {
      return this._nodes.has(o);
    }
    clone() {
      return new In(new Set(this._nodes));
    }
    extract() {
      return this.getNodes();
    }
    insertRawText(o) {
    }
    insertText() {
    }
    insertNodes(o) {
      const a = this.getNodes(), f = a.length, _ = a[f - 1];
      let E;
      if (ft(_))
        E = _.select();
      else {
        const I = _.getIndexWithinParent() + 1;
        E = _.getParentOrThrow().select(I, I);
      }
      E.insertNodes(o);
      for (let I = 0; I < f; I++)
        a[I].remove();
    }
    getNodes() {
      const o = this._cachedNodes;
      if (o !== null)
        return o;
      const a = this._nodes, f = [];
      for (const _ of a) {
        const E = En(_);
        E !== null && f.push(E);
      }
      return zs() || (this._cachedNodes = f), f;
    }
    getTextContent() {
      const o = this.getNodes();
      let a = "";
      for (let f = 0; f < o.length; f++)
        a += o[f].getTextContent();
      return a;
    }
  }
  function gt(u) {
    return u instanceof Pn;
  }
  function xr(u) {
    return u instanceof tn;
  }
  function Zi(u) {
    const [o, , a] = Ud(u), f = a.getChildren(), _ = f.length, E = f[0].getChildren().length, I = new Array(_);
    for (let B = 0; B < _; B++)
      I[B] = new Array(E);
    for (let B = 0; B < _; B++) {
      const fe = f[B].getChildren();
      let Ne = 0;
      for (let Ee = 0; Ee < fe.length; Ee++) {
        for (; I[B][Ne]; )
          Ne++;
        const xe = fe[Ee], Ce = xe.__rowSpan || 1, He = xe.__colSpan || 1;
        for (let Ie = 0; Ie < Ce; Ie++)
          for (let be = 0; be < He; be++)
            I[B + Ie][Ne + be] = xe;
        if (o === xe)
          return {
            colSpan: He,
            columnIndex: Ne,
            rowIndex: B,
            rowSpan: Ce
          };
        Ne += He;
      }
    }
    return null;
  }
  class er extends tn {
    constructor(o, a, f) {
      super(a, f), this.gridKey = o;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(o) {
      this._cachedNodes = o;
    }
    is(o) {
      return ur(o) ? this.gridKey === o.gridKey && this.anchor.is(o.anchor) && this.focus.is(o.focus) : !1;
    }
    set(o, a, f) {
      this.dirty = !0, this.gridKey = o, this.anchor.key = a, this.focus.key = f, this._cachedNodes = null;
    }
    clone() {
      return new er(this.gridKey, this.anchor, this.focus);
    }
    isCollapsed() {
      return !1;
    }
    extract() {
      return this.getNodes();
    }
    insertRawText(o) {
    }
    insertText() {
    }
    insertNodes(o) {
      const a = this.focus.getNode();
      Ki(a.select(0, a.getChildrenSize())).insertNodes(o);
    }
    // TODO Deprecate this method. It's confusing when used with colspan|rowspan
    getShape() {
      const o = En(this.anchor.key);
      if (!jr(o))
        throw Error("Expected GridSelection anchor to be (or a child of) GridCellNode");
      const a = Zi(o);
      if (a === null)
        throw Error("getCellRect: expected to find AnchorNode");
      const f = En(this.focus.key);
      if (!jr(f))
        throw Error("Expected GridSelection focus to be (or a child of) GridCellNode");
      const _ = Zi(f);
      if (_ === null)
        throw Error("getCellRect: expected to find focusCellNode");
      const E = Math.min(a.columnIndex, _.columnIndex), I = Math.max(a.columnIndex, _.columnIndex), B = Math.min(a.rowIndex, _.rowIndex), le = Math.max(a.rowIndex, _.rowIndex);
      return {
        fromX: Math.min(E, I),
        fromY: Math.min(B, le),
        toX: Math.max(E, I),
        toY: Math.max(B, le)
      };
    }
    getNodes() {
      const o = this._cachedNodes;
      if (o !== null)
        return o;
      const a = this.anchor.getNode(), f = this.focus.getNode(), _ = Yo(a, jr), E = Yo(f, jr);
      if (!jr(_))
        throw Error("Expected GridSelection anchor to be (or a child of) GridCellNode");
      if (!jr(E))
        throw Error("Expected GridSelection focus to be (or a child of) GridCellNode");
      const I = _.getParent();
      if (!$l(I))
        throw Error("Expected anchorCell to have a parent GridRowNode");
      const B = I.getParent();
      if (!Gc(B))
        throw Error("Expected tableNode to have a parent GridNode");
      const le = E.getParents()[1];
      if (le !== B) {
        if (B.isParentOf(E)) {
          const xt = le.getParent();
          if (xt == null)
            throw Error("Expected focusCellParent to have a parent");
          this.set(this.gridKey, E.getKey(), xt.getKey());
        } else {
          const xt = B.getParent();
          if (xt == null)
            throw Error("Expected gridParent to have a parent");
          this.set(this.gridKey, xt.getKey(), E.getKey());
        }
        return this.getNodes();
      }
      const [fe, Ne, Ee] = Kd(B, _, E);
      let xe = Math.min(Ne.startColumn, Ee.startColumn), Ce = Math.min(Ne.startRow, Ee.startRow), He = Math.max(Ne.startColumn + Ne.cell.__colSpan - 1, Ee.startColumn + Ee.cell.__colSpan - 1), Ie = Math.max(Ne.startRow + Ne.cell.__rowSpan - 1, Ee.startRow + Ee.cell.__rowSpan - 1), be = xe, pt = Ce, Ue = xe, tt = Ce;
      function $t(xt) {
        const {
          cell: Ht,
          startColumn: qt,
          startRow: pn
        } = xt;
        xe = Math.min(xe, qt), Ce = Math.min(Ce, pn), He = Math.max(He, qt + Ht.__colSpan - 1), Ie = Math.max(Ie, pn + Ht.__rowSpan - 1);
      }
      for (; xe < be || Ce < pt || He > Ue || Ie > tt; ) {
        if (xe < be) {
          const xt = tt - pt, Ht = be - 1;
          for (let qt = 0; qt <= xt; qt++)
            $t(fe[pt + qt][Ht]);
          be = Ht;
        }
        if (Ce < pt) {
          const xt = Ue - be, Ht = pt - 1;
          for (let qt = 0; qt <= xt; qt++)
            $t(fe[Ht][be + qt]);
          pt = Ht;
        }
        if (He > Ue) {
          const xt = tt - pt, Ht = Ue + 1;
          for (let qt = 0; qt <= xt; qt++)
            $t(fe[pt + qt][Ht]);
          Ue = Ht;
        }
        if (Ie > tt) {
          const xt = Ue - be, Ht = tt + 1;
          for (let qt = 0; qt <= xt; qt++)
            $t(fe[Ht][be + qt]);
          tt = Ht;
        }
      }
      const bt = [B];
      let Nt = null;
      for (let xt = Ce; xt <= Ie; xt++)
        for (let Ht = xe; Ht <= He; Ht++) {
          const {
            cell: qt
          } = fe[xt][Ht], pn = qt.getParent();
          if (!$l(pn))
            throw Error("Expected GridCellNode parent to be a GridRowNode");
          pn !== Nt && bt.push(pn), bt.push(qt, ...Gi(qt)), Nt = pn;
        }
      return zs() || (this._cachedNodes = bt), bt;
    }
    getTextContent() {
      const o = this.getNodes();
      let a = "";
      for (let f = 0; f < o.length; f++)
        a += o[f].getTextContent();
      return a;
    }
  }
  function ur(u) {
    return u instanceof er;
  }
  class Pn extends tn {
    constructor(o, a, f, _) {
      super(o, a), this.format = f, this.style = _;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(o) {
      this._cachedNodes = o;
    }
    /**
     * Used to check if the provided selections is equal to this one by value,
     * inluding anchor, focus, format, and style properties.
     * @param selection - the Selection to compare this one to.
     * @returns true if the Selections are equal, false otherwise.
     */
    is(o) {
      return gt(o) ? this.anchor.is(o.anchor) && this.focus.is(o.focus) && this.format === o.format && this.style === o.style : !1;
    }
    /**
     * Returns whether the Selection is "collapsed", meaning the anchor and focus are
     * the same node and have the same offset.
     *
     * @returns true if the Selection is collapsed, false otherwise.
     */
    isCollapsed() {
      return this.anchor.is(this.focus);
    }
    /**
     * Gets all the nodes in the Selection. Uses caching to make it generally suitable
     * for use in hot paths.
     *
     * @returns an Array containing all the nodes in the Selection
     */
    getNodes() {
      const o = this._cachedNodes;
      if (o !== null)
        return o;
      const a = this.anchor, f = this.focus, _ = a.isBefore(f), E = _ ? a : f, I = _ ? f : a;
      let B = E.getNode(), le = I.getNode();
      const fe = E.offset, Ne = I.offset;
      if (Je(B)) {
        const xe = B.getDescendantByIndex(fe);
        B = xe ?? B;
      }
      if (Je(le)) {
        let xe = le.getDescendantByIndex(Ne);
        xe !== null && xe !== B && le.getChildAtIndex(Ne) === xe && (xe = xe.getPreviousSibling()), le = xe ?? le;
      }
      let Ee;
      return B.is(le) ? Je(B) && B.getChildrenSize() > 0 ? Ee = [] : Ee = [B] : Ee = B.getNodesBetween(le), zs() || (this._cachedNodes = Ee), Ee;
    }
    /**
     * Sets this Selection to be of type "text" at the provided anchor and focus values.
     *
     * @param anchorNode - the anchor node to set on the Selection
     * @param anchorOffset - the offset to set on the Selection
     * @param focusNode - the focus node to set on the Selection
     * @param focusOffset - the focus offset to set on the Selection
     */
    setTextNodeRange(o, a, f, _) {
      di(this.anchor, o.__key, a, "text"), di(this.focus, f.__key, _, "text"), this._cachedNodes = null, this.dirty = !0;
    }
    /**
     * Gets the (plain) text content of all the nodes in the selection.
     *
     * @returns a string representing the text content of all the nodes in the Selection
     */
    getTextContent() {
      const o = this.getNodes();
      if (o.length === 0)
        return "";
      const a = o[0], f = o[o.length - 1], _ = this.anchor, E = this.focus, I = _.isBefore(E), [B, le] = tr(this);
      let fe = "", Ne = !0;
      for (let Ee = 0; Ee < o.length; Ee++) {
        const xe = o[Ee];
        if (Je(xe) && !xe.isInline())
          Ne || (fe += `
`), xe.isEmpty() ? Ne = !1 : Ne = !0;
        else if (Ne = !1, ft(xe)) {
          let Ce = xe.getTextContent();
          xe === a ? xe === f ? (_.type !== "element" || E.type !== "element" || E.offset === _.offset) && (Ce = B < le ? Ce.slice(B, le) : Ce.slice(le, B)) : Ce = I ? Ce.slice(B) : Ce.slice(le) : xe === f && (Ce = I ? Ce.slice(0, le) : Ce.slice(0, B)), fe += Ce;
        } else
          (Sn(xe) || Mi(xe)) && (xe !== f || !this.isCollapsed()) && (fe += xe.getTextContent());
      }
      return fe;
    }
    /**
     * Attempts to map a DOM selection range onto this Lexical Selection,
     * setting the anchor, focus, and type accordingly
     *
     * @param range a DOM Selection range conforming to the StaticRange interface.
     */
    applyDOMRange(o) {
      const a = gn(), _ = a.getEditorState()._selection, E = Fd(o.startContainer, o.startOffset, o.endContainer, o.endOffset, a, _);
      if (E === null)
        return;
      const [I, B] = E;
      di(this.anchor, I.key, I.offset, I.type), di(this.focus, B.key, B.offset, B.type), this._cachedNodes = null;
    }
    /**
     * Creates a new RangeSelection, copying over all the property values from this one.
     *
     * @returns a new RangeSelection with the same property values as this one.
     */
    clone() {
      const o = this.anchor, a = this.focus;
      return new Pn(Vr(o.key, o.offset, o.type), Vr(a.key, a.offset, a.type), this.format, this.style);
    }
    /**
     * Toggles the provided format on all the TextNodes in the Selection.
     *
     * @param format a string TextFormatType to toggle on the TextNodes in the selection
     */
    toggleFormat(o) {
      this.format = Rr(this.format, o, null), this.dirty = !0;
    }
    /**
     * Sets the value of the style property on the Selection
     *
     * @param style - the style to set at the value of the style property.
     */
    setStyle(o) {
      this.style = o, this.dirty = !0;
    }
    /**
     * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection
     * has the specified format.
     *
     * @param type the TextFormatType to check for.
     * @returns true if the provided format is currently toggled on on the Selection, false otherwise.
     */
    hasFormat(o) {
      const a = fn[o];
      return (this.format & a) !== 0;
    }
    /**
     * Attempts to insert the provided text into the EditorState at the current Selection.
     * converts tabs, newlines, and carriage returns into LexicalNodes.
     *
     * @param text the text to insert into the Selection
     */
    insertRawText(o) {
      const a = o.split(/(\r?\n|\t)/), f = [], _ = a.length;
      for (let E = 0; E < _; E++) {
        const I = a[E];
        I === `
` || I === `\r
` ? f.push(bi()) : I === "	" ? f.push(qi()) : f.push(Un(I));
      }
      this.insertNodes(f);
    }
    /**
     * Attempts to insert the provided text into the EditorState at the current Selection as a new
     * Lexical TextNode, according to a series of insertion heuristics based on the selection type and position.
     *
     * @param text the text to insert into the Selection
     */
    insertText(o) {
      const a = this.anchor, f = this.focus, _ = this.isCollapsed() || a.isBefore(f), E = this.format, I = this.style;
      _ && a.type === "element" ? Il(a, f, E, I) : !_ && f.type === "element" && Il(f, a, E, I);
      const B = this.getNodes(), le = B.length, fe = _ ? a : f, Ne = _ ? f : a, Ee = fe.offset, xe = Ne.offset;
      let Ce = B[0];
      if (!ft(Ce))
        throw Error("insertText: first node is not a text node");
      const Ie = Ce.getTextContent().length, be = Ce.getParentOrThrow(), pt = le - 1;
      let Ue = B[pt];
      if (this.isCollapsed() && Ee === Ie && (Ce.isSegmented() || Ce.isToken() || !Ce.canInsertTextAfter() || !be.canInsertTextAfter() && Ce.getNextSibling() === null)) {
        let tt = Ce.getNextSibling();
        if ((!ft(tt) || !tt.canInsertTextBefore() || gl(tt)) && (tt = Un(), tt.setFormat(E), be.canInsertTextAfter() ? Ce.insertAfter(tt) : be.insertAfter(tt)), tt.select(0, 0), Ce = tt, o !== "") {
          this.insertText(o);
          return;
        }
      } else if (this.isCollapsed() && Ee === 0 && (Ce.isSegmented() || Ce.isToken() || !Ce.canInsertTextBefore() || !be.canInsertTextBefore() && Ce.getPreviousSibling() === null)) {
        let tt = Ce.getPreviousSibling();
        if ((!ft(tt) || gl(tt)) && (tt = Un(), tt.setFormat(E), be.canInsertTextBefore() ? Ce.insertBefore(tt) : be.insertBefore(tt)), tt.select(), Ce = tt, o !== "") {
          this.insertText(o);
          return;
        }
      } else if (Ce.isSegmented() && Ee !== Ie) {
        const tt = Un(Ce.getTextContent());
        tt.setFormat(E), Ce.replace(tt), Ce = tt;
      } else if (!this.isCollapsed() && o !== "") {
        const tt = Ue.getParent();
        if (!be.canInsertTextBefore() || !be.canInsertTextAfter() || Je(tt) && (!tt.canInsertTextBefore() || !tt.canInsertTextAfter())) {
          this.insertText(""), $d(this.anchor, this.focus, null), this.insertText(o);
          return;
        }
      }
      if (le === 1) {
        if (Ce.isToken()) {
          const Nt = Un(o);
          Nt.select(), Ce.replace(Nt);
          return;
        }
        const tt = Ce.getFormat(), $t = Ce.getStyle();
        if (Ee === xe && (tt !== E || $t !== I))
          if (Ce.getTextContent() === "")
            Ce.setFormat(E), Ce.setStyle(I);
          else {
            const Nt = Un(o);
            if (Nt.setFormat(E), Nt.setStyle(I), Nt.select(), Ee === 0)
              Ce.insertBefore(Nt, !1);
            else {
              const [xt] = Ce.splitText(Ee);
              xt.insertAfter(Nt, !1);
            }
            Nt.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= o.length);
            return;
          }
        else if (ns(Ce)) {
          const Nt = Un(o);
          Nt.setFormat(E), Nt.setStyle(I), Nt.select(), Ce.replace(Nt);
          return;
        }
        const bt = xe - Ee;
        Ce = Ce.spliceText(Ee, bt, o, !0), Ce.getTextContent() === "" ? Ce.remove() : this.anchor.type === "text" && (Ce.isComposing() ? this.anchor.offset -= o.length : (this.format = tt, this.style = $t));
      } else {
        const tt = /* @__PURE__ */ new Set([...Ce.getParentKeys(), ...Ue.getParentKeys()]), $t = Je(Ce) ? Ce : Ce.getParentOrThrow();
        let bt = Je(Ue) ? Ue : Ue.getParentOrThrow(), Nt = Ue;
        if (!$t.is(bt) && bt.isInline())
          do
            Nt = bt, bt = bt.getParentOrThrow();
          while (bt.isInline());
        if (Ne.type === "text" && (xe !== 0 || Ue.getTextContent() === "") || Ne.type === "element" && Ue.getIndexWithinParent() < xe)
          if (ft(Ue) && !Ue.isToken() && xe !== Ue.getTextContentSize()) {
            if (Ue.isSegmented()) {
              const jt = Un(Ue.getTextContent());
              Ue.replace(jt), Ue = jt;
            }
            !Ir(Ne.getNode()) && Ne.type === "text" && (Ue = Ue.spliceText(0, xe, "")), tt.add(Ue.__key);
          } else {
            const jt = Ue.getParentOrThrow();
            !jt.canBeEmpty() && jt.getChildrenSize() === 1 ? jt.remove() : Ue.remove();
          }
        else
          tt.add(Ue.__key);
        const xt = bt.getChildren(), Ht = new Set(B), qt = $t.is(bt), pn = $t.isInline() && Ce.getNextSibling() === null ? $t : Ce;
        for (let jt = xt.length - 1; jt >= 0; jt--) {
          const Dn = xt[jt];
          if (Dn.is(Ce) || Je(Dn) && Dn.isParentOf(Ce))
            break;
          Dn.isAttached() && (!Ht.has(Dn) || Dn.is(Nt) ? qt || pn.insertAfter(Dn, !1) : Dn.remove());
        }
        if (!qt) {
          let jt = bt, Dn = null;
          for (; jt !== null; ) {
            const fi = jt.getChildren(), Qi = fi.length;
            (Qi === 0 || fi[Qi - 1].is(Dn)) && (tt.delete(jt.__key), Dn = jt), jt = jt.getParent();
          }
        }
        if (!Ce.isToken())
          Ce = Ce.spliceText(Ee, Ie - Ee, o, !0), Ce.getTextContent() === "" ? Ce.remove() : Ce.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= o.length);
        else if (Ee === Ie)
          Ce.select();
        else {
          const jt = Un(o);
          jt.select(), Ce.replace(jt);
        }
        for (let jt = 1; jt < le; jt++) {
          const Dn = B[jt], fi = Dn.__key;
          tt.has(fi) || Dn.remove();
        }
      }
    }
    /**
     * Removes the text in the Selection, adjusting the EditorState accordingly.
     */
    removeText() {
      this.insertText("");
    }
    /**
     * Applies the provided format to the TextNodes in the Selection, splitting or
     * merging nodes as necessary.
     *
     * @param formatType the format type to apply to the nodes in the Selection.
     */
    formatText(o) {
      if (this.isCollapsed()) {
        this.toggleFormat(o), _n(null);
        return;
      }
      const a = this.getNodes(), f = [];
      for (const Ue of a)
        ft(Ue) && f.push(Ue);
      const _ = f.length;
      if (_ === 0) {
        this.toggleFormat(o), _n(null);
        return;
      }
      const E = this.anchor, I = this.focus, B = this.isBackward(), le = B ? I : E, fe = B ? E : I;
      let Ne = 0, Ee = f[0], xe = le.type === "element" ? 0 : le.offset;
      if (le.type === "text" && xe === Ee.getTextContentSize() && (Ne = 1, Ee = f[1], xe = 0), Ee == null)
        return;
      const Ce = Ee.getFormatFlags(o, null), He = _ - 1;
      let Ie = f[He];
      const be = fe.type === "text" ? fe.offset : Ie.getTextContentSize();
      if (Ee.is(Ie)) {
        if (xe === be)
          return;
        if (xe === 0 && be === Ee.getTextContentSize())
          Ee.setFormat(Ce);
        else {
          const Ue = Ee.splitText(xe, be), tt = xe === 0 ? Ue[0] : Ue[1];
          tt.setFormat(Ce), le.type === "text" && le.set(tt.__key, 0, "text"), fe.type === "text" && fe.set(tt.__key, be - xe, "text");
        }
        this.format = Ce;
        return;
      }
      xe !== 0 && ([, Ee] = Ee.splitText(xe), xe = 0), Ee.setFormat(Ce);
      const pt = Ie.getFormatFlags(o, Ce);
      be > 0 && (be !== Ie.getTextContentSize() && ([Ie] = Ie.splitText(be)), Ie.setFormat(pt));
      for (let Ue = Ne + 1; Ue < He; Ue++) {
        const tt = f[Ue];
        if (!tt.isToken()) {
          const $t = tt.getFormatFlags(o, pt);
          tt.setFormat($t);
        }
      }
      le.type === "text" && le.set(Ee.__key, xe, "text"), fe.type === "text" && fe.set(Ie.__key, be, "text"), this.format = Ce | pt;
    }
    /**
     * Attempts to "intelligently" insert an arbitrary list of Lexical nodes into the EditorState at the
     * current Selection according to a set of heuristics that determine how surrounding nodes
     * should be changed, replaced, or moved to accomodate the incoming ones.
     *
     * @param nodes - the nodes to insert
     */
    insertNodes(o) {
      if (o.length === 0)
        return;
      if (this.anchor.key === "root") {
        this.insertParagraph();
        const be = an();
        if (!gt(be))
          throw Error("Expected RangeSelection after insertParagraph");
        return be.insertNodes(o);
      }
      const a = As(this.anchor.getNode(), Yi), f = o[o.length - 1];
      if ("__language" in a) {
        if ("__language" in o[0])
          this.insertText(o[0].getTextContent());
        else {
          const be = Bc(this);
          a.splice(be, 0, o), f.selectEnd();
        }
        return;
      }
      const _ = (be) => (Je(be) || Sn(be)) && !be.isInline();
      if (!o.some(_)) {
        const be = Bc(this);
        a.splice(be, 0, o), f.selectEnd();
        return;
      }
      const E = p_(o), I = E.getLastDescendant(), B = E.getChildren(), le = (be) => "__value" in be && "__checked" in be, fe = (be) => Je(be) && Yi(be) && !be.isEmpty() && Je(a) && (!a.isEmpty() || le(a)), Ee = !Je(a) || !a.isEmpty() ? this.insertParagraph() : null, xe = B[B.length - 1];
      let Ce = B[0];
      fe(Ce) && (a.append(...Ce.getChildren()), Ce = B[1]), Ce && cr(a, Ce);
      const He = As(I, Yi);
      Ee && Je(He) && (le(Ee) || Yi(xe)) && (He.append(...Ee.getChildren()), Ee.remove()), Je(a) && a.isEmpty() && a.remove(), I.selectEnd();
      const Ie = Je(a) ? a.getLastChild() : null;
      Mi(Ie) && He !== a && Ie.remove();
    }
    /**
     * Inserts a new ParagraphNode into the EditorState at the current Selection
     *
     * @returns the newly inserted node.
     */
    insertParagraph() {
      if (this.anchor.key === "root") {
        const I = Xi();
        return Jn().splice(this.anchor.offset, 0, [I]), I.select(), I;
      }
      const o = Bc(this), a = As(this.anchor.getNode(), Yi), f = a.getChildAtIndex(o), _ = f ? [f, ...f.getNextSiblings()] : [], E = a.insertNewAfter(this, !1);
      return E ? (E.append(..._), E.selectStart(), E) : null;
    }
    /**
     * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the
     * current Selection.
     */
    insertLineBreak(o) {
      const a = bi();
      if (this.insertNodes([a]), o) {
        const f = a.getParentOrThrow(), _ = a.getIndexWithinParent();
        f.select(_, _);
      }
    }
    /**
     * Extracts the nodes in the Selection, splitting nodes where necessary
     * to get offset-level precision.
     *
     * @returns The nodes in the Selection
     */
    extract() {
      const o = this.getNodes(), a = o.length, f = a - 1, _ = this.anchor, E = this.focus;
      let I = o[0], B = o[f];
      const [le, fe] = tr(this);
      if (a === 0)
        return [];
      if (a === 1) {
        if (ft(I) && !this.isCollapsed()) {
          const Ee = le > fe ? fe : le, xe = le > fe ? le : fe, Ce = I.splitText(Ee, xe), He = Ee === 0 ? Ce[0] : Ce[1];
          return He != null ? [He] : [];
        }
        return [I];
      }
      const Ne = _.isBefore(E);
      if (ft(I)) {
        const Ee = Ne ? le : fe;
        Ee === I.getTextContentSize() ? o.shift() : Ee !== 0 && ([, I] = I.splitText(Ee), o[0] = I);
      }
      if (ft(B)) {
        const xe = B.getTextContent().length, Ce = Ne ? fe : le;
        Ce === 0 ? o.pop() : Ce !== xe && ([B] = B.splitText(Ce), o[f] = B);
      }
      return o;
    }
    /**
     * Modifies the Selection according to the parameters and a set of heuristics that account for
     * various node types. Can be used to safely move or extend selection by one logical "unit" without
     * dealing explicitly with all the possible node types.
     *
     * @param alter the type of modification to perform
     * @param isBackward whether or not selection is backwards
     * @param granularity the granularity at which to apply the modification
     */
    modify(o, a, f) {
      const _ = this.focus, E = this.anchor, I = o === "move", B = li(_, a);
      if (Sn(B) && !B.isIsolated()) {
        if (I && B.isKeyboardSelectable()) {
          const Ce = $c();
          Ce.add(B.__key), br(Ce);
          return;
        }
        const xe = a ? B.getPreviousSibling() : B.getNextSibling();
        if (ft(xe)) {
          const Ce = xe.__key, He = a ? xe.getTextContent().length : 0;
          _.set(Ce, He, "text"), I && E.set(Ce, He, "text");
          return;
        } else {
          const Ce = B.getParentOrThrow();
          let He, Ie;
          Je(xe) ? (Ie = xe.__key, He = a ? xe.getChildrenSize() : 0) : (He = B.getIndexWithinParent(), Ie = Ce.__key, a || He++), _.set(Ie, He, "element"), I && E.set(Ie, He, "element");
          return;
        }
      }
      const le = gn(), fe = Cr(le._window);
      if (!fe)
        return;
      const Ne = le._blockCursorElement, Ee = le._rootElement;
      if (Ee !== null && Ne !== null && Je(B) && !B.isInline() && !B.canBeEmpty() && St(Ne, le, Ee), Ks(fe, o, a ? "backward" : "forward", f), fe.rangeCount > 0) {
        const xe = fe.getRangeAt(0), Ce = this.anchor.getNode(), He = Ir(Ce) ? Ce : Mr(Ce);
        if (this.applyDOMRange(xe), this.dirty = !0, !I) {
          const Ie = this.getNodes(), be = [];
          let pt = !1;
          for (let Ue = 0; Ue < Ie.length; Ue++) {
            const tt = Ie[Ue];
            dt(tt, He) ? be.push(tt) : pt = !0;
          }
          if (pt && be.length > 0)
            if (a) {
              const Ue = be[0];
              Je(Ue) ? Ue.selectStart() : Ue.getParentOrThrow().selectStart();
            } else {
              const Ue = be[be.length - 1];
              Je(Ue) ? Ue.selectEnd() : Ue.getParentOrThrow().selectEnd();
            }
          (fe.anchorNode !== xe.startContainer || fe.anchorOffset !== xe.startOffset) && Ji(this);
        }
      }
    }
    /**
     * Performs one logical character deletion operation on the EditorState based on the current Selection.
     * Handles different node types.
     *
     * @param isBackward whether or not the selection is backwards.
     */
    deleteCharacter(o) {
      const a = this.isCollapsed();
      if (this.isCollapsed()) {
        const f = this.anchor, _ = this.focus;
        let E = f.getNode();
        if (!o && // Delete forward handle case
        (f.type === "element" && Je(E) && f.offset === E.getChildrenSize() || f.type === "text" && f.offset === E.getTextContentSize())) {
          const B = E.getParent(), le = E.getNextSibling() || (B === null ? null : B.getNextSibling());
          if (Je(le) && le.isShadowRoot())
            return;
        }
        const I = li(_, o);
        if (Sn(I) && !I.isIsolated()) {
          if (I.isKeyboardSelectable() && Je(E) && E.getChildrenSize() === 0) {
            E.remove();
            const B = $c();
            B.add(I.__key), br(B);
          } else
            I.remove(), gn().dispatchCommand(e, void 0);
          return;
        } else if (!o && Je(I) && Je(E) && E.isEmpty()) {
          E.remove(), I.selectStart();
          return;
        }
        if (this.modify("extend", o, "character"), this.isCollapsed()) {
          if (o && f.offset === 0 && (f.type === "element" ? f.getNode() : f.getNode().getParentOrThrow()).collapseAtStart(this))
            return;
        } else {
          const B = _.type === "text" ? _.getNode() : null;
          if (E = f.type === "text" ? f.getNode() : null, B !== null && B.isSegmented()) {
            const le = _.offset, fe = B.getTextContentSize();
            if (B.is(E) || o && le !== fe || !o && le !== 0) {
              Ld(B, o, le);
              return;
            }
          } else if (E !== null && E.isSegmented()) {
            const le = f.offset, fe = E.getTextContentSize();
            if (E.is(B) || o && le !== 0 || !o && le !== fe) {
              Ld(E, o, le);
              return;
            }
          }
          Ka(this, o);
        }
      }
      if (this.removeText(), o && !a && this.isCollapsed() && this.anchor.type === "element" && this.anchor.offset === 0) {
        const f = this.anchor.getNode();
        f.isEmpty() && Ir(f.getParent()) && f.getIndexWithinParent() === 0 && f.collapseAtStart(this);
      }
    }
    /**
     * Performs one logical line deletion operation on the EditorState based on the current Selection.
     * Handles different node types.
     *
     * @param isBackward whether or not the selection is backwards.
     */
    deleteLine(o) {
      this.isCollapsed() && (this.anchor.type === "text" && this.modify("extend", o, "lineboundary"), (o ? this.focus : this.anchor).offset === 0 && this.modify("extend", o, "character")), this.removeText();
    }
    /**
     * Performs one logical word deletion operation on the EditorState based on the current Selection.
     * Handles different node types.
     *
     * @param isBackward whether or not the selection is backwards.
     */
    deleteWord(o) {
      this.isCollapsed() && this.modify("extend", o, "word"), this.removeText();
    }
  }
  function vr(u) {
    return u instanceof In;
  }
  function Li(u) {
    const o = u.offset;
    if (u.type === "text")
      return o;
    const a = u.getNode();
    return o === a.getChildrenSize() ? a.getTextContent().length : 0;
  }
  function tr(u) {
    const o = u.anchor, a = u.focus;
    return o.type === "element" && a.type === "element" && o.key === a.key && o.offset === a.offset ? [0, 0] : [Li(o), Li(a)];
  }
  function Ji(u) {
    const o = u.focus, a = u.anchor, f = a.key, _ = a.offset, E = a.type;
    di(a, o.key, o.offset, o.type), di(o, f, _, E), u._cachedNodes = null;
  }
  function Ks(u, o, a, f) {
    u.modify(o, a, f);
  }
  function Ka(u, o) {
    const a = u.anchor, f = u.focus, _ = a.getNode(), E = f.getNode();
    if (_ === E && a.type === "text" && f.type === "text") {
      const I = a.offset, B = f.offset, le = I < B, fe = le ? I : B, Ne = le ? B : I, Ee = Ne - 1;
      if (fe !== Ee) {
        const xe = _.getTextContent().slice(fe, Ne);
        pl(xe) || (o ? f.offset = Ee : a.offset = Ee);
      }
    }
  }
  function Ld(u, o, a) {
    const f = u, E = f.getTextContent().split(/(?=\s)/g), I = E.length;
    let B = 0, le = 0;
    for (let Ne = 0; Ne < I; Ne++) {
      const Ee = E[Ne], xe = Ne === I - 1;
      if (le = B, B += Ee.length, o && B === a || B > a || xe) {
        E.splice(Ne, 1), xe && (le = void 0);
        break;
      }
    }
    const fe = E.join("").trim();
    fe === "" ? f.remove() : (f.setTextContent(fe), f.select(le, le));
  }
  function s_(u, o, a) {
    const f = u.getParent();
    return a === null || f === null || !f.canBeEmpty() || f !== a.getNode();
  }
  function Id(u, o, a, f) {
    let _ = o, E;
    if (u.nodeType === Be) {
      let I = !1;
      const B = u.childNodes, le = B.length;
      _ === le && (I = !0, _ = le - 1);
      let fe = B[_], Ne = !1;
      if (fe === f._blockCursorElement ? (fe = B[_ + 1], Ne = !0) : f._blockCursorElement !== null && _--, E = ii(fe), ft(E))
        _ = ws(E, I);
      else {
        let Ee = ii(u);
        if (Ee === null)
          return null;
        if (Je(Ee)) {
          let xe = Ee.getChildAtIndex(_);
          if (Je(xe) && s_(xe, _, a)) {
            const Ce = I ? xe.getLastDescendant() : xe.getFirstDescendant();
            Ce === null ? (Ee = xe, _ = 0) : (xe = Ce, Ee = Je(xe) ? xe : xe.getParentOrThrow());
          }
          ft(xe) ? (E = xe, Ee = null, _ = ws(xe, I)) : xe !== Ee && I && !Ne && _++;
        } else {
          const xe = Ee.getIndexWithinParent();
          o === 0 && Sn(Ee) && ii(u) === Ee ? _ = xe : _ = xe + 1, Ee = Ee.getParentOrThrow();
        }
        if (Je(Ee))
          return Vr(Ee.__key, _, "element");
      }
    } else
      E = ii(u);
    return ft(E) ? Vr(E.__key, _, "text") : null;
  }
  function Pd(u, o, a) {
    const f = u.offset, _ = u.getNode();
    if (f === 0) {
      const E = _.getPreviousSibling(), I = _.getParent();
      if (!o)
        Je(E) && !a && E.isInline() ? (u.key = E.__key, u.offset = E.getChildrenSize(), u.type = "element") : ft(E) && (u.key = E.__key, u.offset = E.getTextContent().length);
      else if ((a || !o) && E === null && Je(I) && I.isInline()) {
        const B = I.getPreviousSibling();
        ft(B) && (u.key = B.__key, u.offset = B.getTextContent().length);
      }
    } else if (f === _.getTextContent().length) {
      const E = _.getNextSibling(), I = _.getParent();
      if (o && Je(E) && E.isInline())
        u.key = E.__key, u.offset = 0, u.type = "element";
      else if ((a || o) && E === null && Je(I) && I.isInline() && !I.canInsertTextAfter()) {
        const B = I.getNextSibling();
        ft(B) && (u.key = B.__key, u.offset = 0);
      }
    }
  }
  function $d(u, o, a) {
    if (u.type === "text" && o.type === "text") {
      const f = u.isBefore(o), _ = u.is(o);
      Pd(u, f, _), Pd(o, !f, _), _ && (o.key = u.key, o.offset = u.offset, o.type = u.type);
      const E = gn();
      if (E.isComposing() && E._compositionKey !== u.key && gt(a)) {
        const I = a.anchor, B = a.focus;
        di(u, I.key, I.offset, I.type), di(o, B.key, B.offset, B.type);
      }
    }
  }
  function Fd(u, o, a, f, _, E) {
    if (u === null || a === null || !ri(_, u, a))
      return null;
    const I = Id(u, o, gt(E) ? E.anchor : null, _);
    if (I === null)
      return null;
    const B = Id(a, f, gt(E) ? E.focus : null, _);
    if (B === null)
      return null;
    if (I.type === "element" && B.type === "element") {
      const le = ii(u), fe = ii(a);
      if (Sn(le) && Sn(fe))
        return null;
    }
    return $d(I, B, E), [I, B];
  }
  function l_(u) {
    return Je(u) && !u.isInline();
  }
  function Bd(u, o, a, f, _, E) {
    const I = Ii(), B = new Pn(Vr(u, o, _), Vr(a, f, E), 0, "");
    return B.dirty = !0, I._selection = B, B;
  }
  function a_() {
    const u = Vr("root", 0, "element"), o = Vr("root", 0, "element");
    return new Pn(u, o, 0, "");
  }
  function $c() {
    return new In(/* @__PURE__ */ new Set());
  }
  function c_() {
    const u = Vr("root", 0, "element"), o = Vr("root", 0, "element");
    return new er("root", u, o);
  }
  function u_(u) {
    const a = u.getEditorState()._selection, f = Cr(u._window);
    return gt(a) || a == null ? Fc(a, f, u) : a.clone();
  }
  function Fc(u, o, a) {
    const f = a._window;
    if (f === null)
      return null;
    const _ = f.event, E = _ ? _.type : void 0, I = E === "selectionchange", B = !Wt() && (I || E === "beforeinput" || E === "compositionstart" || E === "compositionend" || E === "click" && _ && _.detail === 3 || E === "drop" || E === void 0);
    let le, fe, Ne, Ee;
    if (!gt(u) || B) {
      if (o === null)
        return null;
      if (le = o.anchorNode, fe = o.focusNode, Ne = o.anchorOffset, Ee = o.focusOffset, I && gt(u) && !ri(a, le, fe))
        return u.clone();
    } else
      return u.clone();
    const xe = Fd(le, Ne, fe, Ee, a, u);
    if (xe === null)
      return null;
    const [Ce, He] = xe;
    return new Pn(Ce, He, gt(u) ? u.format : 0, gt(u) ? u.style : "");
  }
  function an() {
    return Ii()._selection;
  }
  function Us() {
    return gn()._editorState._selection;
  }
  function Ua(u, o, a, f = 1) {
    const _ = u.anchor, E = u.focus, I = _.getNode(), B = E.getNode();
    if (!o.is(I) && !o.is(B))
      return;
    const le = o.__key;
    if (u.isCollapsed()) {
      const fe = _.offset;
      if (a <= fe && f > 0 || a < fe && f < 0) {
        const Ne = Math.max(0, fe + f);
        _.set(le, Ne, "element"), E.set(le, Ne, "element"), Hd(u);
      }
    } else {
      const fe = u.isBackward(), Ne = fe ? E : _, Ee = Ne.getNode(), xe = fe ? _ : E, Ce = xe.getNode();
      if (o.is(Ee)) {
        const He = Ne.offset;
        (a <= He && f > 0 || a < He && f < 0) && Ne.set(le, Math.max(0, He + f), "element");
      }
      if (o.is(Ce)) {
        const He = xe.offset;
        (a <= He && f > 0 || a < He && f < 0) && xe.set(le, Math.max(0, He + f), "element");
      }
    }
    Hd(u);
  }
  function Hd(u) {
    const o = u.anchor, a = o.offset, f = u.focus, _ = f.offset, E = o.getNode(), I = f.getNode();
    if (u.isCollapsed()) {
      if (!Je(E))
        return;
      const B = E.getChildrenSize(), le = a >= B, fe = le ? E.getChildAtIndex(B - 1) : E.getChildAtIndex(a);
      if (ft(fe)) {
        let Ne = 0;
        le && (Ne = fe.getTextContentSize()), o.set(fe.__key, Ne, "text"), f.set(fe.__key, Ne, "text");
      }
      return;
    }
    if (Je(E)) {
      const B = E.getChildrenSize(), le = a >= B, fe = le ? E.getChildAtIndex(B - 1) : E.getChildAtIndex(a);
      if (ft(fe)) {
        let Ne = 0;
        le && (Ne = fe.getTextContentSize()), o.set(fe.__key, Ne, "text");
      }
    }
    if (Je(I)) {
      const B = I.getChildrenSize(), le = _ >= B, fe = le ? I.getChildAtIndex(B - 1) : I.getChildAtIndex(_);
      if (ft(fe)) {
        let Ne = 0;
        le && (Ne = fe.getTextContentSize()), f.set(fe.__key, Ne, "text");
      }
    }
  }
  function d_(u, o) {
    const f = o.getEditorState()._selection, _ = u._selection;
    if (gt(_)) {
      const E = _.anchor, I = _.focus;
      let B;
      if (E.type === "text" && (B = E.getNode(), B.selectionTransform(f, _)), I.type === "text") {
        const le = I.getNode();
        B !== le && le.selectionTransform(f, _);
      }
    }
  }
  function za(u, o, a, f, _) {
    let E = null, I = 0, B = null;
    f !== null ? (E = f.__key, ft(f) ? (I = f.getTextContentSize(), B = "text") : Je(f) && (I = f.getChildrenSize(), B = "element")) : _ !== null && (E = _.__key, ft(_) ? B = "text" : Je(_) && (B = "element")), E !== null && B !== null ? u.set(E, I, B) : (I = o.getIndexWithinParent(), I === -1 && (I = a.getChildrenSize()), u.set(a.__key, I, "element"));
  }
  function Wd(u, o, a, f, _) {
    u.type === "text" ? (u.key = a, o || (u.offset += _)) : u.offset > f.getIndexWithinParent() && (u.offset -= 1);
  }
  function f_(u, o, a, f, _, E, I) {
    const B = f.anchorNode, le = f.focusNode, fe = f.anchorOffset, Ne = f.focusOffset, Ee = document.activeElement;
    if (_.has("collaboration") && Ee !== E || Ee !== null && lo(Ee))
      return;
    if (!gt(o)) {
      u !== null && ri(a, B, le) && f.removeAllRanges();
      return;
    }
    const xe = o.anchor, Ce = o.focus, He = xe.key, Ie = Ce.key, be = Rs(a, He), pt = Rs(a, Ie), Ue = xe.offset, tt = Ce.offset, $t = o.format, bt = o.style, Nt = o.isCollapsed();
    let xt = be, Ht = pt, qt = !1;
    if (xe.type === "text") {
      xt = Ln(be);
      const pn = xe.getNode();
      qt = pn.getFormat() !== $t || pn.getStyle() !== bt;
    } else
      gt(u) && u.anchor.type === "text" && (qt = !0);
    if (Ce.type === "text" && (Ht = Ln(pt)), !(xt === null || Ht === null) && (Nt && (u === null || qt || gt(u) && (u.format !== $t || u.style !== bt)) && at($t, bt, Ue, He, performance.now()), !(fe === Ue && Ne === tt && B === xt && le === Ht && // Badly interpreted range selection when collapsed - #1482
    !(f.type === "Range" && Nt) && ((Ee === null || !E.contains(Ee)) && E.focus({
      preventScroll: !0
    }), xe.type !== "element")))) {
      try {
        f.setBaseAndExtent(xt, Ue, Ht, tt);
      } catch {
      }
      if (!_.has("skip-scroll-into-view") && o.isCollapsed() && E !== null && E === document.activeElement) {
        const pn = o instanceof Pn && o.anchor.type === "element" ? xt.childNodes[Ue] || null : f.rangeCount > 0 ? f.getRangeAt(0) : null;
        if (pn !== null) {
          let jt;
          if (pn instanceof Text) {
            const Dn = document.createRange();
            Dn.selectNode(pn), jt = Dn.getBoundingClientRect();
          } else
            jt = pn.getBoundingClientRect();
          va(a, jt, E);
        }
      }
      Xe();
    }
  }
  function h_(u) {
    let o = an() || Us();
    o === null && (o = Jn().selectEnd()), o.insertNodes(u);
  }
  function g_() {
    const u = an();
    return u === null ? "" : u.getTextContent();
  }
  function Kd(u, o, a) {
    const f = [];
    let _ = null, E = null;
    function I(fe, Ne, Ee) {
      const xe = {
        cell: Ee,
        startColumn: Ne,
        startRow: fe
      }, Ce = Ee.__rowSpan, He = Ee.__colSpan;
      for (let Ie = 0; Ie < Ce; Ie++) {
        f[fe + Ie] === void 0 && (f[fe + Ie] = []);
        for (let be = 0; be < He; be++)
          f[fe + Ie][Ne + be] = xe;
      }
      o.is(Ee) && (_ = xe), a.is(Ee) && (E = xe);
    }
    function B(fe, Ne) {
      return f[fe] === void 0 || f[fe][Ne] === void 0;
    }
    const le = u.getChildren();
    for (let fe = 0; fe < le.length; fe++) {
      const Ne = le[fe];
      if (!$l(Ne))
        throw Error("Expected GridNode children to be GridRowNode");
      const Ee = Ne.getChildren();
      let xe = 0;
      for (const Ce of Ee) {
        if (!jr(Ce))
          throw Error("Expected GridRowNode children to be GridCellNode");
        for (; !B(fe, xe); )
          xe++;
        I(fe, xe, Ce), xe += Ce.__colSpan;
      }
    }
    if (_ === null)
      throw Error("Anchor not found in Grid");
    if (E === null)
      throw Error("Focus not found in Grid");
    return [f, _, E];
  }
  function Ud(u) {
    let o;
    if (u instanceof zc)
      o = u;
    else if (u instanceof Rt) {
      const _ = Yo(u, jr);
      if (!jr(_))
        throw Error("Expected to find a parent GridCellNode");
      o = _;
    } else {
      const _ = Yo(u.getNode(), jr);
      if (!jr(_))
        throw Error("Expected to find a parent GridCellNode");
      o = _;
    }
    const a = o.getParent();
    if (!$l(a))
      throw Error("Expected GridCellNode to have a parent GridRowNode");
    const f = a.getParent();
    if (!Gc(f))
      throw Error("Expected GridRowNode to have a parent GridNode");
    return [o, a, f];
  }
  function Bc(u) {
    u.isCollapsed() || u.removeText();
    const o = u.anchor, a = o.getNode();
    if (!ft(a))
      return o.offset;
    const f = a.getParent();
    if (!f) {
      const le = Xi();
      return Jn().append(le), le.select(), 0;
    }
    const _ = a.splitText(o.offset);
    if (_.length === 0)
      return 0;
    const E = o.offset === 0 ? 0 : 1, I = _[0].getIndexWithinParent() + E;
    if (!f.isInline() || I === 0)
      return I;
    const B = f.getChildAtIndex(I);
    return B && f.insertNewAfter(u).append(B, ...B.getNextSiblings()), f.getIndexWithinParent() + E;
  }
  function p_(u) {
    const o = Xi();
    let a = null;
    for (let f = 0; f < u.length; f++) {
      const _ = u[f], E = Mi(_);
      if (E || Sn(_) && _.isInline() || Je(_) && _.isInline() || ft(_) || _.isParentRequired()) {
        if (a === null && (a = _.createParentElementNode(), o.append(a), E))
          continue;
        a !== null && a.append(_);
      } else
        o.append(_), a = null;
    }
    return o;
  }
  let jn = null, qn = null, Sr = !1, Hc = !1, Ga = 0;
  const zd = {
    characterData: !0,
    childList: !0,
    subtree: !0
  };
  function zs() {
    return Sr || jn !== null && jn._readOnly;
  }
  function rr() {
    if (Sr)
      throw Error("Cannot use method in read-only mode.");
  }
  function Gd() {
    if (Ga > 99)
      throw Error("One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.");
  }
  function Ii() {
    if (jn === null)
      throw Error("Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().");
    return jn;
  }
  function gn() {
    if (qn === null)
      throw Error("Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().");
    return qn;
  }
  function m_() {
    return qn;
  }
  function Yd(u, o, a) {
    const f = o.__type, _ = $r(u, f);
    let E = a.get(f);
    E === void 0 && (E = Array.from(_.transforms), a.set(f, E));
    const I = E.length;
    for (let B = 0; B < I && (E[B](o), !!o.isAttached()); B++)
      ;
  }
  function Vd(u, o) {
    return u !== void 0 && // We don't want to transform nodes being composed
    u.__key !== o && u.isAttached();
  }
  function __(u, o) {
    const a = o._dirtyLeaves, f = u._nodeMap;
    for (const _ of a) {
      const E = f.get(_);
      ft(E) && E.isAttached() && E.isSimpleText() && !E.isUnmergeable() && dl(E);
    }
  }
  function y_(u, o) {
    const a = o._dirtyLeaves, f = o._dirtyElements, _ = u._nodeMap, E = Fr(), I = /* @__PURE__ */ new Map();
    let B = a, le = B.size, fe = f, Ne = fe.size;
    for (; le > 0 || Ne > 0; ) {
      if (le > 0) {
        o._dirtyLeaves = /* @__PURE__ */ new Set();
        for (const Ee of B) {
          const xe = _.get(Ee);
          ft(xe) && xe.isAttached() && xe.isSimpleText() && !xe.isUnmergeable() && dl(xe), xe !== void 0 && Vd(xe, E) && Yd(o, xe, I), a.add(Ee);
        }
        if (B = o._dirtyLeaves, le = B.size, le > 0) {
          Ga++;
          continue;
        }
      }
      o._dirtyLeaves = /* @__PURE__ */ new Set(), o._dirtyElements = /* @__PURE__ */ new Map();
      for (const Ee of fe) {
        const xe = Ee[0], Ce = Ee[1];
        if (xe !== "root" && !Ce)
          continue;
        const He = _.get(xe);
        He !== void 0 && Vd(He, E) && Yd(o, He, I), f.set(xe, Ce);
      }
      B = o._dirtyLeaves, le = B.size, fe = o._dirtyElements, Ne = fe.size, Ga++;
    }
    o._dirtyLeaves = a, o._dirtyElements = f;
  }
  function N_(u) {
    return Wc(u, gn()._nodes);
  }
  function Wc(u, o) {
    const a = u.type, f = o.get(a);
    if (f === void 0)
      throw Error(`parseEditorState: type "${a}" + not found`);
    const _ = f.klass;
    if (u.type !== _.getType())
      throw Error(`LexicalNode: Node ${_.name} does not implement .importJSON().`);
    const E = _.importJSON(u), I = u.children;
    if (Je(E) && Array.isArray(I))
      for (let B = 0; B < I.length; B++) {
        const le = I[B], fe = Wc(le, o);
        E.append(fe);
      }
    return E;
  }
  function C_(u, o, a) {
    const f = Uc(), _ = jn, E = Sr, I = qn, B = o._dirtyElements, le = o._dirtyLeaves, fe = o._cloneNotNeeded, Ne = o._dirtyType;
    o._dirtyElements = /* @__PURE__ */ new Map(), o._dirtyLeaves = /* @__PURE__ */ new Set(), o._cloneNotNeeded = /* @__PURE__ */ new Set(), o._dirtyType = 0, jn = f, Sr = !1, qn = o;
    try {
      const Ee = o._nodes, xe = u.root;
      Wc(xe, Ee), a && a(), f._readOnly = !0, qd(f);
    } catch (Ee) {
      Ee instanceof Error && o._onError(Ee);
    } finally {
      o._dirtyElements = B, o._dirtyLeaves = le, o._cloneNotNeeded = fe, o._dirtyType = Ne, jn = _, Sr = E, qn = I;
    }
    return f;
  }
  function jd(u, o) {
    const a = jn, f = Sr, _ = qn;
    jn = u, Sr = !0, qn = null;
    try {
      return o();
    } finally {
      jn = a, Sr = f, qn = _;
    }
  }
  function qd(u) {
    const o = u._nodeMap;
    o.set = () => {
      throw new Error("Cannot call set() on a frozen Lexical node map");
    }, o.clear = () => {
      throw new Error("Cannot call clear() on a frozen Lexical node map");
    }, o.delete = () => {
      throw new Error("Cannot call delete() on a frozen Lexical node map");
    };
  }
  function is(u, o) {
    const a = u._pendingEditorState, f = u._rootElement, _ = u._headless || f === null;
    if (a === null)
      return;
    const E = u._editorState, I = E._selection, B = a._selection, le = u._dirtyType !== lt, fe = jn, Ne = Sr, Ee = qn, xe = u._updating, Ce = u._observer;
    let He = null;
    if (u._pendingEditorState = null, u._editorState = a, !_ && le && Ce !== null) {
      qn = u, jn = a, Sr = !1, u._updating = !0;
      try {
        const Nt = u._dirtyType, xt = u._dirtyElements, Ht = u._dirtyLeaves;
        Ce.disconnect(), He = lr(E, a, u, Nt, xt, Ht);
      } catch (Nt) {
        if (Nt instanceof Error && u._onError(Nt), !Hc)
          tf(u, null, f, a), Zn(u), u._dirtyType = ct, Hc = !0, is(u, E), Hc = !1;
        else
          throw Nt;
        return;
      } finally {
        Ce.observe(f, zd), u._updating = xe, jn = fe, Sr = Ne, qn = Ee;
      }
    }
    a._readOnly || (a._readOnly = !0, qd(a), gt(B) && (Object.freeze(B.anchor), Object.freeze(B.focus)), Object.freeze(B));
    const Ie = u._dirtyLeaves, be = u._dirtyElements, pt = u._normalizedNodes, Ue = u._updateTags, tt = u._deferred;
    le && (u._dirtyType = lt, u._cloneNotNeeded.clear(), u._dirtyLeaves = /* @__PURE__ */ new Set(), u._dirtyElements = /* @__PURE__ */ new Map(), u._normalizedNodes = /* @__PURE__ */ new Set(), u._updateTags = /* @__PURE__ */ new Set()), wa(u, a);
    const $t = _ ? null : Cr(u._window);
    if (u._editable && // domSelection will be null in headless
    $t !== null && (le || B === null || B.dirty)) {
      qn = u, jn = a;
      try {
        if (Ce !== null && Ce.disconnect(), le || B === null || B.dirty) {
          const Nt = u._blockCursorElement;
          Nt !== null && St(Nt, u, f), f_(I, B, u, $t, Ue, f);
        }
        wl(u, f, B), Ce !== null && Ce.observe(f, zd);
      } finally {
        qn = Ee, jn = fe;
      }
    }
    He !== null && T_(u, He, Ue, Ie, E), !gt(B) && B !== null && (I === null || !I.is(B)) && u.dispatchCommand(e, void 0);
    const bt = u._pendingDecorators;
    bt !== null && (u._decorators = bt, u._pendingDecorators = null, Pl("decorator", u, !0, bt)), E_(u, o || E, a), Pl("update", u, !0, {
      dirtyElements: be,
      dirtyLeaves: Ie,
      editorState: a,
      normalizedNodes: pt,
      prevEditorState: o || E,
      tags: Ue
    }), v_(u, tt), x_(u);
  }
  function E_(u, o, a) {
    const f = co(o), _ = co(a);
    f !== _ && Pl("textcontent", u, !0, _);
  }
  function T_(u, o, a, f, _) {
    const E = Array.from(u._listeners.mutation), I = E.length;
    for (let B = 0; B < I; B++) {
      const [le, fe] = E[B], Ne = o.get(fe);
      Ne !== void 0 && le(Ne, {
        dirtyLeaves: f,
        prevEditorState: _,
        updateTags: a
      });
    }
  }
  function Pl(u, o, a, ...f) {
    const _ = o._updating;
    o._updating = a;
    try {
      const E = Array.from(o._listeners[u]);
      for (let I = 0; I < E.length; I++)
        E[I].apply(null, f);
    } finally {
      o._updating = _;
    }
  }
  function Zd(u, o, a) {
    if (u._updating === !1 || qn !== u) {
      let _ = !1;
      return u.update(() => {
        _ = Zd(u, o, a);
      }), _;
    }
    const f = Os(u);
    for (let _ = 4; _ >= 0; _--)
      for (let E = 0; E < f.length; E++) {
        const le = f[E]._commands.get(o);
        if (le !== void 0) {
          const fe = le[_];
          if (fe !== void 0) {
            const Ne = Array.from(fe), Ee = Ne.length;
            for (let xe = 0; xe < Ee; xe++)
              if (Ne[xe](a, u) === !0)
                return !0;
          }
        }
      }
    return !1;
  }
  function x_(u) {
    const o = u._updates;
    if (o.length !== 0) {
      const a = o.shift();
      if (a) {
        const [f, _] = a;
        Xd(u, f, _);
      }
    }
  }
  function v_(u, o) {
    if (u._deferred = [], o.length !== 0) {
      const a = u._updating;
      u._updating = !0;
      try {
        for (let f = 0; f < o.length; f++)
          o[f]();
      } finally {
        u._updating = a;
      }
    }
  }
  function Jd(u, o) {
    const a = u._updates;
    let f = o || !1;
    for (; a.length !== 0; ) {
      const _ = a.shift();
      if (_) {
        const [E, I] = _;
        let B, le;
        I !== void 0 && (B = I.onUpdate, le = I.tag, I.skipTransforms && (f = !0), B && u._deferred.push(B), le && u._updateTags.add(le)), E();
      }
    }
    return f;
  }
  function Xd(u, o, a) {
    const f = u._updateTags;
    let _, E, I = !1, B = !1;
    a !== void 0 && (_ = a.onUpdate, E = a.tag, E != null && f.add(E), I = a.skipTransforms || !1, B = a.discrete || !1), _ && u._deferred.push(_);
    const le = u._editorState;
    let fe = u._pendingEditorState, Ne = !1;
    (fe === null || fe._readOnly) && (fe = u._pendingEditorState = O_(fe || le), Ne = !0), fe._flushSync = B;
    const Ee = jn, xe = Sr, Ce = qn, He = u._updating;
    jn = fe, Sr = !1, u._updating = !0, qn = u;
    try {
      Ne && (u._headless ? le._selection != null && (fe._selection = le._selection.clone()) : fe._selection = u_(u));
      const be = u._compositionKey;
      o(), I = Jd(u, I), d_(fe, u), u._dirtyType !== lt && (I ? __(fe, u) : y_(fe, u), Jd(u), Oa(le, fe, u._dirtyLeaves, u._dirtyElements));
      const pt = u._compositionKey;
      be !== pt && (fe._flushSync = !0);
      const Ue = fe._selection;
      if (gt(Ue)) {
        const tt = fe._nodeMap, $t = Ue.anchor.key, bt = Ue.focus.key;
        if (tt.get($t) === void 0 || tt.get(bt) === void 0)
          throw Error("updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.");
      } else
        vr(Ue) && Ue._nodes.size === 0 && (fe._selection = null);
    } catch (be) {
      be instanceof Error && u._onError(be), u._pendingEditorState = le, u._dirtyType = ct, u._cloneNotNeeded.clear(), u._dirtyLeaves = /* @__PURE__ */ new Set(), u._dirtyElements.clear(), is(u);
      return;
    } finally {
      jn = Ee, Sr = xe, qn = Ce, u._updating = He, Ga = 0;
    }
    u._dirtyType !== lt || w_(fe, u) ? fe._flushSync ? (fe._flushSync = !1, is(u)) : Ne && Ts(() => {
      is(u);
    }) : (fe._flushSync = !1, Ne && (f.clear(), u._deferred = [], u._pendingEditorState = null));
  }
  function Lr(u, o, a) {
    u._updating ? u._updates.push([o, a]) : Xd(u, o, a);
  }
  class Kc extends Rt {
    constructor(o) {
      super(o);
    }
    /**
     * The returned value is added to the LexicalEditor._decorators
     */
    decorate(o, a) {
      throw Error("decorate: base method not extended");
    }
    isIsolated() {
      return !1;
    }
    isInline() {
      return !0;
    }
    isKeyboardSelectable() {
      return !0;
    }
  }
  function Sn(u) {
    return u instanceof Kc;
  }
  class os extends Rt {
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    constructor(o) {
      super(o), this.__first = null, this.__last = null, this.__size = 0, this.__format = 0, this.__indent = 0, this.__dir = null;
    }
    getFormat() {
      return this.getLatest().__format;
    }
    getFormatType() {
      const o = this.getFormat();
      return Cs[o] || "";
    }
    getIndent() {
      return this.getLatest().__indent;
    }
    getChildren() {
      const o = [];
      let a = this.getFirstChild();
      for (; a !== null; )
        o.push(a), a = a.getNextSibling();
      return o;
    }
    getChildrenKeys() {
      const o = [];
      let a = this.getFirstChild();
      for (; a !== null; )
        o.push(a.__key), a = a.getNextSibling();
      return o;
    }
    getChildrenSize() {
      return this.getLatest().__size;
    }
    isEmpty() {
      return this.getChildrenSize() === 0;
    }
    isDirty() {
      const a = gn()._dirtyElements;
      return a !== null && a.has(this.__key);
    }
    isLastChild() {
      const o = this.getLatest(), a = this.getParentOrThrow().getLastChild();
      return a !== null && a.is(o);
    }
    getAllTextNodes() {
      const o = [];
      let a = this.getFirstChild();
      for (; a !== null; ) {
        if (ft(a) && o.push(a), Je(a)) {
          const f = a.getAllTextNodes();
          o.push(...f);
        }
        a = a.getNextSibling();
      }
      return o;
    }
    getFirstDescendant() {
      let o = this.getFirstChild();
      for (; o !== null; ) {
        if (Je(o)) {
          const a = o.getFirstChild();
          if (a !== null) {
            o = a;
            continue;
          }
        }
        break;
      }
      return o;
    }
    getLastDescendant() {
      let o = this.getLastChild();
      for (; o !== null; ) {
        if (Je(o)) {
          const a = o.getLastChild();
          if (a !== null) {
            o = a;
            continue;
          }
        }
        break;
      }
      return o;
    }
    getDescendantByIndex(o) {
      const a = this.getChildren(), f = a.length;
      if (o >= f) {
        const E = a[f - 1];
        return Je(E) && E.getLastDescendant() || E || null;
      }
      const _ = a[o];
      return Je(_) && _.getFirstDescendant() || _ || null;
    }
    getFirstChild() {
      const a = this.getLatest().__first;
      return a === null ? null : En(a);
    }
    getFirstChildOrThrow() {
      const o = this.getFirstChild();
      if (o === null)
        throw Error(`Expected node ${this.__key} to have a first child.`);
      return o;
    }
    getLastChild() {
      const a = this.getLatest().__last;
      return a === null ? null : En(a);
    }
    getLastChildOrThrow() {
      const o = this.getLastChild();
      if (o === null)
        throw Error(`Expected node ${this.__key} to have a last child.`);
      return o;
    }
    getChildAtIndex(o) {
      const a = this.getChildrenSize();
      let f, _;
      if (o < a / 2) {
        for (f = this.getFirstChild(), _ = 0; f !== null && _ <= o; ) {
          if (_ === o)
            return f;
          f = f.getNextSibling(), _++;
        }
        return null;
      }
      for (f = this.getLastChild(), _ = a - 1; f !== null && _ >= o; ) {
        if (_ === o)
          return f;
        f = f.getPreviousSibling(), _--;
      }
      return null;
    }
    getTextContent() {
      let o = "";
      const a = this.getChildren(), f = a.length;
      for (let _ = 0; _ < f; _++) {
        const E = a[_];
        o += E.getTextContent(), Je(E) && _ !== f - 1 && !E.isInline() && (o += Lt);
      }
      return o;
    }
    getTextContentSize() {
      let o = 0;
      const a = this.getChildren(), f = a.length;
      for (let _ = 0; _ < f; _++) {
        const E = a[_];
        o += E.getTextContentSize(), Je(E) && _ !== f - 1 && !E.isInline() && (o += Lt.length);
      }
      return o;
    }
    getDirection() {
      return this.getLatest().__dir;
    }
    hasFormat(o) {
      if (o !== "") {
        const a = ti[o];
        return (this.getFormat() & a) !== 0;
      }
      return !1;
    }
    // Mutators
    select(o, a) {
      rr();
      const f = an();
      let _ = o, E = a;
      const I = this.getChildrenSize();
      if (!this.canBeEmpty()) {
        if (o === 0 && a === 0) {
          const le = this.getFirstChild();
          if (ft(le) || Je(le))
            return le.select(0, 0);
        } else if ((o === void 0 || o === I) && (a === void 0 || a === I)) {
          const le = this.getLastChild();
          if (ft(le) || Je(le))
            return le.select();
        }
      }
      _ === void 0 && (_ = I), E === void 0 && (E = I);
      const B = this.__key;
      if (gt(f))
        f.anchor.set(B, _, "element"), f.focus.set(B, E, "element"), f.dirty = !0;
      else
        return Bd(B, _, B, E, "element", "element");
      return f;
    }
    selectStart() {
      const o = this.getFirstDescendant();
      return o ? o.selectStart() : this.select();
    }
    selectEnd() {
      const o = this.getLastDescendant();
      return o ? o.selectEnd() : this.select();
    }
    clear() {
      const o = this.getWritable();
      return this.getChildren().forEach((f) => f.remove()), o;
    }
    append(...o) {
      return this.splice(this.getChildrenSize(), 0, o);
    }
    setDirection(o) {
      const a = this.getWritable();
      return a.__dir = o, a;
    }
    setFormat(o) {
      const a = this.getWritable();
      return a.__format = o !== "" ? ti[o] : 0, this;
    }
    setIndent(o) {
      const a = this.getWritable();
      return a.__indent = o, this;
    }
    splice(o, a, f) {
      const _ = f.length, E = this.getChildrenSize(), I = this.getWritable(), B = I.__key, le = [], fe = [], Ne = this.getChildAtIndex(o + a);
      let Ee = null, xe = E - a + _;
      if (o !== 0)
        if (o === E)
          Ee = this.getLastChild();
        else {
          const He = this.getChildAtIndex(o);
          He !== null && (Ee = He.getPreviousSibling());
        }
      if (a > 0) {
        let He = Ee === null ? this.getFirstChild() : Ee.getNextSibling();
        for (let Ie = 0; Ie < a; Ie++) {
          if (He === null)
            throw Error("splice: sibling not found");
          const be = He.getNextSibling(), pt = He.__key, Ue = He.getWritable();
          Ei(Ue), fe.push(pt), He = be;
        }
      }
      let Ce = Ee;
      for (let He = 0; He < _; He++) {
        const Ie = f[He];
        Ce !== null && Ie.is(Ce) && (Ee = Ce = Ce.getPreviousSibling());
        const be = Ie.getWritable();
        be.__parent === B && xe--, Ei(be);
        const pt = Ie.__key;
        if (Ce === null)
          I.__first = pt, be.__prev = null;
        else {
          const Ue = Ce.getWritable();
          Ue.__next = pt, be.__prev = Ue.__key;
        }
        if (Ie.__key === B)
          throw Error("append: attempting to append self");
        be.__parent = B, le.push(pt), Ce = Ie;
      }
      if (o + a === E) {
        if (Ce !== null) {
          const He = Ce.getWritable();
          He.__next = null, I.__last = Ce.__key;
        }
      } else if (Ne !== null) {
        const He = Ne.getWritable();
        if (Ce !== null) {
          const Ie = Ce.getWritable();
          He.__prev = Ce.__key, Ie.__next = Ne.__key;
        } else
          He.__prev = null;
      }
      if (I.__size = xe, fe.length) {
        const He = an();
        if (gt(He)) {
          const Ie = new Set(fe), be = new Set(le), {
            anchor: pt,
            focus: Ue
          } = He;
          Qd(pt, Ie, be) && za(pt, pt.getNode(), this, Ee, Ne), Qd(Ue, Ie, be) && za(Ue, Ue.getNode(), this, Ee, Ne), xe === 0 && !this.canBeEmpty() && !Wr(this) && this.remove();
        }
      }
      return I;
    }
    // JSON serialization
    exportJSON() {
      return {
        children: [],
        direction: this.getDirection(),
        format: this.getFormatType(),
        indent: this.getIndent(),
        type: "element",
        version: 1
      };
    }
    // These are intended to be extends for specific element heuristics.
    insertNewAfter(o, a) {
      return null;
    }
    canIndent() {
      return !0;
    }
    /*
     * This method controls the behavior of a the node during backwards
     * deletion (i.e., backspace) when selection is at the beginning of
     * the node (offset 0)
     */
    collapseAtStart(o) {
      return !1;
    }
    excludeFromCopy(o) {
      return !1;
    }
    // TODO 0.10 deprecate
    canExtractContents() {
      return !0;
    }
    canReplaceWith(o) {
      return !0;
    }
    canInsertAfter(o) {
      return !0;
    }
    canBeEmpty() {
      return !0;
    }
    canInsertTextBefore() {
      return !0;
    }
    canInsertTextAfter() {
      return !0;
    }
    isInline() {
      return !1;
    }
    // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the
    // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)
    // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode
    // will return the immediate first child underneath TableCellNode instead of RootNode.
    isShadowRoot() {
      return !1;
    }
    canMergeWith(o) {
      return !1;
    }
    extractWithChild(o, a, f) {
      return !1;
    }
  }
  function Je(u) {
    return u instanceof os;
  }
  function Qd(u, o, a) {
    let f = u.getNode();
    for (; f; ) {
      const _ = f.__key;
      if (o.has(_) && !a.has(_))
        return !0;
      f = f.getParent();
    }
    return !1;
  }
  class Gs extends os {
    /** @internal */
    static getType() {
      return "root";
    }
    static clone() {
      return new Gs();
    }
    constructor() {
      super("root"), this.__cachedText = null;
    }
    getTopLevelElementOrThrow() {
      throw Error("getTopLevelElementOrThrow: root nodes are not top level elements");
    }
    getTextContent() {
      const o = this.__cachedText;
      return (zs() || gn()._dirtyType === lt) && o !== null ? o : super.getTextContent();
    }
    remove() {
      throw Error("remove: cannot be called on root nodes");
    }
    replace(o) {
      throw Error("replace: cannot be called on root nodes");
    }
    insertBefore(o) {
      throw Error("insertBefore: cannot be called on root nodes");
    }
    insertAfter(o) {
      throw Error("insertAfter: cannot be called on root nodes");
    }
    // View
    updateDOM(o, a) {
      return !1;
    }
    // Mutate
    append(...o) {
      for (let a = 0; a < o.length; a++) {
        const f = o[a];
        if (!Je(f) && !Sn(f))
          throw Error("rootNode.append: Only element or decorator nodes can be appended to the root node");
      }
      return super.append(...o);
    }
    static importJSON(o) {
      const a = Jn();
      return a.setFormat(o.format), a.setIndent(o.indent), a.setDirection(o.direction), a;
    }
    exportJSON() {
      return {
        children: [],
        direction: this.getDirection(),
        format: this.getFormatType(),
        indent: this.getIndent(),
        type: "root",
        version: 1
      };
    }
    collapseAtStart() {
      return !0;
    }
  }
  function S_() {
    return new Gs();
  }
  function Ir(u) {
    return u instanceof Gs;
  }
  function w_(u, o) {
    const a = o.getEditorState()._selection, f = u._selection;
    if (f !== null) {
      if (f.dirty || !f.is(a))
        return !0;
    } else if (a !== null)
      return !0;
    return !1;
  }
  function O_(u) {
    return new Ya(new Map(u._nodeMap));
  }
  function Uc() {
    return new Ya(/* @__PURE__ */ new Map([["root", S_()]]));
  }
  function ef(u) {
    const o = u.exportJSON(), a = u.constructor;
    if (o.type !== a.getType())
      throw Error(`LexicalNode: Node ${a.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);
    const f = o.children;
    if (Je(u)) {
      if (!Array.isArray(f))
        throw Error(`LexicalNode: Node ${a.name} is an element but .exportJSON() does not have a children array.`);
      const _ = u.getChildren();
      for (let E = 0; E < _.length; E++) {
        const I = _[E], B = ef(I);
        f.push(B);
      }
    }
    return o;
  }
  class Ya {
    constructor(o, a) {
      this._nodeMap = o, this._selection = a || null, this._flushSync = !1, this._readOnly = !1;
    }
    isEmpty() {
      return this._nodeMap.size === 1 && this._selection === null;
    }
    read(o) {
      return jd(this, o);
    }
    clone(o) {
      const a = new Ya(this._nodeMap, o === void 0 ? this._selection : o);
      return a._readOnly = !0, a;
    }
    toJSON() {
      return jd(this, () => ({
        root: ef(Jn())
      }));
    }
  }
  class Ys extends os {
    static getType() {
      return "paragraph";
    }
    static clone(o) {
      return new Ys(o.__key);
    }
    // View
    createDOM(o) {
      const a = document.createElement("p"), f = Ui(o.theme, "paragraph");
      return f !== void 0 && a.classList.add(...f), a;
    }
    updateDOM(o, a, f) {
      return !1;
    }
    static importDOM() {
      return {
        p: (o) => ({
          conversion: D_,
          priority: 0
        })
      };
    }
    exportDOM(o) {
      const {
        element: a
      } = super.exportDOM(o);
      if (a && jo(a)) {
        this.isEmpty() && a.append(document.createElement("br"));
        const f = this.getFormatType();
        a.style.textAlign = f;
        const _ = this.getDirection();
        _ && (a.dir = _);
        const E = this.getIndent();
        E > 0 && (a.style.textIndent = `${E * 20}px`);
      }
      return {
        element: a
      };
    }
    static importJSON(o) {
      const a = Xi();
      return a.setFormat(o.format), a.setIndent(o.indent), a.setDirection(o.direction), a;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "paragraph",
        version: 1
      };
    }
    // Mutation
    insertNewAfter(o, a) {
      const f = Xi(), _ = this.getDirection();
      return f.setDirection(_), this.insertAfter(f, a), f;
    }
    collapseAtStart() {
      const o = this.getChildren();
      if (o.length === 0 || ft(o[0]) && o[0].getTextContent().trim() === "") {
        if (this.getNextSibling() !== null)
          return this.selectNext(), this.remove(), !0;
        if (this.getPreviousSibling() !== null)
          return this.selectPrevious(), this.remove(), !0;
      }
      return !1;
    }
  }
  function D_(u) {
    const o = Xi();
    if (u.style) {
      o.setFormat(u.style.textAlign);
      const a = parseInt(u.style.textIndent, 10) / 20;
      a > 0 && o.setIndent(a);
    }
    return {
      node: o
    };
  }
  function Xi() {
    return po(new Ys());
  }
  function R_(u) {
    return u instanceof Ys;
  }
  const b_ = 0, M_ = 1, A_ = 2, k_ = 3, L_ = 4;
  function tf(u, o, a, f) {
    const _ = u._keyToDOMMap;
    _.clear(), u._editorState = Uc(), u._pendingEditorState = f, u._compositionKey = null, u._dirtyType = lt, u._cloneNotNeeded.clear(), u._dirtyLeaves = /* @__PURE__ */ new Set(), u._dirtyElements.clear(), u._normalizedNodes = /* @__PURE__ */ new Set(), u._updateTags = /* @__PURE__ */ new Set(), u._updates = [], u._blockCursorElement = null;
    const E = u._observer;
    E !== null && (E.disconnect(), u._observer = null), o !== null && (o.textContent = ""), a !== null && (a.textContent = "", _.set("root", a));
  }
  function I_(u, o) {
    const a = /* @__PURE__ */ new Map(), f = /* @__PURE__ */ new Set(), _ = (E) => {
      Object.keys(E).forEach((I) => {
        let B = a.get(I);
        B === void 0 && (B = [], a.set(I, B)), B.push(E[I]);
      });
    };
    return u.forEach((E) => {
      const I = E.klass.importDOM != null ? E.klass.importDOM.bind(E.klass) : null;
      if (I == null || f.has(I))
        return;
      f.add(I);
      const B = I();
      B !== null && _(B);
    }), o && _(o), a;
  }
  function P_(u) {
    const o = u || {}, a = m_(), f = o.theme || {}, _ = u === void 0 ? a : o.parentEditor || null, E = o.disableEvents || !1, I = Uc(), B = o.namespace || (_ !== null ? _._config.namespace : $o()), le = o.editorState, fe = [Gs, ji, zr, Ai, Ys, ...o.nodes || []], {
      onError: Ne,
      html: Ee
    } = o, xe = o.editable !== void 0 ? o.editable : !0;
    let Ce;
    if (u === void 0 && a !== null)
      Ce = a._nodes;
    else {
      Ce = /* @__PURE__ */ new Map();
      for (let Ie = 0; Ie < fe.length; Ie++) {
        let be = fe[Ie], pt = null, Ue = null;
        if (typeof be != "function") {
          const Nt = be;
          be = Nt.replace, pt = Nt.with, Ue = Nt.withKlass || null;
        }
        {
          const Nt = be.name;
          if (Nt !== "RootNode") {
            const xt = be.prototype;
            ["getType", "clone"].forEach((Ht) => {
              be.hasOwnProperty(Ht) || console.warn(`${Nt} must implement static "${Ht}" method`);
            }), // eslint-disable-next-line no-prototype-builtins
            !be.hasOwnProperty("importDOM") && // eslint-disable-next-line no-prototype-builtins
            be.hasOwnProperty("exportDOM") && console.warn(`${Nt} should implement "importDOM" if using a custom "exportDOM" method to ensure HTML serialization (important for copy & paste) works as expected`), xt instanceof Kc && (xt.hasOwnProperty("decorate") || console.warn(`${xt.constructor.name} must implement "decorate" method`)), be.hasOwnProperty("importJSON") || console.warn(`${Nt} should implement "importJSON" method to ensure JSON and default HTML serialization works as expected`), xt.hasOwnProperty("exportJSON") || console.warn(`${Nt} should implement "exportJSON" method to ensure JSON and default HTML serialization works as expected`);
          }
        }
        const tt = be.getType(), $t = be.transform(), bt = /* @__PURE__ */ new Set();
        $t !== null && bt.add($t), Ce.set(tt, {
          exportDOM: Ee && Ee.export ? Ee.export.get(be) : void 0,
          klass: be,
          replace: pt,
          replaceWithKlass: Ue,
          transforms: bt
        });
      }
    }
    const He = new $_(I, _, Ce, {
      disableEvents: E,
      namespace: B,
      theme: f
    }, Ne || console.error, I_(Ce, Ee ? Ee.import : void 0), xe);
    return le !== void 0 && (He._pendingEditorState = le, He._dirtyType = ct), He;
  }
  class $_ {
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    constructor(o, a, f, _, E, I, B) {
      this._parentEditor = a, this._rootElement = null, this._editorState = o, this._pendingEditorState = null, this._compositionKey = null, this._deferred = [], this._keyToDOMMap = /* @__PURE__ */ new Map(), this._updates = [], this._updating = !1, this._listeners = {
        decorator: /* @__PURE__ */ new Set(),
        editable: /* @__PURE__ */ new Set(),
        mutation: /* @__PURE__ */ new Map(),
        root: /* @__PURE__ */ new Set(),
        textcontent: /* @__PURE__ */ new Set(),
        update: /* @__PURE__ */ new Set()
      }, this._commands = /* @__PURE__ */ new Map(), this._config = _, this._nodes = f, this._decorators = {}, this._pendingDecorators = null, this._dirtyType = lt, this._cloneNotNeeded = /* @__PURE__ */ new Set(), this._dirtyLeaves = /* @__PURE__ */ new Set(), this._dirtyElements = /* @__PURE__ */ new Map(), this._normalizedNodes = /* @__PURE__ */ new Set(), this._updateTags = /* @__PURE__ */ new Set(), this._observer = null, this._key = $o(), this._onError = E, this._htmlConversions = I, this._editable = B, this._headless = a !== null && a._headless, this._window = null, this._blockCursorElement = null;
    }
    /**
     *
     * @returns true if the editor is currently in "composition" mode due to receiving input
     * through an IME, or 3P extension, for example. Returns false otherwise.
     */
    isComposing() {
      return this._compositionKey != null;
    }
    /**
     * Registers a listener for Editor update event. Will trigger the provided callback
     * each time the editor goes through an update (via {@link LexicalEditor.update}) until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerUpdateListener(o) {
      const a = this._listeners.update;
      return a.add(o), () => {
        a.delete(o);
      };
    }
    /**
     * Registers a listener for for when the editor changes between editable and non-editable states.
     * Will trigger the provided callback each time the editor transitions between these states until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerEditableListener(o) {
      const a = this._listeners.editable;
      return a.add(o), () => {
        a.delete(o);
      };
    }
    /**
     * Registers a listener for when the editor's decorator object changes. The decorator object contains
     * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.
     *
     * Will trigger the provided callback each time the editor transitions between these states until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerDecoratorListener(o) {
      const a = this._listeners.decorator;
      return a.add(o), () => {
        a.delete(o);
      };
    }
    /**
     * Registers a listener for when Lexical commits an update to the DOM and the text content of
     * the editor changes from the previous state of the editor. If the text content is the
     * same between updates, no notifications to the listeners will happen.
     *
     * Will trigger the provided callback each time the editor transitions between these states until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerTextContentListener(o) {
      const a = this._listeners.textcontent;
      return a.add(o), () => {
        a.delete(o);
      };
    }
    /**
     * Registers a listener for when the editor's root DOM element (the content editable
     * Lexical attaches to) changes. This is primarily used to attach event listeners to the root
     *  element. The root listener function is executed directly upon registration and then on
     * any subsequent update.
     *
     * Will trigger the provided callback each time the editor transitions between these states until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerRootListener(o) {
      const a = this._listeners.root;
      return o(this._rootElement, null), a.add(o), () => {
        o(null, this._rootElement), a.delete(o);
      };
    }
    /**
     * Registers a listener that will trigger anytime the provided command
     * is dispatched, subject to priority. Listeners that run at a higher priority can "intercept"
     * commands and prevent them from propagating to other handlers by returning true.
     *
     * Listeners registered at the same priority level will run deterministically in the order of registration.
     *
     * @param command - the command that will trigger the callback.
     * @param listener - the function that will execute when the command is dispatched.
     * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerCommand(o, a, f) {
      if (f === void 0)
        throw Error('Listener for type "command" requires a "priority".');
      const _ = this._commands;
      _.has(o) || _.set(o, [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()]);
      const E = _.get(o);
      if (E === void 0)
        throw Error(`registerCommand: Command ${String(o)} not found in command map`);
      const I = E[f];
      return I.add(a), () => {
        I.delete(a), E.every((B) => B.size === 0) && _.delete(o);
      };
    }
    /**
     * Registers a listener that will run when a Lexical node of the provided class is
     * mutated. The listener will receive a list of nodes along with the type of mutation
     * that was performed on each: created, destroyed, or updated.
     *
     * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.
     * {@link LexicalEditor.getElementByKey} can be used for this.
     *
     * @param klass - The class of the node that you want to listen to mutations on.
     * @param listener - The logic you want to run when the node is mutated.
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerMutationListener(o, a) {
      if (this._nodes.get(o.getType()) === void 0)
        throw Error(`Node ${o.name} has not been registered. Ensure node has been passed to createEditor.`);
      const _ = this._listeners.mutation;
      return _.set(a, o), () => {
        _.delete(a);
      };
    }
    /** @internal */
    registerNodeTransformToKlass(o, a) {
      const f = o.getType(), _ = this._nodes.get(f);
      if (_ === void 0)
        throw Error(`Node ${o.name} has not been registered. Ensure node has been passed to createEditor.`);
      return _.transforms.add(a), _;
    }
    /**
     * Registers a listener that will run when a Lexical node of the provided class is
     * marked dirty during an update. The listener will continue to run as long as the node
     * is marked dirty. There are no guarantees around the order of transform execution!
     *
     * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)
     * @param klass - The class of the node that you want to run transforms on.
     * @param listener - The logic you want to run when the node is updated.
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerNodeTransform(o, a) {
      const f = this.registerNodeTransformToKlass(o, a), _ = [f], E = f.replaceWithKlass;
      if (E != null) {
        const I = this.registerNodeTransformToKlass(E, a);
        _.push(I);
      }
      return Ss(this, o.getType()), () => {
        _.forEach((I) => I.transforms.delete(a));
      };
    }
    /**
     * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they
     * depend on have been registered.
     * @returns True if the editor has registered the provided node type, false otherwise.
     */
    hasNode(o) {
      return this._nodes.has(o.getType());
    }
    /**
     * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they
     * depend on have been registered.
     * @returns True if the editor has registered all of the provided node types, false otherwise.
     */
    hasNodes(o) {
      return o.every(this.hasNode.bind(this));
    }
    /**
     * Dispatches a command of the specified type with the specified payload.
     * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})
     * for this type, passing them the provided payload.
     * @param type - the type of command listeners to trigger.
     * @param payload - the data to pass as an argument to the command listeners.
     */
    dispatchCommand(o, a) {
      return ot(this, o, a);
    }
    /**
     * Gets a map of all decorators in the editor.
     * @returns A mapping of call decorator keys to their decorated content
     */
    getDecorators() {
      return this._decorators;
    }
    /**
     *
     * @returns the current root element of the editor. If you want to register
     * an event listener, do it via {@link LexicalEditor.registerRootListener}, since
     * this reference may not be stable.
     */
    getRootElement() {
      return this._rootElement;
    }
    /**
     * Gets the key of the editor
     * @returns The editor key
     */
    getKey() {
      return this._key;
    }
    /**
     * Imperatively set the root contenteditable element that Lexical listens
     * for events on.
     */
    setRootElement(o) {
      const a = this._rootElement;
      if (o !== a) {
        const f = Ui(this._config.theme, "root"), _ = this._pendingEditorState || this._editorState;
        if (this._rootElement = o, tf(this, a, o, _), a !== null && (this._config.disableEvents || Le(a), f != null && a.classList.remove(...f)), o !== null) {
          const E = go(o), I = o.style;
          I.userSelect = "text", I.whiteSpace = "pre-wrap", I.wordBreak = "break-word", o.setAttribute("data-lexical-editor", "true"), this._window = E, this._dirtyType = ct, Zn(this), this._updateTags.add("history-merge"), is(this), this._config.disableEvents || Ke(o, this), f != null && o.classList.add(...f);
        } else
          this._editorState = _, this._pendingEditorState = null, this._window = null;
        Pl("root", this, !1, o, a);
      }
    }
    /**
     * Gets the underlying HTMLElement associated with the LexicalNode for the given key.
     * @returns the HTMLElement rendered by the LexicalNode associated with the key.
     * @param key - the key of the LexicalNode.
     */
    getElementByKey(o) {
      return this._keyToDOMMap.get(o) || null;
    }
    /**
     * Gets the active editor state.
     * @returns The editor state
     */
    getEditorState() {
      return this._editorState;
    }
    /**
     * Imperatively set the EditorState. Triggers reconciliation like an update.
     * @param editorState - the state to set the editor
     * @param options - options for the update.
     */
    setEditorState(o, a) {
      if (o.isEmpty())
        throw Error("setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.");
      Ni(this);
      const f = this._pendingEditorState, _ = this._updateTags, E = a !== void 0 ? a.tag : null;
      f !== null && !f.isEmpty() && (E != null && _.add(E), is(this)), this._pendingEditorState = o, this._dirtyType = ct, this._dirtyElements.set("root", !1), this._compositionKey = null, E != null && _.add(E), is(this);
    }
    /**
     * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns
     * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,
     * deserliazation from JSON stored in a database uses this method.
     * @param maybeStringifiedEditorState
     * @param updateFn
     * @returns
     */
    parseEditorState(o, a) {
      const f = typeof o == "string" ? JSON.parse(o) : o;
      return C_(f, this, a);
    }
    /**
     * Executes an update to the editor state. The updateFn callback is the ONLY place
     * where Lexical editor state can be safely mutated.
     * @param updateFn - A function that has access to writable editor state.
     * @param options - A bag of options to control the behavior of the update.
     * @param options.onUpdate - A function to run once the update is complete.
     * Useful for synchronizing updates in some cases.
     * @param options.skipTransforms - Setting this to true will suppress all node
     * transforms for this update cycle.
     * @param options.tag - A tag to identify this update, in an update listener, for instance.
     * Some tags are reserved by the core and control update behavior in different ways.
     * @param options.discrete - If true, prevents this update from being batched, forcing it to
     * run synchronously.
     */
    update(o, a) {
      Lr(this, o, a);
    }
    /**
     * Focuses the editor
     * @param callbackFn - A function to run after the editor is focused.
     * @param options - A bag of options
     * @param options.defaultSelection - Where to move selection when the editor is
     * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.
     */
    focus(o, a = {}) {
      const f = this._rootElement;
      f !== null && (f.setAttribute("autocapitalize", "off"), Lr(this, () => {
        const _ = an(), E = Jn();
        _ !== null ? _.dirty = !0 : E.getChildrenSize() !== 0 && (a.defaultSelection === "rootStart" ? E.selectStart() : E.selectEnd());
      }, {
        onUpdate: () => {
          f.removeAttribute("autocapitalize"), o && o();
        },
        tag: "focus"
      }), this._pendingEditorState === null && f.removeAttribute("autocapitalize"));
    }
    /**
     * Removes focus from the editor.
     */
    blur() {
      const o = this._rootElement;
      o !== null && o.blur();
      const a = Cr(this._window);
      a !== null && a.removeAllRanges();
    }
    /**
     * Returns true if the editor is editable, false otherwise.
     * @returns True if the editor is editable, false otherwise.
     */
    isEditable() {
      return this._editable;
    }
    /**
     * Sets the editable property of the editor. When false, the
     * editor will not listen for user events on the underling contenteditable.
     * @param editable - the value to set the editable mode to.
     */
    setEditable(o) {
      this._editable !== o && (this._editable = o, Pl("editable", this, !0, o));
    }
    /**
     * Returns a JSON-serializable javascript object NOT a JSON string.
     * You still must call JSON.stringify (or something else) to turn the
     * state into a string you can transfer over the wire and store in a database.
     *
     * See {@link LexicalNode.exportJSON}
     *
     * @returns A JSON-serializable javascript object
     */
    toJSON() {
      return {
        editorState: this._editorState.toJSON()
      };
    }
  }
  class zc extends os {
    /** @internal */
    constructor(o, a) {
      super(a), this.__colSpan = o, this.__rowSpan = 1;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        colSpan: this.__colSpan,
        rowSpan: this.__rowSpan
      };
    }
    getColSpan() {
      return this.__colSpan;
    }
    setColSpan(o) {
      return this.getWritable().__colSpan = o, this;
    }
    getRowSpan() {
      return this.__rowSpan;
    }
    setRowSpan(o) {
      return this.getWritable().__rowSpan = o, this;
    }
  }
  function jr(u) {
    return u instanceof zc;
  }
  class nf extends os {
  }
  function Gc(u) {
    return u instanceof nf;
  }
  class rf extends os {
  }
  function $l(u) {
    return u instanceof rf;
  }
  return $e.$INTERNAL_isPointSelection = xr, $e.$addUpdateTag = Si, $e.$applyNodeReplacement = po, $e.$copyNode = vl, $e.$createLineBreakNode = bi, $e.$createNodeSelection = $c, $e.$createParagraphNode = Xi, $e.$createRangeSelection = a_, $e.$createTabNode = qi, $e.$createTextNode = Un, $e.$getAdjacentNode = li, $e.$getNearestNodeFromDOMNode = Nr, $e.$getNearestRootOrShadowRoot = Mr, $e.$getNodeByKey = En, $e.$getPreviousSelection = Us, $e.$getRoot = Jn, $e.$getSelection = an, $e.$getTextContent = g_, $e.$hasAncestor = dt, $e.$hasUpdateTag = Ic, $e.$insertNodes = h_, $e.$isBlockElementNode = l_, $e.$isDecoratorNode = Sn, $e.$isElementNode = Je, $e.$isInlineElementOrDecoratorNode = Sa, $e.$isLeafNode = Ci, $e.$isLineBreakNode = Mi, $e.$isNodeSelection = vr, $e.$isParagraphNode = R_, $e.$isRangeSelection = gt, $e.$isRootNode = Ir, $e.$isRootOrShadowRoot = Wr, $e.$isTabNode = ns, $e.$isTextNode = ft, $e.$nodesOfType = xl, $e.$normalizeSelection__EXPERIMENTAL = Ki, $e.$parseSerializedNode = N_, $e.$selectAll = Tl, $e.$setCompositionKey = _n, $e.$setSelection = br, $e.$splitNode = Ms, $e.BLUR_COMMAND = Z, $e.CAN_REDO_COMMAND = m, $e.CAN_UNDO_COMMAND = y, $e.CLEAR_EDITOR_COMMAND = Q, $e.CLEAR_HISTORY_COMMAND = k, $e.CLICK_COMMAND = n, $e.COMMAND_PRIORITY_CRITICAL = L_, $e.COMMAND_PRIORITY_EDITOR = b_, $e.COMMAND_PRIORITY_HIGH = k_, $e.COMMAND_PRIORITY_LOW = M_, $e.COMMAND_PRIORITY_NORMAL = A_, $e.CONTROLLED_TEXT_INSERTION_COMMAND = h, $e.COPY_COMMAND = ne, $e.CUT_COMMAND = Y, $e.DELETE_CHARACTER_COMMAND = r, $e.DELETE_LINE_COMMAND = v, $e.DELETE_WORD_COMMAND = x, $e.DEPRECATED_$computeGridMap = Kd, $e.DEPRECATED_$createGridSelection = c_, $e.DEPRECATED_$getGridCellNodeRect = Zi, $e.DEPRECATED_$getNodeTriplet = Ud, $e.DEPRECATED_$isGridCellNode = jr, $e.DEPRECATED_$isGridNode = Gc, $e.DEPRECATED_$isGridRowNode = $l, $e.DEPRECATED_$isGridSelection = ur, $e.DEPRECATED_GridCellNode = zc, $e.DEPRECATED_GridNode = nf, $e.DEPRECATED_GridRowNode = rf, $e.DRAGEND_COMMAND = V, $e.DRAGOVER_COMMAND = D, $e.DRAGSTART_COMMAND = F, $e.DROP_COMMAND = J, $e.DecoratorNode = Kc, $e.ElementNode = os, $e.FOCUS_COMMAND = b, $e.FORMAT_ELEMENT_COMMAND = ee, $e.FORMAT_TEXT_COMMAND = O, $e.INDENT_CONTENT_COMMAND = _e, $e.INSERT_LINE_BREAK_COMMAND = c, $e.INSERT_PARAGRAPH_COMMAND = d, $e.INSERT_TAB_COMMAND = j, $e.KEY_ARROW_DOWN_COMMAND = H, $e.KEY_ARROW_LEFT_COMMAND = K, $e.KEY_ARROW_RIGHT_COMMAND = w, $e.KEY_ARROW_UP_COMMAND = W, $e.KEY_BACKSPACE_COMMAND = re, $e.KEY_DELETE_COMMAND = q, $e.KEY_DOWN_COMMAND = T, $e.KEY_ENTER_COMMAND = z, $e.KEY_ESCAPE_COMMAND = ue, $e.KEY_MODIFIER_COMMAND = ce, $e.KEY_SPACE_COMMAND = te, $e.KEY_TAB_COMMAND = G, $e.LineBreakNode = zr, $e.MOVE_TO_END = P, $e.MOVE_TO_START = $, $e.OUTDENT_CONTENT_COMMAND = pe, $e.PASTE_COMMAND = p, $e.ParagraphNode = Ys, $e.REDO_COMMAND = A, $e.REMOVE_TEXT_COMMAND = N, $e.RootNode = Gs, $e.SELECTION_CHANGE_COMMAND = e, $e.SELECT_ALL_COMMAND = U, $e.TabNode = Ai, $e.TextNode = ji, $e.UNDO_COMMAND = M, $e.createCommand = t, $e.createEditor = P_, $e.getNearestEditorFromDOMNode = Io, $e.isHTMLAnchorElement = Vo, $e.isHTMLElement = jo, $e.isSelectionCapturedInDecoratorInput = lo, $e.isSelectionWithinEditor = ri, $e;
}
var Qc, Sf;
function Bt() {
  return Sf || (Sf = 1, Qc = process.env.NODE_ENV === "development" ? rN() : nN()), Qc;
}
var wf;
function iN() {
  if (wf)
    return Jc;
  wf = 1;
  var t = Yn(), e = Bt(), n = dn;
  let r = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
  var c = r ? n.useLayoutEffect : n.useEffect;
  let d = { tag: "history-merge" };
  function h(p, N) {
    if (N !== null) {
      if (N === void 0)
        p.update(() => {
          var x = e.$getRoot();
          if (x.isEmpty()) {
            let v = e.$createParagraphNode();
            x.append(v), x = r ? document.activeElement : null, (e.$getSelection() !== null || x !== null && x === p.getRootElement()) && v.select();
          }
        }, d);
      else if (N !== null)
        switch (typeof N) {
          case "string":
            let x = p.parseEditorState(N);
            p.setEditorState(x, d);
            break;
          case "object":
            p.setEditorState(N, d);
            break;
          case "function":
            p.update(() => {
              e.$getRoot().isEmpty() && N(p);
            }, d);
        }
    }
  }
  return Jc.LexicalComposer = function({ initialConfig: p, children: N }) {
    let x = n.useMemo(() => {
      const { theme: v, namespace: O, editor__DEPRECATED: M, nodes: A, onError: T, editorState: w, html: P } = p, K = t.createLexicalComposerContext(null, v);
      let $ = M || null;
      if ($ === null) {
        const W = e.createEditor({ editable: p.editable, html: P, namespace: O, nodes: A, onError: (H) => T(H, W), theme: v });
        h(W, w), $ = W;
      }
      return [$, K];
    }, []);
    return c(() => {
      let v = p.editable, [O] = x;
      O.setEditable(v !== void 0 ? v : !0);
    }, []), n.createElement(
      t.LexicalComposerContext.Provider,
      { value: x },
      N
    );
  }, Jc;
}
var eu = {}, Of;
function oN() {
  if (Of)
    return eu;
  Of = 1;
  var t = Yn(), e = Bt(), n = dn;
  const r = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
  var d = r ? n.useLayoutEffect : n.useEffect;
  const h = {
    tag: "history-merge"
  };
  function p({
    initialConfig: x,
    children: v
  }) {
    const O = n.useMemo(
      () => {
        const {
          theme: M,
          namespace: A,
          editor__DEPRECATED: T,
          nodes: w,
          onError: P,
          editorState: K,
          html: $
        } = x, W = t.createLexicalComposerContext(null, M);
        let H = T || null;
        if (H === null) {
          const z = e.createEditor({
            editable: x.editable,
            html: $,
            namespace: A,
            nodes: w,
            onError: (te) => P(te, z),
            theme: M
          });
          N(z, K), H = z;
        }
        return [H, W];
      },
      // We only do this for init
      // eslint-disable-next-line react-hooks/exhaustive-deps
      []
    );
    return d(() => {
      const M = x.editable, [A] = O;
      A.setEditable(M !== void 0 ? M : !0);
    }, []), /* @__PURE__ */ n.createElement(t.LexicalComposerContext.Provider, {
      value: O
    }, v);
  }
  function N(x, v) {
    if (v !== null) {
      if (v === void 0)
        x.update(() => {
          const O = e.$getRoot();
          if (O.isEmpty()) {
            const M = e.$createParagraphNode();
            O.append(M);
            const A = r ? document.activeElement : null;
            (e.$getSelection() !== null || A !== null && A === x.getRootElement()) && M.select();
          }
        }, h);
      else if (v !== null)
        switch (typeof v) {
          case "string": {
            const O = x.parseEditorState(v);
            x.setEditorState(O, h);
            break;
          }
          case "object": {
            x.setEditorState(v, h);
            break;
          }
          case "function": {
            x.update(() => {
              e.$getRoot().isEmpty() && v(x);
            }, h);
            break;
          }
        }
    }
  }
  return eu.LexicalComposer = p, eu;
}
const sN = process.env.NODE_ENV === "development" ? oN() : iN();
var lN = sN, tu = {}, nu, Df;
function aN() {
  if (Df)
    return nu;
  Df = 1;
  var t = Yn(), e = dn, n = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? e.useLayoutEffect : e.useEffect;
  function r(d) {
    let [h] = t.useLexicalComposerContext(), p = e.useMemo(() => d(h), [h, d]), N = e.useRef(p.initialValueFn()), [x, v] = e.useState(N.current);
    return n(() => {
      let { initialValueFn: O, subscribe: M } = p, A = O();
      return N.current !== A && (N.current = A, v(A)), M((T) => {
        N.current = T, v(T);
      });
    }, [p, d]), x;
  }
  function c(d) {
    return { initialValueFn: () => d.isEditable(), subscribe: (h) => d.registerEditableListener(h) };
  }
  return nu = function() {
    return r(c);
  }, nu;
}
var ru, Rf;
function cN() {
  if (Rf)
    return ru;
  Rf = 1;
  var t = Yn(), e = dn, c = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? e.useLayoutEffect : e.useEffect;
  function d(N) {
    const [x] = t.useLexicalComposerContext(), v = e.useMemo(() => N(x), [x, N]), O = e.useRef(v.initialValueFn()), [M, A] = e.useState(O.current);
    return c(() => {
      const {
        initialValueFn: T,
        subscribe: w
      } = v, P = T();
      return O.current !== P && (O.current = P, A(P)), w((K) => {
        O.current = K, A(K);
      });
    }, [v, N]), M;
  }
  function h(N) {
    return {
      initialValueFn: () => N.isEditable(),
      subscribe: (x) => N.registerEditableListener(x)
    };
  }
  function p() {
    return d(h);
  }
  return ru = p, ru;
}
var iu, bf;
function yp() {
  return bf || (bf = 1, iu = process.env.NODE_ENV === "development" ? cN() : aN()), iu;
}
var to = {}, Mf;
function uN() {
  if (Mf)
    return to;
  Mf = 1;
  var t = Bt();
  function e(c, d = !0) {
    return c ? !1 : (c = n(), d && (c = c.trim()), c === "");
  }
  function n() {
    return t.$getRoot().getTextContent();
  }
  function r(c) {
    if (!e(c, !1))
      return !1;
    c = t.$getRoot().getChildren();
    let d = c.length;
    if (1 < d)
      return !1;
    for (let p = 0; p < d; p++) {
      var h = c[p];
      if (t.$isDecoratorNode(h))
        return !1;
      if (t.$isElementNode(h)) {
        if (!t.$isParagraphNode(h) || h.__indent !== 0)
          return !1;
        h = h.getChildren();
        let N = h.length;
        for (let x = 0; x < N; x++)
          if (!t.$isTextNode(h[p]))
            return !1;
      }
    }
    return !0;
  }
  return to.$canShowPlaceholder = r, to.$canShowPlaceholderCurry = function(c) {
    return () => r(c);
  }, to.$findTextIntersectionFromCharacters = function(c, d) {
    var h = c.getFirstChild();
    c = 0;
    e:
      for (; h !== null; ) {
        if (t.$isElementNode(h)) {
          var p = h.getFirstChild();
          if (p !== null) {
            h = p;
            continue;
          }
        } else if (t.$isTextNode(h)) {
          if (p = h.getTextContentSize(), c + p > d)
            return { node: h, offset: d - c };
          c += p;
        }
        if (p = h.getNextSibling(), p !== null)
          h = p;
        else {
          for (h = h.getParent(); h !== null; ) {
            if (p = h.getNextSibling(), p !== null) {
              h = p;
              continue e;
            }
            h = h.getParent();
          }
          break;
        }
      }
    return null;
  }, to.$isRootTextContentEmpty = e, to.$isRootTextContentEmptyCurry = function(c, d) {
    return () => e(c, d);
  }, to.$rootTextContent = n, to.registerLexicalTextEntity = function(c, d, h, p) {
    let N = (v) => {
      const O = t.$createTextNode(v.getTextContent());
      O.setFormat(v.getFormat()), v.replace(O);
    }, x = c.registerNodeTransform(t.TextNode, (v) => {
      if (v.isSimpleText()) {
        var O = v.getPreviousSibling(), M = v.getTextContent(), A = v;
        if (t.$isTextNode(O)) {
          var T = O.getTextContent(), w = d(T + M);
          if (O instanceof h) {
            if (w === null || O.getLatest().__mode !== 0) {
              N(O);
              return;
            }
            if (w = w.end - T.length, 0 < w) {
              A = M.slice(0, w), A = T + A, O.select(), O.setTextContent(A), w === M.length ? v.remove() : (O = M.slice(w), v.setTextContent(O));
              return;
            }
          } else if (w === null || w.start < T.length)
            return;
        }
        for (; ; ) {
          if (v = d(M), M = w = v === null ? "" : M.slice(v.end), w === "") {
            if (T = A.getNextSibling(), t.$isTextNode(T)) {
              if (w = A.getTextContent() + T.getTextContent(), w = d(w), w === null) {
                T instanceof h ? N(T) : T.markDirty();
                break;
              } else if (w.start !== 0)
                break;
            }
          } else if (T = d(w), T !== null && T.start === 0)
            break;
          if (v === null)
            break;
          if (v.start === 0 && t.$isTextNode(O) && O.isTextEntity())
            continue;
          let P;
          if (v.start === 0 ? [P, A] = A.splitText(v.end) : [, P, A] = A.splitText(v.start, v.end), v = p(P), v.setFormat(P.getFormat()), P.replace(v), A == null)
            break;
        }
      }
    });
    return c = c.registerNodeTransform(h, (v) => {
      var O = v.getTextContent();
      const M = d(O);
      M === null || M.start !== 0 ? N(v) : O.length > M.end ? v.splitText(M.end) : (O = v.getPreviousSibling(), t.$isTextNode(O) && O.isTextEntity() && (N(O), N(v)), O = v.getNextSibling(), t.$isTextNode(O) && O.isTextEntity() && (N(O), v instanceof h && N(v)));
    }), [x, c];
  }, to;
}
var no = {}, Af;
function dN() {
  if (Af)
    return no;
  Af = 1;
  var t = Bt();
  function e(N, x) {
    let v = N.getFirstChild(), O = 0;
    e:
      for (; v !== null; ) {
        if (t.$isElementNode(v)) {
          const T = v.getFirstChild();
          if (T !== null) {
            v = T;
            continue;
          }
        } else if (t.$isTextNode(v)) {
          const T = v.getTextContentSize();
          if (O + T > x)
            return {
              node: v,
              offset: x - O
            };
          O += T;
        }
        const M = v.getNextSibling();
        if (M !== null) {
          v = M;
          continue;
        }
        let A = v.getParent();
        for (; A !== null; ) {
          const T = A.getNextSibling();
          if (T !== null) {
            v = T;
            continue e;
          }
          A = A.getParent();
        }
        break;
      }
    return null;
  }
  function n(N, x = !0) {
    if (N)
      return !1;
    let v = c();
    return x && (v = v.trim()), v === "";
  }
  function r(N, x) {
    return () => n(N, x);
  }
  function c() {
    return t.$getRoot().getTextContent();
  }
  function d(N) {
    if (!n(N, !1))
      return !1;
    const v = t.$getRoot().getChildren(), O = v.length;
    if (O > 1)
      return !1;
    for (let M = 0; M < O; M++) {
      const A = v[M];
      if (t.$isDecoratorNode(A))
        return !1;
      if (t.$isElementNode(A)) {
        if (!t.$isParagraphNode(A) || A.__indent !== 0)
          return !1;
        const T = A.getChildren(), w = T.length;
        for (let P = 0; P < w; P++) {
          const K = T[M];
          if (!t.$isTextNode(K))
            return !1;
        }
      }
    }
    return !0;
  }
  function h(N) {
    return () => d(N);
  }
  function p(N, x, v, O) {
    const M = (W) => W instanceof v, A = (W) => {
      const H = t.$createTextNode(W.getTextContent());
      H.setFormat(W.getFormat()), W.replace(H);
    }, T = (W) => W.getLatest().__mode, w = (W) => {
      if (!W.isSimpleText())
        return;
      const H = W.getPreviousSibling();
      let z = W.getTextContent(), te = W, re;
      if (t.$isTextNode(H)) {
        const ue = H.getTextContent(), q = ue + z, G = x(q);
        if (M(H))
          if (G === null || T(H) !== 0) {
            A(H);
            return;
          } else {
            const j = G.end - ue.length;
            if (j > 0) {
              const _e = z.slice(0, j), pe = ue + _e;
              if (H.select(), H.setTextContent(pe), j === z.length)
                W.remove();
              else {
                const J = z.slice(j);
                W.setTextContent(J);
              }
              return;
            }
          }
        else if (G === null || G.start < ue.length)
          return;
      }
      for (; ; ) {
        re = x(z);
        let ue = re === null ? "" : z.slice(re.end);
        if (z = ue, ue === "") {
          const j = te.getNextSibling();
          if (t.$isTextNode(j)) {
            ue = te.getTextContent() + j.getTextContent();
            const _e = x(ue);
            if (_e === null) {
              M(j) ? A(j) : j.markDirty();
              return;
            } else if (_e.start !== 0)
              return;
          }
        } else {
          const j = x(ue);
          if (j !== null && j.start === 0)
            return;
        }
        if (re === null)
          return;
        if (re.start === 0 && t.$isTextNode(H) && H.isTextEntity())
          continue;
        let q;
        re.start === 0 ? [q, te] = te.splitText(re.end) : [, q, te] = te.splitText(re.start, re.end);
        const G = O(q);
        if (G.setFormat(q.getFormat()), q.replace(G), te == null)
          return;
      }
    }, P = (W) => {
      const H = W.getTextContent(), z = x(H);
      if (z === null || z.start !== 0) {
        A(W);
        return;
      }
      if (H.length > z.end) {
        W.splitText(z.end);
        return;
      }
      const te = W.getPreviousSibling();
      t.$isTextNode(te) && te.isTextEntity() && (A(te), A(W));
      const re = W.getNextSibling();
      t.$isTextNode(re) && re.isTextEntity() && (A(re), M(W) && A(W));
    }, K = N.registerNodeTransform(t.TextNode, w), $ = N.registerNodeTransform(v, P);
    return [K, $];
  }
  return no.$canShowPlaceholder = d, no.$canShowPlaceholderCurry = h, no.$findTextIntersectionFromCharacters = e, no.$isRootTextContentEmpty = n, no.$isRootTextContentEmptyCurry = r, no.$rootTextContent = c, no.registerLexicalTextEntity = p, no;
}
var ou, kf;
function Np() {
  return kf || (kf = 1, ou = process.env.NODE_ENV === "development" ? dN() : uN()), ou;
}
var Nn = {}, zn = {}, Lf;
function fN() {
  if (Lf)
    return zn;
  Lf = 1;
  var t = Bt();
  let e = /* @__PURE__ */ new Map();
  function n(T) {
    for (; T != null; ) {
      if (T.nodeType === Node.TEXT_NODE)
        return T;
      T = T.firstChild;
    }
    return null;
  }
  function r(T) {
    let w = T.parentNode;
    if (w == null)
      throw Error("Should never happen");
    return [w, Array.from(w.childNodes).indexOf(T)];
  }
  function c(T) {
    let w = {};
    T = T.split(";");
    for (let P of T)
      if (P !== "") {
        let [K, $] = P.split(/:([^]+)/);
        K && $ && (w[K.trim()] = $.trim());
      }
    return w;
  }
  function d(T) {
    let w = e.get(T);
    return w === void 0 && (w = c(T), e.set(T, w)), w;
  }
  function h(T) {
    let w = "";
    for (let P in T)
      P && (w += `${P}: ${T[P]};`);
    return w;
  }
  function p(T, w) {
    var P = d("getStyle" in T ? T.getStyle() : T.style);
    w = Object.entries(w).reduce((K, [$, W]) => (W === null ? delete K[$] : K[$] = W, K), { ...P }), P = h(w), T.setStyle(P), e.set(P, w);
  }
  function N(T, w) {
    var P = T.getNodes(), K = P.length;
    if (t.DEPRECATED_$isGridSelection(T)) {
      for (var $ = t.$createRangeSelection(), W = $.anchor, H = $.focus, z = 0; z < K; z++) {
        var te = P[z];
        t.DEPRECATED_$isGridCellNode(te) && (W.set(te.getKey(), 0, "element"), H.set(te.getKey(), te.getChildrenSize(), "element"), N(t.$normalizeSelection__EXPERIMENTAL($), w));
      }
      t.$setSelection(T);
    } else if (--K, $ = P[0], W = P[K], T.isCollapsed() && t.$isRangeSelection(T))
      p(T, w);
    else {
      z = T.anchor;
      var re = T.focus;
      te = $.getTextContent().length;
      var ue = re.offset, q = z.offset, G = z.isBefore(re);
      H = G ? q : ue, T = G ? ue : q;
      var j = G ? z.type : re.type, _e = G ? re.type : z.type;
      if (re = G ? re.key : z.key, t.$isTextNode($) && H === te && (G = $.getNextSibling(), t.$isTextNode(G) && (H = q = 0, $ = G)), P.length === 1)
        t.$isTextNode($) && (H = j === "element" ? 0 : q > ue ? ue : q, T = _e === "element" ? te : q > ue ? q : ue, H !== T && (H === 0 && T === te ? (p($, w), $.select(H, T)) : (P = $.splitText(H, T), P = H === 0 ? P[0] : P[1], p(P, w), P.select(0, T - H))));
      else
        for (t.$isTextNode($) && H < $.getTextContentSize() && (H !== 0 && ($ = $.splitText(H)[1], H = 0, z.set($.getKey(), H, "text")), p($, w)), t.$isTextNode(W) && (H = W.getTextContent().length, W.__key !== re && T !== 0 && (T = H), T !== H && ([W] = W.splitText(T)), T !== 0 && p(W, w)), T = 1; T < K; T++)
          H = P[T], z = H.getKey(), t.$isTextNode(H) && z !== $.getKey() && z !== W.getKey() && !H.isToken() && p(H, w);
    }
  }
  function x(T) {
    for (; T !== null && !t.$isRootOrShadowRoot(T); ) {
      let w = T.getLatest(), P = T.getParent();
      w.getChildrenSize() === 0 && T.remove(!0), T = P;
    }
  }
  function v(T, w, P, K, $ = null) {
    if (w.length !== 0) {
      var W = w[0], H = /* @__PURE__ */ new Map(), z = [];
      W = t.$isElementNode(W) ? W : W.getParentOrThrow(), W.isInline() && (W = W.getParentOrThrow());
      for (var te = !1; W !== null; ) {
        var re = W.getPreviousSibling();
        if (re !== null) {
          W = re, te = !0;
          break;
        }
        if (W = W.getParentOrThrow(), t.$isRootOrShadowRoot(W))
          break;
      }
      re = /* @__PURE__ */ new Set();
      for (var ue = 0; ue < P; ue++) {
        var q = w[ue];
        t.$isElementNode(q) && q.getChildrenSize() === 0 && re.add(q.getKey());
      }
      var G = /* @__PURE__ */ new Set();
      for (ue = 0; ue < P; ue++) {
        q = w[ue];
        var j = q.getParent();
        if (j !== null && j.isInline() && (j = j.getParent()), j !== null && t.$isLeafNode(q) && !G.has(q.getKey())) {
          if (q = j.getKey(), H.get(q) === void 0) {
            let _e = K();
            _e.setFormat(j.getFormatType()), _e.setIndent(j.getIndent()), z.push(_e), H.set(q, _e), j.getChildren().forEach((pe) => {
              _e.append(pe), G.add(pe.getKey()), t.$isElementNode(pe) && pe.getChildrenKeys().forEach((J) => G.add(J));
            }), x(j);
          }
        } else
          re.has(q.getKey()) && (j = K(), j.setFormat(q.getFormatType()), j.setIndent(q.getIndent()), z.push(j), q.remove(!0));
      }
      if ($ !== null)
        for (w = 0; w < z.length; w++)
          $.append(z[w]);
      if (w = null, t.$isRootOrShadowRoot(W))
        if (te)
          if ($ !== null)
            W.insertAfter($);
          else
            for ($ = z.length - 1; 0 <= $; $--)
              W.insertAfter(z[$]);
        else if (te = W.getFirstChild(), t.$isElementNode(te) && (W = te), te === null)
          if ($)
            W.append($);
          else
            for ($ = 0; $ < z.length; $++)
              te = z[$], W.append(te), w = te;
        else if ($ !== null)
          te.insertBefore($);
        else
          for (W = 0; W < z.length; W++)
            $ = z[W], te.insertBefore($), w = $;
      else if ($)
        W.insertAfter($);
      else
        for ($ = z.length - 1; 0 <= $; $--)
          te = z[$], W.insertAfter(te), w = te;
      z = t.$getPreviousSelection(), t.$isRangeSelection(z) && z.anchor.getNode().isAttached() && z.focus.getNode().isAttached() ? t.$setSelection(z.clone()) : w !== null ? w.selectEnd() : T.dirty = !0;
    }
  }
  function O(T, w, P, K) {
    T.modify(w ? "extend" : "move", P, K);
  }
  function M(T) {
    return T = T.anchor.getNode(), (t.$isRootNode(T) ? T : T.getParentOrThrow()).getDirection() === "rtl";
  }
  function A(T) {
    if (t.$isDecoratorNode(T) && !T.isInline())
      return !0;
    if (!t.$isElementNode(T) || t.$isRootOrShadowRoot(T))
      return !1;
    var w = T.getFirstChild();
    return w = w === null || t.$isLineBreakNode(w) || t.$isTextNode(w) || w.isInline(), !T.isInline() && T.canBeEmpty() !== !1 && w;
  }
  return zn.$addNodeStyle = function(T) {
    T = T.getStyle();
    let w = c(T);
    e.set(T, w);
  }, zn.$cloneWithProperties = function(T) {
    let w = T.constructor.clone(T);
    return w.__parent = T.__parent, w.__next = T.__next, w.__prev = T.__prev, t.$isElementNode(T) && t.$isElementNode(w) ? (w.__first = T.__first, w.__last = T.__last, w.__size = T.__size, w.__format = T.__format, w.__indent = T.__indent, w.__dir = T.__dir, w) : (t.$isTextNode(T) && t.$isTextNode(w) && (w.__format = T.__format, w.__style = T.__style, w.__mode = T.__mode, w.__detail = T.__detail), w);
  }, zn.$getSelectionStyleValueForProperty = function(T, w, P = "") {
    let K = null, $ = T.getNodes();
    var W = T.anchor, H = T.focus, z = T.isBackward();
    let te = z ? H.offset : W.offset;
    if (W = z ? H.getNode() : W.getNode(), T.isCollapsed() && T.style !== "" && (T = d(T.style), T !== null && w in T))
      return T[w];
    for (T = 0; T < $.length; T++) {
      var re = $[T];
      if ((T === 0 || te !== 0 || !re.is(W)) && t.$isTextNode(re)) {
        if (H = w, z = P, re = re.getStyle(), re = d(re), H = re !== null && re[H] || z, K === null)
          K = H;
        else if (K !== H) {
          K = "";
          break;
        }
      }
    }
    return K === null ? P : K;
  }, zn.$isAtNodeEnd = function(T) {
    return T.type === "text" ? T.offset === T.getNode().getTextContentSize() : T.offset === T.getNode().getChildrenSize();
  }, zn.$isParentElementRTL = M, zn.$moveCaretSelection = O, zn.$moveCharacter = function(T, w, P) {
    let K = M(T);
    O(T, w, P ? !K : K, "character");
  }, zn.$patchStyleText = N, zn.$selectAll = function(T) {
    let w = T.anchor;
    T = T.focus;
    var P = w.getNode().getTopLevelElementOrThrow().getParentOrThrow();
    let K = P.getFirstDescendant();
    P = P.getLastDescendant();
    let $ = "element", W = "element", H = 0;
    t.$isTextNode(K) ? $ = "text" : t.$isElementNode(K) || K === null || (K = K.getParentOrThrow()), t.$isTextNode(P) ? (W = "text", H = P.getTextContentSize()) : t.$isElementNode(P) || P === null || (P = P.getParentOrThrow()), K && P && (w.set(K.getKey(), 0, $), T.set(P.getKey(), H, W));
  }, zn.$setBlocksType = function(T, w) {
    if (T.anchor.key === "root") {
      w = w();
      var P = t.$getRoot();
      (T = P.getFirstChild()) ? T.replace(w, !0) : P.append(w);
    } else {
      for (P = T.getNodes(), T = T.anchor.getNode(); T !== null && T.getParent() !== null && !A(T); )
        T = T.getParentOrThrow();
      for ((T = A(T) ? T : null) && P.indexOf(T) === -1 && P.push(T), T = 0; T < P.length; T++) {
        let K = P[T];
        if (!A(K))
          continue;
        let $ = w();
        $.setFormat(K.getFormatType()), $.setIndent(K.getIndent()), K.replace($, !0);
      }
    }
  }, zn.$shouldOverrideDefaultCharacterSelection = function(T, w) {
    return T = t.$getAdjacentNode(T.focus, w), t.$isDecoratorNode(T) && !T.isIsolated() || t.$isElementNode(T) && !T.isInline() && !T.canBeEmpty();
  }, zn.$sliceSelectedTextNodeContent = function(T, w) {
    if (w.isSelected() && !w.isSegmented() && !w.isToken() && t.$INTERNAL_isPointSelection(T)) {
      var P = T.anchor.getNode(), K = T.focus.getNode(), $ = w.is(P), W = w.is(K);
      if ($ || W) {
        $ = T.isBackward();
        let [H, z] = T.getCharacterOffsets();
        T = P.is(K), W = w.is($ ? K : P), K = w.is($ ? P : K), P = 0;
        let te;
        T ? (P = H > z ? z : H, te = H > z ? H : z) : W ? (P = $ ? z : H, te = void 0) : K && ($ = $ ? H : z, P = 0, te = $), w.__text = w.__text.slice(P, te);
      }
    }
    return w;
  }, zn.$wrapNodes = function(T, w, P = null) {
    var K = T.getNodes();
    let $ = K.length;
    var W = T.anchor;
    if ($ === 0 || $ === 1 && W.type === "element" && W.getNode().getChildrenSize() === 0) {
      T = W.type === "text" ? W.getNode().getParentOrThrow() : W.getNode(), K = T.getChildren();
      let z = w();
      z.setFormat(T.getFormatType()), z.setIndent(T.getIndent()), K.forEach((te) => z.append(te)), P && (z = P.append(z)), T.replace(z);
    } else {
      W = null;
      var H = [];
      for (let z = 0; z < $; z++) {
        let te = K[z];
        t.$isRootOrShadowRoot(te) ? (v(T, H, H.length, w, P), H = [], W = te) : W === null || W !== null && t.$hasAncestor(
          te,
          W
        ) ? H.push(te) : (v(T, H, H.length, w, P), H = [te]);
      }
      v(T, H, H.length, w, P);
    }
  }, zn.createDOMRange = function(T, w, P, K, $) {
    let W = w.getKey(), H = K.getKey(), z = document.createRange(), te = T.getElementByKey(W);
    if (T = T.getElementByKey(H), t.$isTextNode(w) && (te = n(te)), t.$isTextNode(K) && (T = n(T)), w === void 0 || K === void 0 || te === null || T === null)
      return null;
    te.nodeName === "BR" && ([te, P] = r(te)), T.nodeName === "BR" && ([T, $] = r(T)), w = te.firstChild, te === T && w != null && w.nodeName === "BR" && P === 0 && $ === 0 && ($ = 1);
    try {
      z.setStart(te, P), z.setEnd(T, $);
    } catch {
      return null;
    }
    return !z.collapsed || P === $ && W === H || (z.setStart(T, $), z.setEnd(
      te,
      P
    )), z;
  }, zn.createRectsFromDOMRange = function(T, w) {
    var P = T.getRootElement();
    if (P === null)
      return [];
    T = P.getBoundingClientRect(), P = getComputedStyle(P), P = parseFloat(P.paddingLeft) + parseFloat(P.paddingRight), w = Array.from(w.getClientRects());
    let K = w.length;
    w.sort((W, H) => {
      let z = W.top - H.top;
      return 3 >= Math.abs(z) ? W.left - H.left : z;
    });
    let $;
    for (let W = 0; W < K; W++) {
      let H = w[W], z = H.width + P === T.width;
      $ && $.top <= H.top && $.top + $.height > H.top && $.left + $.width > H.left || z ? (w.splice(W--, 1), K--) : $ = H;
    }
    return w;
  }, zn.getStyleObjectFromCSS = d, zn.trimTextContentFromAnchor = function(T, w, P) {
    let K = w.getNode();
    if (t.$isElementNode(K)) {
      var $ = K.getDescendantByIndex(w.offset);
      $ !== null && (K = $);
    }
    for (; 0 < P && K !== null; ) {
      t.$isElementNode(K) && ($ = K.getLastDescendant(), $ !== null && (K = $));
      var W = K.getPreviousSibling(), H = 0;
      if (W === null) {
        $ = K.getParentOrThrow();
        for (var z = $.getPreviousSibling(); z === null; ) {
          if ($ = $.getParent(), $ === null) {
            W = null;
            break;
          }
          z = $.getPreviousSibling();
        }
        $ !== null && (H = $.isInline() ? 0 : 2, W = z);
      }
      if (z = K.getTextContent(), z === "" && t.$isElementNode(K) && !K.isInline() && (z = `

`), $ = z.length, !t.$isTextNode(K) || P >= $)
        z = K.getParent(), K.remove(), z == null || z.getChildrenSize() !== 0 || t.$isRootNode(z) || z.remove(), P -= $ + H, K = W;
      else {
        let te = K.getKey();
        H = T.getEditorState().read(() => {
          const ue = t.$getNodeByKey(te);
          return t.$isTextNode(ue) && ue.isSimpleText() ? ue.getTextContent() : null;
        }), W = $ - P;
        let re = z.slice(0, W);
        H !== null && H !== z ? (P = t.$getPreviousSelection(), $ = K, K.isSimpleText() ? K.setTextContent(H) : ($ = t.$createTextNode(H), K.replace($)), t.$isRangeSelection(P) && P.isCollapsed() && (P = P.anchor.offset, $.select(P, P))) : K.isSimpleText() ? (H = w.key === te, z = w.offset, z < P && (z = $), P = H ? z - P : 0, $ = H ? z : W, H && P === 0 ? ([P] = K.splitText(P, $), P.remove()) : ([, P] = K.splitText(P, $), P.remove())) : (P = t.$createTextNode(re), K.replace(P)), P = 0;
      }
    }
  }, zn;
}
var Gn = {}, If;
function hN() {
  if (If)
    return Gn;
  If = 1;
  var t = Bt();
  const e = /* @__PURE__ */ new Map();
  function n(F) {
    let D = F;
    for (; D != null; ) {
      if (D.nodeType === Node.TEXT_NODE)
        return D;
      D = D.firstChild;
    }
    return null;
  }
  function r(F) {
    const D = F.parentNode;
    if (D == null)
      throw new Error("Should never happen");
    return [D, Array.from(D.childNodes).indexOf(F)];
  }
  function c(F, D, V, ne, Y) {
    const U = D.getKey(), Q = ne.getKey(), k = document.createRange();
    let m = F.getElementByKey(U), y = F.getElementByKey(Q), b = V, Z = Y;
    if (t.$isTextNode(D) && (m = n(m)), t.$isTextNode(ne) && (y = n(y)), D === void 0 || ne === void 0 || m === null || y === null)
      return null;
    m.nodeName === "BR" && ([m, b] = r(m)), y.nodeName === "BR" && ([y, Z] = r(y));
    const ce = m.firstChild;
    m === y && ce != null && ce.nodeName === "BR" && b === 0 && Z === 0 && (Z = 1);
    try {
      k.setStart(m, b), k.setEnd(y, Z);
    } catch {
      return null;
    }
    return k.collapsed && (b !== Z || U !== Q) && (k.setStart(y, Z), k.setEnd(m, b)), k;
  }
  function d(F, D) {
    const V = F.getRootElement();
    if (V === null)
      return [];
    const ne = V.getBoundingClientRect(), Y = getComputedStyle(V), U = parseFloat(Y.paddingLeft) + parseFloat(Y.paddingRight), Q = Array.from(D.getClientRects());
    let k = Q.length;
    Q.sort((y, b) => {
      const Z = y.top - b.top;
      return Math.abs(Z) <= 3 ? y.left - b.left : Z;
    });
    let m;
    for (let y = 0; y < k; y++) {
      const b = Q[y], Z = m && m.top <= b.top && m.top + m.height > b.top && m.left + m.width > b.left, ce = b.width + U === ne.width;
      if (Z || ce) {
        Q.splice(y--, 1), k--;
        continue;
      }
      m = b;
    }
    return Q;
  }
  function h(F) {
    const D = {}, V = F.split(";");
    for (const ne of V)
      if (ne !== "") {
        const [Y, U] = ne.split(/:([^]+)/);
        Y && U && (D[Y.trim()] = U.trim());
      }
    return D;
  }
  function p(F) {
    let D = e.get(F);
    return D === void 0 && (D = h(F), e.set(F, D)), Object.freeze(D), D;
  }
  function N(F) {
    let D = "";
    for (const V in F)
      V && (D += `${V}: ${F[V]};`);
    return D;
  }
  function x(F, D) {
    return F.__first = D.__first, F.__last = D.__last, F.__size = D.__size, F.__format = D.__format, F.__indent = D.__indent, F.__dir = D.__dir, F;
  }
  function v(F, D) {
    return F.__format = D.__format, F.__style = D.__style, F.__mode = D.__mode, F.__detail = D.__detail, F;
  }
  function O(F) {
    const V = F.constructor.clone(F);
    return V.__parent = F.__parent, V.__next = F.__next, V.__prev = F.__prev, t.$isElementNode(F) && t.$isElementNode(V) ? x(V, F) : t.$isTextNode(F) && t.$isTextNode(V) ? v(V, F) : V;
  }
  function M(F, D) {
    if (D.isSelected() && !D.isSegmented() && !D.isToken() && t.$INTERNAL_isPointSelection(F)) {
      const V = F.anchor.getNode(), ne = F.focus.getNode(), Y = D.is(V), U = D.is(ne);
      if (Y || U) {
        const Q = F.isBackward(), [k, m] = F.getCharacterOffsets(), y = V.is(ne), b = D.is(Q ? ne : V), Z = D.is(Q ? V : ne);
        let ce = 0, ge;
        if (y)
          ce = k > m ? m : k, ge = k > m ? k : m;
        else if (b)
          ce = Q ? m : k, ge = void 0;
        else if (Z) {
          const ae = Q ? k : m;
          ce = 0, ge = ae;
        }
        return D.__text = D.__text.slice(ce, ge), D;
      }
    }
    return D;
  }
  function A(F) {
    return F.type === "text" ? F.offset === F.getNode().getTextContentSize() : F.offset === F.getNode().getChildrenSize();
  }
  function T(F, D, V) {
    let ne = D.getNode(), Y = V;
    if (t.$isElementNode(ne)) {
      const U = ne.getDescendantByIndex(D.offset);
      U !== null && (ne = U);
    }
    for (; Y > 0 && ne !== null; ) {
      if (t.$isElementNode(ne)) {
        const y = ne.getLastDescendant();
        y !== null && (ne = y);
      }
      let U = ne.getPreviousSibling(), Q = 0;
      if (U === null) {
        let y = ne.getParentOrThrow(), b = y.getPreviousSibling();
        for (; b === null; ) {
          if (y = y.getParent(), y === null) {
            U = null;
            break;
          }
          b = y.getPreviousSibling();
        }
        y !== null && (Q = y.isInline() ? 0 : 2, U = b);
      }
      let k = ne.getTextContent();
      k === "" && t.$isElementNode(ne) && !ne.isInline() && (k = `

`);
      const m = k.length;
      if (!t.$isTextNode(ne) || Y >= m) {
        const y = ne.getParent();
        ne.remove(), y != null && y.getChildrenSize() === 0 && !t.$isRootNode(y) && y.remove(), Y -= m + Q, ne = U;
      } else {
        const y = ne.getKey(), b = F.getEditorState().read(() => {
          const ge = t.$getNodeByKey(y);
          return t.$isTextNode(ge) && ge.isSimpleText() ? ge.getTextContent() : null;
        }), Z = m - Y, ce = k.slice(0, Z);
        if (b !== null && b !== k) {
          const ge = t.$getPreviousSelection();
          let ae = ne;
          if (ne.isSimpleText())
            ne.setTextContent(b);
          else {
            const Te = t.$createTextNode(b);
            ne.replace(Te), ae = Te;
          }
          if (t.$isRangeSelection(ge) && ge.isCollapsed()) {
            const Te = ge.anchor.offset;
            ae.select(Te, Te);
          }
        } else if (ne.isSimpleText()) {
          const ge = D.key === y;
          let ae = D.offset;
          ae < Y && (ae = m);
          const Te = ge ? ae - Y : 0, Ae = ge ? ae : Z;
          if (ge && Te === 0) {
            const [ze] = ne.splitText(Te, Ae);
            ze.remove();
          } else {
            const [, ze] = ne.splitText(Te, Ae);
            ze.remove();
          }
        } else {
          const ge = t.$createTextNode(ce);
          ne.replace(ge);
        }
        Y = 0;
      }
    }
  }
  function w(F) {
    const D = F.getStyle(), V = h(D);
    e.set(D, V);
  }
  function P(F, D) {
    const V = p("getStyle" in F ? F.getStyle() : F.style), ne = Object.entries(D).reduce((U, [Q, k]) => (k === null ? delete U[Q] : U[Q] = k, U), {
      ...V
    }), Y = N(ne);
    F.setStyle(Y), e.set(Y, ne);
  }
  function K(F, D) {
    const V = F.getNodes(), ne = V.length;
    if (t.DEPRECATED_$isGridSelection(F)) {
      const ie = t.$createRangeSelection(), de = ie.anchor, we = ie.focus;
      for (let ke = 0; ke < ne; ke++) {
        const Be = V[ke];
        t.DEPRECATED_$isGridCellNode(Be) && (de.set(Be.getKey(), 0, "element"), we.set(Be.getKey(), Be.getChildrenSize(), "element"), K(t.$normalizeSelection__EXPERIMENTAL(ie), D));
      }
      t.$setSelection(F);
      return;
    }
    const Y = ne - 1;
    let U = V[0], Q = V[Y];
    if (F.isCollapsed() && t.$isRangeSelection(F)) {
      P(F, D);
      return;
    }
    const k = F.anchor, m = F.focus, b = U.getTextContent().length, Z = m.offset;
    let ce = k.offset;
    const ge = k.isBefore(m);
    let ae = ge ? ce : Z, Te = ge ? Z : ce;
    const Ae = ge ? k.type : m.type, ze = ge ? m.type : k.type, oe = ge ? m.key : k.key;
    if (t.$isTextNode(U) && ae === b) {
      const ie = U.getNextSibling();
      t.$isTextNode(ie) && (ce = 0, ae = 0, U = ie);
    }
    if (V.length === 1) {
      if (t.$isTextNode(U)) {
        if (ae = Ae === "element" ? 0 : ce > Z ? Z : ce, Te = ze === "element" ? b : ce > Z ? ce : Z, ae === Te)
          return;
        if (ae === 0 && Te === b)
          P(U, D), U.select(ae, Te);
        else {
          const ie = U.splitText(ae, Te), de = ae === 0 ? ie[0] : ie[1];
          P(de, D), de.select(0, Te - ae);
        }
      }
    } else {
      if (t.$isTextNode(U) && ae < U.getTextContentSize() && (ae !== 0 && (U = U.splitText(ae)[1], ae = 0, k.set(U.getKey(), ae, "text")), P(U, D)), t.$isTextNode(Q)) {
        const de = Q.getTextContent().length;
        Q.__key !== oe && Te !== 0 && (Te = de), Te !== de && ([Q] = Q.splitText(Te)), Te !== 0 && P(Q, D);
      }
      for (let ie = 1; ie < Y; ie++) {
        const de = V[ie], we = de.getKey();
        t.$isTextNode(de) && we !== U.getKey() && we !== Q.getKey() && !de.isToken() && P(de, D);
      }
    }
  }
  function $(F, D) {
    if (F.anchor.key === "root") {
      const Y = D(), U = t.$getRoot(), Q = U.getFirstChild();
      Q ? Q.replace(Y, !0) : U.append(Y);
      return;
    }
    const V = F.getNodes(), ne = ee(F.anchor.getNode(), J);
    ne && V.indexOf(ne) === -1 && V.push(ne);
    for (let Y = 0; Y < V.length; Y++) {
      const U = V[Y];
      if (!J(U))
        continue;
      const Q = D();
      Q.setFormat(U.getFormatType()), Q.setIndent(U.getIndent()), U.replace(Q, !0);
    }
  }
  function W(F) {
    return F.getNode().isAttached();
  }
  function H(F) {
    let D = F;
    for (; D !== null && !t.$isRootOrShadowRoot(D); ) {
      const V = D.getLatest(), ne = D.getParent();
      V.getChildrenSize() === 0 && D.remove(!0), D = ne;
    }
  }
  function z(F, D, V = null) {
    const ne = F.getNodes(), Y = ne.length, U = F.anchor;
    if (Y === 0 || Y === 1 && U.type === "element" && U.getNode().getChildrenSize() === 0) {
      const m = U.type === "text" ? U.getNode().getParentOrThrow() : U.getNode(), y = m.getChildren();
      let b = D();
      b.setFormat(m.getFormatType()), b.setIndent(m.getIndent()), y.forEach((Z) => b.append(Z)), V && (b = V.append(b)), m.replace(b);
      return;
    }
    let Q = null, k = [];
    for (let m = 0; m < Y; m++) {
      const y = ne[m];
      t.$isRootOrShadowRoot(y) ? (te(F, k, k.length, D, V), k = [], Q = y) : Q === null || Q !== null && t.$hasAncestor(y, Q) ? k.push(y) : (te(F, k, k.length, D, V), k = [y]);
    }
    te(F, k, k.length, D, V);
  }
  function te(F, D, V, ne, Y = null) {
    if (D.length === 0)
      return;
    const U = D[0], Q = /* @__PURE__ */ new Map(), k = [];
    let m = t.$isElementNode(U) ? U : U.getParentOrThrow();
    m.isInline() && (m = m.getParentOrThrow());
    let y = !1;
    for (; m !== null; ) {
      const ae = m.getPreviousSibling();
      if (ae !== null) {
        m = ae, y = !0;
        break;
      }
      if (m = m.getParentOrThrow(), t.$isRootOrShadowRoot(m))
        break;
    }
    const b = /* @__PURE__ */ new Set();
    for (let ae = 0; ae < V; ae++) {
      const Te = D[ae];
      t.$isElementNode(Te) && Te.getChildrenSize() === 0 && b.add(Te.getKey());
    }
    const Z = /* @__PURE__ */ new Set();
    for (let ae = 0; ae < V; ae++) {
      const Te = D[ae];
      let Ae = Te.getParent();
      if (Ae !== null && Ae.isInline() && (Ae = Ae.getParent()), Ae !== null && t.$isLeafNode(Te) && !Z.has(Te.getKey())) {
        const ze = Ae.getKey();
        if (Q.get(ze) === void 0) {
          const oe = ne();
          oe.setFormat(Ae.getFormatType()), oe.setIndent(Ae.getIndent()), k.push(oe), Q.set(ze, oe), Ae.getChildren().forEach((ie) => {
            oe.append(ie), Z.add(ie.getKey()), t.$isElementNode(ie) && ie.getChildrenKeys().forEach((de) => Z.add(de));
          }), H(Ae);
        }
      } else if (b.has(Te.getKey())) {
        const ze = ne();
        ze.setFormat(Te.getFormatType()), ze.setIndent(Te.getIndent()), k.push(ze), Te.remove(!0);
      }
    }
    if (Y !== null)
      for (let ae = 0; ae < k.length; ae++) {
        const Te = k[ae];
        Y.append(Te);
      }
    let ce = null;
    if (t.$isRootOrShadowRoot(m))
      if (y)
        if (Y !== null)
          m.insertAfter(Y);
        else
          for (let ae = k.length - 1; ae >= 0; ae--) {
            const Te = k[ae];
            m.insertAfter(Te);
          }
      else {
        const ae = m.getFirstChild();
        if (t.$isElementNode(ae) && (m = ae), ae === null)
          if (Y)
            m.append(Y);
          else
            for (let Te = 0; Te < k.length; Te++) {
              const Ae = k[Te];
              m.append(Ae), ce = Ae;
            }
        else if (Y !== null)
          ae.insertBefore(Y);
        else
          for (let Te = 0; Te < k.length; Te++) {
            const Ae = k[Te];
            ae.insertBefore(Ae), ce = Ae;
          }
      }
    else if (Y)
      m.insertAfter(Y);
    else
      for (let ae = k.length - 1; ae >= 0; ae--) {
        const Te = k[ae];
        m.insertAfter(Te), ce = Te;
      }
    const ge = t.$getPreviousSelection();
    t.$isRangeSelection(ge) && W(ge.anchor) && W(ge.focus) ? t.$setSelection(ge.clone()) : ce !== null ? ce.selectEnd() : F.dirty = !0;
  }
  function re(F, D) {
    const V = t.$getAdjacentNode(F.focus, D);
    return t.$isDecoratorNode(V) && !V.isIsolated() || t.$isElementNode(V) && !V.isInline() && !V.canBeEmpty();
  }
  function ue(F, D, V, ne) {
    F.modify(D ? "extend" : "move", V, ne);
  }
  function q(F) {
    const D = F.anchor.getNode();
    return (t.$isRootNode(D) ? D : D.getParentOrThrow()).getDirection() === "rtl";
  }
  function G(F, D, V) {
    const ne = q(F);
    ue(F, D, V ? !ne : ne, "character");
  }
  function j(F) {
    const D = F.anchor, V = F.focus, U = D.getNode().getTopLevelElementOrThrow().getParentOrThrow();
    let Q = U.getFirstDescendant(), k = U.getLastDescendant(), m = "element", y = "element", b = 0;
    t.$isTextNode(Q) ? m = "text" : !t.$isElementNode(Q) && Q !== null && (Q = Q.getParentOrThrow()), t.$isTextNode(k) ? (y = "text", b = k.getTextContentSize()) : !t.$isElementNode(k) && k !== null && (k = k.getParentOrThrow()), Q && k && (D.set(Q.getKey(), 0, m), V.set(k.getKey(), b, y));
  }
  function _e(F, D, V) {
    const ne = F.getStyle(), Y = p(ne);
    return Y !== null && Y[D] || V;
  }
  function pe(F, D, V = "") {
    let ne = null;
    const Y = F.getNodes(), U = F.anchor, Q = F.focus, k = F.isBackward(), m = k ? Q.offset : U.offset, y = k ? Q.getNode() : U.getNode();
    if (F.isCollapsed() && F.style !== "") {
      const b = F.style, Z = p(b);
      if (Z !== null && D in Z)
        return Z[D];
    }
    for (let b = 0; b < Y.length; b++) {
      const Z = Y[b];
      if (!(b !== 0 && m === 0 && Z.is(y)) && t.$isTextNode(Z)) {
        const ce = _e(Z, D, V);
        if (ne === null)
          ne = ce;
        else if (ne !== ce) {
          ne = "";
          break;
        }
      }
    }
    return ne === null ? V : ne;
  }
  function J(F) {
    if (t.$isDecoratorNode(F) && !F.isInline())
      return !0;
    if (!t.$isElementNode(F) || t.$isRootOrShadowRoot(F))
      return !1;
    const D = F.getFirstChild(), V = D === null || t.$isLineBreakNode(D) || t.$isTextNode(D) || D.isInline();
    return !F.isInline() && F.canBeEmpty() !== !1 && V;
  }
  function ee(F, D) {
    let V = F;
    for (; V !== null && V.getParent() !== null && !D(V); )
      V = V.getParentOrThrow();
    return D(V) ? V : null;
  }
  return Gn.$addNodeStyle = w, Gn.$cloneWithProperties = O, Gn.$getSelectionStyleValueForProperty = pe, Gn.$isAtNodeEnd = A, Gn.$isParentElementRTL = q, Gn.$moveCaretSelection = ue, Gn.$moveCharacter = G, Gn.$patchStyleText = K, Gn.$selectAll = j, Gn.$setBlocksType = $, Gn.$shouldOverrideDefaultCharacterSelection = re, Gn.$sliceSelectedTextNodeContent = M, Gn.$wrapNodes = z, Gn.createDOMRange = c, Gn.createRectsFromDOMRange = d, Gn.getStyleObjectFromCSS = p, Gn.trimTextContentFromAnchor = T, Gn;
}
var su, Pf;
function Ao() {
  return Pf || (Pf = 1, su = process.env.NODE_ENV === "development" ? hN() : fN()), su;
}
var $f;
function gN() {
  if ($f)
    return Nn;
  $f = 1;
  var t = Ao(), e = Bt();
  function n(N) {
    let x = new URLSearchParams();
    x.append("code", N);
    for (let v = 1; v < arguments.length; v++)
      x.append("v", arguments[v]);
    throw Error(`Minified Lexical error #${N}; visit https://lexical.dev/docs/error?${x} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  function r(...N) {
    return () => {
      N.forEach((x) => x());
    };
  }
  let c = { attributes: !0, characterData: !0, childList: !0, subtree: !0 };
  function d(N, x, v) {
    function O() {
      if (T === null)
        throw Error("Unexpected null rootDOMNode");
      if (w === null)
        throw Error("Unexpected null parentDOMNode");
      let { left: H, top: z } = T.getBoundingClientRect();
      var te = w;
      let re = t.createRectsFromDOMRange(N, x);
      $.isConnected || te.append($), te = !1;
      for (let G = 0; G < re.length; G++) {
        var ue = re[G];
        let j = K[G] || document.createElement("div"), _e = j.style;
        _e.position !== "absolute" && (_e.position = "absolute", te = !0);
        var q = `${ue.left - H}px`;
        _e.left !== q && (_e.left = q, te = !0), q = `${ue.top - z}px`, _e.top !== q && (j.style.top = q, te = !0), q = `${ue.width}px`, _e.width !== q && (j.style.width = q, te = !0), ue = `${ue.height}px`, _e.height !== ue && (j.style.height = ue, te = !0), j.parentNode !== $ && ($.append(j), te = !0), K[G] = j;
      }
      for (; K.length > re.length; )
        K.pop();
      te && v(K);
    }
    function M() {
      T = w = null, P !== null && P.disconnect(), P = null, $.remove();
      for (let H of K)
        H.remove();
      K = [];
    }
    function A() {
      let H = N.getRootElement();
      if (H === null)
        return M();
      let z = H.parentElement;
      if (!(z instanceof HTMLElement))
        return M();
      M(), T = H, w = z, P = new MutationObserver((te) => {
        let re = N.getRootElement(), ue = re && re.parentElement;
        if (re !== T || ue !== w)
          return A();
        for (let q of te)
          if (!$.contains(q.target))
            return O();
      }), P.observe(z, c), O();
    }
    let T = null, w = null, P = null, K = [], $ = document.createElement("div"), W = N.registerRootListener(A);
    return () => {
      W(), M();
    };
  }
  function h(N, x) {
    for (let v of x)
      if (N.type.startsWith(v))
        return !0;
    return !1;
  }
  function p(N, x) {
    for (; N !== e.$getRoot() && N != null; ) {
      if (x(N))
        return N;
      N = N.getParent();
    }
    return null;
  }
  return Nn.$splitNode = e.$splitNode, Nn.isHTMLAnchorElement = e.isHTMLAnchorElement, Nn.isHTMLElement = e.isHTMLElement, Nn.$dfs = function(N, x) {
    let v = [];
    N = (N || e.$getRoot()).getLatest(), x = x || (e.$isElementNode(N) ? N.getLastDescendant() : N);
    for (var O = N, M = 0; (O = O.getParent()) !== null; )
      M++;
    for (O = M; N !== null && !N.is(x); )
      if (v.push({ depth: O, node: N }), e.$isElementNode(N) && 0 < N.getChildrenSize())
        N = N.getFirstChild(), O++;
      else
        for (M = null; M === null && N !== null; )
          M = N.getNextSibling(), M === null ? (N = N.getParent(), O--) : N = M;
    return N !== null && N.is(x) && v.push({ depth: O, node: N }), v;
  }, Nn.$filter = function(N, x) {
    let v = [];
    for (let O = 0; O < N.length; O++) {
      let M = x(N[O]);
      M !== null && v.push(M);
    }
    return v;
  }, Nn.$findMatchingParent = p, Nn.$getNearestBlockElementAncestorOrThrow = function(N) {
    let x = p(N, (v) => e.$isElementNode(v) && !v.isInline());
    return e.$isElementNode(x) || n(4, N.__key), x;
  }, Nn.$getNearestNodeOfType = function(N, x) {
    for (; N != null; ) {
      if (N instanceof x)
        return N;
      N = N.getParent();
    }
    return null;
  }, Nn.$insertFirst = function(N, x) {
    let v = N.getFirstChild();
    v !== null ? v.insertBefore(x) : N.append(x);
  }, Nn.$insertNodeToNearestRoot = function(N) {
    var x = e.$getSelection() || e.$getPreviousSelection();
    if (e.$isRangeSelection(x)) {
      var { focus: v } = x;
      if (x = v.getNode(), v = v.offset, e.$isRootOrShadowRoot(x))
        v = x.getChildAtIndex(v), v == null ? x.append(N) : v.insertBefore(N), N.selectNext();
      else {
        let O, M;
        e.$isTextNode(x) ? (O = x.getParentOrThrow(), M = x.getIndexWithinParent(), 0 < v && (M += 1, x.splitText(v))) : (O = x, M = v), [, x] = e.$splitNode(O, M), x.insertBefore(N), x.selectStart();
      }
    } else
      x != null ? (x = x.getNodes(), x[x.length - 1].getTopLevelElementOrThrow().insertAfter(N)) : e.$getRoot().append(N), x = e.$createParagraphNode(), N.insertAfter(x), x.select();
    return N.getLatest();
  }, Nn.$restoreEditorState = function(N, x) {
    let v = /* @__PURE__ */ new Map(), O = N._pendingEditorState;
    for (let [M, A] of x._nodeMap) {
      let T = t.$cloneWithProperties(A);
      e.$isTextNode(T) && (T.__text = A.__text), v.set(M, T);
    }
    O && (O._nodeMap = v), N._dirtyType = 2, N = x._selection, e.$setSelection(N === null ? null : N.clone());
  }, Nn.$wrapNodeInElement = function(N, x) {
    return x = x(), N.replace(x), x.append(N), x;
  }, Nn.addClassNamesToElement = function(N, ...x) {
    x.forEach((v) => {
      typeof v == "string" && (v = v.split(" ").filter((O) => O !== ""), N.classList.add(...v));
    });
  }, Nn.isMimeType = h, Nn.markSelection = function(N, x) {
    function v(P) {
      P.read(() => {
        var K = e.$getSelection();
        if (e.$isRangeSelection(K)) {
          var { anchor: $, focus: W } = K;
          K = $.getNode();
          var H = K.getKey(), z = $.offset, te = W.getNode(), re = te.getKey(), ue = W.offset, q = N.getElementByKey(H), G = N.getElementByKey(re);
          if (H = O === null || q === null || z !== M || H !== O.getKey() || K !== O && (!(O instanceof e.TextNode) || K.updateDOM(O, q, N._config)), re = A === null || G === null || ue !== T || re !== A.getKey() || te !== A && (!(A instanceof e.TextNode) || te.updateDOM(A, G, N._config)), H || re) {
            q = N.getElementByKey($.getNode().getKey());
            var j = N.getElementByKey(W.getNode().getKey());
            if (q !== null && j !== null && q.tagName === "SPAN" && j.tagName === "SPAN") {
              if (re = document.createRange(), W.isBefore($) ? (H = j, G = W.offset, j = q, q = $.offset) : (H = q, G = $.offset, q = W.offset), H = H.firstChild, H === null || (j = j.firstChild, j === null))
                throw Error("Expected text node to be first child of span");
              re.setStart(H, G), re.setEnd(j, q), w(), w = d(N, re, (_e) => {
                for (let pe of _e) {
                  let J = pe.style;
                  J.background !== "Highlight" && (J.background = "Highlight"), J.color !== "HighlightText" && (J.color = "HighlightText"), J.zIndex !== "-1" && (J.zIndex = "-1"), J.pointerEvents !== "none" && (J.pointerEvents = "none"), J.marginTop !== "-1.5px" && (J.marginTop = "-1.5px"), J.paddingTop !== "4px" && (J.paddingTop = "4px"), J.paddingBottom !== "0px" && (J.paddingBottom = "0px");
                }
                x !== void 0 && x(_e);
              });
            }
          }
          O = K, M = z, A = te, T = ue;
        } else
          T = A = M = O = null, w(), w = () => {
          };
      });
    }
    let O = null, M = null, A = null, T = null, w = () => {
    };
    return v(N.getEditorState()), r(N.registerUpdateListener(({ editorState: P }) => v(P)), w, () => {
      w();
    });
  }, Nn.mediaFileReader = function(N, x) {
    let v = N[Symbol.iterator]();
    return new Promise((O, M) => {
      let A = [], T = () => {
        const { done: w, value: P } = v.next();
        if (w)
          return O(A);
        const K = new FileReader();
        K.addEventListener("error", M), K.addEventListener("load", () => {
          const $ = K.result;
          typeof $ == "string" && A.push({ file: P, result: $ }), T();
        }), h(P, x) ? K.readAsDataURL(P) : T();
      };
      T();
    });
  }, Nn.mergeRegister = r, Nn.objectKlassEquals = function(N, x) {
    return N !== null ? Object.getPrototypeOf(N).constructor.name === x.name : !1;
  }, Nn.positionNodeOnRange = d, Nn.registerNestedElementResolver = function(N, x, v, O) {
    return N.registerNodeTransform(x, (M) => {
      e: {
        for (var A = M.getChildren(), T = 0; T < A.length; T++)
          if (A[T] instanceof x) {
            A = null;
            break e;
          }
        for (A = M; A !== null; )
          if (T = A, A = A.getParent(), A instanceof x) {
            A = { child: T, parent: A };
            break e;
          }
        A = null;
      }
      if (A !== null) {
        const { child: w, parent: P } = A;
        if (w.is(M)) {
          if (O(P, M), M = w.getNextSiblings(), A = M.length, P.insertAfter(w), A !== 0) {
            T = v(P), w.insertAfter(T);
            for (let K = 0; K < A; K++)
              T.append(M[K]);
          }
          P.canBeEmpty() || P.getChildrenSize() !== 0 || P.remove();
        }
      }
    });
  }, Nn.removeClassNamesFromElement = function(N, ...x) {
    x.forEach((v) => {
      typeof v == "string" && N.classList.remove(...v.split(" "));
    });
  }, Nn;
}
var Cn = {}, Ff;
function pN() {
  if (Ff)
    return Cn;
  Ff = 1;
  var t = Ao(), e = Bt();
  function n(...re) {
    return () => {
      re.forEach((ue) => ue());
    };
  }
  function r(re) {
    return `${re}px`;
  }
  const c = {
    attributes: !0,
    characterData: !0,
    childList: !0,
    subtree: !0
  };
  function d(re, ue, q) {
    let G = null, j = null, _e = null, pe = [];
    const J = document.createElement("div");
    function ee() {
      if (G === null)
        throw Error("Unexpected null rootDOMNode");
      if (j === null)
        throw Error("Unexpected null parentDOMNode");
      const {
        left: ne,
        top: Y
      } = G.getBoundingClientRect(), U = j, Q = t.createRectsFromDOMRange(re, ue);
      J.isConnected || U.append(J);
      let k = !1;
      for (let m = 0; m < Q.length; m++) {
        const y = Q[m], b = pe[m] || document.createElement("div"), Z = b.style;
        Z.position !== "absolute" && (Z.position = "absolute", k = !0);
        const ce = r(y.left - ne);
        Z.left !== ce && (Z.left = ce, k = !0);
        const ge = r(y.top - Y);
        Z.top !== ge && (b.style.top = ge, k = !0);
        const ae = r(y.width);
        Z.width !== ae && (b.style.width = ae, k = !0);
        const Te = r(y.height);
        Z.height !== Te && (b.style.height = Te, k = !0), b.parentNode !== J && (J.append(b), k = !0), pe[m] = b;
      }
      for (; pe.length > Q.length; )
        pe.pop();
      k && q(pe);
    }
    function F() {
      j = null, G = null, _e !== null && _e.disconnect(), _e = null, J.remove();
      for (const ne of pe)
        ne.remove();
      pe = [];
    }
    function D() {
      const ne = re.getRootElement();
      if (ne === null)
        return F();
      const Y = ne.parentElement;
      if (!(Y instanceof HTMLElement))
        return F();
      F(), G = ne, j = Y, _e = new MutationObserver((U) => {
        const Q = re.getRootElement(), k = Q && Q.parentElement;
        if (Q !== G || k !== j)
          return D();
        for (const m of U)
          if (!J.contains(m.target))
            return ee();
      }), _e.observe(Y, c), ee();
    }
    const V = re.registerRootListener(D);
    return () => {
      V(), F();
    };
  }
  function h(re, ue) {
    let q = null, G = null, j = null, _e = null, pe = () => {
    };
    function J(ee) {
      ee.read(() => {
        const F = e.$getSelection();
        if (!e.$isRangeSelection(F)) {
          q = null, G = null, j = null, _e = null, pe(), pe = () => {
          };
          return;
        }
        const {
          anchor: D,
          focus: V
        } = F, ne = D.getNode(), Y = ne.getKey(), U = D.offset, Q = V.getNode(), k = Q.getKey(), m = V.offset, y = re.getElementByKey(Y), b = re.getElementByKey(k), Z = q === null || y === null || U !== G || Y !== q.getKey() || ne !== q && (!(q instanceof e.TextNode) || ne.updateDOM(q, y, re._config)), ce = j === null || b === null || m !== _e || k !== j.getKey() || Q !== j && (!(j instanceof e.TextNode) || Q.updateDOM(j, b, re._config));
        if (Z || ce) {
          const ge = re.getElementByKey(D.getNode().getKey()), ae = re.getElementByKey(V.getNode().getKey());
          if (ge !== null && ae !== null && ge.tagName === "SPAN" && ae.tagName === "SPAN") {
            const Te = document.createRange();
            let Ae, ze, oe, ie;
            V.isBefore(D) ? (Ae = ae, ze = V.offset, oe = ge, ie = D.offset) : (Ae = ge, ze = D.offset, oe = ae, ie = V.offset);
            const de = Ae.firstChild;
            if (de === null)
              throw Error("Expected text node to be first child of span");
            const we = oe.firstChild;
            if (we === null)
              throw Error("Expected text node to be first child of span");
            Te.setStart(de, ze), Te.setEnd(we, ie), pe(), pe = d(re, Te, (ke) => {
              for (const Be of ke) {
                const Ye = Be.style;
                Ye.background !== "Highlight" && (Ye.background = "Highlight"), Ye.color !== "HighlightText" && (Ye.color = "HighlightText"), Ye.zIndex !== "-1" && (Ye.zIndex = "-1"), Ye.pointerEvents !== "none" && (Ye.pointerEvents = "none"), Ye.marginTop !== r(-1.5) && (Ye.marginTop = r(-1.5)), Ye.paddingTop !== r(4) && (Ye.paddingTop = r(4)), Ye.paddingBottom !== r(0) && (Ye.paddingBottom = r(0));
              }
              ue !== void 0 && ue(ke);
            });
          }
        }
        q = ne, G = U, j = Q, _e = m;
      });
    }
    return J(re.getEditorState()), n(re.registerUpdateListener(({
      editorState: ee
    }) => J(ee)), pe, () => {
      pe();
    });
  }
  function p(re, ...ue) {
    ue.forEach((q) => {
      if (typeof q == "string") {
        const G = q.split(" ").filter((j) => j !== "");
        re.classList.add(...G);
      }
    });
  }
  function N(re, ...ue) {
    ue.forEach((q) => {
      typeof q == "string" && re.classList.remove(...q.split(" "));
    });
  }
  function x(re, ue) {
    for (const q of ue)
      if (re.type.startsWith(q))
        return !0;
    return !1;
  }
  function v(re, ue) {
    const q = re[Symbol.iterator]();
    return new Promise((G, j) => {
      const _e = [], pe = () => {
        const {
          done: J,
          value: ee
        } = q.next();
        if (J)
          return G(_e);
        const F = new FileReader();
        F.addEventListener("error", j), F.addEventListener("load", () => {
          const D = F.result;
          typeof D == "string" && _e.push({
            file: ee,
            result: D
          }), pe();
        }), x(ee, ue) ? F.readAsDataURL(ee) : pe();
      };
      pe();
    });
  }
  function O(re, ue) {
    const q = [], G = (re || e.$getRoot()).getLatest(), j = ue || (e.$isElementNode(G) ? G.getLastDescendant() : G);
    let _e = G, pe = M(_e);
    for (; _e !== null && !_e.is(j); )
      if (q.push({
        depth: pe,
        node: _e
      }), e.$isElementNode(_e) && _e.getChildrenSize() > 0)
        _e = _e.getFirstChild(), pe++;
      else {
        let J = null;
        for (; J === null && _e !== null; )
          J = _e.getNextSibling(), J === null ? (_e = _e.getParent(), pe--) : _e = J;
      }
    return _e !== null && _e.is(j) && q.push({
      depth: pe,
      node: _e
    }), q;
  }
  function M(re) {
    let ue = re, q = 0;
    for (; (ue = ue.getParent()) !== null; )
      q++;
    return q;
  }
  function A(re, ue) {
    let q = re;
    for (; q != null; ) {
      if (q instanceof ue)
        return q;
      q = q.getParent();
    }
    return null;
  }
  function T(re) {
    const ue = w(re, (q) => e.$isElementNode(q) && !q.isInline());
    if (!e.$isElementNode(ue))
      throw Error(`Expected node ${re.__key} to have closest block element node.`);
    return ue;
  }
  function w(re, ue) {
    let q = re;
    for (; q !== e.$getRoot() && q != null; ) {
      if (ue(q))
        return q;
      q = q.getParent();
    }
    return null;
  }
  function P(re, ue, q, G) {
    const j = (J) => J instanceof ue, _e = (J) => {
      const ee = J.getChildren();
      for (let V = 0; V < ee.length; V++) {
        const ne = ee[V];
        if (j(ne))
          return null;
      }
      let F = J, D = J;
      for (; F !== null; )
        if (D = F, F = F.getParent(), j(F))
          return {
            child: D,
            parent: F
          };
      return null;
    }, pe = (J) => {
      const ee = _e(J);
      if (ee !== null) {
        const {
          child: F,
          parent: D
        } = ee;
        if (F.is(J)) {
          G(D, J);
          const V = F.getNextSiblings(), ne = V.length;
          if (D.insertAfter(F), ne !== 0) {
            const Y = q(D);
            F.insertAfter(Y);
            for (let U = 0; U < ne; U++)
              Y.append(V[U]);
          }
          !D.canBeEmpty() && D.getChildrenSize() === 0 && D.remove();
        }
      }
    };
    return re.registerNodeTransform(ue, pe);
  }
  function K(re, ue) {
    const G = /* @__PURE__ */ new Map(), j = re._pendingEditorState;
    for (const [pe, J] of ue._nodeMap) {
      const ee = t.$cloneWithProperties(J);
      e.$isTextNode(ee) && (ee.__text = J.__text), G.set(pe, ee);
    }
    j && (j._nodeMap = G), re._dirtyType = 2;
    const _e = ue._selection;
    e.$setSelection(_e === null ? null : _e.clone());
  }
  function $(re) {
    const ue = e.$getSelection() || e.$getPreviousSelection();
    if (e.$isRangeSelection(ue)) {
      const {
        focus: q
      } = ue, G = q.getNode(), j = q.offset;
      if (e.$isRootOrShadowRoot(G)) {
        const _e = G.getChildAtIndex(j);
        _e == null ? G.append(re) : _e.insertBefore(re), re.selectNext();
      } else {
        let _e, pe;
        e.$isTextNode(G) ? (_e = G.getParentOrThrow(), pe = G.getIndexWithinParent(), j > 0 && (pe += 1, G.splitText(j))) : (_e = G, pe = j);
        const [, J] = e.$splitNode(_e, pe);
        J.insertBefore(re), J.selectStart();
      }
    } else {
      if (ue != null) {
        const G = ue.getNodes();
        G[G.length - 1].getTopLevelElementOrThrow().insertAfter(re);
      } else
        e.$getRoot().append(re);
      const q = e.$createParagraphNode();
      re.insertAfter(q), q.select();
    }
    return re.getLatest();
  }
  function W(re, ue) {
    const q = ue();
    return re.replace(q), q.append(re), q;
  }
  function H(re, ue) {
    return re !== null ? Object.getPrototypeOf(re).constructor.name === ue.name : !1;
  }
  function z(re, ue) {
    const q = [];
    for (let G = 0; G < re.length; G++) {
      const j = ue(re[G]);
      j !== null && q.push(j);
    }
    return q;
  }
  function te(re, ue) {
    const q = re.getFirstChild();
    q !== null ? q.insertBefore(ue) : re.append(ue);
  }
  return Cn.$splitNode = e.$splitNode, Cn.isHTMLAnchorElement = e.isHTMLAnchorElement, Cn.isHTMLElement = e.isHTMLElement, Cn.$dfs = O, Cn.$filter = z, Cn.$findMatchingParent = w, Cn.$getNearestBlockElementAncestorOrThrow = T, Cn.$getNearestNodeOfType = A, Cn.$insertFirst = te, Cn.$insertNodeToNearestRoot = $, Cn.$restoreEditorState = K, Cn.$wrapNodeInElement = W, Cn.addClassNamesToElement = p, Cn.isMimeType = x, Cn.markSelection = h, Cn.mediaFileReader = v, Cn.mergeRegister = n, Cn.objectKlassEquals = H, Cn.positionNodeOnRange = d, Cn.registerNestedElementResolver = P, Cn.removeClassNamesFromElement = N, Cn;
}
var lu, Bf;
function rn() {
  return Bf || (Bf = 1, lu = process.env.NODE_ENV === "development" ? pN() : gN()), lu;
}
var au = {}, Hf;
function mN() {
  if (Hf)
    return au;
  Hf = 1;
  var t = Bt();
  return au.registerDragonSupport = function(e) {
    let n = window.location.origin, r = (c) => {
      if (c.origin === n) {
        var d = e.getRootElement();
        if (document.activeElement === d && (d = c.data, typeof d == "string")) {
          try {
            var h = JSON.parse(d);
          } catch {
            return;
          }
          if (h && h.protocol === "nuanria_messaging" && h.type === "request" && (h = h.payload) && h.functionId === "makeChanges" && (h = h.args)) {
            const [p, N, x, v, O] = h;
            e.update(() => {
              const M = t.$getSelection();
              if (t.$isRangeSelection(M)) {
                var A = M.anchor;
                let T = A.getNode(), w = 0, P = 0;
                t.$isTextNode(T) && 0 <= p && 0 <= N && (w = p, P = p + N, M.setTextNodeRange(T, w, T, P)), (w !== P || x !== "") && (M.insertRawText(x), T = A.getNode()), t.$isTextNode(T) && (w = v, P = v + O, A = T.getTextContentSize(), w = w > A ? A : w, P = P > A ? A : P, M.setTextNodeRange(T, w, T, P)), c.stopImmediatePropagation();
              }
            });
          }
        }
      }
    };
    return window.addEventListener("message", r, !0), () => {
      window.removeEventListener("message", r, !0);
    };
  }, au;
}
var cu = {}, Wf;
function _N() {
  if (Wf)
    return cu;
  Wf = 1;
  var t = Bt();
  function e(n) {
    const r = window.location.origin, c = (d) => {
      if (d.origin !== r)
        return;
      const h = n.getRootElement();
      if (document.activeElement !== h)
        return;
      const p = d.data;
      if (typeof p == "string") {
        let N;
        try {
          N = JSON.parse(p);
        } catch {
          return;
        }
        if (N && N.protocol === "nuanria_messaging" && N.type === "request") {
          const x = N.payload;
          if (x && x.functionId === "makeChanges") {
            const v = x.args;
            if (v) {
              const [O, M, A, T, w, P] = v;
              n.update(() => {
                const K = t.$getSelection();
                if (t.$isRangeSelection(K)) {
                  const $ = K.anchor;
                  let W = $.getNode(), H = 0, z = 0;
                  if (t.$isTextNode(W) && O >= 0 && M >= 0 && (H = O, z = O + M, K.setTextNodeRange(W, H, W, z)), (H !== z || A !== "") && (K.insertRawText(A), W = $.getNode()), t.$isTextNode(W)) {
                    H = T, z = T + w;
                    const te = W.getTextContentSize();
                    H = H > te ? te : H, z = z > te ? te : z, K.setTextNodeRange(W, H, W, z);
                  }
                  d.stopImmediatePropagation();
                }
              });
            }
          }
        }
      }
    };
    return window.addEventListener("message", c, !0), () => {
      window.removeEventListener("message", c, !0);
    };
  }
  return cu.registerDragonSupport = e, cu;
}
var uu, Kf;
function Cp() {
  return Kf || (Kf = 1, uu = process.env.NODE_ENV === "development" ? _N() : mN()), uu;
}
var hi = {}, Pi = {}, ja = {}, Uf;
function yN() {
  if (Uf)
    return ja;
  Uf = 1;
  var t = Ao(), e = rn(), n = Bt();
  function r(h, p, N, x = null) {
    let v = x != null ? p.isSelected(x) : !0, O = n.$isElementNode(p) && p.excludeFromCopy("html");
    var M = p;
    x !== null && (M = t.$cloneWithProperties(p), M = n.$isTextNode(M) && x != null ? t.$sliceSelectedTextNodeContent(x, M) : M);
    let A = n.$isElementNode(M) ? M.getChildren() : [];
    var T = h._nodes.get(M.getType());
    T = T && T.exportDOM !== void 0 ? T.exportDOM(h, M) : M.exportDOM(h);
    let { element: w, after: P } = T;
    if (!w)
      return !1;
    T = document.createDocumentFragment();
    for (let K = 0; K < A.length; K++) {
      let $ = A[K], W = r(h, $, T, x);
      !v && n.$isElementNode(p) && W && p.extractWithChild($, x, "html") && (v = !0);
    }
    return v && !O ? (e.isHTMLElement(w) && w.append(T), N.append(w), P && (h = P.call(M, w)) && w.replaceWith(h)) : N.append(T), v;
  }
  let c = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
  function d(h, p, N = /* @__PURE__ */ new Map(), x) {
    let v = [];
    if (c.has(h.nodeName))
      return v;
    let O = null;
    var M, { nodeName: A } = h, T = p._htmlConversions.get(A.toLowerCase());
    if (A = null, T !== void 0)
      for (M of T)
        T = M(h), T !== null && (A === null || A.priority < T.priority) && (A = T);
    if (A = (M = A !== null ? A.conversion : null) ? M(h) : null, M = null, A !== null) {
      if (M = A.after, T = A.node, O = Array.isArray(T) ? T[T.length - 1] : T, O !== null) {
        for (var [, w] of N)
          if (O = w(O, x), !O)
            break;
        O && v.push(...Array.isArray(T) ? T : [O]);
      }
      A.forChild != null && N.set(h.nodeName, A.forChild);
    }
    for (h = h.childNodes, x = [], w = 0; w < h.length; w++)
      x.push(...d(h[w], p, new Map(N), O));
    return M != null && (x = M(x)), O == null ? v = v.concat(x) : n.$isElementNode(O) && O.append(...x), v;
  }
  return ja.$generateHtmlFromNodes = function(h, p) {
    if (typeof document > "u" || typeof window > "u")
      throw Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
    let N = document.createElement("div"), x = n.$getRoot().getChildren();
    for (let v = 0; v < x.length; v++)
      r(h, x[v], N, p);
    return N.innerHTML;
  }, ja.$generateNodesFromDOM = function(h, p) {
    p = p.body ? p.body.childNodes : [];
    let N = [];
    for (let v = 0; v < p.length; v++) {
      var x = p[v];
      c.has(x.nodeName) || (x = d(x, h), x !== null && (N = N.concat(x)));
    }
    return N;
  }, ja;
}
var qa = {}, zf;
function NN() {
  if (zf)
    return qa;
  zf = 1;
  var t = Ao(), e = rn(), n = Bt();
  function r(x, v) {
    const O = v.body ? v.body.childNodes : [];
    let M = [];
    for (let A = 0; A < O.length; A++) {
      const T = O[A];
      if (!p.has(T.nodeName)) {
        const w = N(T, x);
        w !== null && (M = M.concat(w));
      }
    }
    return M;
  }
  function c(x, v) {
    if (typeof document > "u" || typeof window > "u")
      throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
    const O = document.createElement("div"), A = n.$getRoot().getChildren();
    for (let T = 0; T < A.length; T++) {
      const w = A[T];
      d(x, w, O, v);
    }
    return O.innerHTML;
  }
  function d(x, v, O, M = null) {
    let A = M != null ? v.isSelected(M) : !0;
    const T = n.$isElementNode(v) && v.excludeFromCopy("html");
    let w = v;
    if (M !== null) {
      let te = t.$cloneWithProperties(v);
      te = n.$isTextNode(te) && M != null ? t.$sliceSelectedTextNodeContent(M, te) : te, w = te;
    }
    const P = n.$isElementNode(w) ? w.getChildren() : [], K = x._nodes.get(w.getType());
    let $;
    K && K.exportDOM !== void 0 ? $ = K.exportDOM(x, w) : $ = w.exportDOM(x);
    const {
      element: W,
      after: H
    } = $;
    if (!W)
      return !1;
    const z = document.createDocumentFragment();
    for (let te = 0; te < P.length; te++) {
      const re = P[te], ue = d(x, re, z, M);
      !A && n.$isElementNode(v) && ue && v.extractWithChild(re, M, "html") && (A = !0);
    }
    if (A && !T) {
      if (e.isHTMLElement(W) && W.append(z), O.append(W), H) {
        const te = H.call(w, W);
        te && W.replaceWith(te);
      }
    } else
      O.append(z);
    return A;
  }
  function h(x, v) {
    const {
      nodeName: O
    } = x, M = v._htmlConversions.get(O.toLowerCase());
    let A = null;
    if (M !== void 0)
      for (const T of M) {
        const w = T(x);
        w !== null && (A === null || A.priority < w.priority) && (A = w);
      }
    return A !== null ? A.conversion : null;
  }
  const p = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
  function N(x, v, O = /* @__PURE__ */ new Map(), M) {
    let A = [];
    if (p.has(x.nodeName))
      return A;
    let T = null;
    const w = h(x, v), P = w ? w(x) : null;
    let K = null;
    if (P !== null) {
      K = P.after;
      const H = P.node;
      if (T = Array.isArray(H) ? H[H.length - 1] : H, T !== null) {
        for (const [, z] of O)
          if (T = z(T, M), !T)
            break;
        T && A.push(...Array.isArray(H) ? H : [T]);
      }
      P.forChild != null && O.set(x.nodeName, P.forChild);
    }
    const $ = x.childNodes;
    let W = [];
    for (let H = 0; H < $.length; H++)
      W.push(...N($[H], v, new Map(O), T));
    return K != null && (W = K(W)), T == null ? A = A.concat(W) : n.$isElementNode(T) && T.append(...W), A;
  }
  return qa.$generateHtmlFromNodes = c, qa.$generateNodesFromDOM = r, qa;
}
var du, Gf;
function Ep() {
  return Gf || (Gf = 1, du = process.env.NODE_ENV === "development" ? NN() : yN()), du;
}
var Yf;
function CN() {
  if (Yf)
    return Pi;
  Yf = 1;
  var t = Ep(), e = Ao(), n = rn(), r = Bt();
  function c(w) {
    let P = new URLSearchParams();
    P.append("code", w);
    for (let K = 1; K < arguments.length; K++)
      P.append("v", arguments[K]);
    throw Error(`Minified Lexical error #${w}; visit https://lexical.dev/docs/error?${P} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  let d = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
  function h(w) {
    let P = r.$getSelection();
    if (P == null)
      throw Error("Expected valid LexicalSelection");
    return r.$isRangeSelection(P) && P.isCollapsed() || P.getNodes().length === 0 ? "" : t.$generateHtmlFromNodes(w, P);
  }
  function p(w) {
    let P = r.$getSelection();
    if (P == null)
      throw Error("Expected valid LexicalSelection");
    return r.$isRangeSelection(P) && P.isCollapsed() || P.getNodes().length === 0 ? null : JSON.stringify(O(w, P));
  }
  function N(w, P, K) {
    let $ = r.DEPRECATED_$isGridSelection(K), W = r.$isRangeSelection(K);
    ($ || W && n.$findMatchingParent(K.anchor.getNode(), (H) => r.DEPRECATED_$isGridCellNode(H)) !== null && n.$findMatchingParent(K.focus.getNode(), (H) => r.DEPRECATED_$isGridCellNode(H)) !== null) && P.length === 1 && r.DEPRECATED_$isGridNode(P[0]) ? x(P, K, !1, w) : K.insertNodes(P);
  }
  function x(w, P, K, $) {
    w.length === 1 && r.DEPRECATED_$isGridNode(w[0]) || c(42);
    var W = w[0];
    w = W.getChildren(), K = W.getFirstChildOrThrow().getChildrenSize();
    var H = W.getChildrenSize(), z = n.$findMatchingParent(P.anchor.getNode(), (_e) => r.DEPRECATED_$isGridCellNode(_e));
    P = (W = z && n.$findMatchingParent(z, (_e) => r.DEPRECATED_$isGridRowNode(_e))) && n.$findMatchingParent(W, (_e) => r.DEPRECATED_$isGridNode(_e)), r.DEPRECATED_$isGridCellNode(z) && r.DEPRECATED_$isGridRowNode(W) && r.DEPRECATED_$isGridNode(P) || c(43);
    var te = W.getIndexWithinParent(), re = Math.min(P.getChildrenSize() - 1, te + H - 1);
    H = z.getIndexWithinParent(), z = Math.min(W.getChildrenSize() - 1, H + K - 1), K = Math.min(H, z), W = Math.min(te, re), H = Math.max(H, z), te = Math.max(te, re), re = P.getChildren(), z = 0;
    let ue, q;
    for (let _e = W; _e <= te; _e++) {
      var G = re[_e];
      r.DEPRECATED_$isGridRowNode(G) || c(24);
      var j = w[z];
      r.DEPRECATED_$isGridRowNode(j) || c(24), G = G.getChildren(), j = j.getChildren();
      let pe = 0;
      for (let J = K; J <= H; J++) {
        let ee = G[J];
        r.DEPRECATED_$isGridCellNode(ee) || c(25);
        let F = j[pe];
        r.DEPRECATED_$isGridCellNode(F) || c(25), _e === W && J === K ? ue = ee.getKey() : _e === te && J === H && (q = ee.getKey());
        let D = ee.getChildren();
        F.getChildren().forEach((V) => {
          r.$isTextNode(V) && r.$createParagraphNode().append(V), ee.append(V);
        }), D.forEach((V) => V.remove()), pe++;
      }
      z++;
    }
    ue && q && (w = r.DEPRECATED_$createGridSelection(), w.set(P.getKey(), ue, q), r.$setSelection(w), $.dispatchCommand(r.SELECTION_CHANGE_COMMAND, void 0));
  }
  function v(w, P, K, $ = []) {
    let W = P != null ? K.isSelected(P) : !0, H = r.$isElementNode(K) && K.excludeFromCopy("html");
    var z = K;
    if (P !== null) {
      var te = e.$cloneWithProperties(K);
      z = te = r.$isTextNode(te) && P != null ? e.$sliceSelectedTextNodeContent(P, te) : te;
    }
    let re = r.$isElementNode(z) ? z.getChildren() : [];
    var ue = z;
    te = ue.exportJSON();
    var q = ue.constructor;
    te.type !== q.getType() && c(58, q.name);
    let G = te.children;
    for (r.$isElementNode(ue) && (Array.isArray(G) || c(59, q.name)), r.$isTextNode(z) && (z = z.__text, 0 < z.length ? te.text = z : W = !1), z = 0; z < re.length; z++)
      ue = re[z], q = v(w, P, ue, te.children), !W && r.$isElementNode(K) && q && K.extractWithChild(ue, P, "clone") && (W = !0);
    if (W && !H)
      $.push(te);
    else if (Array.isArray(te.children))
      for (w = 0; w < te.children.length; w++)
        $.push(te.children[w]);
    return W;
  }
  function O(w, P) {
    let K = [], $ = r.$getRoot().getChildren();
    for (let W = 0; W < $.length; W++)
      v(w, P, $[W], K);
    return { namespace: w._config.namespace, nodes: K };
  }
  function M(w) {
    let P = [];
    for (let K = 0; K < w.length; K++) {
      let $ = r.$parseSerializedNode(w[K]);
      r.$isTextNode($) && e.$addNodeStyle($), P.push($);
    }
    return P;
  }
  let A = null;
  function T(w, P) {
    var K = d ? (w._window || window).getSelection() : null;
    if (!K)
      return !1;
    var $ = K.anchorNode;
    if (K = K.focusNode, $ !== null && K !== null && !r.isSelectionWithinEditor(w, $, K) || (P.preventDefault(), P = P.clipboardData, $ = r.$getSelection(), P === null || $ === null))
      return !1;
    K = h(w), w = p(w);
    let W = "";
    return $ !== null && (W = $.getTextContent()), K !== null && P.setData("text/html", K), w !== null && P.setData("application/x-lexical-editor", w), P.setData("text/plain", W), !0;
  }
  return Pi.$generateJSONFromSelectedNodes = O, Pi.$generateNodesFromSerializedNodes = M, Pi.$getHtmlContent = h, Pi.$getLexicalContent = p, Pi.$insertDataTransferForPlainText = function(w, P) {
    w = w.getData("text/plain") || w.getData("text/uri-list"), w != null && P.insertRawText(w);
  }, Pi.$insertDataTransferForRichText = function(w, P, K) {
    var $ = w.getData("application/x-lexical-editor");
    if ($)
      try {
        let H = JSON.parse($);
        if (H.namespace === K._config.namespace && Array.isArray(H.nodes)) {
          let z = M(H.nodes);
          return N(K, z, P);
        }
      } catch {
      }
    if ($ = w.getData("text/html"))
      try {
        var W = new DOMParser().parseFromString($, "text/html");
        let H = t.$generateNodesFromDOM(K, W);
        return N(K, H, P);
      } catch {
      }
    if (w = w.getData("text/plain") || w.getData("text/uri-list"), w != null)
      if (r.$isRangeSelection(P))
        for (w = w.split(/(\r?\n|\t)/), w[w.length - 1] === "" && w.pop(), K = 0; K < w.length; K++)
          W = w[K], W === `
` || W === `\r
` ? P.insertParagraph() : W === "	" ? P.insertNodes([r.$createTabNode()]) : P.insertText(W);
      else
        P.insertRawText(w);
  }, Pi.$insertGeneratedNodes = N, Pi.copyToClipboard = async function(w, P) {
    if (A !== null)
      return !1;
    if (P !== null)
      return new Promise((z) => {
        w.update(() => {
          z(T(w, P));
        });
      });
    var K = w.getRootElement();
    let $ = w._window == null ? window.document : w._window.document, W = d ? (w._window || window).getSelection() : null;
    if (K === null || W === null)
      return !1;
    let H = $.createElement("span");
    return H.style.cssText = "position: fixed; top: -1000px;", H.append($.createTextNode("#")), K.append(H), K = new Range(), K.setStart(H, 0), K.setEnd(H, 1), W.removeAllRanges(), W.addRange(K), new Promise((z) => {
      let te = w.registerCommand(r.COPY_COMMAND, (re) => (n.objectKlassEquals(re, ClipboardEvent) && (te(), A !== null && (window.clearTimeout(A), A = null), z(T(w, re))), !0), r.COMMAND_PRIORITY_CRITICAL);
      A = window.setTimeout(() => {
        te(), A = null, z(!1);
      }, 50), $.execCommand("copy"), H.remove();
    });
  }, Pi;
}
var $i = {}, Vf;
function EN() {
  if (Vf)
    return $i;
  Vf = 1;
  var t = Ep(), e = Ao(), n = rn(), r = Bt();
  const c = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", d = (H) => c ? (H || window).getSelection() : null;
  function h(H) {
    const z = r.$getSelection();
    if (z == null)
      throw Error("Expected valid LexicalSelection");
    return r.$isRangeSelection(z) && z.isCollapsed() || z.getNodes().length === 0 ? "" : t.$generateHtmlFromNodes(H, z);
  }
  function p(H) {
    const z = r.$getSelection();
    if (z == null)
      throw Error("Expected valid LexicalSelection");
    return r.$isRangeSelection(z) && z.isCollapsed() || z.getNodes().length === 0 ? null : JSON.stringify(T(H, z));
  }
  function N(H, z) {
    const te = H.getData("text/plain") || H.getData("text/uri-list");
    te != null && z.insertRawText(te);
  }
  function x(H, z, te) {
    const re = H.getData("application/x-lexical-editor");
    if (re)
      try {
        const G = JSON.parse(re);
        if (G.namespace === te._config.namespace && Array.isArray(G.nodes)) {
          const j = w(G.nodes);
          return v(te, j, z);
        }
      } catch {
      }
    const ue = H.getData("text/html");
    if (ue)
      try {
        const j = new DOMParser().parseFromString(ue, "text/html"), _e = t.$generateNodesFromDOM(te, j);
        return v(te, _e, z);
      } catch {
      }
    const q = H.getData("text/plain") || H.getData("text/uri-list");
    if (q != null)
      if (r.$isRangeSelection(z)) {
        const G = q.split(/(\r?\n|\t)/);
        G[G.length - 1] === "" && G.pop();
        for (let j = 0; j < G.length; j++) {
          const _e = G[j];
          _e === `
` || _e === `\r
` ? z.insertParagraph() : _e === "	" ? z.insertNodes([r.$createTabNode()]) : z.insertText(_e);
        }
      } else
        z.insertRawText(q);
  }
  function v(H, z, te) {
    const re = r.DEPRECATED_$isGridSelection(te), ue = r.$isRangeSelection(te);
    if ((re || ue && n.$findMatchingParent(te.anchor.getNode(), (G) => r.DEPRECATED_$isGridCellNode(G)) !== null && n.$findMatchingParent(te.focus.getNode(), (G) => r.DEPRECATED_$isGridCellNode(G)) !== null) && z.length === 1 && r.DEPRECATED_$isGridNode(z[0])) {
      O(z, te, !1, H);
      return;
    }
    te.insertNodes(z);
  }
  function O(H, z, te, re) {
    if (H.length !== 1 || !r.DEPRECATED_$isGridNode(H[0]))
      throw Error("$mergeGridNodesStrategy: Expected Grid insertion.");
    const ue = H[0], q = ue.getChildren(), G = ue.getFirstChildOrThrow().getChildrenSize(), j = ue.getChildrenSize(), _e = n.$findMatchingParent(z.anchor.getNode(), (Z) => r.DEPRECATED_$isGridCellNode(Z)), pe = _e && n.$findMatchingParent(_e, (Z) => r.DEPRECATED_$isGridRowNode(Z)), J = pe && n.$findMatchingParent(pe, (Z) => r.DEPRECATED_$isGridNode(Z));
    if (!r.DEPRECATED_$isGridCellNode(_e) || !r.DEPRECATED_$isGridRowNode(pe) || !r.DEPRECATED_$isGridNode(J))
      throw Error("$mergeGridNodesStrategy: Expected selection to be inside of a Grid.");
    const ee = pe.getIndexWithinParent(), F = Math.min(J.getChildrenSize() - 1, ee + j - 1), D = _e.getIndexWithinParent(), V = Math.min(pe.getChildrenSize() - 1, D + G - 1), ne = Math.min(D, V), Y = Math.min(ee, F), U = Math.max(D, V), Q = Math.max(ee, F), k = J.getChildren();
    let m = 0, y, b;
    for (let Z = Y; Z <= Q; Z++) {
      const ce = k[Z];
      if (!r.DEPRECATED_$isGridRowNode(ce))
        throw Error("getNodes: expected to find GridRowNode");
      const ge = q[m];
      if (!r.DEPRECATED_$isGridRowNode(ge))
        throw Error("getNodes: expected to find GridRowNode");
      const ae = ce.getChildren(), Te = ge.getChildren();
      let Ae = 0;
      for (let ze = ne; ze <= U; ze++) {
        const oe = ae[ze];
        if (!r.DEPRECATED_$isGridCellNode(oe))
          throw Error("getNodes: expected to find GridCellNode");
        const ie = Te[Ae];
        if (!r.DEPRECATED_$isGridCellNode(ie))
          throw Error("getNodes: expected to find GridCellNode");
        Z === Y && ze === ne ? y = oe.getKey() : Z === Q && ze === U && (b = oe.getKey());
        const de = oe.getChildren();
        ie.getChildren().forEach((we) => {
          r.$isTextNode(we) && r.$createParagraphNode().append(we), oe.append(we);
        }), de.forEach((we) => we.remove()), Ae++;
      }
      m++;
    }
    if (y && b) {
      const Z = r.DEPRECATED_$createGridSelection();
      Z.set(J.getKey(), y, b), r.$setSelection(Z), re.dispatchCommand(r.SELECTION_CHANGE_COMMAND, void 0);
    }
  }
  function M(H) {
    const z = H.exportJSON(), te = H.constructor;
    if (z.type !== te.getType())
      throw Error(`LexicalNode: Node ${te.name} does not implement .exportJSON().`);
    const re = z.children;
    if (r.$isElementNode(H) && !Array.isArray(re))
      throw Error(`LexicalNode: Node ${te.name} is an element but .exportJSON() does not have a children array.`);
    return z;
  }
  function A(H, z, te, re = []) {
    let ue = z != null ? te.isSelected(z) : !0;
    const q = r.$isElementNode(te) && te.excludeFromCopy("html");
    let G = te;
    if (z !== null) {
      let pe = e.$cloneWithProperties(te);
      pe = r.$isTextNode(pe) && z != null ? e.$sliceSelectedTextNodeContent(z, pe) : pe, G = pe;
    }
    const j = r.$isElementNode(G) ? G.getChildren() : [], _e = M(G);
    if (r.$isTextNode(G)) {
      const pe = G.__text;
      pe.length > 0 ? _e.text = pe : ue = !1;
    }
    for (let pe = 0; pe < j.length; pe++) {
      const J = j[pe], ee = A(H, z, J, _e.children);
      !ue && r.$isElementNode(te) && ee && te.extractWithChild(J, z, "clone") && (ue = !0);
    }
    if (ue && !q)
      re.push(_e);
    else if (Array.isArray(_e.children))
      for (let pe = 0; pe < _e.children.length; pe++) {
        const J = _e.children[pe];
        re.push(J);
      }
    return ue;
  }
  function T(H, z) {
    const te = [], ue = r.$getRoot().getChildren();
    for (let q = 0; q < ue.length; q++) {
      const G = ue[q];
      A(H, z, G, te);
    }
    return {
      namespace: H._config.namespace,
      nodes: te
    };
  }
  function w(H) {
    const z = [];
    for (let te = 0; te < H.length; te++) {
      const re = H[te], ue = r.$parseSerializedNode(re);
      r.$isTextNode(ue) && e.$addNodeStyle(ue), z.push(ue);
    }
    return z;
  }
  const P = 50;
  let K = null;
  async function $(H, z) {
    if (K !== null)
      return !1;
    if (z !== null)
      return new Promise((j, _e) => {
        H.update(() => {
          j(W(H, z));
        });
      });
    const te = H.getRootElement(), re = H._window == null ? window.document : H._window.document, ue = d(H._window);
    if (te === null || ue === null)
      return !1;
    const q = re.createElement("span");
    q.style.cssText = "position: fixed; top: -1000px;", q.append(re.createTextNode("#")), te.append(q);
    const G = new Range();
    return G.setStart(q, 0), G.setEnd(q, 1), ue.removeAllRanges(), ue.addRange(G), new Promise((j, _e) => {
      const pe = H.registerCommand(r.COPY_COMMAND, (J) => (n.objectKlassEquals(J, ClipboardEvent) && (pe(), K !== null && (window.clearTimeout(K), K = null), j(W(H, J))), !0), r.COMMAND_PRIORITY_CRITICAL);
      K = window.setTimeout(() => {
        pe(), K = null, j(!1);
      }, P), re.execCommand("copy"), q.remove();
    });
  }
  function W(H, z) {
    const te = d(H._window);
    if (!te)
      return !1;
    const re = te.anchorNode, ue = te.focusNode;
    if (re !== null && ue !== null && !r.isSelectionWithinEditor(H, re, ue))
      return !1;
    z.preventDefault();
    const q = z.clipboardData, G = r.$getSelection();
    if (q === null || G === null)
      return !1;
    const j = h(H), _e = p(H);
    let pe = "";
    return G !== null && (pe = G.getTextContent()), j !== null && q.setData("text/html", j), _e !== null && q.setData("application/x-lexical-editor", _e), q.setData("text/plain", pe), !0;
  }
  return $i.$generateJSONFromSelectedNodes = T, $i.$generateNodesFromSerializedNodes = w, $i.$getHtmlContent = h, $i.$getLexicalContent = p, $i.$insertDataTransferForPlainText = N, $i.$insertDataTransferForRichText = x, $i.$insertGeneratedNodes = v, $i.copyToClipboard = $, $i;
}
var fu, jf;
function Tp() {
  return jf || (jf = 1, fu = process.env.NODE_ENV === "development" ? EN() : CN()), fu;
}
var qf;
function TN() {
  if (qf)
    return hi;
  qf = 1;
  var t = Tp(), e = Ao(), n = rn(), r = Bt();
  function c(q, G) {
    return typeof document.caretRangeFromPoint < "u" ? (q = document.caretRangeFromPoint(q, G), q === null ? null : { node: q.startContainer, offset: q.startOffset }) : document.caretPositionFromPoint !== "undefined" ? (q = document.caretPositionFromPoint(q, G), q === null ? null : { node: q.offsetNode, offset: q.offset }) : null;
  }
  let d = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", h = d && "documentMode" in document ? document.documentMode : null, p = d && "InputEvent" in window && !h ? "getTargetRanges" in new window.InputEvent("input") : !1, N = d && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), x = d && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, v = d && /^(?=.*Chrome).*/i.test(navigator.userAgent), O = d && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !v, M = r.createCommand("DRAG_DROP_PASTE_FILE");
  class A extends r.ElementNode {
    static getType() {
      return "quote";
    }
    static clone(G) {
      return new A(G.__key);
    }
    constructor(G) {
      super(G);
    }
    createDOM(G) {
      let j = document.createElement("blockquote");
      return n.addClassNamesToElement(j, G.theme.quote), j;
    }
    updateDOM() {
      return !1;
    }
    static importDOM() {
      return { blockquote: () => ({ conversion: $, priority: 0 }) };
    }
    exportDOM(G) {
      if ({ element: G } = super.exportDOM(G), G && n.isHTMLElement(G)) {
        this.isEmpty() && G.append(document.createElement("br"));
        var j = this.getFormatType();
        G.style.textAlign = j, (j = this.getDirection()) && (G.dir = j);
      }
      return { element: G };
    }
    static importJSON(G) {
      let j = T();
      return j.setFormat(G.format), j.setIndent(G.indent), j.setDirection(G.direction), j;
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "quote" };
    }
    insertNewAfter(G, j) {
      G = r.$createParagraphNode();
      let _e = this.getDirection();
      return G.setDirection(_e), this.insertAfter(G, j), G;
    }
    collapseAtStart() {
      let G = r.$createParagraphNode();
      return this.getChildren().forEach((j) => G.append(j)), this.replace(G), !0;
    }
  }
  function T() {
    return r.$applyNodeReplacement(new A());
  }
  class w extends r.ElementNode {
    static getType() {
      return "heading";
    }
    static clone(G) {
      return new w(G.__tag, G.__key);
    }
    constructor(G, j) {
      super(j), this.__tag = G;
    }
    getTag() {
      return this.__tag;
    }
    createDOM(G) {
      let j = this.__tag, _e = document.createElement(j);
      return G = G.theme.heading, G !== void 0 && n.addClassNamesToElement(_e, G[j]), _e;
    }
    updateDOM() {
      return !1;
    }
    static importDOM() {
      return { h1: () => ({ conversion: K, priority: 0 }), h2: () => ({ conversion: K, priority: 0 }), h3: () => ({ conversion: K, priority: 0 }), h4: () => ({ conversion: K, priority: 0 }), h5: () => ({
        conversion: K,
        priority: 0
      }), h6: () => ({ conversion: K, priority: 0 }), p: (G) => (G = G.firstChild, G !== null && P(G) ? { conversion: () => ({ node: null }), priority: 3 } : null), span: (G) => P(G) ? { conversion: () => ({ node: W("h1") }), priority: 3 } : null };
    }
    exportDOM(G) {
      if ({ element: G } = super.exportDOM(G), G && n.isHTMLElement(G)) {
        this.isEmpty() && G.append(document.createElement("br"));
        var j = this.getFormatType();
        G.style.textAlign = j, (j = this.getDirection()) && (G.dir = j);
      }
      return { element: G };
    }
    static importJSON(G) {
      let j = W(G.tag);
      return j.setFormat(G.format), j.setIndent(G.indent), j.setDirection(G.direction), j;
    }
    exportJSON() {
      return { ...super.exportJSON(), tag: this.getTag(), type: "heading", version: 1 };
    }
    insertNewAfter(G, j = !0) {
      let _e = G ? G.anchor.offset : 0, pe = _e !== this.getTextContentSize() && G ? W(this.getTag()) : r.$createParagraphNode(), J = this.getDirection();
      return pe.setDirection(J), this.insertAfter(pe, j), _e === 0 && !this.isEmpty() && G && (G = r.$createParagraphNode(), G.select(), this.replace(G, !0)), pe;
    }
    collapseAtStart() {
      let G = this.isEmpty() ? r.$createParagraphNode() : W(this.getTag());
      return this.getChildren().forEach((j) => G.append(j)), this.replace(G), !0;
    }
    extractWithChild() {
      return !0;
    }
  }
  function P(q) {
    return q.nodeName.toLowerCase() === "span" ? q.style.fontSize === "26pt" : !1;
  }
  function K(q) {
    let G = q.nodeName.toLowerCase(), j = null;
    return (G === "h1" || G === "h2" || G === "h3" || G === "h4" || G === "h5" || G === "h6") && (j = W(G), q.style !== null && j.setFormat(q.style.textAlign)), { node: j };
  }
  function $(q) {
    let G = T();
    return q.style !== null && G.setFormat(q.style.textAlign), { node: G };
  }
  function W(q) {
    return r.$applyNodeReplacement(new w(q));
  }
  function H(q, G) {
    q.preventDefault(), G.update(() => {
      let j = r.$getSelection(), _e = q instanceof InputEvent || q instanceof KeyboardEvent ? null : q.clipboardData;
      _e != null && r.$INTERNAL_isPointSelection(j) && t.$insertDataTransferForRichText(_e, j, G);
    }, { tag: "paste" });
  }
  async function z(q, G) {
    await t.copyToClipboard(G, n.objectKlassEquals(q, ClipboardEvent) ? q : null), G.update(() => {
      let j = r.$getSelection();
      r.$isRangeSelection(j) ? j.removeText() : r.$isNodeSelection(j) && j.getNodes().forEach((_e) => _e.remove());
    });
  }
  function te(q) {
    let G = null;
    if (q instanceof DragEvent ? G = q.dataTransfer : q instanceof ClipboardEvent && (G = q.clipboardData), G === null)
      return [!1, [], !1];
    var j = G.types;
    return q = j.includes("Files"), j = j.includes("text/html") || j.includes("text/plain"), [q, Array.from(G.files), j];
  }
  function re(q) {
    var G = r.$getSelection();
    if (!r.$isRangeSelection(G))
      return !1;
    let j = /* @__PURE__ */ new Set();
    G = G.getNodes();
    for (let J = 0; J < G.length; J++) {
      var _e = G[J], pe = _e.getKey();
      j.has(pe) || (_e = n.$getNearestBlockElementAncestorOrThrow(_e), pe = _e.getKey(), _e.canIndent() && !j.has(pe) && (j.add(pe), q(_e)));
    }
    return 0 < j.size;
  }
  function ue(q) {
    return q = r.$getNearestNodeFromDOMNode(q), r.$isDecoratorNode(q);
  }
  return hi.$createHeadingNode = W, hi.$createQuoteNode = T, hi.$isHeadingNode = function(q) {
    return q instanceof w;
  }, hi.$isQuoteNode = function(q) {
    return q instanceof A;
  }, hi.DRAG_DROP_PASTE = M, hi.HeadingNode = w, hi.QuoteNode = A, hi.eventFiles = te, hi.registerRichText = function(q) {
    return n.mergeRegister(
      q.registerCommand(r.CLICK_COMMAND, () => {
        const G = r.$getSelection();
        return r.$isNodeSelection(G) ? (G.clear(), !0) : !1;
      }, 0),
      q.registerCommand(r.DELETE_CHARACTER_COMMAND, (G) => {
        const j = r.$getSelection();
        return r.$isRangeSelection(j) ? (j.deleteCharacter(G), !0) : !1;
      }, r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(r.DELETE_WORD_COMMAND, (G) => {
        const j = r.$getSelection();
        return r.$isRangeSelection(j) ? (j.deleteWord(G), !0) : !1;
      }, r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(r.DELETE_LINE_COMMAND, (G) => {
        const j = r.$getSelection();
        return r.$isRangeSelection(j) ? (j.deleteLine(G), !0) : !1;
      }, r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(r.CONTROLLED_TEXT_INSERTION_COMMAND, (G) => {
        const j = r.$getSelection();
        if (typeof G == "string")
          r.$INTERNAL_isPointSelection(j) && j.insertText(G);
        else {
          if (!r.$INTERNAL_isPointSelection(j))
            return !1;
          const _e = G.dataTransfer;
          _e != null ? t.$insertDataTransferForRichText(_e, j, q) : r.$isRangeSelection(j) && (G = G.data) && j.insertText(G);
        }
        return !0;
      }, r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(r.REMOVE_TEXT_COMMAND, () => {
        const G = r.$getSelection();
        return r.$isRangeSelection(G) ? (G.removeText(), !0) : !1;
      }, r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(r.FORMAT_TEXT_COMMAND, (G) => {
        const j = r.$getSelection();
        return r.$isRangeSelection(j) ? (j.formatText(G), !0) : !1;
      }, r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(r.FORMAT_ELEMENT_COMMAND, (G) => {
        var j = r.$getSelection();
        if (!r.$isRangeSelection(j) && !r.$isNodeSelection(j))
          return !1;
        j = j.getNodes();
        for (const _e of j)
          j = n.$findMatchingParent(
            _e,
            (pe) => r.$isElementNode(pe) && !pe.isInline()
          ), j !== null && j.setFormat(G);
        return !0;
      }, r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(r.INSERT_LINE_BREAK_COMMAND, (G) => {
        const j = r.$getSelection();
        return r.$isRangeSelection(j) ? (j.insertLineBreak(G), !0) : !1;
      }, r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(r.INSERT_PARAGRAPH_COMMAND, () => {
        const G = r.$getSelection();
        return r.$isRangeSelection(G) ? (G.insertParagraph(), !0) : !1;
      }, r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(r.INSERT_TAB_COMMAND, () => (r.$insertNodes([r.$createTabNode()]), !0), r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(r.INDENT_CONTENT_COMMAND, () => re((G) => {
        const j = G.getIndent();
        G.setIndent(j + 1);
      }), r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(r.OUTDENT_CONTENT_COMMAND, () => re((G) => {
        const j = G.getIndent();
        0 < j && G.setIndent(j - 1);
      }), r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(r.KEY_ARROW_UP_COMMAND, (G) => {
        var j = r.$getSelection();
        if (r.$isNodeSelection(j) && !ue(G.target)) {
          if (G = j.getNodes(), 0 < G.length)
            return G[0].selectPrevious(), !0;
        } else if (r.$isRangeSelection(j) && (j = r.$getAdjacentNode(
          j.focus,
          !0
        ), !G.shiftKey && r.$isDecoratorNode(j) && !j.isIsolated() && !j.isInline()))
          return j.selectPrevious(), G.preventDefault(), !0;
        return !1;
      }, r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(r.KEY_ARROW_DOWN_COMMAND, (G) => {
        var j = r.$getSelection();
        if (r.$isNodeSelection(j)) {
          if (G = j.getNodes(), 0 < G.length)
            return G[0].selectNext(0, 0), !0;
        } else if (r.$isRangeSelection(j)) {
          let _e = j.focus;
          if (_e.key === "root" && _e.offset === r.$getRoot().getChildrenSize())
            return G.preventDefault(), !0;
          if (j = r.$getAdjacentNode(j.focus, !1), !G.shiftKey && r.$isDecoratorNode(j) && !j.isIsolated() && !j.isInline())
            return j.selectNext(), G.preventDefault(), !0;
        }
        return !1;
      }, r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(r.KEY_ARROW_LEFT_COMMAND, (G) => {
        const j = r.$getSelection();
        if (r.$isNodeSelection(j)) {
          var _e = j.getNodes();
          if (0 < _e.length)
            return G.preventDefault(), _e[0].selectPrevious(), !0;
        }
        return r.$isRangeSelection(j) && e.$shouldOverrideDefaultCharacterSelection(j, !0) ? (_e = G.shiftKey, G.preventDefault(), e.$moveCharacter(j, _e, !0), !0) : !1;
      }, r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(
        r.KEY_ARROW_RIGHT_COMMAND,
        (G) => {
          const j = r.$getSelection();
          if (r.$isNodeSelection(j) && !ue(G.target)) {
            var _e = j.getNodes();
            if (0 < _e.length)
              return G.preventDefault(), _e[0].selectNext(0, 0), !0;
          }
          return r.$isRangeSelection(j) ? (_e = G.shiftKey, e.$shouldOverrideDefaultCharacterSelection(j, !1) ? (G.preventDefault(), e.$moveCharacter(j, _e, !1), !0) : !1) : !1;
        },
        r.COMMAND_PRIORITY_EDITOR
      ),
      q.registerCommand(r.KEY_BACKSPACE_COMMAND, (G) => {
        if (ue(G.target))
          return !1;
        const j = r.$getSelection();
        if (!r.$isRangeSelection(j))
          return !1;
        G.preventDefault(), { anchor: G } = j;
        const _e = G.getNode();
        return j.isCollapsed() && G.offset === 0 && !r.$isRootNode(_e) && 0 < n.$getNearestBlockElementAncestorOrThrow(_e).getIndent() ? q.dispatchCommand(r.OUTDENT_CONTENT_COMMAND, void 0) : q.dispatchCommand(r.DELETE_CHARACTER_COMMAND, !0);
      }, r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(r.KEY_DELETE_COMMAND, (G) => {
        if (ue(G.target))
          return !1;
        const j = r.$getSelection();
        return r.$isRangeSelection(j) ? (G.preventDefault(), q.dispatchCommand(r.DELETE_CHARACTER_COMMAND, !1)) : !1;
      }, r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(
        r.KEY_ENTER_COMMAND,
        (G) => {
          const j = r.$getSelection();
          if (!r.$isRangeSelection(j))
            return !1;
          if (G !== null) {
            if ((x || N || O) && p)
              return !1;
            if (G.preventDefault(), G.shiftKey)
              return q.dispatchCommand(r.INSERT_LINE_BREAK_COMMAND, !1);
          }
          return q.dispatchCommand(r.INSERT_PARAGRAPH_COMMAND, void 0);
        },
        r.COMMAND_PRIORITY_EDITOR
      ),
      q.registerCommand(r.KEY_ESCAPE_COMMAND, () => {
        const G = r.$getSelection();
        return r.$isRangeSelection(G) ? (q.blur(), !0) : !1;
      }, r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(r.DROP_COMMAND, (G) => {
        const [, j] = te(G);
        if (0 < j.length) {
          var _e = c(G.clientX, G.clientY);
          if (_e !== null) {
            const { offset: J, node: ee } = _e;
            var pe = r.$getNearestNodeFromDOMNode(ee);
            if (pe !== null) {
              if (_e = r.$createRangeSelection(), r.$isTextNode(pe))
                _e.anchor.set(pe.getKey(), J, "text"), _e.focus.set(pe.getKey(), J, "text");
              else {
                const F = pe.getParentOrThrow().getKey();
                pe = pe.getIndexWithinParent() + 1, _e.anchor.set(F, pe, "element"), _e.focus.set(F, pe, "element");
              }
              _e = r.$normalizeSelection__EXPERIMENTAL(_e), r.$setSelection(_e);
            }
            q.dispatchCommand(M, j);
          }
          return G.preventDefault(), !0;
        }
        return G = r.$getSelection(), !!r.$isRangeSelection(G);
      }, r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(r.DRAGSTART_COMMAND, (G) => {
        [G] = te(G);
        const j = r.$getSelection();
        return !(G && !r.$isRangeSelection(j));
      }, r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(r.DRAGOVER_COMMAND, (G) => {
        var [j] = te(G);
        const _e = r.$getSelection();
        return j && !r.$isRangeSelection(_e) ? !1 : (j = c(G.clientX, G.clientY), j !== null && (j = r.$getNearestNodeFromDOMNode(j.node), r.$isDecoratorNode(j) && G.preventDefault()), !0);
      }, r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(r.SELECT_ALL_COMMAND, () => (r.$selectAll(), !0), r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(r.COPY_COMMAND, (G) => (t.copyToClipboard(q, n.objectKlassEquals(G, ClipboardEvent) ? G : null), !0), r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(r.CUT_COMMAND, (G) => (z(G, q), !0), r.COMMAND_PRIORITY_EDITOR),
      q.registerCommand(r.PASTE_COMMAND, (G) => {
        const [, j, _e] = te(G);
        if (0 < j.length && !_e)
          return q.dispatchCommand(M, j), !0;
        if (r.isSelectionCapturedInDecoratorInput(G.target))
          return !1;
        const pe = r.$getSelection();
        return r.$INTERNAL_isPointSelection(pe) ? (H(G, q), !0) : !1;
      }, r.COMMAND_PRIORITY_EDITOR)
    );
  }, hi;
}
var gi = {}, Zf;
function xN() {
  if (Zf)
    return gi;
  Zf = 1;
  var t = Tp(), e = Ao(), n = rn(), r = Bt();
  function c(pe, J) {
    if (typeof document.caretRangeFromPoint < "u") {
      const ee = document.caretRangeFromPoint(pe, J);
      return ee === null ? null : {
        node: ee.startContainer,
        offset: ee.startOffset
      };
    } else if (document.caretPositionFromPoint !== "undefined") {
      const ee = document.caretPositionFromPoint(pe, J);
      return ee === null ? null : {
        node: ee.offsetNode,
        offset: ee.offset
      };
    } else
      return null;
  }
  const d = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", h = d && "documentMode" in document ? document.documentMode : null, p = d && "InputEvent" in window && !h ? "getTargetRanges" in new window.InputEvent("input") : !1, N = d && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), x = d && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, v = d && /^(?=.*Chrome).*/i.test(navigator.userAgent), O = d && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !v, M = r.createCommand("DRAG_DROP_PASTE_FILE");
  class A extends r.ElementNode {
    static getType() {
      return "quote";
    }
    static clone(J) {
      return new A(J.__key);
    }
    constructor(J) {
      super(J);
    }
    // View
    createDOM(J) {
      const ee = document.createElement("blockquote");
      return n.addClassNamesToElement(ee, J.theme.quote), ee;
    }
    updateDOM(J, ee) {
      return !1;
    }
    static importDOM() {
      return {
        blockquote: (J) => ({
          conversion: W,
          priority: 0
        })
      };
    }
    exportDOM(J) {
      const {
        element: ee
      } = super.exportDOM(J);
      if (ee && n.isHTMLElement(ee)) {
        this.isEmpty() && ee.append(document.createElement("br"));
        const F = this.getFormatType();
        ee.style.textAlign = F;
        const D = this.getDirection();
        D && (ee.dir = D);
      }
      return {
        element: ee
      };
    }
    static importJSON(J) {
      const ee = T();
      return ee.setFormat(J.format), ee.setIndent(J.indent), ee.setDirection(J.direction), ee;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "quote"
      };
    }
    // Mutation
    insertNewAfter(J, ee) {
      const F = r.$createParagraphNode(), D = this.getDirection();
      return F.setDirection(D), this.insertAfter(F, ee), F;
    }
    collapseAtStart() {
      const J = r.$createParagraphNode();
      return this.getChildren().forEach((F) => J.append(F)), this.replace(J), !0;
    }
  }
  function T() {
    return r.$applyNodeReplacement(new A());
  }
  function w(pe) {
    return pe instanceof A;
  }
  class P extends r.ElementNode {
    /** @internal */
    static getType() {
      return "heading";
    }
    static clone(J) {
      return new P(J.__tag, J.__key);
    }
    constructor(J, ee) {
      super(ee), this.__tag = J;
    }
    getTag() {
      return this.__tag;
    }
    // View
    createDOM(J) {
      const ee = this.__tag, F = document.createElement(ee), V = J.theme.heading;
      if (V !== void 0) {
        const ne = V[ee];
        n.addClassNamesToElement(F, ne);
      }
      return F;
    }
    updateDOM(J, ee) {
      return !1;
    }
    static importDOM() {
      return {
        h1: (J) => ({
          conversion: $,
          priority: 0
        }),
        h2: (J) => ({
          conversion: $,
          priority: 0
        }),
        h3: (J) => ({
          conversion: $,
          priority: 0
        }),
        h4: (J) => ({
          conversion: $,
          priority: 0
        }),
        h5: (J) => ({
          conversion: $,
          priority: 0
        }),
        h6: (J) => ({
          conversion: $,
          priority: 0
        }),
        p: (J) => {
          const F = J.firstChild;
          return F !== null && K(F) ? {
            conversion: () => ({
              node: null
            }),
            priority: 3
          } : null;
        },
        span: (J) => K(J) ? {
          conversion: (ee) => ({
            node: H("h1")
          }),
          priority: 3
        } : null
      };
    }
    exportDOM(J) {
      const {
        element: ee
      } = super.exportDOM(J);
      if (ee && n.isHTMLElement(ee)) {
        this.isEmpty() && ee.append(document.createElement("br"));
        const F = this.getFormatType();
        ee.style.textAlign = F;
        const D = this.getDirection();
        D && (ee.dir = D);
      }
      return {
        element: ee
      };
    }
    static importJSON(J) {
      const ee = H(J.tag);
      return ee.setFormat(J.format), ee.setIndent(J.indent), ee.setDirection(J.direction), ee;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        tag: this.getTag(),
        type: "heading",
        version: 1
      };
    }
    // Mutation
    insertNewAfter(J, ee = !0) {
      const F = J ? J.anchor.offset : 0, D = F === this.getTextContentSize() || !J ? r.$createParagraphNode() : H(this.getTag()), V = this.getDirection();
      if (D.setDirection(V), this.insertAfter(D, ee), F === 0 && !this.isEmpty() && J) {
        const ne = r.$createParagraphNode();
        ne.select(), this.replace(ne, !0);
      }
      return D;
    }
    collapseAtStart() {
      const J = this.isEmpty() ? r.$createParagraphNode() : H(this.getTag());
      return this.getChildren().forEach((F) => J.append(F)), this.replace(J), !0;
    }
    extractWithChild() {
      return !0;
    }
  }
  function K(pe) {
    return pe.nodeName.toLowerCase() === "span" ? pe.style.fontSize === "26pt" : !1;
  }
  function $(pe) {
    const J = pe.nodeName.toLowerCase();
    let ee = null;
    return (J === "h1" || J === "h2" || J === "h3" || J === "h4" || J === "h5" || J === "h6") && (ee = H(J), pe.style !== null && ee.setFormat(pe.style.textAlign)), {
      node: ee
    };
  }
  function W(pe) {
    const J = T();
    return pe.style !== null && J.setFormat(pe.style.textAlign), {
      node: J
    };
  }
  function H(pe) {
    return r.$applyNodeReplacement(new P(pe));
  }
  function z(pe) {
    return pe instanceof P;
  }
  function te(pe, J) {
    pe.preventDefault(), J.update(() => {
      const ee = r.$getSelection(), F = pe instanceof InputEvent || pe instanceof KeyboardEvent ? null : pe.clipboardData;
      F != null && r.$INTERNAL_isPointSelection(ee) && t.$insertDataTransferForRichText(F, ee, J);
    }, {
      tag: "paste"
    });
  }
  async function re(pe, J) {
    await t.copyToClipboard(J, n.objectKlassEquals(pe, ClipboardEvent) ? pe : null), J.update(() => {
      const ee = r.$getSelection();
      r.$isRangeSelection(ee) ? ee.removeText() : r.$isNodeSelection(ee) && ee.getNodes().forEach((F) => F.remove());
    });
  }
  function ue(pe) {
    let J = null;
    if (pe instanceof DragEvent ? J = pe.dataTransfer : pe instanceof ClipboardEvent && (J = pe.clipboardData), J === null)
      return [!1, [], !1];
    const ee = J.types, F = ee.includes("Files"), D = ee.includes("text/html") || ee.includes("text/plain");
    return [F, Array.from(J.files), D];
  }
  function q(pe) {
    const J = r.$getSelection();
    if (!r.$isRangeSelection(J))
      return !1;
    const ee = /* @__PURE__ */ new Set(), F = J.getNodes();
    for (let D = 0; D < F.length; D++) {
      const V = F[D], ne = V.getKey();
      if (ee.has(ne))
        continue;
      const Y = n.$getNearestBlockElementAncestorOrThrow(V), U = Y.getKey();
      Y.canIndent() && !ee.has(U) && (ee.add(U), pe(Y));
    }
    return ee.size > 0;
  }
  function G(pe) {
    const J = r.$getNearestNodeFromDOMNode(pe);
    return r.$isDecoratorNode(J);
  }
  function j(pe) {
    const J = pe.focus;
    return J.key === "root" && J.offset === r.$getRoot().getChildrenSize();
  }
  function _e(pe) {
    return n.mergeRegister(pe.registerCommand(r.CLICK_COMMAND, (ee) => {
      const F = r.$getSelection();
      return r.$isNodeSelection(F) ? (F.clear(), !0) : !1;
    }, 0), pe.registerCommand(r.DELETE_CHARACTER_COMMAND, (ee) => {
      const F = r.$getSelection();
      return r.$isRangeSelection(F) ? (F.deleteCharacter(ee), !0) : !1;
    }, r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.DELETE_WORD_COMMAND, (ee) => {
      const F = r.$getSelection();
      return r.$isRangeSelection(F) ? (F.deleteWord(ee), !0) : !1;
    }, r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.DELETE_LINE_COMMAND, (ee) => {
      const F = r.$getSelection();
      return r.$isRangeSelection(F) ? (F.deleteLine(ee), !0) : !1;
    }, r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.CONTROLLED_TEXT_INSERTION_COMMAND, (ee) => {
      const F = r.$getSelection();
      if (typeof ee == "string")
        r.$INTERNAL_isPointSelection(F) && F.insertText(ee);
      else {
        if (!r.$INTERNAL_isPointSelection(F))
          return !1;
        const D = ee.dataTransfer;
        if (D != null)
          t.$insertDataTransferForRichText(D, F, pe);
        else if (r.$isRangeSelection(F)) {
          const V = ee.data;
          return V && F.insertText(V), !0;
        }
      }
      return !0;
    }, r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.REMOVE_TEXT_COMMAND, () => {
      const ee = r.$getSelection();
      return r.$isRangeSelection(ee) ? (ee.removeText(), !0) : !1;
    }, r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.FORMAT_TEXT_COMMAND, (ee) => {
      const F = r.$getSelection();
      return r.$isRangeSelection(F) ? (F.formatText(ee), !0) : !1;
    }, r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.FORMAT_ELEMENT_COMMAND, (ee) => {
      const F = r.$getSelection();
      if (!r.$isRangeSelection(F) && !r.$isNodeSelection(F))
        return !1;
      const D = F.getNodes();
      for (const V of D) {
        const ne = n.$findMatchingParent(V, (Y) => r.$isElementNode(Y) && !Y.isInline());
        ne !== null && ne.setFormat(ee);
      }
      return !0;
    }, r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.INSERT_LINE_BREAK_COMMAND, (ee) => {
      const F = r.$getSelection();
      return r.$isRangeSelection(F) ? (F.insertLineBreak(ee), !0) : !1;
    }, r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.INSERT_PARAGRAPH_COMMAND, () => {
      const ee = r.$getSelection();
      return r.$isRangeSelection(ee) ? (ee.insertParagraph(), !0) : !1;
    }, r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.INSERT_TAB_COMMAND, () => (r.$insertNodes([r.$createTabNode()]), !0), r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.INDENT_CONTENT_COMMAND, () => q((ee) => {
      const F = ee.getIndent();
      ee.setIndent(F + 1);
    }), r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.OUTDENT_CONTENT_COMMAND, () => q((ee) => {
      const F = ee.getIndent();
      F > 0 && ee.setIndent(F - 1);
    }), r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.KEY_ARROW_UP_COMMAND, (ee) => {
      const F = r.$getSelection();
      if (r.$isNodeSelection(F) && !G(ee.target)) {
        const D = F.getNodes();
        if (D.length > 0)
          return D[0].selectPrevious(), !0;
      } else if (r.$isRangeSelection(F)) {
        const D = r.$getAdjacentNode(F.focus, !0);
        if (!ee.shiftKey && r.$isDecoratorNode(D) && !D.isIsolated() && !D.isInline())
          return D.selectPrevious(), ee.preventDefault(), !0;
      }
      return !1;
    }, r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.KEY_ARROW_DOWN_COMMAND, (ee) => {
      const F = r.$getSelection();
      if (r.$isNodeSelection(F)) {
        const D = F.getNodes();
        if (D.length > 0)
          return D[0].selectNext(0, 0), !0;
      } else if (r.$isRangeSelection(F)) {
        if (j(F))
          return ee.preventDefault(), !0;
        const D = r.$getAdjacentNode(F.focus, !1);
        if (!ee.shiftKey && r.$isDecoratorNode(D) && !D.isIsolated() && !D.isInline())
          return D.selectNext(), ee.preventDefault(), !0;
      }
      return !1;
    }, r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.KEY_ARROW_LEFT_COMMAND, (ee) => {
      const F = r.$getSelection();
      if (r.$isNodeSelection(F)) {
        const D = F.getNodes();
        if (D.length > 0)
          return ee.preventDefault(), D[0].selectPrevious(), !0;
      }
      if (!r.$isRangeSelection(F))
        return !1;
      if (e.$shouldOverrideDefaultCharacterSelection(F, !0)) {
        const D = ee.shiftKey;
        return ee.preventDefault(), e.$moveCharacter(F, D, !0), !0;
      }
      return !1;
    }, r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.KEY_ARROW_RIGHT_COMMAND, (ee) => {
      const F = r.$getSelection();
      if (r.$isNodeSelection(F) && !G(ee.target)) {
        const V = F.getNodes();
        if (V.length > 0)
          return ee.preventDefault(), V[0].selectNext(0, 0), !0;
      }
      if (!r.$isRangeSelection(F))
        return !1;
      const D = ee.shiftKey;
      return e.$shouldOverrideDefaultCharacterSelection(F, !1) ? (ee.preventDefault(), e.$moveCharacter(F, D, !1), !0) : !1;
    }, r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.KEY_BACKSPACE_COMMAND, (ee) => {
      if (G(ee.target))
        return !1;
      const F = r.$getSelection();
      if (!r.$isRangeSelection(F))
        return !1;
      ee.preventDefault();
      const {
        anchor: D
      } = F, V = D.getNode();
      return F.isCollapsed() && D.offset === 0 && !r.$isRootNode(V) && n.$getNearestBlockElementAncestorOrThrow(V).getIndent() > 0 ? pe.dispatchCommand(r.OUTDENT_CONTENT_COMMAND, void 0) : pe.dispatchCommand(r.DELETE_CHARACTER_COMMAND, !0);
    }, r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.KEY_DELETE_COMMAND, (ee) => {
      if (G(ee.target))
        return !1;
      const F = r.$getSelection();
      return r.$isRangeSelection(F) ? (ee.preventDefault(), pe.dispatchCommand(r.DELETE_CHARACTER_COMMAND, !1)) : !1;
    }, r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.KEY_ENTER_COMMAND, (ee) => {
      const F = r.$getSelection();
      if (!r.$isRangeSelection(F))
        return !1;
      if (ee !== null) {
        if ((x || N || O) && p)
          return !1;
        if (ee.preventDefault(), ee.shiftKey)
          return pe.dispatchCommand(r.INSERT_LINE_BREAK_COMMAND, !1);
      }
      return pe.dispatchCommand(r.INSERT_PARAGRAPH_COMMAND, void 0);
    }, r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.KEY_ESCAPE_COMMAND, () => {
      const ee = r.$getSelection();
      return r.$isRangeSelection(ee) ? (pe.blur(), !0) : !1;
    }, r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.DROP_COMMAND, (ee) => {
      const [, F] = ue(ee);
      if (F.length > 0) {
        const V = ee.clientX, ne = ee.clientY, Y = c(V, ne);
        if (Y !== null) {
          const {
            offset: U,
            node: Q
          } = Y, k = r.$getNearestNodeFromDOMNode(Q);
          if (k !== null) {
            const m = r.$createRangeSelection();
            if (r.$isTextNode(k))
              m.anchor.set(k.getKey(), U, "text"), m.focus.set(k.getKey(), U, "text");
            else {
              const b = k.getParentOrThrow().getKey(), Z = k.getIndexWithinParent() + 1;
              m.anchor.set(b, Z, "element"), m.focus.set(b, Z, "element");
            }
            const y = r.$normalizeSelection__EXPERIMENTAL(m);
            r.$setSelection(y);
          }
          pe.dispatchCommand(M, F);
        }
        return ee.preventDefault(), !0;
      }
      const D = r.$getSelection();
      return !!r.$isRangeSelection(D);
    }, r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.DRAGSTART_COMMAND, (ee) => {
      const [F] = ue(ee), D = r.$getSelection();
      return !(F && !r.$isRangeSelection(D));
    }, r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.DRAGOVER_COMMAND, (ee) => {
      const [F] = ue(ee), D = r.$getSelection();
      if (F && !r.$isRangeSelection(D))
        return !1;
      const V = ee.clientX, ne = ee.clientY, Y = c(V, ne);
      if (Y !== null) {
        const U = r.$getNearestNodeFromDOMNode(Y.node);
        r.$isDecoratorNode(U) && ee.preventDefault();
      }
      return !0;
    }, r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.SELECT_ALL_COMMAND, () => (r.$selectAll(), !0), r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.COPY_COMMAND, (ee) => (t.copyToClipboard(pe, n.objectKlassEquals(ee, ClipboardEvent) ? ee : null), !0), r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.CUT_COMMAND, (ee) => (re(ee, pe), !0), r.COMMAND_PRIORITY_EDITOR), pe.registerCommand(r.PASTE_COMMAND, (ee) => {
      const [, F, D] = ue(ee);
      if (F.length > 0 && !D)
        return pe.dispatchCommand(M, F), !0;
      if (r.isSelectionCapturedInDecoratorInput(ee.target))
        return !1;
      const V = r.$getSelection();
      return r.$INTERNAL_isPointSelection(V) ? (te(ee, pe), !0) : !1;
    }, r.COMMAND_PRIORITY_EDITOR));
  }
  return gi.$createHeadingNode = H, gi.$createQuoteNode = T, gi.$isHeadingNode = z, gi.$isQuoteNode = w, gi.DRAG_DROP_PASTE = M, gi.HeadingNode = P, gi.QuoteNode = A, gi.eventFiles = ue, gi.registerRichText = _e, gi;
}
var hu, Jf;
function fd() {
  return Jf || (Jf = 1, hu = process.env.NODE_ENV === "development" ? xN() : TN()), hu;
}
var Xf;
function vN() {
  if (Xf)
    return tu;
  Xf = 1;
  var t = Yn(), e = yp(), n = dn, r = Np(), c = rn(), d = ep, h = Cp(), p = fd(), N = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? n.useLayoutEffect : n.useEffect;
  function x(T) {
    return T.getEditorState().read(r.$canShowPlaceholderCurry(T.isComposing()));
  }
  function v(T) {
    let [w, P] = n.useState(() => x(T));
    return N(() => {
      function K() {
        let $ = x(T);
        P($);
      }
      return K(), c.mergeRegister(T.registerUpdateListener(() => {
        K();
      }), T.registerEditableListener(() => {
        K();
      }));
    }, [T]), w;
  }
  function O(T, w) {
    let [P, K] = n.useState(() => T.getDecorators());
    return N(() => T.registerDecoratorListener(($) => {
      d.flushSync(() => {
        K($);
      });
    }), [T]), n.useEffect(() => {
      K(T.getDecorators());
    }, [T]), n.useMemo(() => {
      let $ = [], W = Object.keys(P);
      for (let H = 0; H < W.length; H++) {
        let z = W[H], te = n.createElement(w, { onError: (ue) => T._onError(ue) }, n.createElement(n.Suspense, { fallback: null }, P[z])), re = T.getElementByKey(z);
        re !== null && $.push(d.createPortal(te, re, z));
      }
      return $;
    }, [w, P, T]);
  }
  function M(T) {
    N(() => c.mergeRegister(p.registerRichText(T), h.registerDragonSupport(T)), [T]);
  }
  function A({ content: T }) {
    var [w] = t.useLexicalComposerContext();
    w = v(w);
    let P = e();
    return w ? typeof T == "function" ? T(P) : T : null;
  }
  return tu.RichTextPlugin = function({ contentEditable: T, placeholder: w, ErrorBoundary: P }) {
    let [K] = t.useLexicalComposerContext();
    return P = O(K, P), M(K), n.createElement(n.Fragment, null, T, n.createElement(A, { content: w }), P);
  }, tu;
}
var gu = {}, Qf;
function SN() {
  if (Qf)
    return gu;
  Qf = 1;
  var t = Yn(), e = yp(), n = dn, r = Np(), c = rn(), d = ep, h = Cp(), p = fd(), v = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? n.useLayoutEffect : n.useEffect;
  function O(K) {
    return K.getEditorState().read(r.$canShowPlaceholderCurry(K.isComposing()));
  }
  function M(K) {
    const [$, W] = n.useState(() => O(K));
    return v(() => {
      function H() {
        const z = O(K);
        W(z);
      }
      return H(), c.mergeRegister(K.registerUpdateListener(() => {
        H();
      }), K.registerEditableListener(() => {
        H();
      }));
    }, [K]), $;
  }
  function A(K, $) {
    const [W, H] = n.useState(() => K.getDecorators());
    return v(() => K.registerDecoratorListener((z) => {
      d.flushSync(() => {
        H(z);
      });
    }), [K]), n.useEffect(() => {
      H(K.getDecorators());
    }, [K]), n.useMemo(() => {
      const z = [], te = Object.keys(W);
      for (let re = 0; re < te.length; re++) {
        const ue = te[re], q = /* @__PURE__ */ n.createElement($, {
          onError: (j) => K._onError(j)
        }, /* @__PURE__ */ n.createElement(n.Suspense, {
          fallback: null
        }, W[ue])), G = K.getElementByKey(ue);
        G !== null && z.push(/* @__PURE__ */ d.createPortal(q, G, ue));
      }
      return z;
    }, [$, W, K]);
  }
  function T(K) {
    v(() => c.mergeRegister(p.registerRichText(K), h.registerDragonSupport(K)), [K]);
  }
  function w({
    contentEditable: K,
    placeholder: $,
    ErrorBoundary: W
  }) {
    const [H] = t.useLexicalComposerContext(), z = A(H, W);
    return T(H), /* @__PURE__ */ n.createElement(n.Fragment, null, K, /* @__PURE__ */ n.createElement(P, {
      content: $
    }), z);
  }
  function P({
    content: K
  }) {
    const [$] = t.useLexicalComposerContext(), W = M($), H = e();
    return W ? typeof K == "function" ? K(H) : K : null;
  }
  return gu.RichTextPlugin = w, gu;
}
const wN = process.env.NODE_ENV === "development" ? SN() : vN();
var ON = wN, pu = {}, eh;
function DN() {
  if (eh)
    return pu;
  eh = 1;
  var t = Yn(), e = dn;
  function n() {
    return n = Object.assign ? Object.assign.bind() : function(c) {
      for (var d = 1; d < arguments.length; d++) {
        var h = arguments[d], p;
        for (p in h)
          Object.prototype.hasOwnProperty.call(h, p) && (c[p] = h[p]);
      }
      return c;
    }, n.apply(this, arguments);
  }
  var r = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? e.useLayoutEffect : e.useEffect;
  return pu.ContentEditable = function({ ariaActiveDescendant: c, ariaAutoComplete: d, ariaControls: h, ariaDescribedBy: p, ariaExpanded: N, ariaLabel: x, ariaLabelledBy: v, ariaMultiline: O, ariaOwns: M, ariaRequired: A, autoCapitalize: T, className: w, id: P, role: K = "textbox", spellCheck: $ = !0, style: W, tabIndex: H, "data-testid": z, ...te }) {
    let [re] = t.useLexicalComposerContext(), [ue, q] = e.useState(!1), G = e.useCallback((j) => {
      re.setRootElement(j);
    }, [re]);
    return r(() => (q(re.isEditable()), re.registerEditableListener((j) => {
      q(j);
    })), [re]), e.createElement(
      "div",
      n({}, te, { "aria-activedescendant": ue ? c : void 0, "aria-autocomplete": ue ? d : "none", "aria-controls": ue ? h : void 0, "aria-describedby": p, "aria-expanded": ue && K === "combobox" ? !!N : void 0, "aria-label": x, "aria-labelledby": v, "aria-multiline": O, "aria-owns": ue ? M : void 0, "aria-readonly": ue ? void 0 : !0, "aria-required": A, autoCapitalize: T, className: w, contentEditable: ue, "data-testid": z, id: P, ref: G, role: K, spellCheck: $, style: W, tabIndex: H })
    );
  }, pu;
}
var mu = {}, th;
function RN() {
  if (th)
    return mu;
  th = 1;
  var t = Yn(), e = dn;
  function n() {
    return n = Object.assign ? Object.assign.bind() : function(p) {
      for (var N = 1; N < arguments.length; N++) {
        var x = arguments[N];
        for (var v in x)
          Object.prototype.hasOwnProperty.call(x, v) && (p[v] = x[v]);
      }
      return p;
    }, n.apply(this, arguments);
  }
  var d = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? e.useLayoutEffect : e.useEffect;
  function h({
    ariaActiveDescendant: p,
    ariaAutoComplete: N,
    ariaControls: x,
    ariaDescribedBy: v,
    ariaExpanded: O,
    ariaLabel: M,
    ariaLabelledBy: A,
    ariaMultiline: T,
    ariaOwns: w,
    ariaRequired: P,
    autoCapitalize: K,
    className: $,
    id: W,
    role: H = "textbox",
    spellCheck: z = !0,
    style: te,
    tabIndex: re,
    "data-testid": ue,
    ...q
  }) {
    const [G] = t.useLexicalComposerContext(), [j, _e] = e.useState(!1), pe = e.useCallback((J) => {
      G.setRootElement(J);
    }, [G]);
    return d(() => (_e(G.isEditable()), G.registerEditableListener((J) => {
      _e(J);
    })), [G]), /* @__PURE__ */ e.createElement("div", n({}, q, {
      "aria-activedescendant": j ? p : void 0,
      "aria-autocomplete": j ? N : "none",
      "aria-controls": j ? x : void 0,
      "aria-describedby": v,
      "aria-expanded": j && H === "combobox" ? !!O : void 0,
      "aria-label": M,
      "aria-labelledby": A,
      "aria-multiline": T,
      "aria-owns": j ? w : void 0,
      "aria-readonly": j ? void 0 : !0,
      "aria-required": P,
      autoCapitalize: K,
      className: $,
      contentEditable: j,
      "data-testid": ue,
      id: W,
      ref: pe,
      role: H,
      spellCheck: z,
      style: te,
      tabIndex: re
    }));
  }
  return mu.ContentEditable = h, mu;
}
const bN = process.env.NODE_ENV === "development" ? RN() : DN();
var MN = bN, _u, nh;
function AN() {
  if (nh)
    return _u;
  nh = 1;
  var t = dn;
  function e(h, p) {
    return e = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(N, x) {
      return N.__proto__ = x, N;
    }, e(h, p);
  }
  function n(h, p) {
    h.prototype = Object.create(p.prototype), h.prototype.constructor = h, e(h, p);
  }
  function r(h, p) {
    return h === void 0 && (h = []), p === void 0 && (p = []), h.length !== p.length || h.some(function(N, x) {
      return !Object.is(N, p[x]);
    });
  }
  var c = { error: null }, d = function(h) {
    function p() {
      for (var x, v = arguments.length, O = Array(v), M = 0; M < v; M++)
        O[M] = arguments[M];
      return x = h.call.apply(h, [this].concat(O)) || this, x.state = c, x.resetErrorBoundary = function() {
        for (var A, T = arguments.length, w = Array(T), P = 0; P < T; P++)
          w[P] = arguments[P];
        x.props.onReset == null || (A = x.props).onReset.apply(A, w), x.reset();
      }, x;
    }
    n(p, h), p.getDerivedStateFromError = function(x) {
      return { error: x };
    };
    var N = p.prototype;
    return N.reset = function() {
      this.setState(c);
    }, N.componentDidCatch = function(x, v) {
      var O, M;
      (O = (M = this.props).onError) == null || O.call(M, x, v);
    }, N.componentDidUpdate = function(x, v) {
      var O = this.props.resetKeys;
      if (this.state.error !== null && v.error !== null && r(x.resetKeys, O)) {
        var M, A;
        (M = (A = this.props).onResetKeysChange) == null || M.call(A, x.resetKeys, O), this.reset();
      }
    }, N.render = function() {
      var x = this.state.error, v = this.props, O = v.fallbackRender, M = v.FallbackComponent;
      if (v = v.fallback, x !== null) {
        if (x = { error: x, resetErrorBoundary: this.resetErrorBoundary }, t.isValidElement(v))
          return v;
        if (typeof O == "function")
          return O(x);
        if (M)
          return t.createElement(M, x);
        throw Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
      }
      return this.props.children;
    }, p;
  }(t.Component);
  return _u = function({ children: h, onError: p }) {
    return t.createElement(d, { fallback: t.createElement("div", { style: { border: "1px solid #f00", color: "#f00", padding: "8px" } }, "An error was thrown."), onError: p }, h);
  }, _u;
}
var yu, rh;
function kN() {
  if (rh)
    return yu;
  rh = 1;
  var t = dn;
  function e(p, N) {
    return e = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(v, O) {
      return v.__proto__ = O, v;
    }, e(p, N);
  }
  function n(p, N) {
    p.prototype = Object.create(N.prototype), p.prototype.constructor = p, e(p, N);
  }
  var r = function(N, x) {
    return N === void 0 && (N = []), x === void 0 && (x = []), N.length !== x.length || N.some(function(v, O) {
      return !Object.is(v, x[O]);
    });
  }, c = {
    error: null
  }, d = /* @__PURE__ */ function(p) {
    n(N, p);
    function N() {
      for (var v, O = arguments.length, M = new Array(O), A = 0; A < O; A++)
        M[A] = arguments[A];
      return v = p.call.apply(p, [this].concat(M)) || this, v.state = c, v.resetErrorBoundary = function() {
        for (var T, w = arguments.length, P = new Array(w), K = 0; K < w; K++)
          P[K] = arguments[K];
        v.props.onReset == null || (T = v.props).onReset.apply(T, P), v.reset();
      }, v;
    }
    N.getDerivedStateFromError = function(O) {
      return {
        error: O
      };
    };
    var x = N.prototype;
    return x.reset = function() {
      this.setState(c);
    }, x.componentDidCatch = function(O, M) {
      var A, T;
      (A = (T = this.props).onError) == null || A.call(T, O, M);
    }, x.componentDidUpdate = function(O, M) {
      var A = this.state.error, T = this.props.resetKeys;
      if (A !== null && M.error !== null && r(O.resetKeys, T)) {
        var w, P;
        (w = (P = this.props).onResetKeysChange) == null || w.call(P, O.resetKeys, T), this.reset();
      }
    }, x.render = function() {
      var O = this.state.error, M = this.props, A = M.fallbackRender, T = M.FallbackComponent, w = M.fallback;
      if (O !== null) {
        var P = {
          error: O,
          resetErrorBoundary: this.resetErrorBoundary
        };
        if (/* @__PURE__ */ t.isValidElement(w))
          return w;
        if (typeof A == "function")
          return A(P);
        if (T)
          return /* @__PURE__ */ t.createElement(T, P);
        throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
      }
      return this.props.children;
    }, N;
  }(t.Component);
  function h({
    children: p,
    onError: N
  }) {
    return /* @__PURE__ */ t.createElement(d, {
      fallback: /* @__PURE__ */ t.createElement("div", {
        style: {
          border: "1px solid #f00",
          color: "#f00",
          padding: "8px"
        }
      }, "An error was thrown."),
      onError: N
    }, p);
  }
  return yu = h, yu;
}
const LN = process.env.NODE_ENV === "development" ? kN() : AN();
var IN = LN;
const PN = /* @__PURE__ */ sd(IN);
var Nu = {}, ir = {}, ih;
function $N() {
  if (ih)
    return ir;
  ih = 1;
  var t = Bt(), e = rn();
  function n(F) {
    let D = new URLSearchParams();
    D.append("code", F);
    for (let V = 1; V < arguments.length; V++)
      D.append("v", arguments[V]);
    throw Error(`Minified Lexical error #${F}; visit https://lexical.dev/docs/error?${D} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  function r(F) {
    let D = 1;
    for (F = F.getParent(); F != null; ) {
      if (H(F)) {
        if (F = F.getParent(), j(F)) {
          D++, F = F.getParent();
          continue;
        }
        n(40);
      }
      break;
    }
    return D;
  }
  function c(F) {
    F = F.getParent(), j(F) || n(40);
    let D = F;
    for (; D !== null; )
      D = D.getParent(), j(D) && (F = D);
    return F;
  }
  function d(F) {
    let D = [];
    F = F.getChildren().filter(H);
    for (let V = 0; V < F.length; V++) {
      let ne = F[V], Y = ne.getFirstChild();
      j(Y) ? D = D.concat(d(Y)) : D.push(ne);
    }
    return D;
  }
  function h(F) {
    return H(F) && j(F.getFirstChild());
  }
  function p(F) {
    for (; F.getNextSibling() == null && F.getPreviousSibling() == null; ) {
      let D = F.getParent();
      if (D == null || !H(F) && !j(F))
        break;
      F = D;
    }
    F.remove();
  }
  function N(F) {
    return W().append(F);
  }
  function x(F, D) {
    return H(F) && (D.length === 0 || D.length === 1 && F.is(D[0]) && F.getChildrenSize() === 0);
  }
  function v(F, D) {
    F.splice(F.getChildrenSize(), 0, D);
  }
  function O(F, D) {
    if (j(F))
      return F;
    let V = F.getPreviousSibling(), ne = F.getNextSibling(), Y = W();
    return Y.setFormat(F.getFormatType()), Y.setIndent(F.getIndent()), v(Y, F.getChildren()), j(V) && D === V.getListType() ? (V.append(Y), F.remove(), j(ne) && D === ne.getListType() && (v(V, ne.getChildren()), ne.remove()), V) : j(ne) && D === ne.getListType() ? (ne.getFirstChildOrThrow().insertBefore(Y), F.remove(), ne) : (D = G(D), D.append(Y), F.replace(D), A(D), D);
  }
  function M(F, D) {
    var V = F.getLastChild();
    let ne = D.getFirstChild();
    V && ne && h(V) && h(ne) && (M(V.getFirstChild(), ne.getFirstChild()), ne.remove()), V = D.getChildren(), 0 < V.length && (F.append(...V), A(F)), D.remove();
  }
  function A(F, D) {
    if (F = D || F.getChildren(), F !== void 0)
      for (D = 0; D < F.length; D++) {
        let U = F[D];
        if (H(U)) {
          let Q = U.getValue();
          var V = U, ne = V.getParent(), Y = 1;
          for (ne != null && (j(ne) ? Y = ne.getStart() : n(44)), V = V.getPreviousSiblings(), ne = 0; ne < V.length; ne++) {
            let k = V[ne];
            H(k) && !j(k.getFirstChild()) && Y++;
          }
          Q !== Y && U.setValue(Y);
        }
      }
  }
  function T(F) {
    if (!h(F)) {
      var D = F.getParent(), V = D ? D.getParent() : void 0, ne = V ? V.getParent() : void 0;
      if (j(ne) && H(V) && j(D)) {
        var Y = D ? D.getFirstChild() : void 0, U = D ? D.getLastChild() : void 0;
        if (F.is(Y))
          V.insertBefore(F), D.isEmpty() && V.remove();
        else if (F.is(U))
          V.insertAfter(F), D.isEmpty() && V.remove();
        else {
          var Q = D.getListType();
          Y = W();
          let k = G(Q);
          Y.append(k), F.getPreviousSiblings().forEach((m) => k.append(m)), U = W(), Q = G(Q), U.append(Q), v(Q, F.getNextSiblings()), V.insertBefore(Y), V.insertAfter(U), V.replace(F);
        }
        A(D), A(ne);
      }
    }
  }
  class w extends t.ElementNode {
    static getType() {
      return "listitem";
    }
    static clone(D) {
      return new w(D.__value, D.__checked, D.__key);
    }
    constructor(D, V, ne) {
      super(ne), this.__value = D === void 0 ? 1 : D, this.__checked = V;
    }
    createDOM(D) {
      let V = document.createElement("li"), ne = this.getParent();
      return j(ne) && ne.getListType() === "check" && K(V, this, null), V.value = this.__value, P(V, D.theme, this), V;
    }
    updateDOM(D, V, ne) {
      let Y = this.getParent();
      return j(Y) && Y.getListType() === "check" && K(V, this, D), V.value = this.__value, P(V, ne.theme, this), !1;
    }
    static transform() {
      return (D) => {
        let V = D.getParent();
        j(V) && (A(V), V.getListType() !== "check" && D.getChecked() != null && D.setChecked(void 0));
      };
    }
    static importDOM() {
      return { li: () => ({ conversion: $, priority: 0 }) };
    }
    static importJSON(D) {
      let V = W();
      return V.setChecked(D.checked), V.setValue(D.value), V.setFormat(D.format), V.setDirection(D.direction), V;
    }
    exportDOM(D) {
      return D = this.createDOM(D._config), D.style.textAlign = this.getFormatType(), { element: D };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        checked: this.getChecked(),
        type: "listitem",
        value: this.getValue(),
        version: 1
      };
    }
    append(...D) {
      for (let V = 0; V < D.length; V++) {
        let ne = D[V];
        if (t.$isElementNode(ne) && this.canMergeWith(ne)) {
          let Y = ne.getChildren();
          this.append(...Y), ne.remove();
        } else
          super.append(ne);
      }
      return this;
    }
    replace(D, V) {
      if (H(D))
        return super.replace(D);
      this.setIndent(0);
      let ne = this.getParentOrThrow();
      if (!j(ne))
        return D;
      if (ne.__first === this.getKey())
        ne.insertBefore(D);
      else if (ne.__last === this.getKey())
        ne.insertAfter(D);
      else {
        let Y = G(ne.getListType()), U = this.getNextSibling();
        for (; U; ) {
          let Q = U;
          U = U.getNextSibling(), Y.append(Q);
        }
        ne.insertAfter(D), D.insertAfter(Y);
      }
      return V && this.getChildren().forEach((Y) => {
        D.append(Y);
      }), this.remove(), ne.getChildrenSize() === 0 && ne.remove(), D;
    }
    insertAfter(D, V = !0) {
      var ne = this.getParentOrThrow();
      j(ne) || n(39);
      var Y = this.getNextSiblings();
      if (H(D))
        return V = super.insertAfter(D, V), D = D.getParentOrThrow(), j(D) && A(D), V;
      if (j(D)) {
        for (ne = D, D = D.getChildren(), Y = D.length - 1; 0 <= Y; Y--)
          ne = D[Y], this.insertAfter(ne, V);
        return ne;
      }
      if (ne.insertAfter(D, V), Y.length !== 0) {
        let U = G(ne.getListType());
        Y.forEach((Q) => U.append(Q)), D.insertAfter(U, V);
      }
      return D;
    }
    remove(D) {
      let V = this.getPreviousSibling(), ne = this.getNextSibling();
      super.remove(D), V && ne && h(V) && h(ne) ? (M(V.getFirstChild(), ne.getFirstChild()), ne.remove()) : ne && (D = ne.getParent(), j(D) && A(D));
    }
    insertNewAfter(D, V = !0) {
      return D = W(this.__checked == null ? void 0 : !1), this.insertAfter(D, V), D;
    }
    collapseAtStart(D) {
      let V = t.$createParagraphNode();
      this.getChildren().forEach((Q) => V.append(Q));
      var ne = this.getParentOrThrow(), Y = ne.getParentOrThrow();
      let U = H(Y);
      return ne.getChildrenSize() === 1 ? U ? (ne.remove(), Y.select()) : (ne.insertBefore(V), ne.remove(), ne = D.anchor, D = D.focus, Y = V.getKey(), ne.type === "element" && ne.getNode().is(this) && ne.set(Y, ne.offset, "element"), D.type === "element" && D.getNode().is(this) && D.set(Y, D.offset, "element")) : (ne.insertBefore(V), this.remove()), !0;
    }
    getValue() {
      return this.getLatest().__value;
    }
    setValue(D) {
      this.getWritable().__value = D;
    }
    getChecked() {
      return this.getLatest().__checked;
    }
    setChecked(D) {
      this.getWritable().__checked = D;
    }
    toggleChecked() {
      this.setChecked(!this.__checked);
    }
    getIndent() {
      var D = this.getParent();
      if (D === null)
        return this.getLatest().__indent;
      D = D.getParentOrThrow();
      let V = 0;
      for (; H(D); )
        D = D.getParentOrThrow().getParentOrThrow(), V++;
      return V;
    }
    setIndent(D) {
      typeof D == "number" && -1 < D || n(117);
      let V = this.getIndent();
      for (; V !== D; )
        if (V < D) {
          e: {
            var ne = /* @__PURE__ */ new Set();
            if (h(this) || ne.has(this.getKey()))
              break e;
            let k = this.getParent();
            var Y = this.getNextSibling(), U = this.getPreviousSibling();
            if (h(Y) && h(U)) {
              if (U = U.getFirstChild(), j(U)) {
                U.append(this);
                var Q = Y.getFirstChild();
                j(Q) && (Q = Q.getChildren(), v(U, Q), Y.remove(), ne.add(Y.getKey())), A(U);
              }
            } else
              h(Y) ? (Y = Y.getFirstChild(), j(Y) && (ne = Y.getFirstChild(), ne !== null && ne.insertBefore(this), A(Y))) : h(U) ? (Y = U.getFirstChild(), j(Y) && (Y.append(this), A(Y))) : j(k) && (ne = W(), Q = G(k.getListType()), ne.append(Q), Q.append(this), U ? U.insertAfter(ne) : Y ? Y.insertBefore(ne) : k.append(ne), A(Q));
            j(k) && A(k);
          }
          V++;
        } else
          T(this), V--;
      return this;
    }
    insertBefore(D) {
      if (H(D)) {
        let V = this.getParentOrThrow();
        if (j(V)) {
          let ne = this.getNextSiblings();
          A(V, ne);
        }
      }
      return super.insertBefore(D);
    }
    canInsertAfter(D) {
      return H(D);
    }
    canReplaceWith(D) {
      return H(D);
    }
    canMergeWith(D) {
      return t.$isParagraphNode(D) || H(D);
    }
    extractWithChild(D, V) {
      if (!t.$isRangeSelection(V))
        return !1;
      D = V.anchor.getNode();
      let ne = V.focus.getNode();
      return this.isParentOf(D) && this.isParentOf(ne) && this.getTextContent().length === V.getTextContent().length;
    }
    isParentRequired() {
      return !0;
    }
    createParentElementNode() {
      return G("bullet");
    }
  }
  function P(F, D, V) {
    let ne = [], Y = [];
    var U = (D = D.list) ? D.listitem : void 0;
    if (D && D.nested)
      var Q = D.nested.listitem;
    if (U !== void 0 && (U = U.split(" "), ne.push(...U)), D) {
      U = V.getParent(), U = j(U) && U.getListType() === "check";
      let k = V.getChecked();
      U && !k || Y.push(D.listitemUnchecked), U && k || Y.push(D.listitemChecked), U && ne.push(k ? D.listitemChecked : D.listitemUnchecked);
    }
    Q !== void 0 && (Q = Q.split(" "), V.getChildren().some((k) => j(k)) ? ne.push(...Q) : Y.push(...Q)), 0 < Y.length && e.removeClassNamesFromElement(F, ...Y), 0 < ne.length && e.addClassNamesToElement(
      F,
      ...ne
    );
  }
  function K(F, D, V) {
    j(D.getFirstChild()) ? (F.removeAttribute("role"), F.removeAttribute("tabIndex"), F.removeAttribute("aria-checked")) : (F.setAttribute("role", "checkbox"), F.setAttribute("tabIndex", "-1"), V && D.__checked === V.__checked || F.setAttribute("aria-checked", D.getChecked() ? "true" : "false"));
  }
  function $(F) {
    return F = e.isHTMLElement(F) && F.getAttribute("aria-checked") === "true", { node: W(F) };
  }
  function W(F) {
    return t.$applyNodeReplacement(new w(void 0, F));
  }
  function H(F) {
    return F instanceof w;
  }
  class z extends t.ElementNode {
    static getType() {
      return "list";
    }
    static clone(D) {
      return new z(D.__listType || q[D.__tag], D.__start, D.__key);
    }
    constructor(D, V, ne) {
      super(ne), this.__listType = D = q[D] || D, this.__tag = D === "number" ? "ol" : "ul", this.__start = V;
    }
    getTag() {
      return this.__tag;
    }
    setListType(D) {
      let V = this.getWritable();
      V.__listType = D, V.__tag = D === "number" ? "ol" : "ul";
    }
    getListType() {
      return this.__listType;
    }
    getStart() {
      return this.__start;
    }
    createDOM(D) {
      let V = document.createElement(this.__tag);
      return this.__start !== 1 && V.setAttribute(
        "start",
        String(this.__start)
      ), V.__lexicalListType = this.__listType, te(V, D.theme, this), V;
    }
    updateDOM(D, V, ne) {
      return D.__tag !== this.__tag ? !0 : (te(V, ne.theme, this), !1);
    }
    static importDOM() {
      return { ol: () => ({ conversion: ue, priority: 0 }), ul: () => ({ conversion: ue, priority: 0 }) };
    }
    static importJSON(D) {
      let V = G(D.listType, D.start);
      return V.setFormat(D.format), V.setIndent(D.indent), V.setDirection(D.direction), V;
    }
    exportDOM(D) {
      return { element: D } = super.exportDOM(D), D && e.isHTMLElement(D) && (this.__start !== 1 && D.setAttribute("start", String(this.__start)), this.__listType === "check" && D.setAttribute("__lexicalListType", "check")), { element: D };
    }
    exportJSON() {
      return { ...super.exportJSON(), listType: this.getListType(), start: this.getStart(), tag: this.getTag(), type: "list", version: 1 };
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
    append(...D) {
      for (let ne = 0; ne < D.length; ne++) {
        var V = D[ne];
        if (H(V))
          super.append(V);
        else {
          let Y = W();
          j(V) || t.$isElementNode(V) && (V = t.$createTextNode(V.getTextContent())), Y.append(V), super.append(Y);
        }
      }
      return A(this), this;
    }
    extractWithChild(D) {
      return H(D);
    }
  }
  function te(F, D, V) {
    let ne = [], Y = [];
    var U = D.list;
    if (U !== void 0) {
      let k = U[`${V.__tag}Depth`] || [];
      D = r(V) - 1;
      let m = D % k.length;
      var Q = k[m];
      let y = U[V.__tag], b;
      if (U = U.nested, U !== void 0 && U.list && (b = U.list), y !== void 0 && ne.push(y), Q !== void 0)
        for (Q = Q.split(" "), ne.push(...Q), Q = 0; Q < k.length; Q++)
          Q !== m && Y.push(V.__tag + Q);
      b !== void 0 && (V = b.split(" "), 1 < D ? ne.push(...V) : Y.push(...V));
    }
    0 < Y.length && e.removeClassNamesFromElement(F, ...Y), 0 < ne.length && e.addClassNamesToElement(F, ...ne);
  }
  function re(F) {
    let D = [];
    for (let ne = 0; ne < F.length; ne++) {
      var V = F[ne];
      H(V) ? (D.push(V), V = V.getChildren(), 1 < V.length && V.forEach((Y) => {
        j(Y) && D.push(N(Y));
      })) : D.push(N(V));
    }
    return D;
  }
  function ue(F) {
    let D = F.nodeName.toLowerCase(), V = null;
    return D === "ol" ? V = G("number", F.start) : D === "ul" && (V = e.isHTMLElement(F) && F.getAttribute("__lexicallisttype") === "check" ? G("check") : G("bullet")), { after: re, node: V };
  }
  let q = { ol: "number", ul: "bullet" };
  function G(F, D = 1) {
    return t.$applyNodeReplacement(new z(F, D));
  }
  function j(F) {
    return F instanceof z;
  }
  let _e = t.createCommand("INSERT_UNORDERED_LIST_COMMAND"), pe = t.createCommand("INSERT_ORDERED_LIST_COMMAND"), J = t.createCommand("INSERT_CHECK_LIST_COMMAND"), ee = t.createCommand("REMOVE_LIST_COMMAND");
  return ir.$createListItemNode = W, ir.$createListNode = G, ir.$getListDepth = r, ir.$handleListInsertParagraph = function() {
    var F = t.$getSelection();
    if (!t.$isRangeSelection(F) || !F.isCollapsed() || (F = F.anchor.getNode(), !H(F) || F.getChildrenSize() !== 0))
      return !1;
    var D = c(F), V = F.getParent();
    j(V) || n(40);
    let ne = V.getParent(), Y;
    if (t.$isRootOrShadowRoot(ne))
      Y = t.$createParagraphNode(), D.insertAfter(Y);
    else if (H(ne))
      Y = W(), ne.insertAfter(Y);
    else
      return !1;
    if (Y.select(), D = F.getNextSiblings(), 0 < D.length) {
      let U = G(V.getListType());
      t.$isParagraphNode(Y) ? Y.insertAfter(U) : (V = W(), V.append(U), Y.insertAfter(V)), D.forEach((Q) => {
        Q.remove(), U.append(Q);
      });
    }
    return p(F), !0;
  }, ir.$isListItemNode = H, ir.$isListNode = j, ir.INSERT_CHECK_LIST_COMMAND = J, ir.INSERT_ORDERED_LIST_COMMAND = pe, ir.INSERT_UNORDERED_LIST_COMMAND = _e, ir.ListItemNode = w, ir.ListNode = z, ir.REMOVE_LIST_COMMAND = ee, ir.insertList = function(F, D) {
    F.update(() => {
      var V = t.$getSelection();
      if (t.$INTERNAL_isPointSelection(V)) {
        var ne = V.getNodes();
        V = V.anchor.getNode();
        var Y = V.getParent();
        if (x(V, ne))
          ne = G(D), t.$isRootOrShadowRoot(Y) ? (V.replace(ne), Y = W(), t.$isElementNode(V) && (Y.setFormat(V.getFormatType()), Y.setIndent(V.getIndent())), ne.append(Y)) : H(V) && (V = V.getParentOrThrow(), v(ne, V.getChildren()), V.replace(ne));
        else
          for (V = /* @__PURE__ */ new Set(), Y = 0; Y < ne.length; Y++) {
            var U = ne[Y];
            if (t.$isElementNode(U) && U.isEmpty() && !H(U) && !V.has(U.getKey()))
              O(
                U,
                D
              );
            else if (t.$isLeafNode(U))
              for (U = U.getParent(); U != null; ) {
                let k = U.getKey();
                if (j(U)) {
                  if (!V.has(k)) {
                    var Q = G(D);
                    v(Q, U.getChildren()), U.replace(Q), A(Q), V.add(k);
                  }
                  break;
                } else {
                  if (Q = U.getParent(), t.$isRootOrShadowRoot(Q) && !V.has(k)) {
                    V.add(k), O(U, D);
                    break;
                  }
                  U = Q;
                }
              }
          }
      }
    });
  }, ir.removeList = function(F) {
    F.update(() => {
      let D = t.$getSelection();
      if (t.$isRangeSelection(D)) {
        var V = /* @__PURE__ */ new Set(), ne = D.getNodes(), Y = D.anchor.getNode();
        if (x(Y, ne))
          V.add(c(Y));
        else
          for (Y = 0; Y < ne.length; Y++) {
            var U = ne[Y];
            t.$isLeafNode(U) && (U = e.$getNearestNodeOfType(U, w), U != null && V.add(c(U)));
          }
        for (let Q of V) {
          V = Q, ne = d(Q);
          for (let k of ne)
            ne = t.$createParagraphNode(), v(ne, k.getChildren()), V.insertAfter(ne), V = ne, k.__key === D.anchor.key && D.anchor.set(ne.getKey(), 0, "element"), k.__key === D.focus.key && D.focus.set(ne.getKey(), 0, "element"), k.remove();
          Q.remove();
        }
      }
    });
  }, ir;
}
var or = {}, oh;
function FN() {
  if (oh)
    return or;
  oh = 1;
  var t = Bt(), e = rn();
  function n(Y) {
    let U = 1, Q = Y.getParent();
    for (; Q != null; ) {
      if (ue(Q)) {
        const k = Q.getParent();
        if (ee(k)) {
          U++, Q = k.getParent();
          continue;
        }
        throw Error("A ListItemNode must have a ListNode for a parent.");
      }
      return U;
    }
    return U;
  }
  function r(Y) {
    let U = Y.getParent();
    if (!ee(U))
      throw Error("A ListItemNode must have a ListNode for a parent.");
    let Q = U;
    for (; Q !== null; )
      Q = Q.getParent(), ee(Q) && (U = Q);
    return U;
  }
  function c(Y) {
    let U = [];
    const Q = Y.getChildren().filter(ue);
    for (let k = 0; k < Q.length; k++) {
      const m = Q[k], y = m.getFirstChild();
      ee(y) ? U = U.concat(c(y)) : U.push(m);
    }
    return U;
  }
  function d(Y) {
    return ue(Y) && ee(Y.getFirstChild());
  }
  function h(Y) {
    let U = Y;
    for (; U.getNextSibling() == null && U.getPreviousSibling() == null; ) {
      const Q = U.getParent();
      if (Q == null || !(ue(U) || ee(U)))
        break;
      U = Q;
    }
    U.remove();
  }
  function p(Y) {
    return re().append(Y);
  }
  function N(Y, U) {
    return ue(Y) && (U.length === 0 || U.length === 1 && Y.is(U[0]) && Y.getChildrenSize() === 0);
  }
  function x(Y) {
    const U = Y.getParent();
    let Q = 1;
    if (U != null)
      if (ee(U))
        Q = U.getStart();
      else
        throw Error("$getListItemValue: list node is not parent of list item node");
    const k = Y.getPreviousSiblings();
    for (let m = 0; m < k.length; m++) {
      const y = k[m];
      ue(y) && !ee(y.getFirstChild()) && Q++;
    }
    return Q;
  }
  function v(Y, U) {
    Y.update(() => {
      const Q = t.$getSelection();
      if (t.$INTERNAL_isPointSelection(Q)) {
        const k = Q.getNodes(), y = Q.anchor.getNode(), b = y.getParent();
        if (N(y, k)) {
          const Z = J(U);
          if (t.$isRootOrShadowRoot(b)) {
            y.replace(Z);
            const ce = re();
            t.$isElementNode(y) && (ce.setFormat(y.getFormatType()), ce.setIndent(y.getIndent())), Z.append(ce);
          } else if (ue(y)) {
            const ce = y.getParentOrThrow();
            O(Z, ce.getChildren()), ce.replace(Z);
          }
          return;
        } else {
          const Z = /* @__PURE__ */ new Set();
          for (let ce = 0; ce < k.length; ce++) {
            const ge = k[ce];
            if (t.$isElementNode(ge) && ge.isEmpty() && !ue(ge) && !Z.has(ge.getKey())) {
              M(ge, U);
              continue;
            }
            if (t.$isLeafNode(ge)) {
              let ae = ge.getParent();
              for (; ae != null; ) {
                const Te = ae.getKey();
                if (ee(ae)) {
                  if (!Z.has(Te)) {
                    const Ae = J(U);
                    O(Ae, ae.getChildren()), ae.replace(Ae), w(Ae), Z.add(Te);
                  }
                  break;
                } else {
                  const Ae = ae.getParent();
                  if (t.$isRootOrShadowRoot(Ae) && !Z.has(Te)) {
                    Z.add(Te), M(ae, U);
                    break;
                  }
                  ae = Ae;
                }
              }
            }
          }
        }
      }
    });
  }
  function O(Y, U) {
    Y.splice(Y.getChildrenSize(), 0, U);
  }
  function M(Y, U) {
    if (ee(Y))
      return Y;
    const Q = Y.getPreviousSibling(), k = Y.getNextSibling(), m = re();
    if (m.setFormat(Y.getFormatType()), m.setIndent(Y.getIndent()), O(m, Y.getChildren()), ee(Q) && U === Q.getListType())
      return Q.append(m), Y.remove(), ee(k) && U === k.getListType() && (O(Q, k.getChildren()), k.remove()), Q;
    if (ee(k) && U === k.getListType())
      return k.getFirstChildOrThrow().insertBefore(m), Y.remove(), k;
    {
      const y = J(U);
      return y.append(m), Y.replace(y), w(y), y;
    }
  }
  function A(Y, U) {
    const Q = Y.getLastChild(), k = U.getFirstChild();
    Q && k && d(Q) && d(k) && (A(Q.getFirstChild(), k.getFirstChild()), k.remove());
    const m = U.getChildren();
    m.length > 0 && (Y.append(...m), w(Y)), U.remove();
  }
  function T(Y) {
    Y.update(() => {
      const U = t.$getSelection();
      if (t.$isRangeSelection(U)) {
        const Q = /* @__PURE__ */ new Set(), k = U.getNodes(), m = U.anchor.getNode();
        if (N(m, k))
          Q.add(r(m));
        else
          for (let y = 0; y < k.length; y++) {
            const b = k[y];
            if (t.$isLeafNode(b)) {
              const Z = e.$getNearestNodeOfType(b, W);
              Z != null && Q.add(r(Z));
            }
          }
        for (const y of Q) {
          let b = y;
          const Z = c(y);
          for (const ce of Z) {
            const ge = t.$createParagraphNode();
            O(ge, ce.getChildren()), b.insertAfter(ge), b = ge, ce.__key === U.anchor.key && U.anchor.set(ge.getKey(), 0, "element"), ce.__key === U.focus.key && U.focus.set(ge.getKey(), 0, "element"), ce.remove();
          }
          y.remove();
        }
      }
    });
  }
  function w(Y, U) {
    const Q = U || Y.getChildren();
    if (Q !== void 0)
      for (let k = 0; k < Q.length; k++) {
        const m = Q[k];
        if (ue(m)) {
          const y = m.getValue(), b = x(m);
          y !== b && m.setValue(b);
        }
      }
  }
  function P(Y) {
    const U = /* @__PURE__ */ new Set();
    if (d(Y) || U.has(Y.getKey()))
      return;
    const Q = Y.getParent(), k = Y.getNextSibling(), m = Y.getPreviousSibling();
    if (d(k) && d(m)) {
      const y = m.getFirstChild();
      if (ee(y)) {
        y.append(Y);
        const b = k.getFirstChild();
        if (ee(b)) {
          const Z = b.getChildren();
          O(y, Z), k.remove(), U.add(k.getKey());
        }
        w(y);
      }
    } else if (d(k)) {
      const y = k.getFirstChild();
      if (ee(y)) {
        const b = y.getFirstChild();
        b !== null && b.insertBefore(Y), w(y);
      }
    } else if (d(m)) {
      const y = m.getFirstChild();
      ee(y) && (y.append(Y), w(y));
    } else if (ee(Q)) {
      const y = re(), b = J(Q.getListType());
      y.append(b), b.append(Y), m ? m.insertAfter(y) : k ? k.insertBefore(y) : Q.append(y), w(b);
    }
    ee(Q) && w(Q);
  }
  function K(Y) {
    if (d(Y))
      return;
    const U = Y.getParent(), Q = U ? U.getParent() : void 0, k = Q ? Q.getParent() : void 0;
    if (ee(k) && ue(Q) && ee(U)) {
      const m = U ? U.getFirstChild() : void 0, y = U ? U.getLastChild() : void 0;
      if (Y.is(m))
        Q.insertBefore(Y), U.isEmpty() && Q.remove();
      else if (Y.is(y))
        Q.insertAfter(Y), U.isEmpty() && Q.remove();
      else {
        const b = U.getListType(), Z = re(), ce = J(b);
        Z.append(ce), Y.getPreviousSiblings().forEach((Te) => ce.append(Te));
        const ge = re(), ae = J(b);
        ge.append(ae), O(ae, Y.getNextSiblings()), Q.insertBefore(Z), Q.insertAfter(ge), Q.replace(Y);
      }
      w(U), w(k);
    }
  }
  function $() {
    const Y = t.$getSelection();
    if (!t.$isRangeSelection(Y) || !Y.isCollapsed())
      return !1;
    const U = Y.anchor.getNode();
    if (!ue(U) || U.getChildrenSize() !== 0)
      return !1;
    const Q = r(U), k = U.getParent();
    if (!ee(k))
      throw Error("A ListItemNode must have a ListNode for a parent.");
    const m = k.getParent();
    let y;
    if (t.$isRootOrShadowRoot(m))
      y = t.$createParagraphNode(), Q.insertAfter(y);
    else if (ue(m))
      y = re(), m.insertAfter(y);
    else
      return !1;
    y.select();
    const b = U.getNextSiblings();
    if (b.length > 0) {
      const Z = J(k.getListType());
      if (t.$isParagraphNode(y))
        y.insertAfter(Z);
      else {
        const ce = re();
        ce.append(Z), y.insertAfter(ce);
      }
      b.forEach((ce) => {
        ce.remove(), Z.append(ce);
      });
    }
    return h(U), !0;
  }
  class W extends t.ElementNode {
    /** @internal */
    /** @internal */
    static getType() {
      return "listitem";
    }
    static clone(U) {
      return new W(U.__value, U.__checked, U.__key);
    }
    constructor(U, Q, k) {
      super(k), this.__value = U === void 0 ? 1 : U, this.__checked = Q;
    }
    createDOM(U) {
      const Q = document.createElement("li"), k = this.getParent();
      return ee(k) && k.getListType() === "check" && z(Q, this, null), Q.value = this.__value, H(Q, U.theme, this), Q;
    }
    updateDOM(U, Q, k) {
      const m = this.getParent();
      return ee(m) && m.getListType() === "check" && z(Q, this, U), Q.value = this.__value, H(Q, k.theme, this), !1;
    }
    static transform() {
      return (U) => {
        const Q = U.getParent();
        ee(Q) && (w(Q), Q.getListType() !== "check" && U.getChecked() != null && U.setChecked(void 0));
      };
    }
    static importDOM() {
      return {
        li: (U) => ({
          conversion: te,
          priority: 0
        })
      };
    }
    static importJSON(U) {
      const Q = re();
      return Q.setChecked(U.checked), Q.setValue(U.value), Q.setFormat(U.format), Q.setDirection(U.direction), Q;
    }
    exportDOM(U) {
      const Q = this.createDOM(U._config);
      return Q.style.textAlign = this.getFormatType(), {
        element: Q
      };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        checked: this.getChecked(),
        type: "listitem",
        value: this.getValue(),
        version: 1
      };
    }
    append(...U) {
      for (let Q = 0; Q < U.length; Q++) {
        const k = U[Q];
        if (t.$isElementNode(k) && this.canMergeWith(k)) {
          const m = k.getChildren();
          this.append(...m), k.remove();
        } else
          super.append(k);
      }
      return this;
    }
    replace(U, Q) {
      if (ue(U))
        return super.replace(U);
      this.setIndent(0);
      const k = this.getParentOrThrow();
      if (!ee(k))
        return U;
      if (k.__first === this.getKey())
        k.insertBefore(U);
      else if (k.__last === this.getKey())
        k.insertAfter(U);
      else {
        const m = J(k.getListType());
        let y = this.getNextSibling();
        for (; y; ) {
          const b = y;
          y = y.getNextSibling(), m.append(b);
        }
        k.insertAfter(U), U.insertAfter(m);
      }
      return Q && this.getChildren().forEach((m) => {
        U.append(m);
      }), this.remove(), k.getChildrenSize() === 0 && k.remove(), U;
    }
    insertAfter(U, Q = !0) {
      const k = this.getParentOrThrow();
      if (!ee(k))
        throw Error("insertAfter: list node is not parent of list item node");
      const m = this.getNextSiblings();
      if (ue(U)) {
        const y = super.insertAfter(U, Q), b = U.getParentOrThrow();
        return ee(b) && w(b), y;
      }
      if (ee(U)) {
        let y = U;
        const b = U.getChildren();
        for (let Z = b.length - 1; Z >= 0; Z--)
          y = b[Z], this.insertAfter(y, Q);
        return y;
      }
      if (k.insertAfter(U, Q), m.length !== 0) {
        const y = J(k.getListType());
        m.forEach((b) => y.append(b)), U.insertAfter(y, Q);
      }
      return U;
    }
    remove(U) {
      const Q = this.getPreviousSibling(), k = this.getNextSibling();
      if (super.remove(U), Q && k && d(Q) && d(k))
        A(Q.getFirstChild(), k.getFirstChild()), k.remove();
      else if (k) {
        const m = k.getParent();
        ee(m) && w(m);
      }
    }
    insertNewAfter(U, Q = !0) {
      const k = re(this.__checked == null ? void 0 : !1);
      return this.insertAfter(k, Q), k;
    }
    collapseAtStart(U) {
      const Q = t.$createParagraphNode();
      this.getChildren().forEach((Z) => Q.append(Z));
      const m = this.getParentOrThrow(), y = m.getParentOrThrow(), b = ue(y);
      if (m.getChildrenSize() === 1)
        if (b)
          m.remove(), y.select();
        else {
          m.insertBefore(Q), m.remove();
          const Z = U.anchor, ce = U.focus, ge = Q.getKey();
          Z.type === "element" && Z.getNode().is(this) && Z.set(ge, Z.offset, "element"), ce.type === "element" && ce.getNode().is(this) && ce.set(ge, ce.offset, "element");
        }
      else
        m.insertBefore(Q), this.remove();
      return !0;
    }
    getValue() {
      return this.getLatest().__value;
    }
    setValue(U) {
      const Q = this.getWritable();
      Q.__value = U;
    }
    getChecked() {
      return this.getLatest().__checked;
    }
    setChecked(U) {
      const Q = this.getWritable();
      Q.__checked = U;
    }
    toggleChecked() {
      this.setChecked(!this.__checked);
    }
    getIndent() {
      const U = this.getParent();
      if (U === null)
        return this.getLatest().__indent;
      let Q = U.getParentOrThrow(), k = 0;
      for (; ue(Q); )
        Q = Q.getParentOrThrow().getParentOrThrow(), k++;
      return k;
    }
    setIndent(U) {
      if (!(typeof U == "number" && U > -1))
        throw Error("Invalid indent value.");
      let Q = this.getIndent();
      for (; Q !== U; )
        Q < U ? (P(this), Q++) : (K(this), Q--);
      return this;
    }
    insertBefore(U) {
      if (ue(U)) {
        const Q = this.getParentOrThrow();
        if (ee(Q)) {
          const k = this.getNextSiblings();
          w(Q, k);
        }
      }
      return super.insertBefore(U);
    }
    canInsertAfter(U) {
      return ue(U);
    }
    canReplaceWith(U) {
      return ue(U);
    }
    canMergeWith(U) {
      return t.$isParagraphNode(U) || ue(U);
    }
    extractWithChild(U, Q) {
      if (!t.$isRangeSelection(Q))
        return !1;
      const k = Q.anchor.getNode(), m = Q.focus.getNode();
      return this.isParentOf(k) && this.isParentOf(m) && this.getTextContent().length === Q.getTextContent().length;
    }
    isParentRequired() {
      return !0;
    }
    createParentElementNode() {
      return J("bullet");
    }
  }
  function H(Y, U, Q) {
    const k = [], m = [], y = U.list, b = y ? y.listitem : void 0;
    let Z;
    if (y && y.nested && (Z = y.nested.listitem), b !== void 0) {
      const ce = b.split(" ");
      k.push(...ce);
    }
    if (y) {
      const ce = Q.getParent(), ge = ee(ce) && ce.getListType() === "check", ae = Q.getChecked();
      (!ge || ae) && m.push(y.listitemUnchecked), (!ge || !ae) && m.push(y.listitemChecked), ge && k.push(ae ? y.listitemChecked : y.listitemUnchecked);
    }
    if (Z !== void 0) {
      const ce = Z.split(" ");
      Q.getChildren().some((ge) => ee(ge)) ? k.push(...ce) : m.push(...ce);
    }
    m.length > 0 && e.removeClassNamesFromElement(Y, ...m), k.length > 0 && e.addClassNamesToElement(Y, ...k);
  }
  function z(Y, U, Q, k) {
    ee(U.getFirstChild()) ? (Y.removeAttribute("role"), Y.removeAttribute("tabIndex"), Y.removeAttribute("aria-checked")) : (Y.setAttribute("role", "checkbox"), Y.setAttribute("tabIndex", "-1"), (!Q || U.__checked !== Q.__checked) && Y.setAttribute("aria-checked", U.getChecked() ? "true" : "false"));
  }
  function te(Y) {
    const U = e.isHTMLElement(Y) && Y.getAttribute("aria-checked") === "true";
    return {
      node: re(U)
    };
  }
  function re(Y) {
    return t.$applyNodeReplacement(new W(void 0, Y));
  }
  function ue(Y) {
    return Y instanceof W;
  }
  class q extends t.ElementNode {
    /** @internal */
    /** @internal */
    /** @internal */
    static getType() {
      return "list";
    }
    static clone(U) {
      const Q = U.__listType || pe[U.__tag];
      return new q(Q, U.__start, U.__key);
    }
    constructor(U, Q, k) {
      super(k);
      const m = pe[U] || U;
      this.__listType = m, this.__tag = m === "number" ? "ol" : "ul", this.__start = Q;
    }
    getTag() {
      return this.__tag;
    }
    setListType(U) {
      const Q = this.getWritable();
      Q.__listType = U, Q.__tag = U === "number" ? "ol" : "ul";
    }
    getListType() {
      return this.__listType;
    }
    getStart() {
      return this.__start;
    }
    // View
    createDOM(U, Q) {
      const k = this.__tag, m = document.createElement(k);
      return this.__start !== 1 && m.setAttribute("start", String(this.__start)), m.__lexicalListType = this.__listType, G(m, U.theme, this), m;
    }
    updateDOM(U, Q, k) {
      return U.__tag !== this.__tag ? !0 : (G(Q, k.theme, this), !1);
    }
    static importDOM() {
      return {
        ol: (U) => ({
          conversion: _e,
          priority: 0
        }),
        ul: (U) => ({
          conversion: _e,
          priority: 0
        })
      };
    }
    static importJSON(U) {
      const Q = J(U.listType, U.start);
      return Q.setFormat(U.format), Q.setIndent(U.indent), Q.setDirection(U.direction), Q;
    }
    exportDOM(U) {
      const {
        element: Q
      } = super.exportDOM(U);
      return Q && e.isHTMLElement(Q) && (this.__start !== 1 && Q.setAttribute("start", String(this.__start)), this.__listType === "check" && Q.setAttribute("__lexicalListType", "check")), {
        element: Q
      };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        listType: this.getListType(),
        start: this.getStart(),
        tag: this.getTag(),
        type: "list",
        version: 1
      };
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
    append(...U) {
      for (let Q = 0; Q < U.length; Q++) {
        const k = U[Q];
        if (ue(k))
          super.append(k);
        else {
          const m = re();
          if (ee(k))
            m.append(k);
          else if (t.$isElementNode(k)) {
            const y = t.$createTextNode(k.getTextContent());
            m.append(y);
          } else
            m.append(k);
          super.append(m);
        }
      }
      return w(this), this;
    }
    extractWithChild(U) {
      return ue(U);
    }
  }
  function G(Y, U, Q) {
    const k = [], m = [], y = U.list;
    if (y !== void 0) {
      const b = y[`${Q.__tag}Depth`] || [], Z = n(Q) - 1, ce = Z % b.length, ge = b[ce], ae = y[Q.__tag];
      let Te;
      const Ae = y.nested;
      if (Ae !== void 0 && Ae.list && (Te = Ae.list), ae !== void 0 && k.push(ae), ge !== void 0) {
        const ze = ge.split(" ");
        k.push(...ze);
        for (let oe = 0; oe < b.length; oe++)
          oe !== ce && m.push(Q.__tag + oe);
      }
      if (Te !== void 0) {
        const ze = Te.split(" ");
        Z > 1 ? k.push(...ze) : m.push(...ze);
      }
    }
    m.length > 0 && e.removeClassNamesFromElement(Y, ...m), k.length > 0 && e.addClassNamesToElement(Y, ...k);
  }
  function j(Y) {
    const U = [];
    for (let Q = 0; Q < Y.length; Q++) {
      const k = Y[Q];
      if (ue(k)) {
        U.push(k);
        const m = k.getChildren();
        m.length > 1 && m.forEach((y) => {
          ee(y) && U.push(p(y));
        });
      } else
        U.push(p(k));
    }
    return U;
  }
  function _e(Y) {
    const U = Y.nodeName.toLowerCase();
    let Q = null;
    if (U === "ol") {
      const k = Y.start;
      Q = J("number", k);
    } else
      U === "ul" && (e.isHTMLElement(Y) && Y.getAttribute("__lexicallisttype") === "check" ? Q = J("check") : Q = J("bullet"));
    return {
      after: j,
      node: Q
    };
  }
  const pe = {
    ol: "number",
    ul: "bullet"
  };
  function J(Y, U = 1) {
    return t.$applyNodeReplacement(new q(Y, U));
  }
  function ee(Y) {
    return Y instanceof q;
  }
  const F = t.createCommand("INSERT_UNORDERED_LIST_COMMAND"), D = t.createCommand("INSERT_ORDERED_LIST_COMMAND"), V = t.createCommand("INSERT_CHECK_LIST_COMMAND"), ne = t.createCommand("REMOVE_LIST_COMMAND");
  return or.$createListItemNode = re, or.$createListNode = J, or.$getListDepth = n, or.$handleListInsertParagraph = $, or.$isListItemNode = ue, or.$isListNode = ee, or.INSERT_CHECK_LIST_COMMAND = V, or.INSERT_ORDERED_LIST_COMMAND = D, or.INSERT_UNORDERED_LIST_COMMAND = F, or.ListItemNode = W, or.ListNode = q, or.REMOVE_LIST_COMMAND = ne, or.insertList = v, or.removeList = T, or;
}
var Cu, sh;
function hd() {
  return sh || (sh = 1, Cu = process.env.NODE_ENV === "development" ? FN() : $N()), Cu;
}
var lh;
function BN() {
  if (lh)
    return Nu;
  lh = 1;
  var t = hd(), e = Yn(), n = dn, r = rn(), c = Bt();
  function d(h) {
    n.useEffect(() => r.mergeRegister(h.registerCommand(t.INSERT_ORDERED_LIST_COMMAND, () => (t.insertList(h, "number"), !0), c.COMMAND_PRIORITY_LOW), h.registerCommand(t.INSERT_UNORDERED_LIST_COMMAND, () => (t.insertList(h, "bullet"), !0), c.COMMAND_PRIORITY_LOW), h.registerCommand(t.REMOVE_LIST_COMMAND, () => (t.removeList(h), !0), c.COMMAND_PRIORITY_LOW), h.registerCommand(c.INSERT_PARAGRAPH_COMMAND, () => !!t.$handleListInsertParagraph(), c.COMMAND_PRIORITY_LOW)), [h]);
  }
  return Nu.ListPlugin = function() {
    let [h] = e.useLexicalComposerContext();
    return n.useEffect(() => {
      if (!h.hasNodes([t.ListNode, t.ListItemNode]))
        throw Error("ListPlugin: ListNode and/or ListItemNode not registered on editor");
    }, [h]), d(h), null;
  }, Nu;
}
var Eu = {}, ah;
function HN() {
  if (ah)
    return Eu;
  ah = 1;
  var t = hd(), e = Yn(), n = dn, r = rn(), c = Bt();
  function d(p) {
    n.useEffect(() => r.mergeRegister(p.registerCommand(t.INSERT_ORDERED_LIST_COMMAND, () => (t.insertList(p, "number"), !0), c.COMMAND_PRIORITY_LOW), p.registerCommand(t.INSERT_UNORDERED_LIST_COMMAND, () => (t.insertList(p, "bullet"), !0), c.COMMAND_PRIORITY_LOW), p.registerCommand(t.REMOVE_LIST_COMMAND, () => (t.removeList(p), !0), c.COMMAND_PRIORITY_LOW), p.registerCommand(c.INSERT_PARAGRAPH_COMMAND, () => !!t.$handleListInsertParagraph(), c.COMMAND_PRIORITY_LOW)), [p]);
  }
  function h() {
    const [p] = e.useLexicalComposerContext();
    return n.useEffect(() => {
      if (!p.hasNodes([t.ListNode, t.ListItemNode]))
        throw new Error("ListPlugin: ListNode and/or ListItemNode not registered on editor");
    }, [p]), d(p), null;
  }
  return Eu.ListPlugin = h, Eu;
}
const WN = process.env.NODE_ENV === "development" ? HN() : BN();
var KN = WN, Tu = {}, Fi = {}, ch;
function UN() {
  if (ch)
    return Fi;
  ch = 1;
  var t = rn(), e = Bt();
  let n = /* @__PURE__ */ new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
  class r extends e.ElementNode {
    static getType() {
      return "link";
    }
    static clone(M) {
      return new r(M.__url, { rel: M.__rel, target: M.__target, title: M.__title }, M.__key);
    }
    constructor(M, A = {}, T) {
      super(T);
      let { target: w = null, rel: P = null, title: K = null } = A;
      this.__url = M, this.__target = w, this.__rel = P, this.__title = K;
    }
    createDOM(M) {
      let A = document.createElement("a");
      return A.href = this.sanitizeUrl(this.__url), this.__target !== null && (A.target = this.__target), this.__rel !== null && (A.rel = this.__rel), this.__title !== null && (A.title = this.__title), t.addClassNamesToElement(
        A,
        M.theme.link
      ), A;
    }
    updateDOM(M, A) {
      let T = this.__url, w = this.__target, P = this.__rel, K = this.__title;
      return T !== M.__url && (A.href = T), w !== M.__target && (w ? A.target = w : A.removeAttribute("target")), P !== M.__rel && (P ? A.rel = P : A.removeAttribute("rel")), K !== M.__title && (K ? A.title = K : A.removeAttribute("title")), !1;
    }
    static importDOM() {
      return { a: () => ({ conversion: c, priority: 1 }) };
    }
    static importJSON(M) {
      let A = d(M.url, { rel: M.rel, target: M.target, title: M.title });
      return A.setFormat(M.format), A.setIndent(M.indent), A.setDirection(M.direction), A;
    }
    sanitizeUrl(M) {
      try {
        let A = new URL(M);
        if (!n.has(A.protocol))
          return "about:blank";
      } catch {
      }
      return M;
    }
    exportJSON() {
      return { ...super.exportJSON(), rel: this.getRel(), target: this.getTarget(), title: this.getTitle(), type: "link", url: this.getURL(), version: 1 };
    }
    getURL() {
      return this.getLatest().__url;
    }
    setURL(M) {
      this.getWritable().__url = M;
    }
    getTarget() {
      return this.getLatest().__target;
    }
    setTarget(M) {
      this.getWritable().__target = M;
    }
    getRel() {
      return this.getLatest().__rel;
    }
    setRel(M) {
      this.getWritable().__rel = M;
    }
    getTitle() {
      return this.getLatest().__title;
    }
    setTitle(M) {
      this.getWritable().__title = M;
    }
    insertNewAfter(M, A = !0) {
      return M = d(this.__url, { rel: this.__rel, target: this.__target, title: this.__title }), this.insertAfter(M, A), M;
    }
    canInsertTextBefore() {
      return !1;
    }
    canInsertTextAfter() {
      return !1;
    }
    canBeEmpty() {
      return !1;
    }
    isInline() {
      return !0;
    }
    extractWithChild(M, A) {
      if (!e.$isRangeSelection(A))
        return !1;
      M = A.anchor.getNode();
      let T = A.focus.getNode();
      return this.isParentOf(M) && this.isParentOf(T) && 0 < A.getTextContent().length;
    }
  }
  function c(O) {
    let M = null;
    if (t.isHTMLAnchorElement(O)) {
      let A = O.textContent;
      (A !== null && A !== "" || 0 < O.children.length) && (M = d(O.getAttribute("href") || "", { rel: O.getAttribute("rel"), target: O.getAttribute("target"), title: O.getAttribute("title") }));
    }
    return { node: M };
  }
  function d(O, M) {
    return e.$applyNodeReplacement(new r(O, M));
  }
  function h(O) {
    return O instanceof r;
  }
  class p extends r {
    static getType() {
      return "autolink";
    }
    static clone(M) {
      return new p(M.__url, { rel: M.__rel, target: M.__target, title: M.__title }, M.__key);
    }
    static importJSON(M) {
      let A = N(M.url, { rel: M.rel, target: M.target, title: M.title });
      return A.setFormat(M.format), A.setIndent(M.indent), A.setDirection(M.direction), A;
    }
    static importDOM() {
      return null;
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "autolink", version: 1 };
    }
    insertNewAfter(M, A = !0) {
      return M = this.getParentOrThrow().insertNewAfter(M, A), e.$isElementNode(M) ? (A = N(this.__url, { rel: this.__rel, target: this.__target, title: this.__title }), M.append(A), A) : null;
    }
  }
  function N(O, M) {
    return e.$applyNodeReplacement(new p(O, M));
  }
  let x = e.createCommand("TOGGLE_LINK_COMMAND");
  function v(O, M) {
    for (; O !== null && O.getParent() !== null && !M(O); )
      O = O.getParentOrThrow();
    return M(O) ? O : null;
  }
  return Fi.$createAutoLinkNode = N, Fi.$createLinkNode = d, Fi.$isAutoLinkNode = function(O) {
    return O instanceof p;
  }, Fi.$isLinkNode = h, Fi.AutoLinkNode = p, Fi.LinkNode = r, Fi.TOGGLE_LINK_COMMAND = x, Fi.toggleLink = function(O, M = {}) {
    let { target: A, title: T } = M, w = M.rel === void 0 ? "noreferrer" : M.rel;
    if (M = e.$getSelection(), e.$isRangeSelection(M))
      if (M = M.extract(), O === null)
        M.forEach((P) => {
          if (P = P.getParent(), h(P)) {
            let K = P.getChildren();
            for (let $ = 0; $ < K.length; $++)
              P.insertBefore(K[$]);
            P.remove();
          }
        });
      else {
        if (M.length === 1) {
          let $ = v(M[0], h);
          if ($ !== null) {
            $.setURL(O), A !== void 0 && $.setTarget(A), w !== null && $.setRel(w), T !== void 0 && $.setTitle(T);
            return;
          }
        }
        let P = null, K = null;
        M.forEach(($) => {
          var W = $.getParent();
          if (W !== K && W !== null && (!e.$isElementNode($) || $.isInline()))
            if (h(W))
              K = W, W.setURL(O), A !== void 0 && W.setTarget(A), w !== null && K.setRel(w), T !== void 0 && K.setTitle(T);
            else if (W.is(P) || (P = W, K = d(O, { rel: w, target: A, title: T }), h(W) ? $.getPreviousSibling() === null ? W.insertBefore(K) : W.insertAfter(K) : $.insertBefore(K)), h($)) {
              if (!$.is(K)) {
                if (K !== null) {
                  W = $.getChildren();
                  for (let H = 0; H < W.length; H++)
                    K.append(W[H]);
                }
                $.remove();
              }
            } else
              K !== null && K.append($);
        });
      }
  }, Fi;
}
var Bi = {}, uh;
function zN() {
  if (uh)
    return Bi;
  uh = 1;
  var t = rn(), e = Bt();
  const n = /* @__PURE__ */ new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
  class r extends e.ElementNode {
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    static getType() {
      return "link";
    }
    static clone(T) {
      return new r(T.__url, {
        rel: T.__rel,
        target: T.__target,
        title: T.__title
      }, T.__key);
    }
    constructor(T, w = {}, P) {
      super(P);
      const {
        target: K = null,
        rel: $ = null,
        title: W = null
      } = w;
      this.__url = T, this.__target = K, this.__rel = $, this.__title = W;
    }
    createDOM(T) {
      const w = document.createElement("a");
      return w.href = this.sanitizeUrl(this.__url), this.__target !== null && (w.target = this.__target), this.__rel !== null && (w.rel = this.__rel), this.__title !== null && (w.title = this.__title), t.addClassNamesToElement(w, T.theme.link), w;
    }
    updateDOM(T, w, P) {
      const K = this.__url, $ = this.__target, W = this.__rel, H = this.__title;
      return K !== T.__url && (w.href = K), $ !== T.__target && ($ ? w.target = $ : w.removeAttribute("target")), W !== T.__rel && (W ? w.rel = W : w.removeAttribute("rel")), H !== T.__title && (H ? w.title = H : w.removeAttribute("title")), !1;
    }
    static importDOM() {
      return {
        a: (T) => ({
          conversion: c,
          priority: 1
        })
      };
    }
    static importJSON(T) {
      const w = d(T.url, {
        rel: T.rel,
        target: T.target,
        title: T.title
      });
      return w.setFormat(T.format), w.setIndent(T.indent), w.setDirection(T.direction), w;
    }
    sanitizeUrl(T) {
      try {
        const w = new URL(T);
        if (!n.has(w.protocol))
          return "about:blank";
      } catch {
        return T;
      }
      return T;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        rel: this.getRel(),
        target: this.getTarget(),
        title: this.getTitle(),
        type: "link",
        url: this.getURL(),
        version: 1
      };
    }
    getURL() {
      return this.getLatest().__url;
    }
    setURL(T) {
      const w = this.getWritable();
      w.__url = T;
    }
    getTarget() {
      return this.getLatest().__target;
    }
    setTarget(T) {
      const w = this.getWritable();
      w.__target = T;
    }
    getRel() {
      return this.getLatest().__rel;
    }
    setRel(T) {
      const w = this.getWritable();
      w.__rel = T;
    }
    getTitle() {
      return this.getLatest().__title;
    }
    setTitle(T) {
      const w = this.getWritable();
      w.__title = T;
    }
    insertNewAfter(T, w = !0) {
      const P = d(this.__url, {
        rel: this.__rel,
        target: this.__target,
        title: this.__title
      });
      return this.insertAfter(P, w), P;
    }
    canInsertTextBefore() {
      return !1;
    }
    canInsertTextAfter() {
      return !1;
    }
    canBeEmpty() {
      return !1;
    }
    isInline() {
      return !0;
    }
    extractWithChild(T, w, P) {
      if (!e.$isRangeSelection(w))
        return !1;
      const K = w.anchor.getNode(), $ = w.focus.getNode();
      return this.isParentOf(K) && this.isParentOf($) && w.getTextContent().length > 0;
    }
  }
  function c(A) {
    let T = null;
    if (t.isHTMLAnchorElement(A)) {
      const w = A.textContent;
      (w !== null && w !== "" || A.children.length > 0) && (T = d(A.getAttribute("href") || "", {
        rel: A.getAttribute("rel"),
        target: A.getAttribute("target"),
        title: A.getAttribute("title")
      }));
    }
    return {
      node: T
    };
  }
  function d(A, T) {
    return e.$applyNodeReplacement(new r(A, T));
  }
  function h(A) {
    return A instanceof r;
  }
  class p extends r {
    static getType() {
      return "autolink";
    }
    static clone(T) {
      return new p(T.__url, {
        rel: T.__rel,
        target: T.__target,
        title: T.__title
      }, T.__key);
    }
    static importJSON(T) {
      const w = N(T.url, {
        rel: T.rel,
        target: T.target,
        title: T.title
      });
      return w.setFormat(T.format), w.setIndent(T.indent), w.setDirection(T.direction), w;
    }
    static importDOM() {
      return null;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "autolink",
        version: 1
      };
    }
    insertNewAfter(T, w = !0) {
      const P = this.getParentOrThrow().insertNewAfter(T, w);
      if (e.$isElementNode(P)) {
        const K = N(this.__url, {
          rel: this.__rel,
          target: this.__target,
          title: this.__title
        });
        return P.append(K), K;
      }
      return null;
    }
  }
  function N(A, T) {
    return e.$applyNodeReplacement(new p(A, T));
  }
  function x(A) {
    return A instanceof p;
  }
  const v = e.createCommand("TOGGLE_LINK_COMMAND");
  function O(A, T = {}) {
    const {
      target: w,
      title: P
    } = T, K = T.rel === void 0 ? "noreferrer" : T.rel, $ = e.$getSelection();
    if (!e.$isRangeSelection($))
      return;
    const W = $.extract();
    if (A === null)
      W.forEach((H) => {
        const z = H.getParent();
        if (h(z)) {
          const te = z.getChildren();
          for (let re = 0; re < te.length; re++)
            z.insertBefore(te[re]);
          z.remove();
        }
      });
    else {
      if (W.length === 1) {
        const te = W[0], re = M(te, h);
        if (re !== null) {
          re.setURL(A), w !== void 0 && re.setTarget(w), K !== null && re.setRel(K), P !== void 0 && re.setTitle(P);
          return;
        }
      }
      let H = null, z = null;
      W.forEach((te) => {
        const re = te.getParent();
        if (!(re === z || re === null || e.$isElementNode(te) && !te.isInline())) {
          if (h(re)) {
            z = re, re.setURL(A), w !== void 0 && re.setTarget(w), K !== null && z.setRel(K), P !== void 0 && z.setTitle(P);
            return;
          }
          if (re.is(H) || (H = re, z = d(A, {
            rel: K,
            target: w,
            title: P
          }), h(re) ? te.getPreviousSibling() === null ? re.insertBefore(z) : re.insertAfter(z) : te.insertBefore(z)), h(te)) {
            if (te.is(z))
              return;
            if (z !== null) {
              const ue = te.getChildren();
              for (let q = 0; q < ue.length; q++)
                z.append(ue[q]);
            }
            te.remove();
            return;
          }
          z !== null && z.append(te);
        }
      });
    }
  }
  function M(A, T) {
    let w = A;
    for (; w !== null && w.getParent() !== null && !T(w); )
      w = w.getParentOrThrow();
    return T(w) ? w : null;
  }
  return Bi.$createAutoLinkNode = N, Bi.$createLinkNode = d, Bi.$isAutoLinkNode = x, Bi.$isLinkNode = h, Bi.AutoLinkNode = p, Bi.LinkNode = r, Bi.TOGGLE_LINK_COMMAND = v, Bi.toggleLink = O, Bi;
}
var xu, dh;
function gd() {
  return dh || (dh = 1, xu = process.env.NODE_ENV === "development" ? zN() : UN()), xu;
}
var fh;
function GN() {
  if (fh)
    return Tu;
  fh = 1;
  var t = gd(), e = Yn(), n = rn(), r = Bt(), c = dn;
  return Tu.LinkPlugin = function({ validateUrl: d }) {
    let [h] = e.useLexicalComposerContext();
    return c.useEffect(() => {
      if (!h.hasNodes([t.LinkNode]))
        throw Error("LinkPlugin: LinkNode not registered on editor");
      return n.mergeRegister(h.registerCommand(t.TOGGLE_LINK_COMMAND, (p) => {
        if (p === null)
          return t.toggleLink(p), !0;
        if (typeof p == "string")
          return d === void 0 || d(p) ? (t.toggleLink(p), !0) : !1;
        let { url: N, target: x, rel: v, title: O } = p;
        return t.toggleLink(N, { rel: v, target: x, title: O }), !0;
      }, r.COMMAND_PRIORITY_LOW), d !== void 0 ? h.registerCommand(
        r.PASTE_COMMAND,
        (p) => {
          let N = r.$getSelection();
          if (!r.$isRangeSelection(N) || N.isCollapsed() || !(p instanceof ClipboardEvent) || p.clipboardData == null)
            return !1;
          let x = p.clipboardData.getData("text");
          return d(x) ? N.getNodes().some((v) => r.$isElementNode(v)) ? !1 : (h.dispatchCommand(t.TOGGLE_LINK_COMMAND, x), p.preventDefault(), !0) : !1;
        },
        r.COMMAND_PRIORITY_LOW
      ) : () => {
      });
    }, [h, d]), null;
  }, Tu;
}
var vu = {}, hh;
function YN() {
  if (hh)
    return vu;
  hh = 1;
  var t = gd(), e = Yn(), n = rn(), r = Bt(), c = dn;
  function d({
    validateUrl: h
  }) {
    const [p] = e.useLexicalComposerContext();
    return c.useEffect(() => {
      if (!p.hasNodes([t.LinkNode]))
        throw new Error("LinkPlugin: LinkNode not registered on editor");
      return n.mergeRegister(p.registerCommand(t.TOGGLE_LINK_COMMAND, (N) => {
        if (N === null)
          return t.toggleLink(N), !0;
        if (typeof N == "string")
          return h === void 0 || h(N) ? (t.toggleLink(N), !0) : !1;
        {
          const {
            url: x,
            target: v,
            rel: O,
            title: M
          } = N;
          return t.toggleLink(x, {
            rel: O,
            target: v,
            title: M
          }), !0;
        }
      }, r.COMMAND_PRIORITY_LOW), h !== void 0 ? p.registerCommand(r.PASTE_COMMAND, (N) => {
        const x = r.$getSelection();
        if (!r.$isRangeSelection(x) || x.isCollapsed() || !(N instanceof ClipboardEvent) || N.clipboardData == null)
          return !1;
        const v = N.clipboardData.getData("text");
        return h(v) ? x.getNodes().some((O) => r.$isElementNode(O)) ? !1 : (p.dispatchCommand(t.TOGGLE_LINK_COMMAND, v), N.preventDefault(), !0) : !1;
      }, r.COMMAND_PRIORITY_LOW) : () => {
      });
    }, [p, h]), null;
  }
  return vu.LinkPlugin = d, vu;
}
const VN = process.env.NODE_ENV === "development" ? YN() : GN();
var jN = VN, Su = {}, zt = {}, gh;
function qN() {
  if (gh)
    return zt;
  gh = 1;
  var t = Bt(), e = rn();
  let n = /^(\d+(?:\.\d+)?)px$/, r = { BOTH: 3, COLUMN: 2, NO_STATUS: 0, ROW: 1 };
  class c extends t.DEPRECATED_GridCellNode {
    static getType() {
      return "tablecell";
    }
    static clone(y) {
      let b = new c(y.__headerState, y.__colSpan, y.__width, y.__key);
      return b.__rowSpan = y.__rowSpan, b.__backgroundColor = y.__backgroundColor, b;
    }
    static importDOM() {
      return { td: () => ({ conversion: d, priority: 0 }), th: () => ({ conversion: d, priority: 0 }) };
    }
    static importJSON(y) {
      let b = y.rowSpan || 1, Z = h(y.headerState, y.colSpan || 1, y.width || void 0);
      return Z.__rowSpan = b, Z.__backgroundColor = y.backgroundColor || null, Z;
    }
    constructor(y = r.NO_STATUS, b = 1, Z, ce) {
      super(b, ce), this.__headerState = y, this.__width = Z, this.__backgroundColor = null;
    }
    createDOM(y) {
      let b = document.createElement(this.getTag());
      return this.__width && (b.style.width = `${this.__width}px`), 1 < this.__colSpan && (b.colSpan = this.__colSpan), 1 < this.__rowSpan && (b.rowSpan = this.__rowSpan), this.__backgroundColor !== null && (b.style.backgroundColor = this.__backgroundColor), e.addClassNamesToElement(b, y.theme.tableCell, this.hasHeader() && y.theme.tableCellHeader), b;
    }
    exportDOM(y) {
      if ({ element: y } = super.exportDOM(y), y) {
        var b = this.getParentOrThrow().getChildrenSize();
        y.style.border = "1px solid black", 1 < this.__colSpan && (y.colSpan = this.__colSpan), 1 < this.__rowSpan && (y.rowSpan = this.__rowSpan), y.style.width = `${this.getWidth() || Math.max(90, 700 / b)}px`, y.style.verticalAlign = "top", y.style.textAlign = "start", b = this.getBackgroundColor(), b !== null ? y.style.backgroundColor = b : this.hasHeader() && (y.style.backgroundColor = "#f2f3f5");
      }
      return { element: y };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        backgroundColor: this.getBackgroundColor(),
        headerState: this.__headerState,
        type: "tablecell",
        width: this.getWidth()
      };
    }
    getTag() {
      return this.hasHeader() ? "th" : "td";
    }
    setHeaderStyles(y) {
      return this.getWritable().__headerState = y, this.__headerState;
    }
    getHeaderStyles() {
      return this.getLatest().__headerState;
    }
    setWidth(y) {
      return this.getWritable().__width = y, this.__width;
    }
    getWidth() {
      return this.getLatest().__width;
    }
    getBackgroundColor() {
      return this.getLatest().__backgroundColor;
    }
    setBackgroundColor(y) {
      this.getWritable().__backgroundColor = y;
    }
    toggleHeaderStyle(y) {
      let b = this.getWritable();
      return b.__headerState = (b.__headerState & y) === y ? b.__headerState - y : b.__headerState + y, b;
    }
    hasHeaderState(y) {
      return (this.getHeaderStyles() & y) === y;
    }
    hasHeader() {
      return this.getLatest().__headerState !== r.NO_STATUS;
    }
    updateDOM(y) {
      return y.__headerState !== this.__headerState || y.__width !== this.__width || y.__colSpan !== this.__colSpan || y.__rowSpan !== this.__rowSpan || y.__backgroundColor !== this.__backgroundColor;
    }
    isShadowRoot() {
      return !0;
    }
    collapseAtStart() {
      return !0;
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
  }
  function d(m) {
    var y = m.nodeName.toLowerCase();
    let b;
    return n.test(m.style.width) && (b = parseFloat(m.style.width)), y = h(y === "th" ? r.ROW : r.NO_STATUS, m.colSpan, b), y.__rowSpan = m.rowSpan, m = m.style.backgroundColor, m !== "" && (y.__backgroundColor = m), { forChild: (Z, ce) => p(ce) && !t.$isElementNode(Z) ? (ce = t.$createParagraphNode(), t.$isLineBreakNode(Z) && Z.getTextContent() === `
` ? null : (ce.append(Z), ce)) : Z, node: y };
  }
  function h(m, y = 1, b) {
    return t.$applyNodeReplacement(new c(m, y, b));
  }
  function p(m) {
    return m instanceof c;
  }
  class N extends t.DEPRECATED_GridRowNode {
    static getType() {
      return "tablerow";
    }
    static clone(y) {
      return new N(y.__height, y.__key);
    }
    static importDOM() {
      return { tr: () => ({ conversion: x, priority: 0 }) };
    }
    static importJSON(y) {
      return v(y.height);
    }
    constructor(y, b) {
      super(b), this.__height = y;
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "tablerow", version: 1 };
    }
    createDOM(y) {
      let b = document.createElement("tr");
      return this.__height && (b.style.height = `${this.__height}px`), e.addClassNamesToElement(b, y.theme.tableRow), b;
    }
    isShadowRoot() {
      return !0;
    }
    setHeight(y) {
      return this.getWritable().__height = y, this.__height;
    }
    getHeight() {
      return this.getLatest().__height;
    }
    updateDOM(y) {
      return y.__height !== this.__height;
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
  }
  function x(m) {
    let y;
    return n.test(m.style.height) && (y = parseFloat(m.style.height)), { node: v(y) };
  }
  function v(m) {
    return t.$applyNodeReplacement(new N(m));
  }
  function O(m) {
    return m instanceof N;
  }
  function M(m) {
    let y = new URLSearchParams();
    y.append("code", m);
    for (let b = 1; b < arguments.length; b++)
      y.append("v", arguments[b]);
    throw Error(`Minified Lexical error #${m}; visit https://lexical.dev/docs/error?${y} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  let A = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
  class T {
    constructor(y, b) {
      this.isHighlightingCells = !1, this.focusY = this.focusX = this.anchorY = this.anchorX = -1, this.listenersToRemove = /* @__PURE__ */ new Set(), this.tableNodeKey = b, this.editor = y, this.grid = { cells: [], columns: 0, rows: 0 }, this.focusCell = this.anchorCell = this.focusCellNodeKey = this.anchorCellNodeKey = this.gridSelection = null, this.hasHijackedSelectionStyles = !1, this.trackTableGrid();
    }
    getGrid() {
      return this.grid;
    }
    removeListeners() {
      Array.from(this.listenersToRemove).forEach((y) => y());
    }
    trackTableGrid() {
      let y = new MutationObserver((b) => {
        this.editor.update(() => {
          var Z = !1;
          for (let ce = 0; ce < b.length; ce++) {
            const ge = b[ce].target.nodeName;
            if (ge === "TABLE" || ge === "TR") {
              Z = !0;
              break;
            }
          }
          if (Z) {
            if (Z = this.editor.getElementByKey(this.tableNodeKey), !Z)
              throw Error("Expected to find TableElement in DOM");
            this.grid = P(Z);
          }
        });
      });
      this.editor.update(() => {
        let b = this.editor.getElementByKey(this.tableNodeKey);
        if (!b)
          throw Error("Expected to find TableElement in DOM");
        this.grid = P(b), y.observe(b, { childList: !0, subtree: !0 });
      });
    }
    clearHighlight() {
      let y = this.editor;
      this.isHighlightingCells = !1, this.focusY = this.focusX = this.anchorY = this.anchorX = -1, this.focusCell = this.anchorCell = this.focusCellNodeKey = this.anchorCellNodeKey = this.gridSelection = null, this.hasHijackedSelectionStyles = !1, this.enableHighlightStyle(), y.update(() => {
        var b = t.$getNodeByKey(this.tableNodeKey);
        if (!D(b))
          throw Error("Expected TableNode.");
        if (b = y.getElementByKey(this.tableNodeKey), !b)
          throw Error("Expected to find TableElement in DOM");
        b = P(b), K(y, b, null), t.$setSelection(null), y.dispatchCommand(
          t.SELECTION_CHANGE_COMMAND,
          void 0
        );
      });
    }
    enableHighlightStyle() {
      let y = this.editor;
      y.update(() => {
        let b = y.getElementByKey(this.tableNodeKey);
        if (!b)
          throw Error("Expected to find TableElement in DOM");
        e.removeClassNamesFromElement(b, y._config.theme.tableSelection), b.classList.remove("disable-selection"), this.hasHijackedSelectionStyles = !1;
      });
    }
    disableHighlightStyle() {
      let y = this.editor;
      y.update(() => {
        let b = y.getElementByKey(this.tableNodeKey);
        if (!b)
          throw Error("Expected to find TableElement in DOM");
        e.addClassNamesToElement(b, y._config.theme.tableSelection), this.hasHijackedSelectionStyles = !0;
      });
    }
    updateTableGridSelection(y) {
      if (y != null && y.gridKey === this.tableNodeKey) {
        let b = this.editor;
        this.gridSelection = y, this.isHighlightingCells = !0, this.disableHighlightStyle(), K(b, this.grid, this.gridSelection);
      } else
        y == null ? this.clearHighlight() : (this.tableNodeKey = y.gridKey, this.updateTableGridSelection(y));
    }
    setFocusCellForSelection(y, b = !1) {
      let Z = this.editor;
      Z.update(() => {
        var ce = t.$getNodeByKey(this.tableNodeKey);
        if (!D(ce))
          throw Error("Expected TableNode.");
        if (!Z.getElementByKey(this.tableNodeKey))
          throw Error("Expected to find TableElement in DOM");
        ce = y.x;
        let ge = y.y;
        if (this.focusCell = y, this.anchorCell !== null) {
          let ae = A ? (Z._window || window).getSelection() : null;
          ae && ae.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);
        }
        if (!this.isHighlightingCells && (this.anchorX !== ce || this.anchorY !== ge || b))
          this.isHighlightingCells = !0, this.disableHighlightStyle();
        else if (ce === this.focusX && ge === this.focusY)
          return;
        this.focusX = ce, this.focusY = ge, this.isHighlightingCells && (ce = t.$getNearestNodeFromDOMNode(y.elem), this.gridSelection != null && this.anchorCellNodeKey != null && p(ce) && (ce = ce.getKey(), this.gridSelection = this.gridSelection.clone() || t.DEPRECATED_$createGridSelection(), this.focusCellNodeKey = ce, this.gridSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey), t.$setSelection(this.gridSelection), Z.dispatchCommand(t.SELECTION_CHANGE_COMMAND, void 0), K(Z, this.grid, this.gridSelection)));
      });
    }
    setAnchorCellForSelection(y) {
      this.isHighlightingCells = !1, this.anchorCell = y, this.anchorX = y.x, this.anchorY = y.y, this.editor.update(() => {
        var b = t.$getNearestNodeFromDOMNode(y.elem);
        p(b) && (b = b.getKey(), this.gridSelection = this.gridSelection != null ? this.gridSelection.clone() : t.DEPRECATED_$createGridSelection(), this.anchorCellNodeKey = b);
      });
    }
    formatCells(y) {
      this.editor.update(() => {
        let b = t.$getSelection();
        t.DEPRECATED_$isGridSelection(b) || M(11);
        let Z = t.$createRangeSelection(), ce = Z.anchor, ge = Z.focus;
        b.getNodes().forEach((ae) => {
          p(ae) && ae.getTextContentSize() !== 0 && (ce.set(ae.getKey(), 0, "element"), ge.set(ae.getKey(), ae.getChildrenSize(), "element"), Z.formatText(y));
        }), t.$setSelection(b), this.editor.dispatchCommand(
          t.SELECTION_CHANGE_COMMAND,
          void 0
        );
      });
    }
    clearText() {
      let y = this.editor;
      y.update(() => {
        let b = t.$getNodeByKey(this.tableNodeKey);
        if (!D(b))
          throw Error("Expected TableNode.");
        var Z = t.$getSelection();
        t.DEPRECATED_$isGridSelection(Z) || M(11), Z = Z.getNodes().filter(p), Z.length === this.grid.columns * this.grid.rows ? (b.selectPrevious(), b.remove(), t.$getRoot().selectStart()) : (Z.forEach((ce) => {
          if (t.$isElementNode(ce)) {
            let ge = t.$createParagraphNode(), ae = t.$createTextNode();
            ge.append(ae), ce.append(ge), ce.getChildren().forEach((Te) => {
              Te !== ge && Te.remove();
            });
          }
        }), K(
          y,
          this.grid,
          null
        ), t.$setSelection(null), y.dispatchCommand(t.SELECTION_CHANGE_COMMAND, void 0));
      });
    }
  }
  function w(m) {
    for (; m != null; ) {
      let y = m.nodeName;
      if (y === "TD" || y === "TH") {
        if (m = m._cell, m === void 0)
          break;
        return m;
      }
      m = m.parentNode;
    }
    return null;
  }
  function P(m) {
    let y = [], b = { cells: y, columns: 0, rows: 0 };
    var Z = m.firstChild;
    let ce = m = 0;
    for (y.length = 0; Z != null; ) {
      var ge = Z.nodeName;
      if (ge === "TD" || ge === "TH") {
        ge = Z, ge = { elem: ge, hasBackgroundColor: ge.style.backgroundColor !== "", highlighted: !1, x: m, y: ce }, Z._cell = ge;
        let ae = y[ce];
        ae === void 0 && (ae = y[ce] = []), ae[m] = ge;
      } else if (ge = Z.firstChild, ge != null) {
        Z = ge;
        continue;
      }
      if (ge = Z.nextSibling, ge != null)
        m++, Z = ge;
      else if (ge = Z.parentNode, ge != null) {
        if (Z = ge.nextSibling, Z == null)
          break;
        ce++, m = 0;
      }
    }
    return b.columns = m + 1, b.rows = ce + 1, b;
  }
  function K(m, y, b) {
    let Z = new Set(b ? b.getNodes() : []);
    $(y, (ce, ge) => {
      let ae = ce.elem;
      Z.has(ge) ? (ce.highlighted = !0, ue(m, ce)) : (ce.highlighted = !1, q(m, ce), ae.getAttribute("style") || ae.removeAttribute("style"));
    });
  }
  function $(m, y) {
    ({ cells: m } = m);
    for (let b = 0; b < m.length; b++) {
      let Z = m[b];
      if (Z)
        for (let ce = 0; ce < Z.length; ce++) {
          let ge = Z[ce];
          if (!ge)
            continue;
          let ae = t.$getNearestNodeFromDOMNode(ge.elem);
          ae !== null && y(ge, ae, { x: ce, y: b });
        }
    }
  }
  function W(m, y) {
    y.disableHighlightStyle(), $(y.grid, (b) => {
      b.highlighted = !0, ue(m, b);
    });
  }
  function H(m, y) {
    y.enableHighlightStyle(), $(y.grid, (b) => {
      let Z = b.elem;
      b.highlighted = !1, q(m, b), Z.getAttribute("style") || Z.removeAttribute("style");
    });
  }
  let z = (m, y, b, Z, ce) => {
    const ge = ce === "forward";
    switch (ce) {
      case "backward":
      case "forward":
        return b !== (ge ? m.grid.columns - 1 : 0) ? (m = y.getCellNodeFromCordsOrThrow(b + (ge ? 1 : -1), Z, m.grid), ge ? m.selectStart() : m.selectEnd()) : Z !== (ge ? m.grid.rows - 1 : 0) ? (m = y.getCellNodeFromCordsOrThrow(ge ? 0 : m.grid.columns - 1, Z + (ge ? 1 : -1), m.grid), ge ? m.selectStart() : m.selectEnd()) : ge ? y.selectNext() : y.selectPrevious(), !0;
      case "up":
        return Z !== 0 ? y.getCellNodeFromCordsOrThrow(b, Z - 1, m.grid).selectEnd() : y.selectPrevious(), !0;
      case "down":
        return Z !== m.grid.rows - 1 ? y.getCellNodeFromCordsOrThrow(b, Z + 1, m.grid).selectStart() : y.selectNext(), !0;
      default:
        return !1;
    }
  }, te = (m, y, b, Z, ce) => {
    const ge = ce === "forward";
    switch (ce) {
      case "backward":
      case "forward":
        return b !== (ge ? m.grid.columns - 1 : 0) && m.setFocusCellForSelection(y.getCellFromCordsOrThrow(b + (ge ? 1 : -1), Z, m.grid)), !0;
      case "up":
        return Z !== 0 ? (m.setFocusCellForSelection(y.getCellFromCordsOrThrow(b, Z - 1, m.grid)), !0) : !1;
      case "down":
        return Z !== m.grid.rows - 1 ? (m.setFocusCellForSelection(y.getCellFromCordsOrThrow(b, Z + 1, m.grid)), !0) : !1;
      default:
        return !1;
    }
  };
  function re(m, y) {
    if (t.$isRangeSelection(m) || t.DEPRECATED_$isGridSelection(m)) {
      let b = y.isParentOf(m.anchor.getNode());
      return m = y.isParentOf(m.focus.getNode()), b && m;
    }
    return !1;
  }
  function ue(m, y) {
    m = y.elem, y = t.$getNearestNodeFromDOMNode(m), p(y) || M(131), y.getBackgroundColor() === null ? m.style.setProperty("background-color", "rgb(172,206,247)") : m.style.setProperty("background-image", "linear-gradient(to right, rgba(172,206,247,0.85), rgba(172,206,247,0.85))"), m.style.setProperty("caret-color", "transparent");
  }
  function q(m, y) {
    m = y.elem, y = t.$getNearestNodeFromDOMNode(m), p(y) || M(131), y.getBackgroundColor() === null && m.style.removeProperty("background-color"), m.style.removeProperty("background-image"), m.style.removeProperty("caret-color");
  }
  function G(m) {
    return m = e.$findMatchingParent(m, p), p(m) ? m : null;
  }
  function j(m) {
    return m = e.$findMatchingParent(m, D), D(m) ? m : null;
  }
  function _e(m, y, b, Z, ce) {
    let ge = t.$getSelection();
    if (!re(ge, Z))
      return !1;
    if (t.$isRangeSelection(ge) && ge.isCollapsed()) {
      if (b === "backward" || b === "forward")
        return !1;
      let { anchor: ze, focus: oe } = ge;
      var ae = e.$findMatchingParent(ze.getNode(), p), Te = e.$findMatchingParent(oe.getNode(), p);
      if (!p(ae) || !ae.is(Te))
        return !1;
      if (Te = j(ae), Te !== Z && Te != null) {
        var Ae = m.getElementByKey(Te.getKey());
        if (Ae != null)
          return ce.grid = P(Ae), _e(m, y, b, Te, ce);
      }
      if (Te = m.getElementByKey(ae.__key), Ae = m.getElementByKey(ze.key), Ae == null || Te == null)
        return !1;
      if (ze.type === "element")
        Te = Ae.getBoundingClientRect();
      else {
        if (Te = window.getSelection(), Te === null || Te.rangeCount === 0)
          return !1;
        Te = Te.getRangeAt(0).getBoundingClientRect();
      }
      if (Ae = b === "up" ? ae.getFirstChild() : ae.getLastChild(), Ae == null || (m = m.getElementByKey(Ae.__key), m == null))
        return !1;
      if (m = m.getBoundingClientRect(), b === "up" ? m.top > Te.top - Te.height : Te.bottom + Te.height > m.bottom) {
        if (pe(y), m = Z.getCordsFromCellNode(ae, ce.grid), y.shiftKey)
          b = Z.getCellFromCordsOrThrow(m.x, m.y, ce.grid), ce.setAnchorCellForSelection(b), ce.setFocusCellForSelection(b, !0);
        else
          return z(ce, Z, m.x, m.y, b);
        return !0;
      }
    } else if (t.DEPRECATED_$isGridSelection(ge)) {
      let { anchor: ze, focus: oe } = ge;
      return Ae = e.$findMatchingParent(ze.getNode(), p), Te = e.$findMatchingParent(oe.getNode(), p), [ae] = ge.getNodes(), m = m.getElementByKey(ae.getKey()), !p(Ae) || !p(Te) || !D(ae) || m == null ? !1 : (ce.updateTableGridSelection(ge), m = P(m), Ae = Z.getCordsFromCellNode(Ae, m), Ae = Z.getCellFromCordsOrThrow(Ae.x, Ae.y, m), ce.setAnchorCellForSelection(Ae), pe(y), y.shiftKey ? (y = Z.getCordsFromCellNode(Te, m), te(ce, ae, y.x, y.y, b)) : (Te.selectEnd(), !0));
    }
    return !1;
  }
  function pe(m) {
    m.preventDefault(), m.stopImmediatePropagation(), m.stopPropagation();
  }
  class J extends t.DEPRECATED_GridNode {
    static getType() {
      return "table";
    }
    static clone(y) {
      return new J(y.__key);
    }
    static importDOM() {
      return { table: () => ({ conversion: ee, priority: 1 }) };
    }
    static importJSON() {
      return F();
    }
    constructor(y) {
      super(y);
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "table", version: 1 };
    }
    createDOM(y) {
      let b = document.createElement("table");
      return e.addClassNamesToElement(b, y.theme.table), b;
    }
    updateDOM() {
      return !1;
    }
    exportDOM(y) {
      return { ...super.exportDOM(y), after: (b) => {
        if (b) {
          let Z = b.cloneNode(), ce = document.createElement("colgroup"), ge = document.createElement("tbody");
          if (e.isHTMLElement(b) && ge.append(...b.children), b = this.getFirstChildOrThrow(), !O(b))
            throw Error("Expected to find row node.");
          b = b.getChildrenSize();
          for (let ae = 0; ae < b; ae++) {
            let Te = document.createElement("col");
            ce.append(Te);
          }
          return Z.replaceChildren(ce, ge), Z;
        }
      } };
    }
    canExtractContents() {
      return !1;
    }
    canBeEmpty() {
      return !1;
    }
    isShadowRoot() {
      return !0;
    }
    getCordsFromCellNode(y, b) {
      let { rows: Z, cells: ce } = b;
      for (b = 0; b < Z; b++) {
        var ge = ce[b];
        if (ge != null && (ge = ge.findIndex((ae) => {
          if (ae)
            return { elem: ae } = ae, t.$getNearestNodeFromDOMNode(ae) === y;
        }), ge !== -1))
          return { x: ge, y: b };
      }
      throw Error("Cell not found in table.");
    }
    getCellFromCords(y, b, Z) {
      return { cells: Z } = Z, b = Z[b], b == null ? null : (y = b[y], y ?? null);
    }
    getCellFromCordsOrThrow(y, b, Z) {
      if (y = this.getCellFromCords(y, b, Z), !y)
        throw Error("Cell not found at cords.");
      return y;
    }
    getCellNodeFromCords(y, b, Z) {
      return y = this.getCellFromCords(y, b, Z), y == null ? null : (y = t.$getNearestNodeFromDOMNode(y.elem), p(y) ? y : null);
    }
    getCellNodeFromCordsOrThrow(y, b, Z) {
      if (y = this.getCellNodeFromCords(y, b, Z), !y)
        throw Error("Node at cords not TableCellNode.");
      return y;
    }
    canSelectBefore() {
      return !0;
    }
    canIndent() {
      return !1;
    }
  }
  function ee() {
    return { node: F() };
  }
  function F() {
    return t.$applyNodeReplacement(new J());
  }
  function D(m) {
    return m instanceof J;
  }
  function V(m) {
    if (m = e.$findMatchingParent(m, (y) => O(y)), O(m))
      return m;
    throw Error("Expected table cell to be inside of table row.");
  }
  function ne(m) {
    if (m = e.$findMatchingParent(m, (y) => D(y)), D(m))
      return m;
    throw Error("Expected table cell to be inside of table.");
  }
  function Y(m, y) {
    let b = ne(m), { x: Z, y: ce } = b.getCordsFromCellNode(m, y);
    return { above: b.getCellNodeFromCords(Z, ce - 1, y), below: b.getCellNodeFromCords(Z, ce + 1, y), left: b.getCellNodeFromCords(Z - 1, ce, y), right: b.getCellNodeFromCords(Z + 1, ce, y) };
  }
  function U(m) {
    let y = m.getFirstDescendant();
    y == null ? m.selectStart() : y.getParentOrThrow().selectStart();
  }
  function Q(m, y) {
    let b = m.getFirstChild();
    b !== null ? b.insertBefore(y) : m.append(y);
  }
  let k = t.createCommand("INSERT_TABLE_COMMAND");
  return zt.$createTableCellNode = h, zt.$createTableNode = F, zt.$createTableNodeWithDimensions = function(m, y, b = !0) {
    let Z = F();
    for (let ge = 0; ge < m; ge++) {
      let ae = v();
      for (let Te = 0; Te < y; Te++) {
        var ce = r.NO_STATUS;
        typeof b == "object" ? (ge === 0 && b.rows && (ce |= r.ROW), Te === 0 && b.columns && (ce |= r.COLUMN)) : b && (ge === 0 && (ce |= r.ROW), Te === 0 && (ce |= r.COLUMN)), ce = h(ce);
        let Ae = t.$createParagraphNode();
        Ae.append(t.$createTextNode()), ce.append(Ae), ae.append(ce);
      }
      Z.append(ae);
    }
    return Z;
  }, zt.$createTableRowNode = v, zt.$deleteTableColumn = function(m, y) {
    let b = m.getChildren();
    for (let ce = 0; ce < b.length; ce++) {
      var Z = b[ce];
      if (O(Z)) {
        if (Z = Z.getChildren(), y >= Z.length || 0 > y)
          throw Error("Table column target index out of range");
        Z[y].remove();
      }
    }
    return m;
  }, zt.$deleteTableColumn__EXPERIMENTAL = function() {
    var m = t.$getSelection();
    if (!t.$INTERNAL_isPointSelection(m))
      throw Error("Expected a INTERNAL_PointSelection");
    var y = m.anchor.getNode();
    m = m.focus.getNode();
    let [b, , Z] = t.DEPRECATED_$getNodeTriplet(y);
    [y] = t.DEPRECATED_$getNodeTriplet(m);
    let [ce, ge, ae] = t.DEPRECATED_$computeGridMap(Z, b, y);
    var { startColumn: Te } = ge;
    let { startRow: Ae, startColumn: ze } = ae;
    m = Math.min(Te, ze), Te = Math.max(Te + b.__colSpan - 1, ze + y.__colSpan - 1);
    let oe = Te - m + 1;
    if (ce[0].length === Te - m + 1)
      Z.selectPrevious(), Z.remove();
    else {
      var ie = ce.length;
      for (let de = 0; de < ie; de++)
        for (let we = m; we <= Te; we++) {
          let { cell: ke, startColumn: Be } = ce[de][we];
          Be < m ? we === m && ke.setColSpan(ke.__colSpan - Math.min(oe, ke.__colSpan - (m - Be))) : Be + ke.__colSpan - 1 > Te ? we === Te && ke.setColSpan(ke.__colSpan - (Te - Be + 1)) : ke.remove();
        }
      m = ce[Ae], y = m[ze + y.__colSpan], y !== void 0 ? ({ cell: y } = y, U(y)) : ({ cell: y } = m[ze - 1], U(y));
    }
  }, zt.$deleteTableRow__EXPERIMENTAL = function() {
    var m = t.$getSelection();
    if (!t.$INTERNAL_isPointSelection(m))
      throw Error("Expected a INTERNAL_PointSelection");
    var y = m.anchor.getNode();
    m = m.focus.getNode();
    let [b, , Z] = t.DEPRECATED_$getNodeTriplet(y);
    [m] = t.DEPRECATED_$getNodeTriplet(m);
    let [ce, ge, ae] = t.DEPRECATED_$computeGridMap(Z, b, m);
    ({ startRow: y } = ge);
    var { startRow: Te } = ae;
    if (m = Te + m.__rowSpan - 1, ce.length === m - y + 1)
      Z.remove();
    else {
      Te = ce[0].length;
      var Ae = ce[m + 1], ze = Z.getChildAtIndex(m + 1);
      for (let ie = m; ie >= y; ie--) {
        for (var oe = Te - 1; 0 <= oe; oe--) {
          let { cell: de, startRow: we, startColumn: ke } = ce[ie][oe];
          if (ke === oe && (ie === y && we < y && de.setRowSpan(de.__rowSpan - (we - y)), we >= y && we + de.__rowSpan - 1 > m))
            if (de.setRowSpan(de.__rowSpan - (m - we + 1)), ze === null && M(122), oe === 0)
              Q(ze, de);
            else {
              let { cell: Be } = Ae[oe - 1];
              Be.insertAfter(de);
            }
        }
        oe = Z.getChildAtIndex(ie), t.DEPRECATED_$isGridRowNode(oe) || M(123, String(ie)), oe.remove();
      }
      Ae !== void 0 ? ({ cell: y } = Ae[0], U(y)) : ({ cell: y } = ce[y - 1][0], U(y));
    }
  }, zt.$getElementGridForTableNode = function(m, y) {
    if (m = m.getElementByKey(y.getKey()), m == null)
      throw Error("Table Element Not Found");
    return P(m);
  }, zt.$getTableCellNodeFromLexicalNode = function(m) {
    return m = e.$findMatchingParent(m, (y) => p(y)), p(m) ? m : null;
  }, zt.$getTableColumnIndexFromTableCellNode = function(m) {
    return V(m).getChildren().findIndex((y) => y.is(m));
  }, zt.$getTableNodeFromLexicalNodeOrThrow = ne, zt.$getTableRowIndexFromTableCellNode = function(m) {
    let y = V(m);
    return ne(y).getChildren().findIndex((b) => b.is(y));
  }, zt.$getTableRowNodeFromTableCellNodeOrThrow = V, zt.$insertTableColumn = function(m, y, b = !0, Z, ce) {
    let ge = m.getChildren(), ae = [];
    for (let ze = 0; ze < ge.length; ze++) {
      let oe = ge[ze];
      if (O(oe))
        for (let ie = 0; ie < Z; ie++) {
          var Te = oe.getChildren();
          if (y >= Te.length || 0 > y)
            throw Error("Table column target index out of range");
          Te = Te[y], p(Te) || M(12);
          let { left: de, right: we } = Y(Te, ce);
          var Ae = r.NO_STATUS;
          (de && de.hasHeaderState(r.ROW) || we && we.hasHeaderState(r.ROW)) && (Ae |= r.ROW), Ae = h(Ae), Ae.append(t.$createParagraphNode()), ae.push({ newTableCell: Ae, targetCell: Te });
        }
    }
    return ae.forEach(({ newTableCell: ze, targetCell: oe }) => {
      b ? oe.insertAfter(ze) : oe.insertBefore(ze);
    }), m;
  }, zt.$insertTableColumn__EXPERIMENTAL = function(m = !0) {
    function y() {
      let ie = h(r.NO_STATUS).append(t.$createParagraphNode());
      return ze === null && (ze = ie), ie;
    }
    var b = t.$getSelection();
    if (!t.$INTERNAL_isPointSelection(b))
      throw Error("Expected a PointSeleciton");
    var Z = b.anchor.getNode();
    b = b.focus.getNode(), [Z] = t.DEPRECATED_$getNodeTriplet(Z);
    let [ce, , ge] = t.DEPRECATED_$getNodeTriplet(b), [ae, Te, Ae] = t.DEPRECATED_$computeGridMap(ge, ce, Z);
    Z = ae.length, b = m ? Math.max(Te.startColumn, Ae.startColumn) : Math.min(Te.startColumn, Ae.startColumn), m = m ? b + ce.__colSpan - 1 : b - 1, b = ge.getFirstChild(), t.DEPRECATED_$isGridRowNode(b) || M(120);
    let ze = null;
    var oe = b;
    e:
      for (b = 0; b < Z; b++) {
        b !== 0 && (oe = oe.getNextSibling(), t.DEPRECATED_$isGridRowNode(oe) || M(121));
        let ie = ae[b];
        if (0 > m) {
          Q(oe, y());
          continue;
        }
        let { cell: de, startColumn: we, startRow: ke } = ie[m];
        if (we + de.__colSpan - 1 <= m) {
          let Be = de, Ye = ke, lt = m;
          for (; Ye !== b && 1 < Be.__rowSpan; )
            if (lt -= de.__colSpan, 0 <= lt) {
              let { cell: _t, startRow: ct } = ie[lt];
              Be = _t, Ye = ct;
            } else {
              oe.append(y());
              continue e;
            }
          Be.insertAfter(y());
        } else
          de.setColSpan(de.__colSpan + 1);
      }
    ze !== null && U(ze);
  }, zt.$insertTableRow = function(m, y, b = !0, Z, ce) {
    var ge = m.getChildren();
    if (y >= ge.length || 0 > y)
      throw Error("Table row target index out of range");
    if (y = ge[y], O(y))
      for (ge = 0; ge < Z; ge++) {
        let Te = y.getChildren(), Ae = Te.length, ze = v();
        for (let oe = 0; oe < Ae; oe++) {
          var ae = Te[oe];
          p(ae) || M(12);
          let { above: ie, below: de } = Y(ae, ce);
          ae = r.NO_STATUS;
          let we = ie && ie.getWidth() || de && de.getWidth() || void 0;
          (ie && ie.hasHeaderState(r.COLUMN) || de && de.hasHeaderState(r.COLUMN)) && (ae |= r.COLUMN), ae = h(ae, 1, we), ae.append(t.$createParagraphNode()), ze.append(ae);
        }
        b ? y.insertAfter(ze) : y.insertBefore(ze);
      }
    else
      throw Error("Row before insertion index does not exist.");
    return m;
  }, zt.$insertTableRow__EXPERIMENTAL = function(m = !0) {
    var y = t.$getSelection();
    if (!t.$INTERNAL_isPointSelection(y))
      throw Error("Expected a INTERNAL_PointSelection");
    y = y.focus.getNode();
    let [b, , Z] = t.DEPRECATED_$getNodeTriplet(y), [ce, ge] = t.DEPRECATED_$computeGridMap(Z, b, b);
    y = ce[0].length;
    var { startRow: ae } = ge;
    if (m) {
      m = ae + b.__rowSpan - 1;
      var Te = ce[m];
      ae = v();
      for (var Ae = 0; Ae < y; Ae++) {
        let { cell: ze, startRow: oe } = Te[Ae];
        oe + ze.__rowSpan - 1 <= m ? ae.append(h(r.NO_STATUS)) : ze.setRowSpan(ze.__rowSpan + 1);
      }
      y = Z.getChildAtIndex(m), t.DEPRECATED_$isGridRowNode(y) || M(119), y.insertAfter(ae);
    } else {
      for (Te = ce[ae], m = v(), Ae = 0; Ae < y; Ae++) {
        let { cell: ze, startRow: oe } = Te[Ae];
        oe === ae ? m.append(h(r.NO_STATUS)) : ze.setRowSpan(ze.__rowSpan + 1);
      }
      y = Z.getChildAtIndex(ae), t.DEPRECATED_$isGridRowNode(y) || M(119), y.insertBefore(m);
    }
  }, zt.$isTableCellNode = p, zt.$isTableNode = D, zt.$isTableRowNode = O, zt.$removeTableRowAtIndex = function(m, y) {
    let b = m.getChildren();
    if (y >= b.length || 0 > y)
      throw Error("Expected table cell to be inside of table row.");
    return b[y].remove(), m;
  }, zt.$unmergeCell = function() {
    var m = t.$getSelection();
    if (!t.$INTERNAL_isPointSelection(m))
      throw Error("Expected a INTERNAL_PointSelection");
    m = m.anchor.getNode();
    let [y, b, Z] = t.DEPRECATED_$getNodeTriplet(m);
    m = y.__colSpan;
    let ce = y.__rowSpan;
    if (1 < m) {
      for (var ge = 1; ge < m; ge++)
        y.insertAfter(h(r.NO_STATUS));
      y.setColSpan(1);
    }
    if (1 < ce) {
      let [Ae, ze] = t.DEPRECATED_$computeGridMap(Z, y, y), { startColumn: oe, startRow: ie } = ze, de;
      for (ge = 1; ge < ce; ge++) {
        var ae = ie + ge;
        let we = Ae[ae];
        de = (de || b).getNextSibling(), t.DEPRECATED_$isGridRowNode(de) || M(125);
        var Te = null;
        for (let ke = 0; ke < oe; ke++) {
          let Be = we[ke], Ye = Be.cell;
          Be.startRow === ae && (Te = Ye), 1 < Ye.__colSpan && (ke += Ye.__colSpan - 1);
        }
        if (Te === null)
          for (Te = 0; Te < m; Te++)
            Q(de, h(r.NO_STATUS));
        else
          for (ae = 0; ae < m; ae++)
            Te.insertAfter(h(r.NO_STATUS));
      }
      y.setRowSpan(1);
    }
  }, zt.INSERT_TABLE_COMMAND = k, zt.TableCellHeaderStates = r, zt.TableCellNode = c, zt.TableNode = J, zt.TableRowNode = N, zt.TableSelection = T, zt.applyTableHandlers = function(m, y, b, Z) {
    function ce(oe) {
      return oe = m.getCordsFromCellNode(oe, ae.grid), m.getCellFromCordsOrThrow(oe.x, oe.y, ae.grid);
    }
    let ge = b.getRootElement();
    if (ge === null)
      throw Error("No root element.");
    let ae = new T(b, m.getKey()), Te = b._window || window;
    y.__lexicalTableSelection = ae, y.addEventListener("mousedown", (oe) => {
      setTimeout(() => {
        if (oe.button === 0 && Te) {
          var ie = w(oe.target);
          ie !== null && (pe(oe), ae.setAnchorCellForSelection(ie));
          var de = () => {
            Te.removeEventListener("mouseup", de), Te.removeEventListener(
              "mousemove",
              we
            );
          }, we = (ke) => {
            const Be = w(ke.target);
            Be === null || ae.anchorX === Be.x && ae.anchorY === Be.y || (ke.preventDefault(), ae.setFocusCellForSelection(Be));
          };
          Te.addEventListener("mouseup", de), Te.addEventListener("mousemove", we);
        }
      }, 0);
    });
    let Ae = (oe) => {
      oe.button === 0 && b.update(() => {
        const ie = t.$getSelection(), de = oe.target;
        t.DEPRECATED_$isGridSelection(ie) && ie.gridKey === ae.tableNodeKey && ge.contains(de) && ae.clearHighlight();
      });
    };
    Te.addEventListener("mousedown", Ae), ae.listenersToRemove.add(() => Te.removeEventListener("mousedown", Ae)), ae.listenersToRemove.add(b.registerCommand(
      t.KEY_ARROW_DOWN_COMMAND,
      (oe) => _e(b, oe, "down", m, ae),
      t.COMMAND_PRIORITY_HIGH
    )), ae.listenersToRemove.add(b.registerCommand(t.KEY_ARROW_UP_COMMAND, (oe) => _e(b, oe, "up", m, ae), t.COMMAND_PRIORITY_HIGH)), ae.listenersToRemove.add(b.registerCommand(t.KEY_ARROW_LEFT_COMMAND, (oe) => _e(b, oe, "backward", m, ae), t.COMMAND_PRIORITY_HIGH)), ae.listenersToRemove.add(b.registerCommand(t.KEY_ARROW_RIGHT_COMMAND, (oe) => _e(b, oe, "forward", m, ae), t.COMMAND_PRIORITY_HIGH)), ae.listenersToRemove.add(b.registerCommand(t.KEY_ESCAPE_COMMAND, (oe) => {
      var ie = t.$getSelection();
      return t.DEPRECATED_$isGridSelection(ie) && (ie = e.$findMatchingParent(ie.focus.getNode(), p), p(ie)) ? (pe(oe), ie.selectEnd(), !0) : !1;
    }, t.COMMAND_PRIORITY_HIGH));
    let ze = (oe) => () => {
      var ie = t.$getSelection();
      if (!re(ie, m))
        return !1;
      if (t.DEPRECATED_$isGridSelection(ie))
        return ae.clearText(), !0;
      if (t.$isRangeSelection(ie)) {
        const ke = e.$findMatchingParent(ie.anchor.getNode(), (Be) => p(Be));
        if (!p(ke))
          return !1;
        var de = ie.anchor.getNode(), we = ie.focus.getNode();
        if (de = m.isParentOf(de), we = m.isParentOf(we), de && !we || we && !de)
          return ae.clearText(), !0;
        if (de = (we = e.$findMatchingParent(ie.anchor.getNode(), (Be) => t.$isElementNode(Be))) && e.$findMatchingParent(we, (Be) => t.$isElementNode(Be) && p(Be.getParent())), !t.$isElementNode(de) || !t.$isElementNode(we))
          return !1;
        if (oe === t.DELETE_LINE_COMMAND && de.getPreviousSibling() === null)
          return !0;
        if ((oe === t.DELETE_CHARACTER_COMMAND || oe === t.DELETE_WORD_COMMAND) && ie.isCollapsed() && ie.anchor.offset === 0 && we !== de) {
          ie = we.getChildren();
          const Be = t.$createParagraphNode();
          return ie.forEach((Ye) => Be.append(Ye)), we.replace(Be), we.getWritable().__parent = ke.getKey(), !0;
        }
      }
      return !1;
    };
    return [t.DELETE_WORD_COMMAND, t.DELETE_LINE_COMMAND, t.DELETE_CHARACTER_COMMAND].forEach((oe) => {
      ae.listenersToRemove.add(b.registerCommand(oe, ze(oe), t.COMMAND_PRIORITY_CRITICAL));
    }), y = (oe) => {
      const ie = t.$getSelection();
      return re(ie, m) ? t.DEPRECATED_$isGridSelection(ie) ? (oe.preventDefault(), oe.stopPropagation(), ae.clearText(), !0) : (t.$isRangeSelection(ie) && (oe = e.$findMatchingParent(ie.anchor.getNode(), (de) => p(de)), p(oe)), !1) : !1;
    }, ae.listenersToRemove.add(b.registerCommand(t.KEY_BACKSPACE_COMMAND, y, t.COMMAND_PRIORITY_CRITICAL)), ae.listenersToRemove.add(b.registerCommand(t.KEY_DELETE_COMMAND, y, t.COMMAND_PRIORITY_CRITICAL)), ae.listenersToRemove.add(b.registerCommand(t.FORMAT_TEXT_COMMAND, (oe) => {
      let ie = t.$getSelection();
      return re(ie, m) ? t.DEPRECATED_$isGridSelection(ie) ? (ae.formatCells(oe), !0) : (t.$isRangeSelection(ie) && (oe = e.$findMatchingParent(ie.anchor.getNode(), (de) => p(de)), p(oe)), !1) : !1;
    }, t.COMMAND_PRIORITY_CRITICAL)), ae.listenersToRemove.add(b.registerCommand(t.CONTROLLED_TEXT_INSERTION_COMMAND, () => {
      var oe = t.$getSelection();
      return re(oe, m) && (t.DEPRECATED_$isGridSelection(oe) ? ae.clearHighlight() : t.$isRangeSelection(oe) && (oe = e.$findMatchingParent(oe.anchor.getNode(), (ie) => p(ie)), p(oe))), !1;
    }, t.COMMAND_PRIORITY_CRITICAL)), Z && ae.listenersToRemove.add(b.registerCommand(t.KEY_TAB_COMMAND, (oe) => {
      var ie = t.$getSelection();
      return !t.$isRangeSelection(ie) || !ie.isCollapsed() || !re(ie, m) || (ie = G(ie.anchor.getNode()), ie === null) ? !1 : (pe(oe), ie = m.getCordsFromCellNode(ie, ae.grid), z(ae, m, ie.x, ie.y, oe.shiftKey ? "backward" : "forward"), !0);
    }, t.COMMAND_PRIORITY_CRITICAL)), ae.listenersToRemove.add(b.registerCommand(
      t.FOCUS_COMMAND,
      () => m.isSelected(),
      t.COMMAND_PRIORITY_HIGH
    )), ae.listenersToRemove.add(b.registerCommand(t.SELECTION_CHANGE_COMMAND, () => {
      let oe = t.$getSelection(), ie = t.$getPreviousSelection();
      if (t.$isRangeSelection(oe)) {
        let { anchor: Ye, focus: lt } = oe;
        var de = Ye.getNode(), we = lt.getNode();
        de = G(de), we = G(we);
        var ke = de && m.is(j(de)), Be = we && m.is(j(we));
        let _t = ke !== Be;
        Be = ke && Be, ke = oe.isBackward(), _t ? (de = oe.clone(), de.focus.set(m.getKey(), ke ? 0 : m.getChildrenSize(), "element"), t.$setSelection(de), W(b, ae)) : Be && !de.is(we) && (ae.setAnchorCellForSelection(ce(de)), ae.setFocusCellForSelection(
          ce(we),
          !0
        ));
      }
      return oe && !oe.is(ie) && (t.DEPRECATED_$isGridSelection(oe) || t.DEPRECATED_$isGridSelection(ie)) && ae.gridSelection && !ae.gridSelection.is(ie) ? (t.DEPRECATED_$isGridSelection(oe) && oe.gridKey === ae.tableNodeKey ? ae.updateTableGridSelection(oe) : !t.DEPRECATED_$isGridSelection(oe) && t.DEPRECATED_$isGridSelection(ie) && ie.gridKey === ae.tableNodeKey && ae.updateTableGridSelection(null), !1) : (ae.hasHijackedSelectionStyles && !m.isSelected() ? H(b, ae) : !ae.hasHijackedSelectionStyles && m.isSelected() && W(b, ae), !1);
    }, t.COMMAND_PRIORITY_CRITICAL)), ae;
  }, zt.getCellFromTarget = w, zt.getTableSelectionFromTableElement = function(m) {
    return m.__lexicalTableSelection;
  }, zt;
}
var Gt = {}, ph;
function ZN() {
  if (ph)
    return Gt;
  ph = 1;
  var t = Bt(), e = rn();
  const n = /^(\d+(?:\.\d+)?)px$/, r = {
    BOTH: 3,
    COLUMN: 2,
    NO_STATUS: 0,
    ROW: 1
  };
  class c extends t.DEPRECATED_GridCellNode {
    /** @internal */
    /** @internal */
    /** @internal */
    static getType() {
      return "tablecell";
    }
    static clone(se) {
      const he = new c(se.__headerState, se.__colSpan, se.__width, se.__key);
      return he.__rowSpan = se.__rowSpan, he.__backgroundColor = se.__backgroundColor, he;
    }
    static importDOM() {
      return {
        td: (se) => ({
          conversion: d,
          priority: 0
        }),
        th: (se) => ({
          conversion: d,
          priority: 0
        })
      };
    }
    static importJSON(se) {
      const he = se.colSpan || 1, Oe = se.rowSpan || 1, Me = h(se.headerState, he, se.width || void 0);
      return Me.__rowSpan = Oe, Me.__backgroundColor = se.backgroundColor || null, Me;
    }
    constructor(se = r.NO_STATUS, he = 1, Oe, Me) {
      super(he, Me), this.__headerState = se, this.__width = Oe, this.__backgroundColor = null;
    }
    createDOM(se) {
      const he = document.createElement(this.getTag());
      return this.__width && (he.style.width = `${this.__width}px`), this.__colSpan > 1 && (he.colSpan = this.__colSpan), this.__rowSpan > 1 && (he.rowSpan = this.__rowSpan), this.__backgroundColor !== null && (he.style.backgroundColor = this.__backgroundColor), e.addClassNamesToElement(he, se.theme.tableCell, this.hasHeader() && se.theme.tableCellHeader), he;
    }
    exportDOM(se) {
      const {
        element: he
      } = super.exportDOM(se);
      if (he) {
        const Oe = he, Me = 700, De = this.getParentOrThrow().getChildrenSize();
        Oe.style.border = "1px solid black", this.__colSpan > 1 && (Oe.colSpan = this.__colSpan), this.__rowSpan > 1 && (Oe.rowSpan = this.__rowSpan), Oe.style.width = `${this.getWidth() || Math.max(90, Me / De)}px`, Oe.style.verticalAlign = "top", Oe.style.textAlign = "start";
        const We = this.getBackgroundColor();
        We !== null ? Oe.style.backgroundColor = We : this.hasHeader() && (Oe.style.backgroundColor = "#f2f3f5");
      }
      return {
        element: he
      };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        backgroundColor: this.getBackgroundColor(),
        headerState: this.__headerState,
        type: "tablecell",
        width: this.getWidth()
      };
    }
    getTag() {
      return this.hasHeader() ? "th" : "td";
    }
    setHeaderStyles(se) {
      const he = this.getWritable();
      return he.__headerState = se, this.__headerState;
    }
    getHeaderStyles() {
      return this.getLatest().__headerState;
    }
    setWidth(se) {
      const he = this.getWritable();
      return he.__width = se, this.__width;
    }
    getWidth() {
      return this.getLatest().__width;
    }
    getBackgroundColor() {
      return this.getLatest().__backgroundColor;
    }
    setBackgroundColor(se) {
      this.getWritable().__backgroundColor = se;
    }
    toggleHeaderStyle(se) {
      const he = this.getWritable();
      return (he.__headerState & se) === se ? he.__headerState -= se : he.__headerState += se, he;
    }
    hasHeaderState(se) {
      return (this.getHeaderStyles() & se) === se;
    }
    hasHeader() {
      return this.getLatest().__headerState !== r.NO_STATUS;
    }
    updateDOM(se) {
      return se.__headerState !== this.__headerState || se.__width !== this.__width || se.__colSpan !== this.__colSpan || se.__rowSpan !== this.__rowSpan || se.__backgroundColor !== this.__backgroundColor;
    }
    isShadowRoot() {
      return !0;
    }
    collapseAtStart() {
      return !0;
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
  }
  function d(ve) {
    const se = ve, he = ve.nodeName.toLowerCase();
    let Oe;
    n.test(se.style.width) && (Oe = parseFloat(se.style.width));
    const Me = h(he === "th" ? r.ROW : r.NO_STATUS, se.colSpan, Oe);
    Me.__rowSpan = se.rowSpan;
    const De = se.style.backgroundColor;
    return De !== "" && (Me.__backgroundColor = De), {
      forChild: (We, qe) => {
        if (p(qe) && !t.$isElementNode(We)) {
          const Qe = t.$createParagraphNode();
          return t.$isLineBreakNode(We) && We.getTextContent() === `
` ? null : (Qe.append(We), Qe);
        }
        return We;
      },
      node: Me
    };
  }
  function h(ve, se = 1, he) {
    return t.$applyNodeReplacement(new c(ve, se, he));
  }
  function p(ve) {
    return ve instanceof c;
  }
  class N extends t.DEPRECATED_GridRowNode {
    /** @internal */
    static getType() {
      return "tablerow";
    }
    static clone(se) {
      return new N(se.__height, se.__key);
    }
    static importDOM() {
      return {
        tr: (se) => ({
          conversion: x,
          priority: 0
        })
      };
    }
    static importJSON(se) {
      return v(se.height);
    }
    constructor(se, he) {
      super(he), this.__height = se;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "tablerow",
        version: 1
      };
    }
    createDOM(se) {
      const he = document.createElement("tr");
      return this.__height && (he.style.height = `${this.__height}px`), e.addClassNamesToElement(he, se.theme.tableRow), he;
    }
    isShadowRoot() {
      return !0;
    }
    setHeight(se) {
      const he = this.getWritable();
      return he.__height = se, this.__height;
    }
    getHeight() {
      return this.getLatest().__height;
    }
    updateDOM(se) {
      return se.__height !== this.__height;
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
  }
  function x(ve) {
    const se = ve;
    let he;
    return n.test(se.style.height) && (he = parseFloat(se.style.height)), {
      node: v(he)
    };
  }
  function v(ve) {
    return t.$applyNodeReplacement(new N(ve));
  }
  function O(ve) {
    return ve instanceof N;
  }
  const M = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", A = (ve) => M ? (ve || window).getSelection() : null;
  class T {
    constructor(se, he) {
      this.isHighlightingCells = !1, this.anchorX = -1, this.anchorY = -1, this.focusX = -1, this.focusY = -1, this.listenersToRemove = /* @__PURE__ */ new Set(), this.tableNodeKey = he, this.editor = se, this.grid = {
        cells: [],
        columns: 0,
        rows: 0
      }, this.gridSelection = null, this.anchorCellNodeKey = null, this.focusCellNodeKey = null, this.anchorCell = null, this.focusCell = null, this.hasHijackedSelectionStyles = !1, this.trackTableGrid();
    }
    getGrid() {
      return this.grid;
    }
    removeListeners() {
      Array.from(this.listenersToRemove).forEach((se) => se());
    }
    trackTableGrid() {
      const se = new MutationObserver((he) => {
        this.editor.update(() => {
          let Oe = !1;
          for (let De = 0; De < he.length; De++) {
            const Qe = he[De].target.nodeName;
            if (Qe === "TABLE" || Qe === "TR") {
              Oe = !0;
              break;
            }
          }
          if (!Oe)
            return;
          const Me = this.editor.getElementByKey(this.tableNodeKey);
          if (!Me)
            throw new Error("Expected to find TableElement in DOM");
          this.grid = H(Me);
        });
      });
      this.editor.update(() => {
        const he = this.editor.getElementByKey(this.tableNodeKey);
        if (!he)
          throw new Error("Expected to find TableElement in DOM");
        this.grid = H(he), se.observe(he, {
          childList: !0,
          subtree: !0
        });
      });
    }
    clearHighlight() {
      const se = this.editor;
      this.isHighlightingCells = !1, this.anchorX = -1, this.anchorY = -1, this.focusX = -1, this.focusY = -1, this.gridSelection = null, this.anchorCellNodeKey = null, this.focusCellNodeKey = null, this.anchorCell = null, this.focusCell = null, this.hasHijackedSelectionStyles = !1, this.enableHighlightStyle(), se.update(() => {
        const he = t.$getNodeByKey(this.tableNodeKey);
        if (!m(he))
          throw new Error("Expected TableNode.");
        const Oe = se.getElementByKey(this.tableNodeKey);
        if (!Oe)
          throw new Error("Expected to find TableElement in DOM");
        const Me = H(Oe);
        z(se, Me, null), t.$setSelection(null), se.dispatchCommand(t.SELECTION_CHANGE_COMMAND, void 0);
      });
    }
    enableHighlightStyle() {
      const se = this.editor;
      se.update(() => {
        const he = se.getElementByKey(this.tableNodeKey);
        if (!he)
          throw new Error("Expected to find TableElement in DOM");
        e.removeClassNamesFromElement(he, se._config.theme.tableSelection), he.classList.remove("disable-selection"), this.hasHijackedSelectionStyles = !1;
      });
    }
    disableHighlightStyle() {
      const se = this.editor;
      se.update(() => {
        const he = se.getElementByKey(this.tableNodeKey);
        if (!he)
          throw new Error("Expected to find TableElement in DOM");
        e.addClassNamesToElement(he, se._config.theme.tableSelection), this.hasHijackedSelectionStyles = !0;
      });
    }
    updateTableGridSelection(se) {
      if (se != null && se.gridKey === this.tableNodeKey) {
        const he = this.editor;
        this.gridSelection = se, this.isHighlightingCells = !0, this.disableHighlightStyle(), z(he, this.grid, this.gridSelection);
      } else
        se == null ? this.clearHighlight() : (this.tableNodeKey = se.gridKey, this.updateTableGridSelection(se));
    }
    setFocusCellForSelection(se, he = !1) {
      const Oe = this.editor;
      Oe.update(() => {
        const Me = t.$getNodeByKey(this.tableNodeKey);
        if (!m(Me))
          throw new Error("Expected TableNode.");
        if (!Oe.getElementByKey(this.tableNodeKey))
          throw new Error("Expected to find TableElement in DOM");
        const We = se.x, qe = se.y;
        if (this.focusCell = se, this.anchorCell !== null) {
          const Qe = A(Oe._window);
          Qe && Qe.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);
        }
        if (!this.isHighlightingCells && (this.anchorX !== We || this.anchorY !== qe || he))
          this.isHighlightingCells = !0, this.disableHighlightStyle();
        else if (We === this.focusX && qe === this.focusY)
          return;
        if (this.focusX = We, this.focusY = qe, this.isHighlightingCells) {
          const Qe = t.$getNearestNodeFromDOMNode(se.elem);
          if (this.gridSelection != null && this.anchorCellNodeKey != null && p(Qe)) {
            const ut = Qe.getKey();
            this.gridSelection = this.gridSelection.clone() || t.DEPRECATED_$createGridSelection(), this.focusCellNodeKey = ut, this.gridSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey), t.$setSelection(this.gridSelection), Oe.dispatchCommand(t.SELECTION_CHANGE_COMMAND, void 0), z(Oe, this.grid, this.gridSelection);
          }
        }
      });
    }
    setAnchorCellForSelection(se) {
      this.isHighlightingCells = !1, this.anchorCell = se, this.anchorX = se.x, this.anchorY = se.y, this.editor.update(() => {
        const he = t.$getNearestNodeFromDOMNode(se.elem);
        if (p(he)) {
          const Oe = he.getKey();
          this.gridSelection = this.gridSelection != null ? this.gridSelection.clone() : t.DEPRECATED_$createGridSelection(), this.anchorCellNodeKey = Oe;
        }
      });
    }
    formatCells(se) {
      this.editor.update(() => {
        const he = t.$getSelection();
        if (!t.DEPRECATED_$isGridSelection(he))
          throw Error("Expected grid selection");
        const Oe = t.$createRangeSelection(), Me = Oe.anchor, De = Oe.focus;
        he.getNodes().forEach((We) => {
          p(We) && We.getTextContentSize() !== 0 && (Me.set(We.getKey(), 0, "element"), De.set(We.getKey(), We.getChildrenSize(), "element"), Oe.formatText(se));
        }), t.$setSelection(he), this.editor.dispatchCommand(t.SELECTION_CHANGE_COMMAND, void 0);
      });
    }
    clearText() {
      const se = this.editor;
      se.update(() => {
        const he = t.$getNodeByKey(this.tableNodeKey);
        if (!m(he))
          throw new Error("Expected TableNode.");
        const Oe = t.$getSelection();
        if (!t.DEPRECATED_$isGridSelection(Oe))
          throw Error("Expected grid selection");
        const Me = Oe.getNodes().filter(p);
        if (Me.length === this.grid.columns * this.grid.rows) {
          he.selectPrevious(), he.remove(), t.$getRoot().selectStart();
          return;
        }
        Me.forEach((De) => {
          if (t.$isElementNode(De)) {
            const We = t.$createParagraphNode(), qe = t.$createTextNode();
            We.append(qe), De.append(We), De.getChildren().forEach((Qe) => {
              Qe !== We && Qe.remove();
            });
          }
        }), z(se, this.grid, null), t.$setSelection(null), se.dispatchCommand(t.SELECTION_CHANGE_COMMAND, void 0);
      });
    }
  }
  const w = "__lexicalTableSelection";
  function P(ve, se, he, Oe) {
    const Me = he.getRootElement();
    if (Me === null)
      throw new Error("No root element.");
    const De = new T(he, ve.getKey()), We = he._window || window;
    K(se, De), se.addEventListener("mousedown", (Ve) => {
      setTimeout(() => {
        if (Ve.button !== 0 || !We)
          return;
        const je = W(Ve.target);
        je !== null && (ne(Ve), De.setAnchorCellForSelection(je));
        const nt = () => {
          We.removeEventListener("mouseup", nt), We.removeEventListener("mousemove", mt);
        }, mt = (Ct) => {
          const vt = W(Ct.target);
          vt !== null && (De.anchorX !== vt.x || De.anchorY !== vt.y) && (Ct.preventDefault(), De.setFocusCellForSelection(vt));
        };
        We.addEventListener("mouseup", nt), We.addEventListener("mousemove", mt);
      }, 0);
    });
    const qe = (Ve) => {
      Ve.button === 0 && he.update(() => {
        const je = t.$getSelection(), nt = Ve.target;
        t.DEPRECATED_$isGridSelection(je) && je.gridKey === De.tableNodeKey && Me.contains(nt) && De.clearHighlight();
      });
    };
    We.addEventListener("mousedown", qe), De.listenersToRemove.add(() => We.removeEventListener("mousedown", qe)), De.listenersToRemove.add(he.registerCommand(t.KEY_ARROW_DOWN_COMMAND, (Ve) => V(he, Ve, "down", ve, De), t.COMMAND_PRIORITY_HIGH)), De.listenersToRemove.add(he.registerCommand(t.KEY_ARROW_UP_COMMAND, (Ve) => V(he, Ve, "up", ve, De), t.COMMAND_PRIORITY_HIGH)), De.listenersToRemove.add(he.registerCommand(t.KEY_ARROW_LEFT_COMMAND, (Ve) => V(he, Ve, "backward", ve, De), t.COMMAND_PRIORITY_HIGH)), De.listenersToRemove.add(he.registerCommand(t.KEY_ARROW_RIGHT_COMMAND, (Ve) => V(he, Ve, "forward", ve, De), t.COMMAND_PRIORITY_HIGH)), De.listenersToRemove.add(he.registerCommand(t.KEY_ESCAPE_COMMAND, (Ve) => {
      const je = t.$getSelection();
      if (t.DEPRECATED_$isGridSelection(je)) {
        const nt = e.$findMatchingParent(je.focus.getNode(), p);
        if (p(nt))
          return ne(Ve), nt.selectEnd(), !0;
      }
      return !1;
    }, t.COMMAND_PRIORITY_HIGH));
    const Qe = (Ve) => () => {
      const je = t.$getSelection();
      if (!j(je, ve))
        return !1;
      if (t.DEPRECATED_$isGridSelection(je))
        return De.clearText(), !0;
      if (t.$isRangeSelection(je)) {
        const nt = e.$findMatchingParent(je.anchor.getNode(), (Mt) => p(Mt));
        if (!p(nt))
          return !1;
        const mt = je.anchor.getNode(), Ct = je.focus.getNode(), vt = ve.isParentOf(mt), wt = ve.isParentOf(Ct);
        if (vt && !wt || wt && !vt)
          return De.clearText(), !0;
        const Tt = e.$findMatchingParent(je.anchor.getNode(), (Mt) => t.$isElementNode(Mt)), Xt = Tt && e.$findMatchingParent(Tt, (Mt) => t.$isElementNode(Mt) && p(Mt.getParent()));
        if (!t.$isElementNode(Xt) || !t.$isElementNode(Tt))
          return !1;
        if (Ve === t.DELETE_LINE_COMMAND && Xt.getPreviousSibling() === null)
          return !0;
        if ((Ve === t.DELETE_CHARACTER_COMMAND || Ve === t.DELETE_WORD_COMMAND) && je.isCollapsed() && je.anchor.offset === 0 && Tt !== Xt) {
          const Mt = Tt.getChildren(), Ut = t.$createParagraphNode();
          return Mt.forEach((Lt) => Ut.append(Lt)), Tt.replace(Ut), Tt.getWritable().__parent = nt.getKey(), !0;
        }
      }
      return !1;
    };
    [t.DELETE_WORD_COMMAND, t.DELETE_LINE_COMMAND, t.DELETE_CHARACTER_COMMAND].forEach((Ve) => {
      De.listenersToRemove.add(he.registerCommand(Ve, Qe(Ve), t.COMMAND_PRIORITY_CRITICAL));
    });
    const ut = (Ve) => {
      const je = t.$getSelection();
      if (!j(je, ve))
        return !1;
      if (t.DEPRECATED_$isGridSelection(je))
        return Ve.preventDefault(), Ve.stopPropagation(), De.clearText(), !0;
      if (t.$isRangeSelection(je)) {
        const nt = e.$findMatchingParent(je.anchor.getNode(), (mt) => p(mt));
        if (!p(nt))
          return !1;
      }
      return !1;
    };
    De.listenersToRemove.add(he.registerCommand(t.KEY_BACKSPACE_COMMAND, ut, t.COMMAND_PRIORITY_CRITICAL)), De.listenersToRemove.add(he.registerCommand(t.KEY_DELETE_COMMAND, ut, t.COMMAND_PRIORITY_CRITICAL)), De.listenersToRemove.add(he.registerCommand(t.FORMAT_TEXT_COMMAND, (Ve) => {
      const je = t.$getSelection();
      if (!j(je, ve))
        return !1;
      if (t.DEPRECATED_$isGridSelection(je))
        return De.formatCells(Ve), !0;
      if (t.$isRangeSelection(je)) {
        const nt = e.$findMatchingParent(je.anchor.getNode(), (mt) => p(mt));
        if (!p(nt))
          return !1;
      }
      return !1;
    }, t.COMMAND_PRIORITY_CRITICAL)), De.listenersToRemove.add(he.registerCommand(t.CONTROLLED_TEXT_INSERTION_COMMAND, (Ve) => {
      const je = t.$getSelection();
      if (!j(je, ve))
        return !1;
      if (t.DEPRECATED_$isGridSelection(je))
        return De.clearHighlight(), !1;
      if (t.$isRangeSelection(je)) {
        const nt = e.$findMatchingParent(je.anchor.getNode(), (mt) => p(mt));
        if (!p(nt))
          return !1;
      }
      return !1;
    }, t.COMMAND_PRIORITY_CRITICAL)), Oe && De.listenersToRemove.add(he.registerCommand(t.KEY_TAB_COMMAND, (Ve) => {
      const je = t.$getSelection();
      if (!t.$isRangeSelection(je) || !je.isCollapsed() || !j(je, ve))
        return !1;
      const nt = F(je.anchor.getNode());
      if (nt === null)
        return !1;
      ne(Ve);
      const mt = ve.getCordsFromCellNode(nt, De.grid);
      return q(De, ve, mt.x, mt.y, Ve.shiftKey ? "backward" : "forward"), !0;
    }, t.COMMAND_PRIORITY_CRITICAL)), De.listenersToRemove.add(he.registerCommand(t.FOCUS_COMMAND, (Ve) => ve.isSelected(), t.COMMAND_PRIORITY_HIGH));
    function kt(Ve) {
      const je = ve.getCordsFromCellNode(Ve, De.grid);
      return ve.getCellFromCordsOrThrow(je.x, je.y, De.grid);
    }
    return De.listenersToRemove.add(he.registerCommand(t.SELECTION_CHANGE_COMMAND, () => {
      const Ve = t.$getSelection(), je = t.$getPreviousSelection();
      if (t.$isRangeSelection(Ve)) {
        const {
          anchor: nt,
          focus: mt
        } = Ve, Ct = nt.getNode(), vt = mt.getNode(), wt = F(Ct), Dt = F(vt), Tt = wt && ve.is(D(wt)), Xt = Dt && ve.is(D(Dt)), Mt = Tt !== Xt, Ut = Tt && Xt, Lt = Ve.isBackward();
        if (Mt) {
          const mr = Ve.clone();
          mr.focus.set(ve.getKey(), Lt ? 0 : ve.getChildrenSize(), "element"), t.$setSelection(mr), re(he, De);
        } else
          Ut && (wt.is(Dt) || (De.setAnchorCellForSelection(kt(wt)), De.setFocusCellForSelection(kt(Dt), !0)));
      }
      return Ve && !Ve.is(je) && (t.DEPRECATED_$isGridSelection(Ve) || t.DEPRECATED_$isGridSelection(je)) && De.gridSelection && !De.gridSelection.is(je) ? (t.DEPRECATED_$isGridSelection(Ve) && Ve.gridKey === De.tableNodeKey ? De.updateTableGridSelection(Ve) : !t.DEPRECATED_$isGridSelection(Ve) && t.DEPRECATED_$isGridSelection(je) && je.gridKey === De.tableNodeKey && De.updateTableGridSelection(null), !1) : (De.hasHijackedSelectionStyles && !ve.isSelected() ? ue(he, De) : !De.hasHijackedSelectionStyles && ve.isSelected() && re(he, De), !1);
    }, t.COMMAND_PRIORITY_CRITICAL)), De;
  }
  function K(ve, se) {
    ve[w] = se;
  }
  function $(ve) {
    return ve[w];
  }
  function W(ve) {
    let se = ve;
    for (; se != null; ) {
      const he = se.nodeName;
      if (he === "TD" || he === "TH") {
        const Oe = se._cell;
        return Oe === void 0 ? null : Oe;
      }
      se = se.parentNode;
    }
    return null;
  }
  function H(ve) {
    const se = [], he = {
      cells: se,
      columns: 0,
      rows: 0
    };
    let Oe = ve.firstChild, Me = 0, De = 0;
    for (se.length = 0; Oe != null; ) {
      const We = Oe.nodeName;
      if (We === "TD" || We === "TH") {
        const ut = Oe, kt = {
          elem: ut,
          hasBackgroundColor: ut.style.backgroundColor !== "",
          highlighted: !1,
          x: Me,
          y: De
        };
        Oe._cell = kt;
        let Ve = se[De];
        Ve === void 0 && (Ve = se[De] = []), Ve[Me] = kt;
      } else {
        const ut = Oe.firstChild;
        if (ut != null) {
          Oe = ut;
          continue;
        }
      }
      const qe = Oe.nextSibling;
      if (qe != null) {
        Me++, Oe = qe;
        continue;
      }
      const Qe = Oe.parentNode;
      if (Qe != null) {
        const ut = Qe.nextSibling;
        if (ut == null)
          break;
        De++, Me = 0, Oe = ut;
      }
    }
    return he.columns = Me + 1, he.rows = De + 1, he;
  }
  function z(ve, se, he) {
    const Oe = new Set(he ? he.getNodes() : []);
    te(se, (Me, De) => {
      const We = Me.elem;
      Oe.has(De) ? (Me.highlighted = !0, J(ve, Me)) : (Me.highlighted = !1, ee(ve, Me), We.getAttribute("style") || We.removeAttribute("style"));
    });
  }
  function te(ve, se) {
    const {
      cells: he
    } = ve;
    for (let Oe = 0; Oe < he.length; Oe++) {
      const Me = he[Oe];
      if (Me)
        for (let De = 0; De < Me.length; De++) {
          const We = Me[De];
          if (!We)
            continue;
          const qe = t.$getNearestNodeFromDOMNode(We.elem);
          qe !== null && se(We, qe, {
            x: De,
            y: Oe
          });
        }
    }
  }
  function re(ve, se) {
    se.disableHighlightStyle(), te(se.grid, (he) => {
      he.highlighted = !0, J(ve, he);
    });
  }
  function ue(ve, se) {
    se.enableHighlightStyle(), te(se.grid, (he) => {
      const Oe = he.elem;
      he.highlighted = !1, ee(ve, he), Oe.getAttribute("style") || Oe.removeAttribute("style");
    });
  }
  const q = (ve, se, he, Oe, Me) => {
    const De = Me === "forward";
    switch (Me) {
      case "backward":
      case "forward":
        return he !== (De ? ve.grid.columns - 1 : 0) ? _e(se.getCellNodeFromCordsOrThrow(he + (De ? 1 : -1), Oe, ve.grid), De) : Oe !== (De ? ve.grid.rows - 1 : 0) ? _e(se.getCellNodeFromCordsOrThrow(De ? 0 : ve.grid.columns - 1, Oe + (De ? 1 : -1), ve.grid), De) : De ? se.selectNext() : se.selectPrevious(), !0;
      case "up":
        return Oe !== 0 ? _e(se.getCellNodeFromCordsOrThrow(he, Oe - 1, ve.grid), !1) : se.selectPrevious(), !0;
      case "down":
        return Oe !== ve.grid.rows - 1 ? _e(se.getCellNodeFromCordsOrThrow(he, Oe + 1, ve.grid), !0) : se.selectNext(), !0;
      default:
        return !1;
    }
  }, G = (ve, se, he, Oe, Me) => {
    const De = Me === "forward";
    switch (Me) {
      case "backward":
      case "forward":
        return he !== (De ? ve.grid.columns - 1 : 0) && ve.setFocusCellForSelection(se.getCellFromCordsOrThrow(he + (De ? 1 : -1), Oe, ve.grid)), !0;
      case "up":
        return Oe !== 0 ? (ve.setFocusCellForSelection(se.getCellFromCordsOrThrow(he, Oe - 1, ve.grid)), !0) : !1;
      case "down":
        return Oe !== ve.grid.rows - 1 ? (ve.setFocusCellForSelection(se.getCellFromCordsOrThrow(he, Oe + 1, ve.grid)), !0) : !1;
      default:
        return !1;
    }
  };
  function j(ve, se) {
    if (t.$isRangeSelection(ve) || t.DEPRECATED_$isGridSelection(ve)) {
      const he = se.isParentOf(ve.anchor.getNode()), Oe = se.isParentOf(ve.focus.getNode());
      return he && Oe;
    }
    return !1;
  }
  function _e(ve, se) {
    se ? ve.selectStart() : ve.selectEnd();
  }
  const pe = "172,206,247";
  function J(ve, se) {
    const he = se.elem, Oe = t.$getNearestNodeFromDOMNode(he);
    if (!p(Oe))
      throw Error("Expected to find LexicalNode from Table Cell DOMNode");
    Oe.getBackgroundColor() === null ? he.style.setProperty("background-color", `rgb(${pe})`) : he.style.setProperty("background-image", `linear-gradient(to right, rgba(${pe},0.85), rgba(${pe},0.85))`), he.style.setProperty("caret-color", "transparent");
  }
  function ee(ve, se) {
    const he = se.elem, Oe = t.$getNearestNodeFromDOMNode(he);
    if (!p(Oe))
      throw Error("Expected to find LexicalNode from Table Cell DOMNode");
    Oe.getBackgroundColor() === null && he.style.removeProperty("background-color"), he.style.removeProperty("background-image"), he.style.removeProperty("caret-color");
  }
  function F(ve) {
    const se = e.$findMatchingParent(ve, p);
    return p(se) ? se : null;
  }
  function D(ve) {
    const se = e.$findMatchingParent(ve, m);
    return m(se) ? se : null;
  }
  function V(ve, se, he, Oe, Me) {
    const De = t.$getSelection();
    if (!j(De, Oe))
      return !1;
    if (t.$isRangeSelection(De) && De.isCollapsed()) {
      if (he === "backward" || he === "forward")
        return !1;
      const {
        anchor: We,
        focus: qe
      } = De, Qe = e.$findMatchingParent(We.getNode(), p), ut = e.$findMatchingParent(qe.getNode(), p);
      if (!p(Qe) || !Qe.is(ut))
        return !1;
      const kt = D(Qe);
      if (kt !== Oe && kt != null) {
        const Dt = ve.getElementByKey(kt.getKey());
        if (Dt != null)
          return Me.grid = H(Dt), V(ve, se, he, kt, Me);
      }
      const Ve = ve.getElementByKey(Qe.__key), je = ve.getElementByKey(We.key);
      if (je == null || Ve == null)
        return !1;
      let nt;
      if (We.type === "element")
        nt = je.getBoundingClientRect();
      else {
        const Dt = window.getSelection();
        if (Dt === null || Dt.rangeCount === 0)
          return !1;
        nt = Dt.getRangeAt(0).getBoundingClientRect();
      }
      const mt = he === "up" ? Qe.getFirstChild() : Qe.getLastChild();
      if (mt == null)
        return !1;
      const Ct = ve.getElementByKey(mt.__key);
      if (Ct == null)
        return !1;
      const vt = Ct.getBoundingClientRect();
      if (he === "up" ? vt.top > nt.top - nt.height : nt.bottom + nt.height > vt.bottom) {
        ne(se);
        const Dt = Oe.getCordsFromCellNode(Qe, Me.grid);
        if (se.shiftKey) {
          const Tt = Oe.getCellFromCordsOrThrow(Dt.x, Dt.y, Me.grid);
          Me.setAnchorCellForSelection(Tt), Me.setFocusCellForSelection(Tt, !0);
        } else
          return q(Me, Oe, Dt.x, Dt.y, he);
        return !0;
      }
    } else if (t.DEPRECATED_$isGridSelection(De)) {
      const {
        anchor: We,
        focus: qe
      } = De, Qe = e.$findMatchingParent(We.getNode(), p), ut = e.$findMatchingParent(qe.getNode(), p), [kt] = De.getNodes(), Ve = ve.getElementByKey(kt.getKey());
      if (!p(Qe) || !p(ut) || !m(kt) || Ve == null)
        return !1;
      Me.updateTableGridSelection(De);
      const je = H(Ve), nt = Oe.getCordsFromCellNode(Qe, je), mt = Oe.getCellFromCordsOrThrow(nt.x, nt.y, je);
      if (Me.setAnchorCellForSelection(mt), ne(se), se.shiftKey) {
        const Ct = Oe.getCordsFromCellNode(ut, je);
        return G(Me, kt, Ct.x, Ct.y, he);
      } else
        ut.selectEnd();
      return !0;
    }
    return !1;
  }
  function ne(ve) {
    ve.preventDefault(), ve.stopImmediatePropagation(), ve.stopPropagation();
  }
  class Y extends t.DEPRECATED_GridNode {
    /** @internal */
    static getType() {
      return "table";
    }
    static clone(se) {
      return new Y(se.__key);
    }
    static importDOM() {
      return {
        table: (se) => ({
          conversion: Q,
          priority: 1
        })
      };
    }
    static importJSON(se) {
      return k();
    }
    constructor(se) {
      super(se);
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "table",
        version: 1
      };
    }
    createDOM(se, he) {
      const Oe = document.createElement("table");
      return e.addClassNamesToElement(Oe, se.theme.table), Oe;
    }
    updateDOM() {
      return !1;
    }
    exportDOM(se) {
      return {
        ...super.exportDOM(se),
        after: (he) => {
          if (he) {
            const Oe = he.cloneNode(), Me = document.createElement("colgroup"), De = document.createElement("tbody");
            e.isHTMLElement(he) && De.append(...he.children);
            const We = this.getFirstChildOrThrow();
            if (!O(We))
              throw new Error("Expected to find row node.");
            const qe = We.getChildrenSize();
            for (let Qe = 0; Qe < qe; Qe++) {
              const ut = document.createElement("col");
              Me.append(ut);
            }
            return Oe.replaceChildren(Me, De), Oe;
          }
        }
      };
    }
    // TODO 0.10 deprecate
    canExtractContents() {
      return !1;
    }
    canBeEmpty() {
      return !1;
    }
    isShadowRoot() {
      return !0;
    }
    getCordsFromCellNode(se, he) {
      const {
        rows: Oe,
        cells: Me
      } = he;
      for (let De = 0; De < Oe; De++) {
        const We = Me[De];
        if (We == null)
          continue;
        const qe = We.findIndex((Qe) => {
          if (!Qe)
            return;
          const {
            elem: ut
          } = Qe;
          return t.$getNearestNodeFromDOMNode(ut) === se;
        });
        if (qe !== -1)
          return {
            x: qe,
            y: De
          };
      }
      throw new Error("Cell not found in table.");
    }
    getCellFromCords(se, he, Oe) {
      const {
        cells: Me
      } = Oe, De = Me[he];
      if (De == null)
        return null;
      const We = De[se];
      return We ?? null;
    }
    getCellFromCordsOrThrow(se, he, Oe) {
      const Me = this.getCellFromCords(se, he, Oe);
      if (!Me)
        throw new Error("Cell not found at cords.");
      return Me;
    }
    getCellNodeFromCords(se, he, Oe) {
      const Me = this.getCellFromCords(se, he, Oe);
      if (Me == null)
        return null;
      const De = t.$getNearestNodeFromDOMNode(Me.elem);
      return p(De) ? De : null;
    }
    getCellNodeFromCordsOrThrow(se, he, Oe) {
      const Me = this.getCellNodeFromCords(se, he, Oe);
      if (!Me)
        throw new Error("Node at cords not TableCellNode.");
      return Me;
    }
    canSelectBefore() {
      return !0;
    }
    canIndent() {
      return !1;
    }
  }
  function U(ve, se) {
    const he = ve.getElementByKey(se.getKey());
    if (he == null)
      throw new Error("Table Element Not Found");
    return H(he);
  }
  function Q(ve) {
    return {
      node: k()
    };
  }
  function k() {
    return t.$applyNodeReplacement(new Y());
  }
  function m(ve) {
    return ve instanceof Y;
  }
  function y(ve, se, he = !0) {
    const Oe = k();
    for (let Me = 0; Me < ve; Me++) {
      const De = v();
      for (let We = 0; We < se; We++) {
        let qe = r.NO_STATUS;
        typeof he == "object" ? (Me === 0 && he.rows && (qe |= r.ROW), We === 0 && he.columns && (qe |= r.COLUMN)) : he && (Me === 0 && (qe |= r.ROW), We === 0 && (qe |= r.COLUMN));
        const Qe = h(qe), ut = t.$createParagraphNode();
        ut.append(t.$createTextNode()), Qe.append(ut), De.append(Qe);
      }
      Oe.append(De);
    }
    return Oe;
  }
  function b(ve) {
    const se = e.$findMatchingParent(ve, (he) => p(he));
    return p(se) ? se : null;
  }
  function Z(ve) {
    const se = e.$findMatchingParent(ve, (he) => O(he));
    if (O(se))
      return se;
    throw new Error("Expected table cell to be inside of table row.");
  }
  function ce(ve) {
    const se = e.$findMatchingParent(ve, (he) => m(he));
    if (m(se))
      return se;
    throw new Error("Expected table cell to be inside of table.");
  }
  function ge(ve) {
    const se = Z(ve);
    return ce(se).getChildren().findIndex((Oe) => Oe.is(se));
  }
  function ae(ve) {
    return Z(ve).getChildren().findIndex((he) => he.is(ve));
  }
  function Te(ve, se) {
    const he = ce(ve), {
      x: Oe,
      y: Me
    } = he.getCordsFromCellNode(ve, se);
    return {
      above: he.getCellNodeFromCords(Oe, Me - 1, se),
      below: he.getCellNodeFromCords(Oe, Me + 1, se),
      left: he.getCellNodeFromCords(Oe - 1, Me, se),
      right: he.getCellNodeFromCords(Oe + 1, Me, se)
    };
  }
  function Ae(ve, se) {
    const he = ve.getChildren();
    if (se >= he.length || se < 0)
      throw new Error("Expected table cell to be inside of table row.");
    return he[se].remove(), ve;
  }
  function ze(ve, se, he = !0, Oe, Me) {
    const De = ve.getChildren();
    if (se >= De.length || se < 0)
      throw new Error("Table row target index out of range");
    const We = De[se];
    if (O(We))
      for (let qe = 0; qe < Oe; qe++) {
        const Qe = We.getChildren(), ut = Qe.length, kt = v();
        for (let Ve = 0; Ve < ut; Ve++) {
          const je = Qe[Ve];
          if (!p(je))
            throw Error("Expected table cell");
          const {
            above: nt,
            below: mt
          } = Te(je, Me);
          let Ct = r.NO_STATUS;
          const vt = nt && nt.getWidth() || mt && mt.getWidth() || void 0;
          (nt && nt.hasHeaderState(r.COLUMN) || mt && mt.hasHeaderState(r.COLUMN)) && (Ct |= r.COLUMN);
          const wt = h(Ct, 1, vt);
          wt.append(t.$createParagraphNode()), kt.append(wt);
        }
        he ? We.insertAfter(kt) : We.insertBefore(kt);
      }
    else
      throw new Error("Row before insertion index does not exist.");
    return ve;
  }
  function oe(ve = !0) {
    const se = t.$getSelection();
    if (!t.$INTERNAL_isPointSelection(se))
      throw Error("Expected a INTERNAL_PointSelection");
    const he = se.focus.getNode(), [Oe, , Me] = t.DEPRECATED_$getNodeTriplet(he), [De, We] = t.DEPRECATED_$computeGridMap(Me, Oe, Oe), qe = De[0].length, {
      startRow: Qe
    } = We;
    if (ve) {
      const ut = Qe + Oe.__rowSpan - 1, kt = De[ut], Ve = v();
      for (let nt = 0; nt < qe; nt++) {
        const {
          cell: mt,
          startRow: Ct
        } = kt[nt];
        Ct + mt.__rowSpan - 1 <= ut ? Ve.append(h(r.NO_STATUS)) : mt.setRowSpan(mt.__rowSpan + 1);
      }
      const je = Me.getChildAtIndex(ut);
      if (!t.DEPRECATED_$isGridRowNode(je))
        throw Error("focusEndRow is not a GridRowNode");
      je.insertAfter(Ve);
    } else {
      const ut = De[Qe], kt = v();
      for (let je = 0; je < qe; je++) {
        const {
          cell: nt,
          startRow: mt
        } = ut[je];
        mt === Qe ? kt.append(h(r.NO_STATUS)) : nt.setRowSpan(nt.__rowSpan + 1);
      }
      const Ve = Me.getChildAtIndex(Qe);
      if (!t.DEPRECATED_$isGridRowNode(Ve))
        throw Error("focusEndRow is not a GridRowNode");
      Ve.insertBefore(kt);
    }
  }
  function ie(ve, se, he = !0, Oe, Me) {
    const De = ve.getChildren(), We = [];
    for (let qe = 0; qe < De.length; qe++) {
      const Qe = De[qe];
      if (O(Qe))
        for (let ut = 0; ut < Oe; ut++) {
          const kt = Qe.getChildren();
          if (se >= kt.length || se < 0)
            throw new Error("Table column target index out of range");
          const Ve = kt[se];
          if (!p(Ve))
            throw Error("Expected table cell");
          const {
            left: je,
            right: nt
          } = Te(Ve, Me);
          let mt = r.NO_STATUS;
          (je && je.hasHeaderState(r.ROW) || nt && nt.hasHeaderState(r.ROW)) && (mt |= r.ROW);
          const Ct = h(mt);
          Ct.append(t.$createParagraphNode()), We.push({
            newTableCell: Ct,
            targetCell: Ve
          });
        }
    }
    return We.forEach(({
      newTableCell: qe,
      targetCell: Qe
    }) => {
      he ? Qe.insertAfter(qe) : Qe.insertBefore(qe);
    }), ve;
  }
  function de(ve = !0) {
    const se = t.$getSelection();
    if (!t.$INTERNAL_isPointSelection(se))
      throw Error("Expected a PointSeleciton");
    const he = se.anchor.getNode(), Oe = se.focus.getNode(), [Me] = t.DEPRECATED_$getNodeTriplet(he), [De, , We] = t.DEPRECATED_$getNodeTriplet(Oe), [qe, Qe, ut] = t.DEPRECATED_$computeGridMap(We, De, Me), kt = qe.length, Ve = ve ? Math.max(Qe.startColumn, ut.startColumn) : Math.min(Qe.startColumn, ut.startColumn), je = ve ? Ve + De.__colSpan - 1 : Ve - 1, nt = We.getFirstChild();
    if (!t.DEPRECATED_$isGridRowNode(nt))
      throw Error("Expected firstTable child to be a row");
    let mt = null;
    function Ct() {
      const wt = h(r.NO_STATUS).append(t.$createParagraphNode());
      return mt === null && (mt = wt), wt;
    }
    let vt = nt;
    e:
      for (let wt = 0; wt < kt; wt++) {
        if (wt !== 0) {
          const Ut = vt.getNextSibling();
          if (!t.DEPRECATED_$isGridRowNode(Ut))
            throw Error("Expected row nextSibling to be a row");
          vt = Ut;
        }
        const Dt = qe[wt];
        if (je < 0) {
          lt(vt, Ct());
          continue;
        }
        const {
          cell: Tt,
          startColumn: Xt,
          startRow: Mt
        } = Dt[je];
        if (Xt + Tt.__colSpan - 1 <= je) {
          let Ut = Tt, Lt = Mt, mr = je;
          for (; Lt !== wt && Ut.__rowSpan > 1; )
            if (mr -= Tt.__colSpan, mr >= 0) {
              const {
                cell: Dr,
                startRow: Wi
              } = Dt[mr];
              Ut = Dr, Lt = Wi;
            } else {
              vt.append(Ct());
              continue e;
            }
          Ut.insertAfter(Ct());
        } else
          Tt.setColSpan(Tt.__colSpan + 1);
      }
    mt !== null && Ye(mt);
  }
  function we(ve, se) {
    const he = ve.getChildren();
    for (let Oe = 0; Oe < he.length; Oe++) {
      const Me = he[Oe];
      if (O(Me)) {
        const De = Me.getChildren();
        if (se >= De.length || se < 0)
          throw new Error("Table column target index out of range");
        De[se].remove();
      }
    }
    return ve;
  }
  function ke() {
    const ve = t.$getSelection();
    if (!t.$INTERNAL_isPointSelection(ve))
      throw Error("Expected a INTERNAL_PointSelection");
    const se = ve.anchor.getNode(), he = ve.focus.getNode(), [Oe, , Me] = t.DEPRECATED_$getNodeTriplet(se), [De] = t.DEPRECATED_$getNodeTriplet(he), [We, qe, Qe] = t.DEPRECATED_$computeGridMap(Me, Oe, De), {
      startRow: ut
    } = qe, {
      startRow: kt
    } = Qe, Ve = kt + De.__rowSpan - 1;
    if (We.length === Ve - ut + 1) {
      Me.remove();
      return;
    }
    const je = We[0].length, nt = We[Ve + 1], mt = Me.getChildAtIndex(Ve + 1);
    for (let Ct = Ve; Ct >= ut; Ct--) {
      for (let wt = je - 1; wt >= 0; wt--) {
        const {
          cell: Dt,
          startRow: Tt,
          startColumn: Xt
        } = We[Ct][wt];
        if (Xt === wt && (Ct === ut && Tt < ut && Dt.setRowSpan(Dt.__rowSpan - (Tt - ut)), Tt >= ut && Tt + Dt.__rowSpan - 1 > Ve)) {
          if (Dt.setRowSpan(Dt.__rowSpan - (Ve - Tt + 1)), mt === null)
            throw Error("Expected nextRowNode not to be null");
          if (wt === 0)
            lt(mt, Dt);
          else {
            const {
              cell: Mt
            } = nt[wt - 1];
            Mt.insertAfter(Dt);
          }
        }
      }
      const vt = Me.getChildAtIndex(Ct);
      if (!t.DEPRECATED_$isGridRowNode(vt))
        throw Error(`Expected GridNode childAtIndex(${String(Ct)}) to be RowNode`);
      vt.remove();
    }
    if (nt !== void 0) {
      const {
        cell: Ct
      } = nt[0];
      Ye(Ct);
    } else {
      const Ct = We[ut - 1], {
        cell: vt
      } = Ct[0];
      Ye(vt);
    }
  }
  function Be() {
    const ve = t.$getSelection();
    if (!t.$INTERNAL_isPointSelection(ve))
      throw Error("Expected a INTERNAL_PointSelection");
    const se = ve.anchor.getNode(), he = ve.focus.getNode(), [Oe, , Me] = t.DEPRECATED_$getNodeTriplet(se), [De] = t.DEPRECATED_$getNodeTriplet(he), [We, qe, Qe] = t.DEPRECATED_$computeGridMap(Me, Oe, De), {
      startColumn: ut
    } = qe, {
      startRow: kt,
      startColumn: Ve
    } = Qe, je = Math.min(ut, Ve), nt = Math.max(ut + Oe.__colSpan - 1, Ve + De.__colSpan - 1), mt = nt - je + 1;
    if (We[0].length === nt - je + 1) {
      Me.selectPrevious(), Me.remove();
      return;
    }
    const vt = We.length;
    for (let Tt = 0; Tt < vt; Tt++)
      for (let Xt = je; Xt <= nt; Xt++) {
        const {
          cell: Mt,
          startColumn: Ut
        } = We[Tt][Xt];
        if (Ut < je) {
          if (Xt === je) {
            const Lt = je - Ut;
            Mt.setColSpan(Mt.__colSpan - // Possible overflow right too
            Math.min(mt, Mt.__colSpan - Lt));
          }
        } else if (Ut + Mt.__colSpan - 1 > nt) {
          if (Xt === nt) {
            const Lt = nt - Ut + 1;
            Mt.setColSpan(Mt.__colSpan - Lt);
          }
        } else
          Mt.remove();
      }
    const wt = We[kt], Dt = wt[Ve + De.__colSpan];
    if (Dt !== void 0) {
      const {
        cell: Tt
      } = Dt;
      Ye(Tt);
    } else {
      const Tt = wt[Ve - 1], {
        cell: Xt
      } = Tt;
      Ye(Xt);
    }
  }
  function Ye(ve) {
    const se = ve.getFirstDescendant();
    se == null ? ve.selectStart() : se.getParentOrThrow().selectStart();
  }
  function lt(ve, se) {
    const he = ve.getFirstChild();
    he !== null ? he.insertBefore(se) : ve.append(se);
  }
  function _t() {
    const ve = t.$getSelection();
    if (!t.$INTERNAL_isPointSelection(ve))
      throw Error("Expected a INTERNAL_PointSelection");
    const se = ve.anchor.getNode(), [he, Oe, Me] = t.DEPRECATED_$getNodeTriplet(se), De = he.__colSpan, We = he.__rowSpan;
    if (De > 1) {
      for (let qe = 1; qe < De; qe++)
        he.insertAfter(h(r.NO_STATUS));
      he.setColSpan(1);
    }
    if (We > 1) {
      const [qe, Qe] = t.DEPRECATED_$computeGridMap(Me, he, he), {
        startColumn: ut,
        startRow: kt
      } = Qe;
      let Ve;
      for (let je = 1; je < We; je++) {
        const nt = kt + je, mt = qe[nt];
        if (Ve = (Ve || Oe).getNextSibling(), !t.DEPRECATED_$isGridRowNode(Ve))
          throw Error("Expected row next sibling to be a row");
        let Ct = null;
        for (let vt = 0; vt < ut; vt++) {
          const wt = mt[vt], Dt = wt.cell;
          wt.startRow === nt && (Ct = Dt), Dt.__colSpan > 1 && (vt += Dt.__colSpan - 1);
        }
        if (Ct === null)
          for (let vt = 0; vt < De; vt++)
            lt(Ve, h(r.NO_STATUS));
        else
          for (let vt = 0; vt < De; vt++)
            Ct.insertAfter(h(r.NO_STATUS));
      }
      he.setRowSpan(1);
    }
  }
  const ct = t.createCommand("INSERT_TABLE_COMMAND");
  return Gt.$createTableCellNode = h, Gt.$createTableNode = k, Gt.$createTableNodeWithDimensions = y, Gt.$createTableRowNode = v, Gt.$deleteTableColumn = we, Gt.$deleteTableColumn__EXPERIMENTAL = Be, Gt.$deleteTableRow__EXPERIMENTAL = ke, Gt.$getElementGridForTableNode = U, Gt.$getTableCellNodeFromLexicalNode = b, Gt.$getTableColumnIndexFromTableCellNode = ae, Gt.$getTableNodeFromLexicalNodeOrThrow = ce, Gt.$getTableRowIndexFromTableCellNode = ge, Gt.$getTableRowNodeFromTableCellNodeOrThrow = Z, Gt.$insertTableColumn = ie, Gt.$insertTableColumn__EXPERIMENTAL = de, Gt.$insertTableRow = ze, Gt.$insertTableRow__EXPERIMENTAL = oe, Gt.$isTableCellNode = p, Gt.$isTableNode = m, Gt.$isTableRowNode = O, Gt.$removeTableRowAtIndex = Ae, Gt.$unmergeCell = _t, Gt.INSERT_TABLE_COMMAND = ct, Gt.TableCellHeaderStates = r, Gt.TableCellNode = c, Gt.TableNode = Y, Gt.TableRowNode = N, Gt.TableSelection = T, Gt.applyTableHandlers = P, Gt.getCellFromTarget = W, Gt.getTableSelectionFromTableElement = $, Gt;
}
var wu, mh;
function pd() {
  return mh || (mh = 1, wu = process.env.NODE_ENV === "development" ? ZN() : qN()), wu;
}
var _h;
function JN() {
  if (_h)
    return Su;
  _h = 1;
  var t = Yn(), e = pd(), n = rn(), r = Bt(), c = dn;
  function d(h) {
    let p = new URLSearchParams();
    p.append("code", h);
    for (let N = 1; N < arguments.length; N++)
      p.append("v", arguments[N]);
    throw Error(`Minified Lexical error #${h}; visit https://lexical.dev/docs/error?${p} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  return Su.TablePlugin = function({ hasCellMerge: h = !0, hasCellBackgroundColor: p = !0, hasTabHandler: N = !0 }) {
    let [x] = t.useLexicalComposerContext();
    return c.useEffect(() => (x.hasNodes([e.TableNode, e.TableCellNode, e.TableRowNode]) || d(10), x.registerCommand(e.INSERT_TABLE_COMMAND, ({ columns: v, rows: O, includeHeaders: M }) => (v = e.$createTableNodeWithDimensions(Number(O), Number(v), M), n.$insertNodeToNearestRoot(v), v = v.getFirstDescendant(), r.$isTextNode(v) && v.select(), !0), r.COMMAND_PRIORITY_EDITOR)), [x]), c.useEffect(
      () => {
        let v = /* @__PURE__ */ new Map(), O = (A) => {
          const T = A.getKey(), w = x.getElementByKey(T);
          w && !v.has(T) && (A = e.applyTableHandlers(A, w, x, N), v.set(T, A));
        };
        x.getEditorState().read(() => {
          let A = r.$nodesOfType(e.TableNode);
          for (let T of A)
            e.$isTableNode(T) && O(T);
        });
        let M = x.registerMutationListener(e.TableNode, (A) => {
          for (const [T, w] of A)
            w === "created" ? x.getEditorState().read(() => {
              const P = r.$getNodeByKey(T);
              e.$isTableNode(P) && O(P);
            }) : w === "destroyed" && (A = v.get(T), A !== void 0 && (A.removeListeners(), v.delete(T)));
        });
        return () => {
          M();
          for (let [, A] of v)
            A.removeListeners();
        };
      },
      [x, N]
    ), c.useEffect(() => {
      if (!h)
        return x.registerNodeTransform(e.TableCellNode, (v) => {
          if (1 < v.getColSpan() || 1 < v.getRowSpan()) {
            var [, , O] = r.DEPRECATED_$getNodeTriplet(v);
            [v] = r.DEPRECATED_$computeGridMap(O, v, v);
            let A = v.length, T = v[0].length;
            if (O = O.getFirstChild(), !r.DEPRECATED_$isGridRowNode(O))
              throw Error("Expected TableNode first child to be a RowNode");
            let w = [];
            for (let P = 0; P < A; P++) {
              if (P !== 0 && (O = O.getNextSibling(), !r.DEPRECATED_$isGridRowNode(O)))
                throw Error("Expected TableNode first child to be a RowNode");
              let K = null;
              for (let $ = 0; $ < T; $++) {
                var M = v[P][$];
                let W = M.cell;
                M.startRow === P && M.startColumn === $ ? (K = W, w.push(W)) : (1 < W.getColSpan() || 1 < W.getRowSpan()) && (M = e.$createTableCellNode(W.__headerState), K !== null ? K.insertAfter(M) : n.$insertFirst(O, M));
              }
            }
            for (let P of w)
              P.setColSpan(1), P.setRowSpan(1);
          }
        });
    }, [x, h]), c.useEffect(() => {
      if (!p)
        return x.registerNodeTransform(e.TableCellNode, (v) => {
          v.getBackgroundColor() !== null && v.setBackgroundColor(null);
        });
    }, [x, p, h]), null;
  }, Su;
}
var Ou = {}, yh;
function XN() {
  if (yh)
    return Ou;
  yh = 1;
  var t = Yn(), e = pd(), n = rn(), r = Bt(), c = dn;
  function d({
    hasCellMerge: h = !0,
    hasCellBackgroundColor: p = !0,
    hasTabHandler: N = !0
  }) {
    const [x] = t.useLexicalComposerContext();
    return c.useEffect(() => {
      if (!x.hasNodes([e.TableNode, e.TableCellNode, e.TableRowNode]))
        throw Error("TablePlugin: TableNode, TableCellNode or TableRowNode not registered on editor");
      return x.registerCommand(e.INSERT_TABLE_COMMAND, ({
        columns: v,
        rows: O,
        includeHeaders: M
      }) => {
        const A = e.$createTableNodeWithDimensions(Number(O), Number(v), M);
        n.$insertNodeToNearestRoot(A);
        const T = A.getFirstDescendant();
        return r.$isTextNode(T) && T.select(), !0;
      }, r.COMMAND_PRIORITY_EDITOR);
    }, [x]), c.useEffect(() => {
      const v = /* @__PURE__ */ new Map(), O = (A) => {
        const T = A.getKey(), w = x.getElementByKey(T);
        if (w && !v.has(T)) {
          const P = e.applyTableHandlers(A, w, x, N);
          v.set(T, P);
        }
      };
      x.getEditorState().read(() => {
        const A = r.$nodesOfType(e.TableNode);
        for (const T of A)
          e.$isTableNode(T) && O(T);
      });
      const M = x.registerMutationListener(e.TableNode, (A) => {
        for (const [T, w] of A)
          if (w === "created")
            x.getEditorState().read(() => {
              const P = r.$getNodeByKey(T);
              e.$isTableNode(P) && O(P);
            });
          else if (w === "destroyed") {
            const P = v.get(T);
            P !== void 0 && (P.removeListeners(), v.delete(T));
          }
      });
      return () => {
        M();
        for (const [, A] of v)
          A.removeListeners();
      };
    }, [x, N]), c.useEffect(() => {
      if (!h)
        return x.registerNodeTransform(e.TableCellNode, (v) => {
          if (v.getColSpan() > 1 || v.getRowSpan() > 1) {
            const [, , O] = r.DEPRECATED_$getNodeTriplet(v), [M] = r.DEPRECATED_$computeGridMap(O, v, v), A = M.length, T = M[0].length;
            let w = O.getFirstChild();
            if (!r.DEPRECATED_$isGridRowNode(w))
              throw Error("Expected TableNode first child to be a RowNode");
            const P = [];
            for (let K = 0; K < A; K++) {
              if (K !== 0 && (w = w.getNextSibling(), !r.DEPRECATED_$isGridRowNode(w)))
                throw Error("Expected TableNode first child to be a RowNode");
              let $ = null;
              for (let W = 0; W < T; W++) {
                const H = M[K][W], z = H.cell;
                if (H.startRow === K && H.startColumn === W)
                  $ = z, P.push(z);
                else if (z.getColSpan() > 1 || z.getRowSpan() > 1) {
                  const te = e.$createTableCellNode(z.__headerState);
                  $ !== null ? $.insertAfter(te) : n.$insertFirst(w, te);
                }
              }
            }
            for (const K of P)
              K.setColSpan(1), K.setRowSpan(1);
          }
        });
    }, [x, h]), c.useEffect(() => {
      if (!p)
        return x.registerNodeTransform(e.TableCellNode, (v) => {
          v.getBackgroundColor() !== null && v.setBackgroundColor(null);
        });
    }, [x, p, h]), null;
  }
  return Ou.TablePlugin = d, Ou;
}
const QN = process.env.NODE_ENV === "development" ? XN() : JN();
var eC = QN, Rn = {}, Du = { exports: {} }, Nh;
function xp() {
  return Nh || (Nh = 1, function(t) {
    var e = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};
    /**
     * Prism: Lightweight, robust, elegant syntax highlighting
     *
     * @license MIT <https://opensource.org/licenses/MIT>
     * @author Lea Verou <https://lea.verou.me>
     * @namespace
     * @public
     */
    var n = function(r) {
      var c = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, d = 0, h = {}, p = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: r.Prism && r.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: r.Prism && r.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function $(W) {
            return W instanceof N ? new N(W.type, $(W.content), W.alias) : Array.isArray(W) ? W.map($) : W.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function($) {
            return Object.prototype.toString.call($).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function($) {
            return $.__id || Object.defineProperty($, "__id", { value: ++d }), $.__id;
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function $(W, H) {
            H = H || {};
            var z, te;
            switch (p.util.type(W)) {
              case "Object":
                if (te = p.util.objId(W), H[te])
                  return H[te];
                z = /** @type {Record<string, any>} */
                {}, H[te] = z;
                for (var re in W)
                  W.hasOwnProperty(re) && (z[re] = $(W[re], H));
                return (
                  /** @type {any} */
                  z
                );
              case "Array":
                return te = p.util.objId(W), H[te] ? H[te] : (z = [], H[te] = z, /** @type {Array} */
                /** @type {any} */
                W.forEach(function(ue, q) {
                  z[q] = $(ue, H);
                }), /** @type {any} */
                z);
              default:
                return W;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function($) {
            for (; $; ) {
              var W = c.exec($.className);
              if (W)
                return W[1].toLowerCase();
              $ = $.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function($, W) {
            $.className = $.className.replace(RegExp(c, "gi"), ""), $.classList.add("language-" + W);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document > "u")
              return null;
            if ("currentScript" in document && 1 < 2)
              return (
                /** @type {any} */
                document.currentScript
              );
            try {
              throw new Error();
            } catch (z) {
              var $ = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(z.stack) || [])[1];
              if ($) {
                var W = document.getElementsByTagName("script");
                for (var H in W)
                  if (W[H].src == $)
                    return W[H];
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function($, W, H) {
            for (var z = "no-" + W; $; ) {
              var te = $.classList;
              if (te.contains(W))
                return !0;
              if (te.contains(z))
                return !1;
              $ = $.parentElement;
            }
            return !!H;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: h,
          plaintext: h,
          text: h,
          txt: h,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function($, W) {
            var H = p.util.clone(p.languages[$]);
            for (var z in W)
              H[z] = W[z];
            return H;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function($, W, H, z) {
            z = z || /** @type {any} */
            p.languages;
            var te = z[$], re = {};
            for (var ue in te)
              if (te.hasOwnProperty(ue)) {
                if (ue == W)
                  for (var q in H)
                    H.hasOwnProperty(q) && (re[q] = H[q]);
                H.hasOwnProperty(ue) || (re[ue] = te[ue]);
              }
            var G = z[$];
            return z[$] = re, p.languages.DFS(p.languages, function(j, _e) {
              _e === G && j != $ && (this[j] = re);
            }), re;
          },
          // Traverse a language definition with Depth First Search
          DFS: function $(W, H, z, te) {
            te = te || {};
            var re = p.util.objId;
            for (var ue in W)
              if (W.hasOwnProperty(ue)) {
                H.call(W, ue, W[ue], z || ue);
                var q = W[ue], G = p.util.type(q);
                G === "Object" && !te[re(q)] ? (te[re(q)] = !0, $(q, H, null, te)) : G === "Array" && !te[re(q)] && (te[re(q)] = !0, $(q, H, ue, te));
              }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prisms API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function($, W) {
          p.highlightAllUnder(document, $, W);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function($, W, H) {
          var z = {
            callback: H,
            container: $,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          p.hooks.run("before-highlightall", z), z.elements = Array.prototype.slice.apply(z.container.querySelectorAll(z.selector)), p.hooks.run("before-all-elements-highlight", z);
          for (var te = 0, re; re = z.elements[te++]; )
            p.highlightElement(re, W === !0, z.callback);
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function($, W, H) {
          var z = p.util.getLanguage($), te = p.languages[z];
          p.util.setLanguage($, z);
          var re = $.parentElement;
          re && re.nodeName.toLowerCase() === "pre" && p.util.setLanguage(re, z);
          var ue = $.textContent, q = {
            element: $,
            language: z,
            grammar: te,
            code: ue
          };
          function G(_e) {
            q.highlightedCode = _e, p.hooks.run("before-insert", q), q.element.innerHTML = q.highlightedCode, p.hooks.run("after-highlight", q), p.hooks.run("complete", q), H && H.call(q.element);
          }
          if (p.hooks.run("before-sanity-check", q), re = q.element.parentElement, re && re.nodeName.toLowerCase() === "pre" && !re.hasAttribute("tabindex") && re.setAttribute("tabindex", "0"), !q.code) {
            p.hooks.run("complete", q), H && H.call(q.element);
            return;
          }
          if (p.hooks.run("before-highlight", q), !q.grammar) {
            G(p.util.encode(q.code));
            return;
          }
          if (W && r.Worker) {
            var j = new Worker(p.filename);
            j.onmessage = function(_e) {
              G(_e.data);
            }, j.postMessage(JSON.stringify({
              language: q.language,
              code: q.code,
              immediateClose: !0
            }));
          } else
            G(p.highlight(q.code, q.grammar, q.language));
        },
        /**
         * Low-level function, only use if you know what youre doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function($, W, H) {
          var z = {
            code: $,
            grammar: W,
            language: H
          };
          if (p.hooks.run("before-tokenize", z), !z.grammar)
            throw new Error('The language "' + z.language + '" has no grammar.');
          return z.tokens = p.tokenize(z.code, z.grammar), p.hooks.run("after-tokenize", z), N.stringify(p.util.encode(z.tokens), z.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function($, W) {
          var H = W.rest;
          if (H) {
            for (var z in H)
              W[z] = H[z];
            delete W.rest;
          }
          var te = new O();
          return M(te, te.head, $), v($, te, W, te.head, 0), T(te);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function($, W) {
            var H = p.hooks.all;
            H[$] = H[$] || [], H[$].push(W);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function($, W) {
            var H = p.hooks.all[$];
            if (!(!H || !H.length))
              for (var z = 0, te; te = H[z++]; )
                te(W);
          }
        },
        Token: N
      };
      r.Prism = p;
      function N($, W, H, z) {
        this.type = $, this.content = W, this.alias = H, this.length = (z || "").length | 0;
      }
      N.stringify = function $(W, H) {
        if (typeof W == "string")
          return W;
        if (Array.isArray(W)) {
          var z = "";
          return W.forEach(function(G) {
            z += $(G, H);
          }), z;
        }
        var te = {
          type: W.type,
          content: $(W.content, H),
          tag: "span",
          classes: ["token", W.type],
          attributes: {},
          language: H
        }, re = W.alias;
        re && (Array.isArray(re) ? Array.prototype.push.apply(te.classes, re) : te.classes.push(re)), p.hooks.run("wrap", te);
        var ue = "";
        for (var q in te.attributes)
          ue += " " + q + '="' + (te.attributes[q] || "").replace(/"/g, "&quot;") + '"';
        return "<" + te.tag + ' class="' + te.classes.join(" ") + '"' + ue + ">" + te.content + "</" + te.tag + ">";
      };
      function x($, W, H, z) {
        $.lastIndex = W;
        var te = $.exec(H);
        if (te && z && te[1]) {
          var re = te[1].length;
          te.index += re, te[0] = te[0].slice(re);
        }
        return te;
      }
      function v($, W, H, z, te, re) {
        for (var ue in H)
          if (!(!H.hasOwnProperty(ue) || !H[ue])) {
            var q = H[ue];
            q = Array.isArray(q) ? q : [q];
            for (var G = 0; G < q.length; ++G) {
              if (re && re.cause == ue + "," + G)
                return;
              var j = q[G], _e = j.inside, pe = !!j.lookbehind, J = !!j.greedy, ee = j.alias;
              if (J && !j.pattern.global) {
                var F = j.pattern.toString().match(/[imsuy]*$/)[0];
                j.pattern = RegExp(j.pattern.source, F + "g");
              }
              for (var D = j.pattern || j, V = z.next, ne = te; V !== W.tail && !(re && ne >= re.reach); ne += V.value.length, V = V.next) {
                var Y = V.value;
                if (W.length > $.length)
                  return;
                if (!(Y instanceof N)) {
                  var U = 1, Q;
                  if (J) {
                    if (Q = x(D, ne, $, pe), !Q || Q.index >= $.length)
                      break;
                    var b = Q.index, k = Q.index + Q[0].length, m = ne;
                    for (m += V.value.length; b >= m; )
                      V = V.next, m += V.value.length;
                    if (m -= V.value.length, ne = m, V.value instanceof N)
                      continue;
                    for (var y = V; y !== W.tail && (m < k || typeof y.value == "string"); y = y.next)
                      U++, m += y.value.length;
                    U--, Y = $.slice(ne, m), Q.index -= ne;
                  } else if (Q = x(D, 0, Y, pe), !Q)
                    continue;
                  var b = Q.index, Z = Q[0], ce = Y.slice(0, b), ge = Y.slice(b + Z.length), ae = ne + Y.length;
                  re && ae > re.reach && (re.reach = ae);
                  var Te = V.prev;
                  ce && (Te = M(W, Te, ce), ne += ce.length), A(W, Te, U);
                  var Ae = new N(ue, _e ? p.tokenize(Z, _e) : Z, ee, Z);
                  if (V = M(W, Te, Ae), ge && M(W, V, ge), U > 1) {
                    var ze = {
                      cause: ue + "," + G,
                      reach: ae
                    };
                    v($, W, H, V.prev, ne, ze), re && ze.reach > re.reach && (re.reach = ze.reach);
                  }
                }
              }
            }
          }
      }
      function O() {
        var $ = { value: null, prev: null, next: null }, W = { value: null, prev: $, next: null };
        $.next = W, this.head = $, this.tail = W, this.length = 0;
      }
      function M($, W, H) {
        var z = W.next, te = { value: H, prev: W, next: z };
        return W.next = te, z.prev = te, $.length++, te;
      }
      function A($, W, H) {
        for (var z = W.next, te = 0; te < H && z !== $.tail; te++)
          z = z.next;
        W.next = z, z.prev = W, $.length -= te;
      }
      function T($) {
        for (var W = [], H = $.head.next; H !== $.tail; )
          W.push(H.value), H = H.next;
        return W;
      }
      if (!r.document)
        return r.addEventListener && (p.disableWorkerMessageHandler || r.addEventListener("message", function($) {
          var W = JSON.parse($.data), H = W.language, z = W.code, te = W.immediateClose;
          r.postMessage(p.highlight(z, p.languages[H], H)), te && r.close();
        }, !1)), p;
      var w = p.util.currentScript();
      w && (p.filename = w.src, w.hasAttribute("data-manual") && (p.manual = !0));
      function P() {
        p.manual || p.highlightAll();
      }
      if (!p.manual) {
        var K = document.readyState;
        K === "loading" || K === "interactive" && w && w.defer ? document.addEventListener("DOMContentLoaded", P) : window.requestAnimationFrame ? window.requestAnimationFrame(P) : window.setTimeout(P, 16);
      }
      return p;
    }(e);
    t.exports && (t.exports = n), typeof Ku < "u" && (Ku.Prism = n), n.languages.markup = {
      comment: {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: !0
      },
      prolog: {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: !0
      },
      doctype: {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: !0,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: !0,
            greedy: !0,
            inside: null
            // see below
          },
          string: {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: !0
          },
          punctuation: /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          name: /[^\s<>'"]+/
        }
      },
      cdata: {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: !0
      },
      tag: {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: !0,
        inside: {
          tag: {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              punctuation: /^<\/?/,
              namespace: /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: !0
                }
              ]
            }
          },
          punctuation: /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              namespace: /^[^\s>\/:]+:/
            }
          }
        }
      },
      entity: [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    }, n.languages.markup.tag.inside["attr-value"].inside.entity = n.languages.markup.entity, n.languages.markup.doctype.inside["internal-subset"].inside = n.languages.markup, n.hooks.add("wrap", function(r) {
      r.type === "entity" && (r.attributes.title = r.content.replace(/&amp;/, "&"));
    }), Object.defineProperty(n.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function(c, d) {
        var h = {};
        h["language-" + d] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: !0,
          inside: n.languages[d]
        }, h.cdata = /^<!\[CDATA\[|\]\]>$/i;
        var p = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: h
          }
        };
        p["language-" + d] = {
          pattern: /[\s\S]+/,
          inside: n.languages[d]
        };
        var N = {};
        N[c] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return c;
          }), "i"),
          lookbehind: !0,
          greedy: !0,
          inside: p
        }, n.languages.insertBefore("markup", "cdata", N);
      }
    }), Object.defineProperty(n.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(r, c) {
        n.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + r + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: !0,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                value: {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: !0,
                  alias: [c, "language-" + c],
                  inside: n.languages[c]
                },
                punctuation: [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    }), n.languages.html = n.languages.markup, n.languages.mathml = n.languages.markup, n.languages.svg = n.languages.markup, n.languages.xml = n.languages.extend("markup", {}), n.languages.ssml = n.languages.xml, n.languages.atom = n.languages.xml, n.languages.rss = n.languages.xml, function(r) {
      var c = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      r.languages.css = {
        comment: /\/\*[\s\S]*?\*\//,
        atrule: {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + c.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            rule: /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: !0,
              alias: "selector"
            },
            keyword: {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: !0
            }
            // See rest below
          }
        },
        url: {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp("\\burl\\((?:" + c.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: !0,
          inside: {
            function: /^url/i,
            punctuation: /^\(|\)$/,
            string: {
              pattern: RegExp("^" + c.source + "$"),
              alias: "url"
            }
          }
        },
        selector: {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + c.source + ")*(?=\\s*\\{)"),
          lookbehind: !0
        },
        string: {
          pattern: c,
          greedy: !0
        },
        property: {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: !0
        },
        important: /!important\b/i,
        function: {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: !0
        },
        punctuation: /[(){};:,]/
      }, r.languages.css.atrule.inside.rest = r.languages.css;
      var d = r.languages.markup;
      d && (d.tag.addInlined("style", "css"), d.tag.addAttribute("style", "css"));
    }(n), n.languages.clike = {
      comment: [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: !0,
        inside: {
          punctuation: /[.\\]/
        }
      },
      keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      boolean: /\b(?:false|true)\b/,
      function: /\b\w+(?=\()/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      punctuation: /[{}[\];(),.:]/
    }, n.languages.javascript = n.languages.extend("clike", {
      "class-name": [
        n.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: !0
        }
      ],
      keyword: [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: !0
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: !0
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      number: {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: !0
      },
      operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    }), n.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, n.languages.insertBefore("javascript", "keyword", {
      regex: {
        pattern: RegExp(
          // lookbehind
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
          // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
          // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
          // with the only syntax, so we have to define 2 different regex patterns.
          /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
          /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
          /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: !0,
            alias: "language-regex",
            inside: n.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      parameter: [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: !0,
          inside: n.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: !0,
          inside: n.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: !0,
          inside: n.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: !0,
          inside: n.languages.javascript
        }
      ],
      constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    }), n.languages.insertBefore("javascript", "string", {
      hashbang: {
        pattern: /^#!.*/,
        greedy: !0,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: !0,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: !0,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: n.languages.javascript
            }
          },
          string: /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: !0,
        greedy: !0,
        alias: "property"
      }
    }), n.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: !0,
        alias: "property"
      }
    }), n.languages.markup && (n.languages.markup.tag.addInlined("script", "javascript"), n.languages.markup.tag.addAttribute(
      /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
      "javascript"
    )), n.languages.js = n.languages.javascript, function() {
      if (typeof n > "u" || typeof document > "u")
        return;
      Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
      var r = "Loading", c = function(w, P) {
        return " Error " + w + " while fetching file: " + P;
      }, d = " Error: File does not exist or is empty", h = {
        js: "javascript",
        py: "python",
        rb: "ruby",
        ps1: "powershell",
        psm1: "powershell",
        sh: "bash",
        bat: "batch",
        h: "c",
        tex: "latex"
      }, p = "data-src-status", N = "loading", x = "loaded", v = "failed", O = "pre[data-src]:not([" + p + '="' + x + '"]):not([' + p + '="' + N + '"])';
      function M(w, P, K) {
        var $ = new XMLHttpRequest();
        $.open("GET", w, !0), $.onreadystatechange = function() {
          $.readyState == 4 && ($.status < 400 && $.responseText ? P($.responseText) : $.status >= 400 ? K(c($.status, $.statusText)) : K(d));
        }, $.send(null);
      }
      function A(w) {
        var P = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(w || "");
        if (P) {
          var K = Number(P[1]), $ = P[2], W = P[3];
          return $ ? W ? [K, Number(W)] : [K, void 0] : [K, K];
        }
      }
      n.hooks.add("before-highlightall", function(w) {
        w.selector += ", " + O;
      }), n.hooks.add("before-sanity-check", function(w) {
        var P = (
          /** @type {HTMLPreElement} */
          w.element
        );
        if (P.matches(O)) {
          w.code = "", P.setAttribute(p, N);
          var K = P.appendChild(document.createElement("CODE"));
          K.textContent = r;
          var $ = P.getAttribute("data-src"), W = w.language;
          if (W === "none") {
            var H = (/\.(\w+)$/.exec($) || [, "none"])[1];
            W = h[H] || H;
          }
          n.util.setLanguage(K, W), n.util.setLanguage(P, W);
          var z = n.plugins.autoloader;
          z && z.loadLanguages(W), M(
            $,
            function(te) {
              P.setAttribute(p, x);
              var re = A(P.getAttribute("data-range"));
              if (re) {
                var ue = te.split(/\r\n?|\n/g), q = re[0], G = re[1] == null ? ue.length : re[1];
                q < 0 && (q += ue.length), q = Math.max(0, Math.min(q - 1, ue.length)), G < 0 && (G += ue.length), G = Math.max(0, Math.min(G, ue.length)), te = ue.slice(q, G).join(`
`), P.hasAttribute("data-start") || P.setAttribute("data-start", String(q + 1));
              }
              K.textContent = te, n.highlightElement(K);
            },
            function(te) {
              P.setAttribute(p, v), K.textContent = te;
            }
          );
        }
      }), n.plugins.fileHighlight = {
        /**
         * Executes the File Highlight plugin for all matching `pre` elements under the given container.
         *
         * Note: Elements which are already loaded or currently loading will not be touched by this method.
         *
         * @param {ParentNode} [container=document]
         */
        highlight: function(P) {
          for (var K = (P || document).querySelectorAll(O), $ = 0, W; W = K[$++]; )
            n.highlightElement(W);
        }
      };
      var T = !1;
      n.fileHighlight = function() {
        T || (console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."), T = !0), n.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    }();
  }(Du)), Du.exports;
}
var Ch = {}, Eh;
function vp() {
  return Eh || (Eh = 1, Prism.languages.clike = {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        greedy: !0
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: !0,
      inside: {
        punctuation: /[.\\]/
      }
    },
    keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
  }), Ch;
}
var Th = {}, xh;
function Sp() {
  return xh || (xh = 1, Prism.languages.javascript = Prism.languages.extend("clike", {
    "class-name": [
      Prism.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: !0
      }
    ],
    keyword: [
      {
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: !0
      }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    number: {
      pattern: RegExp(
        /(^|[^\w$])/.source + "(?:" + // constant
        (/NaN|Infinity/.source + "|" + // binary integer
        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
        /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
      ),
      lookbehind: !0
    },
    operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  }), Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, Prism.languages.insertBefore("javascript", "keyword", {
    regex: {
      pattern: RegExp(
        // lookbehind
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
        // with the only syntax, so we have to define 2 different regex patterns.
        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: !0,
          alias: "language-regex",
          inside: Prism.languages.regex
        },
        "regex-delimiter": /^\/|\/$/,
        "regex-flags": /^[a-z]+$/
      }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    },
    parameter: [
      {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: !0,
        inside: Prism.languages.javascript
      },
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: !0,
        inside: Prism.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: !0,
        inside: Prism.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: !0,
        inside: Prism.languages.javascript
      }
    ],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  }), Prism.languages.insertBefore("javascript", "string", {
    hashbang: {
      pattern: /^#!.*/,
      greedy: !0,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: !0,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: !0,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            rest: Prism.languages.javascript
          }
        },
        string: /[\s\S]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: !0,
      greedy: !0,
      alias: "property"
    }
  }), Prism.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: !0,
      alias: "property"
    }
  }), Prism.languages.markup && (Prism.languages.markup.tag.addInlined("script", "javascript"), Prism.languages.markup.tag.addAttribute(
    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    "javascript"
  )), Prism.languages.js = Prism.languages.javascript), Th;
}
var vh = {}, Sh;
function wp() {
  return Sh || (Sh = 1, Prism.languages.markup = {
    comment: {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: !0
    },
    prolog: {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: !0
    },
    doctype: {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: !0,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: !0,
          greedy: !0,
          inside: null
          // see below
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: !0
        },
        punctuation: /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        name: /[^\s<>'"]+/
      }
    },
    cdata: {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: !0
    },
    tag: {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: !0,
      inside: {
        tag: {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            punctuation: /^<\/?/,
            namespace: /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            punctuation: [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: !0
              }
            ]
          }
        },
        punctuation: /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            namespace: /^[^\s>\/:]+:/
          }
        }
      }
    },
    entity: [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  }, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup, Prism.hooks.add("wrap", function(t) {
    t.type === "entity" && (t.attributes.title = t.content.replace(/&amp;/, "&"));
  }), Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function(e, n) {
      var r = {};
      r["language-" + n] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: !0,
        inside: Prism.languages[n]
      }, r.cdata = /^<!\[CDATA\[|\]\]>$/i;
      var c = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: r
        }
      };
      c["language-" + n] = {
        pattern: /[\s\S]+/,
        inside: Prism.languages[n]
      };
      var d = {};
      d[e] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return e;
        }), "i"),
        lookbehind: !0,
        greedy: !0,
        inside: c
      }, Prism.languages.insertBefore("markup", "cdata", d);
    }
  }), Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: function(t, e) {
      Prism.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + t + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: !0,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              value: {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: !0,
                alias: [e, "language-" + e],
                inside: Prism.languages[e]
              },
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  }), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend("markup", {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml), vh;
}
var wh = {}, Oh;
function Op() {
  return Oh || (Oh = 1, function(t) {
    var e = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
    function n(v) {
      return v = v.replace(/<inner>/g, function() {
        return e;
      }), RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + v + ")");
    }
    var r = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source, c = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
      return r;
    }), d = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
    t.languages.markdown = t.languages.extend("markup", {}), t.languages.insertBefore("markdown", "prolog", {
      "front-matter-block": {
        pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          punctuation: /^---|---$/,
          "front-matter": {
            pattern: /\S+(?:\s+\S+)*/,
            alias: ["yaml", "language-yaml"],
            inside: t.languages.yaml
          }
        }
      },
      blockquote: {
        // > ...
        pattern: /^>(?:[\t ]*>)*/m,
        alias: "punctuation"
      },
      table: {
        pattern: RegExp("^" + c + d + "(?:" + c + ")*", "m"),
        inside: {
          "table-data-rows": {
            pattern: RegExp("^(" + c + d + ")(?:" + c + ")*$"),
            lookbehind: !0,
            inside: {
              "table-data": {
                pattern: RegExp(r),
                inside: t.languages.markdown
              },
              punctuation: /\|/
            }
          },
          "table-line": {
            pattern: RegExp("^(" + c + ")" + d + "$"),
            lookbehind: !0,
            inside: {
              punctuation: /\||:?-{3,}:?/
            }
          },
          "table-header-row": {
            pattern: RegExp("^" + c + "$"),
            inside: {
              "table-header": {
                pattern: RegExp(r),
                alias: "important",
                inside: t.languages.markdown
              },
              punctuation: /\|/
            }
          }
        }
      },
      code: [
        {
          // Prefixed by 4 spaces or 1 tab and preceded by an empty line
          pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
          lookbehind: !0,
          alias: "keyword"
        },
        {
          // ```optional language
          // code block
          // ```
          pattern: /^```[\s\S]*?^```$/m,
          greedy: !0,
          inside: {
            "code-block": {
              pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
              lookbehind: !0
            },
            "code-language": {
              pattern: /^(```).+/,
              lookbehind: !0
            },
            punctuation: /```/
          }
        }
      ],
      title: [
        {
          // title 1
          // =======
          // title 2
          // -------
          pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
          alias: "important",
          inside: {
            punctuation: /==+$|--+$/
          }
        },
        {
          // # title 1
          // ###### title 6
          pattern: /(^\s*)#.+/m,
          lookbehind: !0,
          alias: "important",
          inside: {
            punctuation: /^#+|#+$/
          }
        }
      ],
      hr: {
        // ***
        // ---
        // * * *
        // -----------
        pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
        lookbehind: !0,
        alias: "punctuation"
      },
      list: {
        // * item
        // + item
        // - item
        // 1. item
        pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
        lookbehind: !0,
        alias: "punctuation"
      },
      "url-reference": {
        // [id]: http://example.com "Optional title"
        // [id]: http://example.com 'Optional title'
        // [id]: http://example.com (Optional title)
        // [id]: <http://example.com> "Optional title"
        pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
        inside: {
          variable: {
            pattern: /^(!?\[)[^\]]+/,
            lookbehind: !0
          },
          string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
          punctuation: /^[\[\]!:]|[<>]/
        },
        alias: "url"
      },
      bold: {
        // **strong**
        // __strong__
        // allow one nested instance of italic text using the same delimiter
        pattern: n(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
        lookbehind: !0,
        greedy: !0,
        inside: {
          content: {
            pattern: /(^..)[\s\S]+(?=..$)/,
            lookbehind: !0,
            inside: {}
            // see below
          },
          punctuation: /\*\*|__/
        }
      },
      italic: {
        // *em*
        // _em_
        // allow one nested instance of bold text using the same delimiter
        pattern: n(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
        lookbehind: !0,
        greedy: !0,
        inside: {
          content: {
            pattern: /(^.)[\s\S]+(?=.$)/,
            lookbehind: !0,
            inside: {}
            // see below
          },
          punctuation: /[*_]/
        }
      },
      strike: {
        // ~~strike through~~
        // ~strike~
        // eslint-disable-next-line regexp/strict
        pattern: n(/(~~?)(?:(?!~)<inner>)+\2/.source),
        lookbehind: !0,
        greedy: !0,
        inside: {
          content: {
            pattern: /(^~~?)[\s\S]+(?=\1$)/,
            lookbehind: !0,
            inside: {}
            // see below
          },
          punctuation: /~~?/
        }
      },
      "code-snippet": {
        // `code`
        // ``code``
        pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
        lookbehind: !0,
        greedy: !0,
        alias: ["code", "keyword"]
      },
      url: {
        // [example](http://example.com "Optional title")
        // [example][id]
        // [example] [id]
        pattern: n(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
        lookbehind: !0,
        greedy: !0,
        inside: {
          operator: /^!/,
          content: {
            pattern: /(^\[)[^\]]+(?=\])/,
            lookbehind: !0,
            inside: {}
            // see below
          },
          variable: {
            pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
            lookbehind: !0
          },
          url: {
            pattern: /(^\]\()[^\s)]+/,
            lookbehind: !0
          },
          string: {
            pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
            lookbehind: !0
          }
        }
      }
    }), ["url", "bold", "italic", "strike"].forEach(function(v) {
      ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(O) {
        v !== O && (t.languages.markdown[v].inside.content.inside[O] = t.languages.markdown[O]);
      });
    }), t.hooks.add("after-tokenize", function(v) {
      if (v.language !== "markdown" && v.language !== "md")
        return;
      function O(M) {
        if (!(!M || typeof M == "string"))
          for (var A = 0, T = M.length; A < T; A++) {
            var w = M[A];
            if (w.type !== "code") {
              O(w.content);
              continue;
            }
            var P = w.content[1], K = w.content[3];
            if (P && K && P.type === "code-language" && K.type === "code-block" && typeof P.content == "string") {
              var $ = P.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
              $ = (/[a-z][\w-]*/i.exec($) || [""])[0].toLowerCase();
              var W = "language-" + $;
              K.alias ? typeof K.alias == "string" ? K.alias = [K.alias, W] : K.alias.push(W) : K.alias = [W];
            }
          }
      }
      O(v.tokens);
    }), t.hooks.add("wrap", function(v) {
      if (v.type === "code-block") {
        for (var O = "", M = 0, A = v.classes.length; M < A; M++) {
          var T = v.classes[M], w = /language-(.+)/.exec(T);
          if (w) {
            O = w[1];
            break;
          }
        }
        var P = t.languages[O];
        if (P)
          v.content = t.highlight(x(v.content), P, O);
        else if (O && O !== "none" && t.plugins.autoloader) {
          var K = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
          v.attributes.id = K, t.plugins.autoloader.loadLanguages(O, function() {
            var $ = document.getElementById(K);
            $ && ($.innerHTML = t.highlight($.textContent, t.languages[O], O));
          });
        }
      }
    });
    var h = RegExp(t.languages.markup.tag.pattern.source, "gi"), p = {
      amp: "&",
      lt: "<",
      gt: ">",
      quot: '"'
    }, N = String.fromCodePoint || String.fromCharCode;
    function x(v) {
      var O = v.replace(h, "");
      return O = O.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(M, A) {
        if (A = A.toLowerCase(), A[0] === "#") {
          var T;
          return A[1] === "x" ? T = parseInt(A.slice(2), 16) : T = Number(A.slice(1)), N(T);
        } else {
          var w = p[A];
          return w || M;
        }
      }), O;
    }
    t.languages.md = t.languages.markdown;
  }(Prism)), wh;
}
var Dh = {}, Rh;
function Dp() {
  return Rh || (Rh = 1, Prism.languages.c = Prism.languages.extend("clike", {
    comment: {
      pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
      greedy: !0
    },
    string: {
      // https://en.cppreference.com/w/c/language/string_literal
      pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
      lookbehind: !0
    },
    keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
    operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
  }), Prism.languages.insertBefore("c", "string", {
    char: {
      // https://en.cppreference.com/w/c/language/character_constant
      pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
      greedy: !0
    }
  }), Prism.languages.insertBefore("c", "string", {
    macro: {
      // allow for multiline macro definitions
      // spaces after the # character compile fine with gcc
      pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
      lookbehind: !0,
      greedy: !0,
      alias: "property",
      inside: {
        string: [
          {
            // highlight the path of the include statement as a string
            pattern: /^(#\s*include\s*)<[^>]+>/,
            lookbehind: !0
          },
          Prism.languages.c.string
        ],
        char: Prism.languages.c.char,
        comment: Prism.languages.c.comment,
        "macro-name": [
          {
            pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
            lookbehind: !0
          },
          {
            pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
            lookbehind: !0,
            alias: "function"
          }
        ],
        // highlight macro directives as keywords
        directive: {
          pattern: /^(#\s*)[a-z]+/,
          lookbehind: !0,
          alias: "keyword"
        },
        "directive-hash": /^#/,
        punctuation: /##|\\(?=[\r\n])/,
        expression: {
          pattern: /\S[\s\S]*/,
          inside: Prism.languages.c
        }
      }
    }
  }), Prism.languages.insertBefore("c", "function", {
    // highlight predefined macros as constants
    constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
  }), delete Prism.languages.c.boolean), Dh;
}
var bh = {}, Mh;
function Rp() {
  return Mh || (Mh = 1, function(t) {
    var e = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    t.languages.css = {
      comment: /\/\*[\s\S]*?\*\//,
      atrule: {
        pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + e.source + ")*?" + /(?:;|(?=\s*\{))/.source),
        inside: {
          rule: /^@[\w-]+/,
          "selector-function-argument": {
            pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
            lookbehind: !0,
            alias: "selector"
          },
          keyword: {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: !0
          }
          // See rest below
        }
      },
      url: {
        // https://drafts.csswg.org/css-values-3/#urls
        pattern: RegExp("\\burl\\((?:" + e.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
        greedy: !0,
        inside: {
          function: /^url/i,
          punctuation: /^\(|\)$/,
          string: {
            pattern: RegExp("^" + e.source + "$"),
            alias: "url"
          }
        }
      },
      selector: {
        pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + e.source + ")*(?=\\s*\\{)"),
        lookbehind: !0
      },
      string: {
        pattern: e,
        greedy: !0
      },
      property: {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: !0
      },
      important: /!important\b/i,
      function: {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: !0
      },
      punctuation: /[(){};:,]/
    }, t.languages.css.atrule.inside.rest = t.languages.css;
    var n = t.languages.markup;
    n && (n.tag.addInlined("style", "css"), n.tag.addAttribute("style", "css"));
  }(Prism)), bh;
}
var Ah = {}, kh;
function bp() {
  return kh || (kh = 1, Prism.languages.objectivec = Prism.languages.extend("c", {
    string: {
      pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: !0
    },
    keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
    operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
  }), delete Prism.languages.objectivec["class-name"], Prism.languages.objc = Prism.languages.objectivec), Ah;
}
var Lh = {}, Ih;
function Mp() {
  return Ih || (Ih = 1, Prism.languages.sql = {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
      lookbehind: !0
    },
    variable: [
      {
        pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
        greedy: !0
      },
      /@[\w.$]+/
    ],
    string: {
      pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
      greedy: !0,
      lookbehind: !0
    },
    identifier: {
      pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
      greedy: !0,
      lookbehind: !0,
      inside: {
        punctuation: /^`|`$/
      }
    },
    function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
    // Should we highlight user defined functions too?
    keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
    boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
    number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
    operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
    punctuation: /[;[\]()`,.]/
  }), Lh;
}
var Ph = {}, $h;
function Ap() {
  return $h || ($h = 1, Prism.languages.python = {
    comment: {
      pattern: /(^|[^\\])#.*/,
      lookbehind: !0,
      greedy: !0
    },
    "string-interpolation": {
      pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
      greedy: !0,
      inside: {
        interpolation: {
          // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
          pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
          lookbehind: !0,
          inside: {
            "format-spec": {
              pattern: /(:)[^:(){}]+(?=\}$)/,
              lookbehind: !0
            },
            "conversion-option": {
              pattern: /![sra](?=[:}]$)/,
              alias: "punctuation"
            },
            rest: null
          }
        },
        string: /[\s\S]+/
      }
    },
    "triple-quoted-string": {
      pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
      greedy: !0,
      alias: "string"
    },
    string: {
      pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
      greedy: !0
    },
    function: {
      pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
      lookbehind: !0
    },
    "class-name": {
      pattern: /(\bclass\s+)\w+/i,
      lookbehind: !0
    },
    decorator: {
      pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
      lookbehind: !0,
      alias: ["annotation", "punctuation"],
      inside: {
        punctuation: /\./
      }
    },
    keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
    builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
    boolean: /\b(?:False|None|True)\b/,
    number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
    operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
    punctuation: /[{}[\];(),.:]/
  }, Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python, Prism.languages.py = Prism.languages.python), Ph;
}
var Fh = {}, Bh;
function kp() {
  return Bh || (Bh = 1, function(t) {
    for (var e = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source, n = 0; n < 2; n++)
      e = e.replace(/<self>/g, function() {
        return e;
      });
    e = e.replace(/<self>/g, function() {
      return /[^\s\S]/.source;
    }), t.languages.rust = {
      comment: [
        {
          pattern: RegExp(/(^|[^\\])/.source + e),
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      string: {
        pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
        greedy: !0
      },
      char: {
        pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
        greedy: !0
      },
      attribute: {
        pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
        greedy: !0,
        alias: "attr-name",
        inside: {
          string: null
          // see below
        }
      },
      // Closure params should not be confused with bitwise OR |
      "closure-params": {
        pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          "closure-punctuation": {
            pattern: /^\||\|$/,
            alias: "punctuation"
          },
          rest: null
          // see below
        }
      },
      "lifetime-annotation": {
        pattern: /'\w+/,
        alias: "symbol"
      },
      "fragment-specifier": {
        pattern: /(\$\w+:)[a-z]+/,
        lookbehind: !0,
        alias: "punctuation"
      },
      variable: /\$\w+/,
      "function-definition": {
        pattern: /(\bfn\s+)\w+/,
        lookbehind: !0,
        alias: "function"
      },
      "type-definition": {
        pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
        lookbehind: !0,
        alias: "class-name"
      },
      "module-declaration": [
        {
          pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
          lookbehind: !0,
          alias: "namespace"
        },
        {
          pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
          lookbehind: !0,
          alias: "namespace",
          inside: {
            punctuation: /::/
          }
        }
      ],
      keyword: [
        // https://github.com/rust-lang/reference/blob/master/src/keywords.md
        /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
        // primitives and str
        // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
        /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
      ],
      // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
      // and Rust's naming conventions recommend snake_case anyway.
      // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
      function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
      macro: {
        pattern: /\b\w+!/,
        alias: "property"
      },
      constant: /\b[A-Z_][A-Z_\d]+\b/,
      "class-name": /\b[A-Z]\w*\b/,
      namespace: {
        pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
        inside: {
          punctuation: /::/
        }
      },
      // Hex, oct, bin, dec numbers with visual separators and type suffix
      number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
      boolean: /\b(?:false|true)\b/,
      punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
      operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
    }, t.languages.rust["closure-params"].inside.rest = t.languages.rust, t.languages.rust.attribute.inside.string = t.languages.rust.string;
  }(Prism)), Fh;
}
var Hh = {}, Wh;
function Lp() {
  return Wh || (Wh = 1, Prism.languages.swift = {
    comment: {
      // Nested comments are supported up to 2 levels
      pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
      lookbehind: !0,
      greedy: !0
    },
    "string-literal": [
      // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
      {
        pattern: RegExp(
          /(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: !0,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\\($/,
            alias: "punctuation"
          },
          punctuation: /\\(?=[\r\n])/,
          string: /[\s\S]+/
        }
      },
      {
        pattern: RegExp(
          /(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: !0,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\#+\($/,
            alias: "punctuation"
          },
          string: /[\s\S]+/
        }
      }
    ],
    directive: {
      // directives with conditions
      pattern: RegExp(
        /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
      ),
      alias: "property",
      inside: {
        "directive-name": /^#\w+/,
        boolean: /\b(?:false|true)\b/,
        number: /\b\d+(?:\.\d+)*\b/,
        operator: /!|&&|\|\||[<>]=?/,
        punctuation: /[(),]/
      }
    },
    literal: {
      pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
      alias: "constant"
    },
    "other-directive": {
      pattern: /#\w+\b/,
      alias: "property"
    },
    attribute: {
      pattern: /@\w+/,
      alias: "atrule"
    },
    "function-definition": {
      pattern: /(\bfunc\s+)\w+/,
      lookbehind: !0,
      alias: "function"
    },
    label: {
      // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
      pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
      lookbehind: !0,
      alias: "important"
    },
    keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
    boolean: /\b(?:false|true)\b/,
    nil: {
      pattern: /\bnil\b/,
      alias: "constant"
    },
    "short-argument": /\$\d+\b/,
    omit: {
      pattern: /\b_\b/,
      alias: "keyword"
    },
    number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
    // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
    "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
    // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
    // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
    // This regex only supports ASCII operators.
    operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
    punctuation: /[{}[\]();,.:\\]/
  }, Prism.languages.swift["string-literal"].forEach(function(t) {
    t.inside.interpolation.inside = Prism.languages.swift;
  })), Hh;
}
var Kh = {}, Uh;
function Ip() {
  return Uh || (Uh = 1, function(t) {
    t.languages.typescript = t.languages.extend("javascript", {
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
        lookbehind: !0,
        greedy: !0,
        inside: null
        // see below
      },
      builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
    }), t.languages.typescript.keyword.push(
      /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
      // keywords that have to be followed by an identifier
      /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
      // This is for `import type *, {}`
      /\btype\b(?=\s*(?:[\{*]|$))/
    ), delete t.languages.typescript.parameter, delete t.languages.typescript["literal-property"];
    var e = t.languages.extend("typescript", {});
    delete e["class-name"], t.languages.typescript["class-name"].inside = e, t.languages.insertBefore("typescript", "function", {
      decorator: {
        pattern: /@[$\w\xA0-\uFFFF]+/,
        inside: {
          at: {
            pattern: /^@/,
            alias: "operator"
          },
          function: /^[\s\S]+/
        }
      },
      "generic-function": {
        // e.g. foo<T extends "bar" | "baz">( ...
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
        greedy: !0,
        inside: {
          function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
          generic: {
            pattern: /<[\s\S]+/,
            // everything after the first <
            alias: "class-name",
            inside: e
          }
        }
      }
    }), t.languages.ts = t.languages.typescript;
  }(Prism)), Kh;
}
var zh = {}, Gh;
function Pp() {
  return Gh || (Gh = 1, function(t) {
    var e = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/, n = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source, r = {
      pattern: RegExp(/(^|[^\w.])/.source + n + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
      lookbehind: !0,
      inside: {
        namespace: {
          pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
          inside: {
            punctuation: /\./
          }
        },
        punctuation: /\./
      }
    };
    t.languages.java = t.languages.extend("clike", {
      string: {
        pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
        lookbehind: !0,
        greedy: !0
      },
      "class-name": [
        r,
        {
          // variables, parameters, and constructor references
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(/(^|[^\w.])/.source + n + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
          lookbehind: !0,
          inside: r.inside
        },
        {
          // class names based on keyword
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + n + /[A-Z]\w*\b/.source),
          lookbehind: !0,
          inside: r.inside
        }
      ],
      keyword: e,
      function: [
        t.languages.clike.function,
        {
          pattern: /(::\s*)[a-z_]\w*/,
          lookbehind: !0
        }
      ],
      number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
      operator: {
        pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
        lookbehind: !0
      },
      constant: /\b[A-Z][A-Z_\d]+\b/
    }), t.languages.insertBefore("java", "string", {
      "triple-quoted-string": {
        // http://openjdk.java.net/jeps/355#Description
        pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
        greedy: !0,
        alias: "string"
      },
      char: {
        pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
        greedy: !0
      }
    }), t.languages.insertBefore("java", "class-name", {
      annotation: {
        pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
        lookbehind: !0,
        alias: "punctuation"
      },
      generics: {
        pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
        inside: {
          "class-name": r,
          keyword: e,
          punctuation: /[<>(),.:]/,
          operator: /[?&|]/
        }
      },
      import: [
        {
          pattern: RegExp(/(\bimport\s+)/.source + n + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
          lookbehind: !0,
          inside: {
            namespace: r.inside.namespace,
            punctuation: /\./,
            operator: /\*/,
            "class-name": /\w+/
          }
        },
        {
          pattern: RegExp(/(\bimport\s+static\s+)/.source + n + /(?:\w+|\*)(?=\s*;)/.source),
          lookbehind: !0,
          alias: "static",
          inside: {
            namespace: r.inside.namespace,
            static: /\b\w+$/,
            punctuation: /\./,
            operator: /\*/,
            "class-name": /\w+/
          }
        }
      ],
      namespace: {
        pattern: RegExp(
          /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
            return e.source;
          })
        ),
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      }
    });
  }(Prism)), zh;
}
var Yh = {}, Vh;
function $p() {
  return Vh || (Vh = 1, function(t) {
    var e = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, n = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
      return e.source;
    });
    t.languages.cpp = t.languages.extend("c", {
      "class-name": [
        {
          pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
            return e.source;
          })),
          lookbehind: !0
        },
        // This is intended to capture the class name of method implementations like:
        //   void foo::bar() const {}
        // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
        // it starts with an uppercase letter. This approximation should give decent results.
        /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
        // This will capture the class name before destructors like:
        //   Foo::~Foo() {}
        /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
        // This also intends to capture the class name of method implementations but here the class has template
        // parameters, so it can't be a namespace (until C++ adds generic namespaces).
        /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
      ],
      keyword: e,
      number: {
        pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
        greedy: !0
      },
      operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
      boolean: /\b(?:false|true)\b/
    }), t.languages.insertBefore("cpp", "string", {
      module: {
        // https://en.cppreference.com/w/cpp/language/modules
        pattern: RegExp(
          /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
          /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
          /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
            return n;
          }) + ")"
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          string: /^[<"][\s\S]+/,
          operator: /:/,
          punctuation: /\./
        }
      },
      "raw-string": {
        pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
        alias: "string",
        greedy: !0
      }
    }), t.languages.insertBefore("cpp", "keyword", {
      "generic-function": {
        pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
        inside: {
          function: /^\w+/,
          generic: {
            pattern: /<[\s\S]+/,
            alias: "class-name",
            inside: t.languages.cpp
          }
        }
      }
    }), t.languages.insertBefore("cpp", "operator", {
      "double-colon": {
        pattern: /::/,
        alias: "punctuation"
      }
    }), t.languages.insertBefore("cpp", "class-name", {
      // the base clause is an optional list of parent classes
      // https://en.cppreference.com/w/cpp/language/class
      "base-clause": {
        pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
        lookbehind: !0,
        greedy: !0,
        inside: t.languages.extend("cpp", {})
      }
    }), t.languages.insertBefore("inside", "double-colon", {
      // All untokenized words that are not namespaces should be class names
      "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
    }, t.languages.cpp["base-clause"]);
  }(Prism)), Yh;
}
var jh;
function tC() {
  if (jh)
    return Rn;
  jh = 1;
  var t = xp();
  vp(), Sp(), wp(), Op(), Dp(), Rp(), bp(), Mp(), Ap(), kp(), Lp(), Ip(), Pp(), $p();
  var e = rn(), n = Bt();
  let r = (k) => k != null && t.languages.hasOwnProperty(k) ? k : void 0;
  function c(k, m) {
    for (let y of k.childNodes) {
      if (e.isHTMLElement(y) && y.tagName === m)
        return !0;
      c(y, m);
    }
    return !1;
  }
  class d extends n.ElementNode {
    static getType() {
      return "code";
    }
    static clone(m) {
      return new d(m.__language, m.__key);
    }
    constructor(m, y) {
      super(y), this.__language = r(m);
    }
    createDOM(m) {
      let y = document.createElement("code");
      return e.addClassNamesToElement(y, m.theme.code), y.setAttribute("spellcheck", "false"), (m = this.getLanguage()) && y.setAttribute("data-highlight-language", m), y;
    }
    updateDOM(m, y) {
      let b = this.__language;
      return m = m.__language, b ? b !== m && y.setAttribute("data-highlight-language", b) : m && y.removeAttribute("data-highlight-language"), !1;
    }
    exportDOM() {
      let m = document.createElement("pre");
      m.setAttribute("spellcheck", "false");
      let y = this.getLanguage();
      return y && m.setAttribute("data-highlight-language", y), { element: m };
    }
    static importDOM() {
      return { code: (m) => m.textContent != null && (/\r?\n/.test(m.textContent) || c(m, "BR")) ? { conversion: N, priority: 1 } : null, div: () => ({ conversion: x, priority: 1 }), pre: () => ({ conversion: N, priority: 0 }), table: (m) => T(m) ? { conversion: v, priority: 3 } : null, td: (m) => {
        let y = m.closest("table");
        return m.classList.contains("js-file-line") ? { conversion: M, priority: 3 } : y && T(y) ? { conversion: O, priority: 3 } : null;
      }, tr: (m) => (m = m.closest("table")) && T(m) ? { conversion: O, priority: 3 } : null };
    }
    static importJSON(m) {
      let y = h(m.language);
      return y.setFormat(m.format), y.setIndent(m.indent), y.setDirection(m.direction), y;
    }
    exportJSON() {
      return { ...super.exportJSON(), language: this.getLanguage(), type: "code", version: 1 };
    }
    insertNewAfter(m, y = !0) {
      var b = this.getChildren(), Z = b.length;
      if (2 <= Z && b[Z - 1].getTextContent() === `
` && b[Z - 2].getTextContent() === `
` && m.isCollapsed() && m.anchor.key === this.__key && m.anchor.offset === Z)
        return b[Z - 1].remove(), b[Z - 2].remove(), m = n.$createParagraphNode(), this.insertAfter(m, y), m;
      let { anchor: ce, focus: ge } = m;
      if (y = (ce.isBefore(ge) ? ce : ge).getNode(), n.$isTextNode(y)) {
        for (Z = te(y), b = []; ; )
          if (n.$isTabNode(Z))
            b.push(n.$createTabNode()), Z = Z.getNextSibling();
          else if (z(Z)) {
            for (var ae = 0, Te = Z.getTextContent(), Ae = Z.getTextContentSize(); ae < Ae && Te[ae] === " "; ae++)
              ;
            if (ae !== 0 && b.push(H(" ".repeat(ae))), ae !== Ae)
              break;
            Z = Z.getNextSibling();
          } else
            break;
        Z = y.splitText(ce.offset)[0], ae = ce.offset === 0 ? 0 : 1, ae = Z.getIndexWithinParent() + ae, Te = y.getParentOrThrow(), Ae = [n.$createLineBreakNode(), ...b], Te.splice(ae, 0, Ae), (b = b[b.length - 1]) ? b.select() : ce.offset === 0 ? Z.selectPrevious() : Z.getNextSibling().selectNext(0, 0);
      }
      return p(y) && ({ offset: m } = m.anchor, y.splice(m, 0, [n.$createLineBreakNode()]), y.select(m + 1, m + 1)), null;
    }
    canIndent() {
      return !1;
    }
    collapseAtStart() {
      let m = n.$createParagraphNode();
      return this.getChildren().forEach((y) => m.append(y)), this.replace(m), !0;
    }
    setLanguage(m) {
      this.getWritable().__language = r(m);
    }
    getLanguage() {
      return this.getLatest().__language;
    }
  }
  function h(k) {
    return n.$applyNodeReplacement(new d(k));
  }
  function p(k) {
    return k instanceof d;
  }
  function N(k) {
    let m;
    return e.isHTMLElement(k) && (m = k.getAttribute("data-highlight-language")), { node: h(m) };
  }
  function x(k) {
    let m = k.style.fontFamily.match("monospace") !== null;
    return m || A(k) ? { after: (y) => {
      let b = k.parentNode;
      return b != null && k !== b.lastChild && y.push(n.$createLineBreakNode()), y;
    }, node: m ? h() : null } : { node: null };
  }
  function v() {
    return { node: h() };
  }
  function O() {
    return { node: null };
  }
  function M(k) {
    return { after: (m) => (k.parentNode && k.parentNode.nextSibling && m.push(n.$createLineBreakNode()), m), node: null };
  }
  function A(k) {
    for (k = k.parentElement; k !== null; ) {
      if (k.style.fontFamily.match("monospace") !== null)
        return !0;
      k = k.parentElement;
    }
    return !1;
  }
  function T(k) {
    return k.classList.contains("js-file-line-container");
  }
  let w = { c: "C", clike: "C-like", cpp: "C++", css: "CSS", html: "HTML", java: "Java", js: "JavaScript", markdown: "Markdown", objc: "Objective-C", plain: "Plain Text", py: "Python", rust: "Rust", sql: "SQL", swift: "Swift", typescript: "TypeScript", xml: "XML" }, P = { cpp: "cpp", java: "java", javascript: "js", md: "markdown", plaintext: "plain", python: "py", text: "plain", ts: "typescript" };
  function K(k) {
    return P[k] || k;
  }
  class $ extends n.TextNode {
    constructor(m, y, b) {
      super(m, b), this.__highlightType = y;
    }
    static getType() {
      return "code-highlight";
    }
    static clone(m) {
      return new $(m.__text, m.__highlightType || void 0, m.__key);
    }
    getHighlightType() {
      return this.getLatest().__highlightType;
    }
    createDOM(m) {
      let y = super.createDOM(m);
      return m = W(m.theme, this.__highlightType), e.addClassNamesToElement(y, m), y;
    }
    updateDOM(m, y, b) {
      let Z = super.updateDOM(m, y, b);
      return m = W(b.theme, m.__highlightType), b = W(b.theme, this.__highlightType), m !== b && (m && e.removeClassNamesFromElement(
        y,
        m
      ), b && e.addClassNamesToElement(y, b)), Z;
    }
    static importJSON(m) {
      let y = H(m.text, m.highlightType);
      return y.setFormat(m.format), y.setDetail(m.detail), y.setMode(m.mode), y.setStyle(m.style), y;
    }
    exportJSON() {
      return { ...super.exportJSON(), highlightType: this.getHighlightType(), type: "code-highlight", version: 1 };
    }
    setFormat() {
      return this;
    }
    isParentRequired() {
      return !0;
    }
    createParentElementNode() {
      return h();
    }
  }
  function W(k, m) {
    return m && k && k.codeHighlight && k.codeHighlight[m];
  }
  function H(k, m) {
    return n.$applyNodeReplacement(new $(k, m));
  }
  function z(k) {
    return k instanceof $;
  }
  function te(k) {
    let m = k;
    for (; z(k) || n.$isTabNode(k); )
      m = k, k = k.getPreviousSibling();
    return m;
  }
  function re(k) {
    let m = k;
    for (; z(k) || n.$isTabNode(k); )
      m = k, k = k.getNextSibling();
    return m;
  }
  let ue = { defaultLanguage: "javascript", tokenize(k, m) {
    return t.tokenize(k, t.languages[m || ""] || t.languages[this.defaultLanguage]);
  } };
  function q(k, m) {
    let y = null;
    var b = null, Z = k;
    let ce = m, ge = k.getTextContent();
    for (; ; ) {
      if (ce === 0) {
        if (Z = Z.getPreviousSibling(), Z === null)
          break;
        if (!(z(Z) || n.$isTabNode(Z) || n.$isLineBreakNode(Z)))
          throw Error("Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode");
        if (n.$isLineBreakNode(Z)) {
          y = { node: Z, offset: 1 };
          break;
        }
        ce = Math.max(0, Z.getTextContentSize() - 1), ge = Z.getTextContent();
      } else
        ce--;
      let ae = ge[ce];
      z(Z) && ae !== " " && (b = { node: Z, offset: ce });
    }
    if (b !== null)
      return b;
    if (b = null, m < k.getTextContentSize() ? z(k) && (b = k.getTextContent()[m]) : (Z = k.getNextSibling(), z(Z) && (b = Z.getTextContent()[0])), b !== null && b !== " ")
      return y;
    e:
      for (b = k, Z = k.getTextContent(), k = k.getTextContentSize(); ; ) {
        if (!z(b) || m === k) {
          if (b = b.getNextSibling(), b === null || n.$isLineBreakNode(b)) {
            k = null;
            break e;
          }
          z(b) && (m = 0, Z = b.getTextContent(), k = b.getTextContentSize());
        }
        if (z(b)) {
          if (Z[m] !== " ") {
            k = { node: b, offset: m };
            break e;
          }
          m++;
        }
      }
    return k !== null ? k : y;
  }
  function G(k) {
    if (k = re(k), n.$isLineBreakNode(k))
      throw Error("Unexpected lineBreakNode in getEndOfCodeInLine");
    return k;
  }
  function j(k, m, y) {
    let b = k.getParent();
    p(b) ? pe(b, m, y) : z(k) && k.replace(n.$createTextNode(k.__text));
  }
  let _e = /* @__PURE__ */ new Set();
  function pe(k, m, y) {
    let b = k.getKey();
    _e.has(b) || (_e.add(b), k.getLanguage() === void 0 && k.setLanguage(y.defaultLanguage), m.update(() => {
      ee(b, () => {
        var Z = n.$getNodeByKey(b);
        if (!p(Z) || !Z.isAttached())
          return !1;
        var ce = Z.getTextContent();
        ce = y.tokenize(ce, Z.getLanguage() || y.defaultLanguage), ce = J(ce);
        var ge = Z.getChildren();
        for (Z = 0; Z < ge.length && F(ge[Z], ce[Z]); )
          Z++;
        var ae = ge.length;
        let Te = ce.length, Ae = Math.min(ae, Te) - Z, ze = 0;
        for (; ze < Ae; )
          if (ze++, !F(ge[ae - ze], ce[Te - ze])) {
            ze--;
            break;
          }
        ge = Z, ae -= ze, ce = ce.slice(Z, Te - ze);
        let { from: oe, to: ie, nodesForReplacement: de } = { from: ge, nodesForReplacement: ce, to: ae };
        return oe !== ie || de.length ? (k.splice(oe, ie - oe, de), !0) : !1;
      });
    }, { onUpdate: () => {
      _e.delete(b);
    }, skipTransforms: !0 }));
  }
  function J(k, m) {
    let y = [];
    for (let b of k)
      if (typeof b == "string") {
        k = b.split(/(\n|\t)/);
        let Z = k.length;
        for (let ce = 0; ce < Z; ce++) {
          let ge = k[ce];
          ge === `
` || ge === `\r
` ? y.push(n.$createLineBreakNode()) : ge === "	" ? y.push(n.$createTabNode()) : 0 < ge.length && y.push(H(ge, m));
        }
      } else
        ({ content: k } = b), typeof k == "string" ? y.push(...J([k], b.type)) : Array.isArray(k) && y.push(...J(k, b.type));
    return y;
  }
  function ee(k, m) {
    if (k = n.$getNodeByKey(k), p(k) && k.isAttached()) {
      var y = n.$getSelection();
      if (n.$isRangeSelection(y)) {
        y = y.anchor;
        var b = y.offset, Z = y.type === "element" && n.$isLineBreakNode(k.getChildAtIndex(y.offset - 1)), ce = 0;
        if (!Z) {
          let ge = y.getNode();
          ce = b + ge.getPreviousSiblings().reduce((ae, Te) => ae + Te.getTextContentSize(), 0);
        }
        m() && (Z ? y.getNode().select(b, b) : k.getChildren().some((ge) => {
          let ae = n.$isTextNode(ge);
          if (ae || n.$isLineBreakNode(ge)) {
            let Te = ge.getTextContentSize();
            if (ae && Te >= ce)
              return ge.select(ce, ce), !0;
            ce -= Te;
          }
          return !1;
        }));
      } else
        m();
    }
  }
  function F(k, m) {
    return z(k) && z(m) && k.__text === m.__text && k.__highlightType === m.__highlightType || n.$isTabNode(k) && n.$isTabNode(m) || n.$isLineBreakNode(k) && n.$isLineBreakNode(m);
  }
  function D(k) {
    if (!n.$isRangeSelection(k))
      return !1;
    var m = k.anchor.getNode();
    return k = k.focus.getNode(), m.is(k) && p(m) ? !0 : (m = m.getParent(), p(m) && m.is(k.getParent()));
  }
  function V(k) {
    k = k.getNodes();
    let m = [[]];
    if (k.length === 1 && p(k[0]))
      return m;
    let y = m[0];
    for (let b = 0; b < k.length; b++) {
      let Z = k[b];
      if (!(z(Z) || n.$isTabNode(Z) || n.$isLineBreakNode(Z)))
        throw Error("Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode");
      n.$isLineBreakNode(Z) ? b !== 0 && 0 < y.length && (y = [], m.push(y)) : y.push(Z);
    }
    return m;
  }
  function ne(k) {
    var m = n.$getSelection();
    if (!n.$isRangeSelection(m) || !D(m))
      return null;
    let y = k ? n.OUTDENT_CONTENT_COMMAND : n.INDENT_CONTENT_COMMAND;
    if (k = k ? n.OUTDENT_CONTENT_COMMAND : n.INSERT_TAB_COMMAND, 1 < V(m).length)
      return y;
    var b = m.getNodes()[0];
    if (!(p(b) || z(b) || n.$isTabNode(b) || n.$isLineBreakNode(b)))
      throw Error("Expected selection firstNode to be CodeHighlightNode or TabNode");
    if (p(b))
      return y;
    let Z = te(b);
    b = re(b);
    var ce = m.anchor;
    let ge = m.focus;
    return ge.isBefore(ce) ? m = ge : (m = ce, ce = ge), Z !== null && b !== null && m.key === Z.getKey() && m.offset === 0 && ce.key === b.getKey() && ce.offset === b.getTextContentSize() ? y : k;
  }
  function Y(k) {
    var m = n.$getSelection();
    if (!n.$isRangeSelection(m) || !D(m))
      return !1;
    var y = V(m);
    let b = y.length;
    if (1 < y.length) {
      for (m = 0; m < b; m++) {
        var Z = y[m];
        0 < Z.length && (Z = Z[0], m === 0 && (Z = te(Z)), Z !== null && (k === n.INDENT_CONTENT_COMMAND ? Z.insertBefore(n.$createTabNode()) : n.$isTabNode(Z) && Z.remove()));
      }
      return !0;
    }
    if (y = m.getNodes()[0], !(p(y) || z(y) || n.$isTabNode(y) || n.$isLineBreakNode(y)))
      throw Error("Expected selection firstNode to be CodeHighlightNode or CodeTabNode");
    if (p(y))
      return k === n.INDENT_CONTENT_COMMAND && m.insertNodes([n.$createTabNode()]), !0;
    if (y = te(y), y === null)
      throw Error("Expected getFirstCodeNodeOfLine to return a valid Code Node");
    return k === n.INDENT_CONTENT_COMMAND ? n.$isLineBreakNode(y) ? y.insertAfter(n.$createTabNode()) : y.insertBefore(n.$createTabNode()) : n.$isTabNode(y) && y.remove(), !0;
  }
  function U(k, m) {
    let y = n.$getSelection();
    if (!n.$isRangeSelection(y))
      return !1;
    let { anchor: b, focus: Z } = y, ce = b.offset, ge = Z.offset, ae = b.getNode(), Te = Z.getNode();
    var Ae = k === n.KEY_ARROW_UP_COMMAND;
    if (!D(y) || !z(ae) && !n.$isTabNode(ae) || !z(Te) && !n.$isTabNode(Te))
      return !1;
    if (!m.altKey) {
      if (y.isCollapsed()) {
        if (k = ae.getParentOrThrow(), Ae && ce === 0 && ae.getPreviousSibling() === null) {
          if (k.getPreviousSibling() === null)
            return k.selectPrevious(), m.preventDefault(), !0;
        } else if (!Ae && ce === ae.getTextContentSize() && ae.getNextSibling() === null && k.getNextSibling() === null)
          return k.selectNext(), m.preventDefault(), !0;
      }
      return !1;
    }
    let ze;
    if (ae.isBefore(Te)) {
      var oe = te(ae);
      ze = re(Te);
    } else
      oe = te(Te), ze = re(ae);
    if (oe == null || ze == null)
      return !1;
    let ie = oe.getNodesBetween(ze);
    for (let we = 0; we < ie.length; we++) {
      let ke = ie[we];
      if (!z(ke) && !n.$isTabNode(ke) && !n.$isLineBreakNode(ke))
        return !1;
    }
    if (m.preventDefault(), m.stopPropagation(), m = Ae ? oe.getPreviousSibling() : ze.getNextSibling(), !n.$isLineBreakNode(m) || (oe = Ae ? m.getPreviousSibling() : m.getNextSibling(), oe == null))
      return !0;
    Ae = z(oe) || n.$isTabNode(oe) || n.$isLineBreakNode(oe) ? Ae ? te(oe) : re(oe) : null;
    let de = Ae ?? oe;
    return m.remove(), ie.forEach((we) => we.remove()), k === n.KEY_ARROW_UP_COMMAND ? (ie.forEach((we) => de.insertBefore(we)), de.insertBefore(m)) : (de.insertAfter(m), de = m, ie.forEach((we) => {
      de.insertAfter(we), de = we;
    })), y.setTextNodeRange(ae, ce, Te, ge), !0;
  }
  function Q(k, m) {
    let y = n.$getSelection();
    if (!n.$isRangeSelection(y))
      return !1;
    let { anchor: b, focus: Z } = y;
    var ce = b.getNode();
    let ge = Z.getNode();
    if (k = k === n.MOVE_TO_START, !z(ce) && !n.$isTabNode(ce) || !z(ge) && !n.$isTabNode(ge))
      return !1;
    if (k)
      if (ce = q(ge, Z.offset), ce !== null) {
        let { node: ae, offset: Te } = ce;
        n.$isLineBreakNode(ae) ? ae.selectNext(0, 0) : y.setTextNodeRange(ae, Te, ae, Te);
      } else
        ge.getParentOrThrow().selectStart();
    else
      G(ge).select();
    return m.preventDefault(), m.stopPropagation(), !0;
  }
  return Rn.$createCodeHighlightNode = H, Rn.$createCodeNode = h, Rn.$isCodeHighlightNode = z, Rn.$isCodeNode = p, Rn.CODE_LANGUAGE_FRIENDLY_NAME_MAP = w, Rn.CODE_LANGUAGE_MAP = P, Rn.CodeHighlightNode = $, Rn.CodeNode = d, Rn.DEFAULT_CODE_LANGUAGE = "javascript", Rn.PrismTokenizer = ue, Rn.getCodeLanguages = () => Object.keys(t.languages).filter((k) => typeof t.languages[k] != "function").sort(), Rn.getDefaultCodeLanguage = () => "javascript", Rn.getEndOfCodeInLine = G, Rn.getFirstCodeNodeOfLine = te, Rn.getLanguageFriendlyName = function(k) {
    return k = K(k), w[k] || k;
  }, Rn.getLastCodeNodeOfLine = re, Rn.getStartOfCodeInLine = q, Rn.normalizeCodeLang = K, Rn.registerCodeHighlighting = function(k, m) {
    if (!k.hasNodes([d, $]))
      throw Error("CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor");
    return m == null && (m = ue), e.mergeRegister(
      k.registerMutationListener(d, (y) => {
        k.update(() => {
          for (let [ce, ge] of y)
            if (ge !== "destroyed") {
              var b = n.$getNodeByKey(ce);
              if (b !== null)
                e: {
                  var Z = b;
                  if (b = k.getElementByKey(Z.getKey()), b === null)
                    break e;
                  Z = Z.getChildren();
                  let ae = Z.length;
                  if (ae === b.__cachedChildrenLength)
                    break e;
                  b.__cachedChildrenLength = ae;
                  let Te = "1", Ae = 1;
                  for (let ze = 0; ze < ae; ze++)
                    n.$isLineBreakNode(Z[ze]) && (Te += `
` + ++Ae);
                  b.setAttribute("data-gutter", Te);
                }
            }
        });
      }),
      k.registerNodeTransform(d, (y) => pe(y, k, m)),
      k.registerNodeTransform(n.TextNode, (y) => j(y, k, m)),
      k.registerNodeTransform($, (y) => j(y, k, m)),
      k.registerCommand(n.KEY_TAB_COMMAND, (y) => {
        let b = ne(y.shiftKey);
        return b === null ? !1 : (y.preventDefault(), k.dispatchCommand(b, void 0), !0);
      }, n.COMMAND_PRIORITY_LOW),
      k.registerCommand(n.INSERT_TAB_COMMAND, () => {
        let y = n.$getSelection();
        return D(y) ? (n.$insertNodes([n.$createTabNode()]), !0) : !1;
      }, n.COMMAND_PRIORITY_LOW),
      k.registerCommand(n.INDENT_CONTENT_COMMAND, () => Y(n.INDENT_CONTENT_COMMAND), n.COMMAND_PRIORITY_LOW),
      k.registerCommand(n.OUTDENT_CONTENT_COMMAND, () => Y(n.OUTDENT_CONTENT_COMMAND), n.COMMAND_PRIORITY_LOW),
      k.registerCommand(n.KEY_ARROW_UP_COMMAND, (y) => U(n.KEY_ARROW_UP_COMMAND, y), n.COMMAND_PRIORITY_LOW),
      k.registerCommand(n.KEY_ARROW_DOWN_COMMAND, (y) => U(n.KEY_ARROW_DOWN_COMMAND, y), n.COMMAND_PRIORITY_LOW),
      k.registerCommand(n.MOVE_TO_END, (y) => Q(n.MOVE_TO_END, y), n.COMMAND_PRIORITY_LOW),
      k.registerCommand(n.MOVE_TO_START, (y) => Q(n.MOVE_TO_START, y), n.COMMAND_PRIORITY_LOW)
    );
  }, Rn;
}
var bn = {}, qh;
function nC() {
  if (qh)
    return bn;
  qh = 1;
  var t = xp();
  vp(), Sp(), wp(), Op(), Dp(), Rp(), bp(), Mp(), Ap(), kp(), Lp(), Ip(), Pp(), $p();
  var e = rn(), n = Bt();
  const r = (oe) => oe != null && t.languages.hasOwnProperty(oe) ? oe : void 0;
  function c(oe, ie) {
    for (const de of oe.childNodes) {
      if (e.isHTMLElement(de) && de.tagName === ie)
        return !0;
      c(de, ie);
    }
    return !1;
  }
  const d = "data-highlight-language";
  class h extends n.ElementNode {
    /** @internal */
    static getType() {
      return "code";
    }
    static clone(ie) {
      return new h(ie.__language, ie.__key);
    }
    constructor(ie, de) {
      super(de), this.__language = r(ie);
    }
    // View
    createDOM(ie) {
      const de = document.createElement("code");
      e.addClassNamesToElement(de, ie.theme.code), de.setAttribute("spellcheck", "false");
      const we = this.getLanguage();
      return we && de.setAttribute(d, we), de;
    }
    updateDOM(ie, de, we) {
      const ke = this.__language, Be = ie.__language;
      return ke ? ke !== Be && de.setAttribute(d, ke) : Be && de.removeAttribute(d), !1;
    }
    exportDOM() {
      const ie = document.createElement("pre");
      ie.setAttribute("spellcheck", "false");
      const de = this.getLanguage();
      return de && ie.setAttribute(d, de), {
        element: ie
      };
    }
    static importDOM() {
      return {
        // Typically <pre> is used for code blocks, and <code> for inline code styles
        // but if it's a multi line <code> we'll create a block. Pass through to
        // inline format handled by TextNode otherwise.
        code: (ie) => ie.textContent != null && (/\r?\n/.test(ie.textContent) || c(ie, "BR")) ? {
          conversion: x,
          priority: 1
        } : null,
        div: (ie) => ({
          conversion: v,
          priority: 1
        }),
        pre: (ie) => ({
          conversion: x,
          priority: 0
        }),
        table: (ie) => K(ie) ? {
          conversion: O,
          priority: 3
        } : null,
        td: (ie) => {
          const de = ie, we = de.closest("table");
          return P(de) ? {
            conversion: A,
            priority: 3
          } : we && K(we) ? {
            conversion: M,
            priority: 3
          } : null;
        },
        tr: (ie) => {
          const we = ie.closest("table");
          return we && K(we) ? {
            conversion: M,
            priority: 3
          } : null;
        }
      };
    }
    static importJSON(ie) {
      const de = p(ie.language);
      return de.setFormat(ie.format), de.setIndent(ie.indent), de.setDirection(ie.direction), de;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        language: this.getLanguage(),
        type: "code",
        version: 1
      };
    }
    // Mutation
    insertNewAfter(ie, de = !0) {
      const we = this.getChildren(), ke = we.length;
      if (ke >= 2 && we[ke - 1].getTextContent() === `
` && we[ke - 2].getTextContent() === `
` && ie.isCollapsed() && ie.anchor.key === this.__key && ie.anchor.offset === ke) {
        we[ke - 1].remove(), we[ke - 2].remove();
        const ct = n.$createParagraphNode();
        return this.insertAfter(ct, de), ct;
      }
      const {
        anchor: Be,
        focus: Ye
      } = ie, _t = (Be.isBefore(Ye) ? Be : Ye).getNode();
      if (n.$isTextNode(_t)) {
        let ct = pe(_t);
        const ve = [];
        for (; ; )
          if (n.$isTabNode(ct))
            ve.push(n.$createTabNode()), ct = ct.getNextSibling();
          else if (_e(ct)) {
            let qe = 0;
            const Qe = ct.getTextContent(), ut = ct.getTextContentSize();
            for (; qe < ut && Qe[qe] === " "; qe++)
              ;
            if (qe !== 0 && ve.push(j(" ".repeat(qe))), qe !== ut)
              break;
            ct = ct.getNextSibling();
          } else
            break;
        const se = _t.splitText(Be.offset)[0], he = Be.offset === 0 ? 0 : 1, Oe = se.getIndexWithinParent() + he, Me = _t.getParentOrThrow(), De = [n.$createLineBreakNode(), ...ve];
        Me.splice(Oe, 0, De);
        const We = ve[ve.length - 1];
        We ? We.select() : Be.offset === 0 ? se.selectPrevious() : se.getNextSibling().selectNext(0, 0);
      }
      if (N(_t)) {
        const {
          offset: ct
        } = ie.anchor;
        _t.splice(ct, 0, [n.$createLineBreakNode()]), _t.select(ct + 1, ct + 1);
      }
      return null;
    }
    canIndent() {
      return !1;
    }
    collapseAtStart() {
      const ie = n.$createParagraphNode();
      return this.getChildren().forEach((we) => ie.append(we)), this.replace(ie), !0;
    }
    setLanguage(ie) {
      const de = this.getWritable();
      de.__language = r(ie);
    }
    getLanguage() {
      return this.getLatest().__language;
    }
  }
  function p(oe) {
    return n.$applyNodeReplacement(new h(oe));
  }
  function N(oe) {
    return oe instanceof h;
  }
  function x(oe) {
    let ie;
    return e.isHTMLElement(oe) && (ie = oe.getAttribute(d)), {
      node: p(ie)
    };
  }
  function v(oe) {
    const ie = oe, de = T(ie);
    return !de && !w(ie) ? {
      node: null
    } : {
      after: (we) => {
        const ke = oe.parentNode;
        return ke != null && oe !== ke.lastChild && we.push(n.$createLineBreakNode()), we;
      },
      node: de ? p() : null
    };
  }
  function O() {
    return {
      node: p()
    };
  }
  function M() {
    return {
      node: null
    };
  }
  function A(oe) {
    const ie = oe;
    return {
      after: (de) => (ie.parentNode && ie.parentNode.nextSibling && de.push(n.$createLineBreakNode()), de),
      node: null
    };
  }
  function T(oe) {
    return oe.style.fontFamily.match("monospace") !== null;
  }
  function w(oe) {
    let ie = oe.parentElement;
    for (; ie !== null; ) {
      if (T(ie))
        return !0;
      ie = ie.parentElement;
    }
    return !1;
  }
  function P(oe) {
    return oe.classList.contains("js-file-line");
  }
  function K(oe) {
    return oe.classList.contains("js-file-line-container");
  }
  const $ = "javascript", W = {
    c: "C",
    clike: "C-like",
    cpp: "C++",
    css: "CSS",
    html: "HTML",
    java: "Java",
    js: "JavaScript",
    markdown: "Markdown",
    objc: "Objective-C",
    plain: "Plain Text",
    py: "Python",
    rust: "Rust",
    sql: "SQL",
    swift: "Swift",
    typescript: "TypeScript",
    xml: "XML"
  }, H = {
    cpp: "cpp",
    java: "java",
    javascript: "js",
    md: "markdown",
    plaintext: "plain",
    python: "py",
    text: "plain",
    ts: "typescript"
  };
  function z(oe) {
    return H[oe] || oe;
  }
  function te(oe) {
    const ie = z(oe);
    return W[ie] || ie;
  }
  const re = () => $, ue = () => Object.keys(t.languages).filter(
    // Prism has several language helpers mixed into languages object
    // so filtering them out here to get langs list
    (oe) => typeof t.languages[oe] != "function"
  ).sort();
  class q extends n.TextNode {
    /** @internal */
    constructor(ie, de, we) {
      super(ie, we), this.__highlightType = de;
    }
    static getType() {
      return "code-highlight";
    }
    static clone(ie) {
      return new q(ie.__text, ie.__highlightType || void 0, ie.__key);
    }
    getHighlightType() {
      return this.getLatest().__highlightType;
    }
    createDOM(ie) {
      const de = super.createDOM(ie), we = G(ie.theme, this.__highlightType);
      return e.addClassNamesToElement(de, we), de;
    }
    updateDOM(ie, de, we) {
      const ke = super.updateDOM(ie, de, we), Be = G(we.theme, ie.__highlightType), Ye = G(we.theme, this.__highlightType);
      return Be !== Ye && (Be && e.removeClassNamesFromElement(de, Be), Ye && e.addClassNamesToElement(de, Ye)), ke;
    }
    static importJSON(ie) {
      const de = j(ie.text, ie.highlightType);
      return de.setFormat(ie.format), de.setDetail(ie.detail), de.setMode(ie.mode), de.setStyle(ie.style), de;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        highlightType: this.getHighlightType(),
        type: "code-highlight",
        version: 1
      };
    }
    // Prevent formatting (bold, underline, etc)
    setFormat(ie) {
      return this;
    }
    isParentRequired() {
      return !0;
    }
    createParentElementNode() {
      return p();
    }
  }
  function G(oe, ie) {
    return ie && oe && oe.codeHighlight && oe.codeHighlight[ie];
  }
  function j(oe, ie) {
    return n.$applyNodeReplacement(new q(oe, ie));
  }
  function _e(oe) {
    return oe instanceof q;
  }
  function pe(oe) {
    let ie = oe, de = oe;
    for (; _e(de) || n.$isTabNode(de); )
      ie = de, de = de.getPreviousSibling();
    return ie;
  }
  function J(oe) {
    let ie = oe, de = oe;
    for (; _e(de) || n.$isTabNode(de); )
      ie = de, de = de.getNextSibling();
    return ie;
  }
  const ee = {
    defaultLanguage: $,
    tokenize(oe, ie) {
      return t.tokenize(oe, t.languages[ie || ""] || t.languages[this.defaultLanguage]);
    }
  };
  function F(oe, ie) {
    let de = null, we = null, ke = oe, Be = ie, Ye = oe.getTextContent();
    for (; ; ) {
      if (Be === 0) {
        if (ke = ke.getPreviousSibling(), ke === null)
          break;
        if (!(_e(ke) || n.$isTabNode(ke) || n.$isLineBreakNode(ke)))
          throw Error("Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode");
        if (n.$isLineBreakNode(ke)) {
          de = {
            node: ke,
            offset: 1
          };
          break;
        }
        Be = Math.max(0, ke.getTextContentSize() - 1), Ye = ke.getTextContent();
      } else
        Be--;
      const _t = Ye[Be];
      _e(ke) && _t !== " " && (we = {
        node: ke,
        offset: Be
      });
    }
    if (we !== null)
      return we;
    let lt = null;
    if (ie < oe.getTextContentSize())
      _e(oe) && (lt = oe.getTextContent()[ie]);
    else {
      const _t = oe.getNextSibling();
      _e(_t) && (lt = _t.getTextContent()[0]);
    }
    if (lt !== null && lt !== " ")
      return de;
    {
      const _t = D(oe, ie);
      return _t !== null ? _t : de;
    }
  }
  function D(oe, ie) {
    let de = oe, we = ie, ke = oe.getTextContent(), Be = oe.getTextContentSize();
    for (; ; ) {
      if (!_e(de) || we === Be) {
        if (de = de.getNextSibling(), de === null || n.$isLineBreakNode(de))
          return null;
        _e(de) && (we = 0, ke = de.getTextContent(), Be = de.getTextContentSize());
      }
      if (_e(de)) {
        if (ke[we] !== " ")
          return {
            node: de,
            offset: we
          };
        we++;
      }
    }
  }
  function V(oe) {
    const ie = J(oe);
    if (n.$isLineBreakNode(ie))
      throw Error("Unexpected lineBreakNode in getEndOfCodeInLine");
    return ie;
  }
  function ne(oe, ie, de) {
    const we = oe.getParent();
    N(we) ? Q(we, ie, de) : _e(oe) && oe.replace(n.$createTextNode(oe.__text));
  }
  function Y(oe, ie) {
    const de = ie.getElementByKey(oe.getKey());
    if (de === null)
      return;
    const we = oe.getChildren(), ke = we.length;
    if (ke === de.__cachedChildrenLength)
      return;
    de.__cachedChildrenLength = ke;
    let Be = "1", Ye = 1;
    for (let lt = 0; lt < ke; lt++)
      n.$isLineBreakNode(we[lt]) && (Be += `
` + ++Ye);
    de.setAttribute("data-gutter", Be);
  }
  const U = /* @__PURE__ */ new Set();
  function Q(oe, ie, de) {
    const we = oe.getKey();
    U.has(we) || (U.add(we), oe.getLanguage() === void 0 && oe.setLanguage(de.defaultLanguage), ie.update(() => {
      m(we, () => {
        const ke = n.$getNodeByKey(we);
        if (!N(ke) || !ke.isAttached())
          return !1;
        const Be = ke.getTextContent(), Ye = de.tokenize(Be, ke.getLanguage() || de.defaultLanguage), lt = k(Ye), _t = y(ke.getChildren(), lt), {
          from: ct,
          to: ve,
          nodesForReplacement: se
        } = _t;
        return ct !== ve || se.length ? (oe.splice(ct, ve - ct, se), !0) : !1;
      });
    }, {
      onUpdate: () => {
        U.delete(we);
      },
      skipTransforms: !0
    }));
  }
  function k(oe, ie) {
    const de = [];
    for (const we of oe)
      if (typeof we == "string") {
        const ke = we.split(/(\n|\t)/), Be = ke.length;
        for (let Ye = 0; Ye < Be; Ye++) {
          const lt = ke[Ye];
          lt === `
` || lt === `\r
` ? de.push(n.$createLineBreakNode()) : lt === "	" ? de.push(n.$createTabNode()) : lt.length > 0 && de.push(j(lt, ie));
        }
      } else {
        const {
          content: ke
        } = we;
        typeof ke == "string" ? de.push(...k([ke], we.type)) : Array.isArray(ke) && de.push(...k(ke, we.type));
      }
    return de;
  }
  function m(oe, ie) {
    const de = n.$getNodeByKey(oe);
    if (!N(de) || !de.isAttached())
      return;
    const we = n.$getSelection();
    if (!n.$isRangeSelection(we)) {
      ie();
      return;
    }
    const ke = we.anchor, Be = ke.offset, Ye = ke.type === "element" && n.$isLineBreakNode(de.getChildAtIndex(ke.offset - 1));
    let lt = 0;
    if (!Ye) {
      const ct = ke.getNode();
      lt = Be + ct.getPreviousSiblings().reduce((ve, se) => ve + se.getTextContentSize(), 0);
    }
    if (ie()) {
      if (Ye) {
        ke.getNode().select(Be, Be);
        return;
      }
      de.getChildren().some((ct) => {
        const ve = n.$isTextNode(ct);
        if (ve || n.$isLineBreakNode(ct)) {
          const se = ct.getTextContentSize();
          if (ve && se >= lt)
            return ct.select(lt, lt), !0;
          lt -= se;
        }
        return !1;
      });
    }
  }
  function y(oe, ie) {
    let de = 0;
    for (; de < oe.length && b(oe[de], ie[de]); )
      de++;
    const we = oe.length, ke = ie.length, Be = Math.min(we, ke) - de;
    let Ye = 0;
    for (; Ye < Be; )
      if (Ye++, !b(oe[we - Ye], ie[ke - Ye])) {
        Ye--;
        break;
      }
    const lt = de, _t = we - Ye, ct = ie.slice(de, ke - Ye);
    return {
      from: lt,
      nodesForReplacement: ct,
      to: _t
    };
  }
  function b(oe, ie) {
    return _e(oe) && _e(ie) && oe.__text === ie.__text && oe.__highlightType === ie.__highlightType || n.$isTabNode(oe) && n.$isTabNode(ie) || n.$isLineBreakNode(oe) && n.$isLineBreakNode(ie);
  }
  function Z(oe) {
    if (!n.$isRangeSelection(oe))
      return !1;
    const ie = oe.anchor.getNode(), de = oe.focus.getNode();
    if (ie.is(de) && N(ie))
      return !0;
    const we = ie.getParent();
    return N(we) && we.is(de.getParent());
  }
  function ce(oe) {
    const ie = oe.getNodes(), de = [[]];
    if (ie.length === 1 && N(ie[0]))
      return de;
    let we = de[0];
    for (let ke = 0; ke < ie.length; ke++) {
      const Be = ie[ke];
      if (!(_e(Be) || n.$isTabNode(Be) || n.$isLineBreakNode(Be)))
        throw Error("Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode");
      n.$isLineBreakNode(Be) ? ke !== 0 && we.length > 0 && (we = [], de.push(we)) : we.push(Be);
    }
    return de;
  }
  function ge(oe) {
    const ie = n.$getSelection();
    if (!n.$isRangeSelection(ie) || !Z(ie))
      return null;
    const de = oe ? n.OUTDENT_CONTENT_COMMAND : n.INDENT_CONTENT_COMMAND, we = oe ? n.OUTDENT_CONTENT_COMMAND : n.INSERT_TAB_COMMAND;
    if (ce(ie).length > 1)
      return de;
    const Ye = ie.getNodes()[0];
    if (!(N(Ye) || _e(Ye) || n.$isTabNode(Ye) || n.$isLineBreakNode(Ye)))
      throw Error("Expected selection firstNode to be CodeHighlightNode or TabNode");
    if (N(Ye))
      return de;
    const lt = pe(Ye), _t = J(Ye), ct = ie.anchor, ve = ie.focus;
    let se, he;
    return ve.isBefore(ct) ? (se = ve, he = ct) : (se = ct, he = ve), lt !== null && _t !== null && se.key === lt.getKey() && se.offset === 0 && he.key === _t.getKey() && he.offset === _t.getTextContentSize() ? de : we;
  }
  function ae(oe) {
    const ie = n.$getSelection();
    if (!n.$isRangeSelection(ie) || !Z(ie))
      return !1;
    const de = ce(ie), we = de.length;
    if (de.length > 1) {
      for (let lt = 0; lt < we; lt++) {
        const _t = de[lt];
        if (_t.length > 0) {
          let ct = _t[0];
          lt === 0 && (ct = pe(ct)), ct !== null && (oe === n.INDENT_CONTENT_COMMAND ? ct.insertBefore(n.$createTabNode()) : n.$isTabNode(ct) && ct.remove());
        }
      }
      return !0;
    }
    const Be = ie.getNodes()[0];
    if (!(N(Be) || _e(Be) || n.$isTabNode(Be) || n.$isLineBreakNode(Be)))
      throw Error("Expected selection firstNode to be CodeHighlightNode or CodeTabNode");
    if (N(Be))
      return oe === n.INDENT_CONTENT_COMMAND && ie.insertNodes([n.$createTabNode()]), !0;
    const Ye = pe(Be);
    if (Ye === null)
      throw Error("Expected getFirstCodeNodeOfLine to return a valid Code Node");
    return oe === n.INDENT_CONTENT_COMMAND ? n.$isLineBreakNode(Ye) ? Ye.insertAfter(n.$createTabNode()) : Ye.insertBefore(n.$createTabNode()) : n.$isTabNode(Ye) && Ye.remove(), !0;
  }
  function Te(oe, ie) {
    const de = n.$getSelection();
    if (!n.$isRangeSelection(de))
      return !1;
    const {
      anchor: we,
      focus: ke
    } = de, Be = we.offset, Ye = ke.offset, lt = we.getNode(), _t = ke.getNode(), ct = oe === n.KEY_ARROW_UP_COMMAND;
    if (!Z(de) || !(_e(lt) || n.$isTabNode(lt)) || !(_e(_t) || n.$isTabNode(_t)))
      return !1;
    if (!ie.altKey) {
      if (de.isCollapsed()) {
        const qe = lt.getParentOrThrow();
        if (ct && Be === 0 && lt.getPreviousSibling() === null) {
          if (qe.getPreviousSibling() === null)
            return qe.selectPrevious(), ie.preventDefault(), !0;
        } else if (!ct && Be === lt.getTextContentSize() && lt.getNextSibling() === null && qe.getNextSibling() === null)
          return qe.selectNext(), ie.preventDefault(), !0;
      }
      return !1;
    }
    let ve, se;
    if (lt.isBefore(_t) ? (ve = pe(lt), se = J(_t)) : (ve = pe(_t), se = J(lt)), ve == null || se == null)
      return !1;
    const he = ve.getNodesBetween(se);
    for (let qe = 0; qe < he.length; qe++) {
      const Qe = he[qe];
      if (!_e(Qe) && !n.$isTabNode(Qe) && !n.$isLineBreakNode(Qe))
        return !1;
    }
    ie.preventDefault(), ie.stopPropagation();
    const Oe = ct ? ve.getPreviousSibling() : se.getNextSibling();
    if (!n.$isLineBreakNode(Oe))
      return !0;
    const Me = ct ? Oe.getPreviousSibling() : Oe.getNextSibling();
    if (Me == null)
      return !0;
    const De = _e(Me) || n.$isTabNode(Me) || n.$isLineBreakNode(Me) ? ct ? pe(Me) : J(Me) : null;
    let We = De ?? Me;
    return Oe.remove(), he.forEach((qe) => qe.remove()), oe === n.KEY_ARROW_UP_COMMAND ? (he.forEach((qe) => We.insertBefore(qe)), We.insertBefore(Oe)) : (We.insertAfter(Oe), We = Oe, he.forEach((qe) => {
      We.insertAfter(qe), We = qe;
    })), de.setTextNodeRange(lt, Be, _t, Ye), !0;
  }
  function Ae(oe, ie) {
    const de = n.$getSelection();
    if (!n.$isRangeSelection(de))
      return !1;
    const {
      anchor: we,
      focus: ke
    } = de, Be = we.getNode(), Ye = ke.getNode(), lt = oe === n.MOVE_TO_START;
    if (!(_e(Be) || n.$isTabNode(Be)) || !(_e(Ye) || n.$isTabNode(Ye)))
      return !1;
    if (lt) {
      const _t = F(Ye, ke.offset);
      if (_t !== null) {
        const {
          node: ct,
          offset: ve
        } = _t;
        n.$isLineBreakNode(ct) ? ct.selectNext(0, 0) : de.setTextNodeRange(ct, ve, ct, ve);
      } else
        Ye.getParentOrThrow().selectStart();
    } else
      V(Ye).select();
    return ie.preventDefault(), ie.stopPropagation(), !0;
  }
  function ze(oe, ie) {
    if (!oe.hasNodes([h, q]))
      throw new Error("CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor");
    return ie == null && (ie = ee), e.mergeRegister(oe.registerMutationListener(h, (de) => {
      oe.update(() => {
        for (const [we, ke] of de)
          if (ke !== "destroyed") {
            const Be = n.$getNodeByKey(we);
            Be !== null && Y(Be, oe);
          }
      });
    }), oe.registerNodeTransform(h, (de) => Q(de, oe, ie)), oe.registerNodeTransform(n.TextNode, (de) => ne(de, oe, ie)), oe.registerNodeTransform(q, (de) => ne(de, oe, ie)), oe.registerCommand(n.KEY_TAB_COMMAND, (de) => {
      const we = ge(de.shiftKey);
      return we === null ? !1 : (de.preventDefault(), oe.dispatchCommand(we, void 0), !0);
    }, n.COMMAND_PRIORITY_LOW), oe.registerCommand(n.INSERT_TAB_COMMAND, () => {
      const de = n.$getSelection();
      return Z(de) ? (n.$insertNodes([n.$createTabNode()]), !0) : !1;
    }, n.COMMAND_PRIORITY_LOW), oe.registerCommand(n.INDENT_CONTENT_COMMAND, (de) => ae(n.INDENT_CONTENT_COMMAND), n.COMMAND_PRIORITY_LOW), oe.registerCommand(n.OUTDENT_CONTENT_COMMAND, (de) => ae(n.OUTDENT_CONTENT_COMMAND), n.COMMAND_PRIORITY_LOW), oe.registerCommand(n.KEY_ARROW_UP_COMMAND, (de) => Te(n.KEY_ARROW_UP_COMMAND, de), n.COMMAND_PRIORITY_LOW), oe.registerCommand(n.KEY_ARROW_DOWN_COMMAND, (de) => Te(n.KEY_ARROW_DOWN_COMMAND, de), n.COMMAND_PRIORITY_LOW), oe.registerCommand(n.MOVE_TO_END, (de) => Ae(n.MOVE_TO_END, de), n.COMMAND_PRIORITY_LOW), oe.registerCommand(n.MOVE_TO_START, (de) => Ae(n.MOVE_TO_START, de), n.COMMAND_PRIORITY_LOW));
  }
  return bn.$createCodeHighlightNode = j, bn.$createCodeNode = p, bn.$isCodeHighlightNode = _e, bn.$isCodeNode = N, bn.CODE_LANGUAGE_FRIENDLY_NAME_MAP = W, bn.CODE_LANGUAGE_MAP = H, bn.CodeHighlightNode = q, bn.CodeNode = h, bn.DEFAULT_CODE_LANGUAGE = $, bn.PrismTokenizer = ee, bn.getCodeLanguages = ue, bn.getDefaultCodeLanguage = re, bn.getEndOfCodeInLine = V, bn.getFirstCodeNodeOfLine = pe, bn.getLanguageFriendlyName = te, bn.getLastCodeNodeOfLine = J, bn.getStartOfCodeInLine = F, bn.normalizeCodeLang = z, bn.registerCodeHighlighting = ze, bn;
}
const rC = process.env.NODE_ENV === "development" ? nC() : tC();
var Vu = rC, md = Yn();
function iC() {
  const [t] = md.useLexicalComposerContext();
  return fr(() => Vu.registerCodeHighlighting(t), [t]), null;
}
var Zh = rn(), An = Bt();
function oC({
  src: t,
  altText: e,
  width: n,
  height: r,
  maxWidth: c
}) {
  const d = Qg(() => ({ height: r, width: n, maxWidth: c }), [r, n, c]);
  return /* @__PURE__ */ ht.jsx("img", { src: t, alt: e, style: d });
}
function Fp({
  altText: t,
  height: e,
  maxWidth: n = 500,
  src: r,
  width: c,
  key: d
}) {
  return An.$applyNodeReplacement(
    new ol(r, t, n, c, e, d)
  );
}
function sC(t) {
  return t instanceof ol;
}
class ol extends An.DecoratorNode {
  constructor(n, r, c, d, h, p) {
    super(p);
    $n(this, "__src");
    $n(this, "__altText");
    $n(this, "__width");
    $n(this, "__height");
    $n(this, "__maxWidth");
    this.__src = n, this.__altText = r, this.__maxWidth = c, this.__width = d || "inherit", this.__height = h || "inherit";
  }
  static getType() {
    return "image";
  }
  static clone(n) {
    return new ol(
      n.__src,
      n.__altText,
      n.__maxWidth,
      n.__width,
      n.__height,
      n.__key
    );
  }
  getSrc() {
    return this.getLatest().__src;
  }
  getAltText() {
    return this.getLatest().__altText;
  }
  /**
   * Defines the JSON Serialization strategy for an {@link ImageNode}.
   */
  exportJSON() {
    return {
      altText: this.getAltText(),
      height: this.__height === "inherit" ? 0 : this.__height,
      maxWidth: this.__maxWidth,
      src: this.getSrc(),
      type: "image",
      version: 1,
      width: this.__width === "inherit" ? 0 : this.__width
    };
  }
  /**
   * Static constructor for creating an {@link ImageNode} from a JSON serialized Node.
   */
  static importJSON(n) {
    return Fp(n);
  }
  /**
   * Inserts the {@link ImageNode}'s placeholder {@link HTMLElement} into the Lexical Dev's DOM.
   */
  createDOM(n) {
    const r = document.createElement("span"), c = n.theme.image;
    return c && (r.className = c), r;
  }
  /**
   * Since this Node will only be used in a read-only context, we don't need to worry about
   * updating the DOM when its attributes change.
   */
  updateDOM() {
    return !1;
  }
  decorate() {
    return /* @__PURE__ */ ht.jsx(
      oC,
      {
        src: this.__src,
        altText: this.__altText,
        width: this.__width,
        height: this.__height,
        maxWidth: this.__maxWidth
      }
    );
  }
}
const lC = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", aC = (t) => lC ? (t || window).getSelection() : null, Bp = An.createCommand(
  "INSERT_IMAGE_COMMAND"
);
function cC() {
  const [t] = md.useLexicalComposerContext();
  return fr(() => {
    if (!t.hasNodes([ol]))
      throw new Error("ImagePlugin: ImageNode not registered on editor");
    return Zh.mergeRegister(
      t.registerCommand(
        Bp,
        (e) => {
          const n = Fp(e);
          return An.$insertNodes([n]), An.$isRootOrShadowRoot(n.getParentOrThrow()) && Zh.$wrapNodeInElement(n, An.$createParagraphNode).selectEnd(), !0;
        },
        An.COMMAND_PRIORITY_EDITOR
      ),
      t.registerCommand(
        An.DRAGSTART_COMMAND,
        (e) => uC(e),
        An.COMMAND_PRIORITY_HIGH
      ),
      t.registerCommand(
        An.DRAGOVER_COMMAND,
        (e) => dC(e),
        An.COMMAND_PRIORITY_LOW
      ),
      t.registerCommand(
        An.DROP_COMMAND,
        (e) => fC(e, t),
        An.COMMAND_PRIORITY_HIGH
      )
    );
  }, [t]), null;
}
function uC(t) {
  const e = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", n = document.createElement("img");
  n.src = e;
  const r = _d();
  if (!r)
    return !1;
  const c = t.dataTransfer;
  return c ? (c.setData("text/plain", "_"), c.setDragImage(n, 0, 0), c.setData(
    "application/x-lexical-drag",
    JSON.stringify({
      data: {
        altText: r.__altText,
        height: r.__height,
        key: r.getKey(),
        maxWidth: r.__maxWidth,
        src: r.__src,
        width: r.__width
      },
      type: "image"
    })
  ), !0) : !1;
}
function dC(t) {
  return _d() ? (Hp(t) || t.preventDefault(), !0) : !1;
}
function fC(t, e) {
  const n = _d();
  if (!n)
    return !1;
  const r = hC(t);
  if (!r)
    return !1;
  if (t.preventDefault(), Hp(t)) {
    const c = gC(t);
    n.remove();
    const d = An.$createRangeSelection();
    c != null && d.applyDOMRange(c), An.$setSelection(d), e.dispatchCommand(Bp, r);
  }
  return !0;
}
function _d() {
  const t = An.$getSelection();
  if (!An.$isNodeSelection(t))
    return null;
  const n = t.getNodes()[0];
  return sC(n) ? n : null;
}
function hC(t) {
  var c;
  const e = (c = t.dataTransfer) == null ? void 0 : c.getData("application/x-lexical-drag");
  if (!e)
    return null;
  const { type: n, data: r } = JSON.parse(e);
  return n !== "image" ? null : r;
}
function Hp(t) {
  const e = t.target;
  return !!(e && e instanceof HTMLElement && !e.closest("code, span.yext-default-richtextv2-theme__image") && e.parentElement);
}
function gC(t) {
  let e;
  const n = t.target, r = n === null || !(n instanceof Node) ? null : n.nodeType === 9 ? n.defaultView : n.ownerDocument.defaultView, c = aC(r);
  if (document.caretRangeFromPoint)
    e = document.caretRangeFromPoint(t.clientX, t.clientY);
  else if (t.rangeParent && c !== null)
    c.collapse(t.rangeParent, t.rangeOffset || 0), e = c.getRangeAt(0);
  else
    throw Error("Cannot get the selection when dragging");
  return e;
}
var cs = hd();
function pC(t) {
  const e = t.getNodes();
  return e.length === 0 ? /* @__PURE__ */ new Set([
    t.anchor.getNode().getParentOrThrow(),
    t.focus.getNode().getParentOrThrow()
  ]) : new Set(
    e.map((n) => An.$isElementNode(n) ? n : n.getParentOrThrow())
  );
}
const mC = 3;
function _C(t) {
  const e = An.$getSelection();
  if (!An.$isRangeSelection(e))
    return !1;
  const n = pC(e);
  let r = 0;
  for (const c of n)
    if (cs.$isListNode(c))
      r = Math.max(cs.$getListDepth(c) + 1, r);
    else if (cs.$isListItemNode(c)) {
      const d = c.getParent();
      if (!cs.$isListNode(d))
        throw new Error(
          "ListMaxIndentLevelPlugin: A ListItemNode must have a ListNode for a parent."
        );
      r = Math.max(cs.$getListDepth(d) + 1, r);
    }
  return r <= t;
}
function yC({ maxDepth: t }) {
  const [e] = md.useLexicalComposerContext();
  return fr(() => e.registerCommand(
    An.INDENT_CONTENT_COMMAND,
    () => !_C(t || 7),
    mC
  ), [e, t]), null;
}
var Ru = pd(), Jh = gd(), Xh = fd(), Kl = {}, Qh;
function NC() {
  if (Qh)
    return Kl;
  Qh = 1;
  var t = rn(), e = Bt();
  class n extends e.TextNode {
    static getType() {
      return "hashtag";
    }
    static clone(d) {
      return new n(d.__text, d.__key);
    }
    constructor(d, h) {
      super(d, h);
    }
    createDOM(d) {
      let h = super.createDOM(d);
      return t.addClassNamesToElement(h, d.theme.hashtag), h;
    }
    static importJSON(d) {
      let h = r(d.text);
      return h.setFormat(d.format), h.setDetail(d.detail), h.setMode(d.mode), h.setStyle(d.style), h;
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "hashtag" };
    }
    canInsertTextBefore() {
      return !1;
    }
    isTextEntity() {
      return !0;
    }
  }
  function r(c = "") {
    return e.$applyNodeReplacement(new n(c));
  }
  return Kl.$createHashtagNode = r, Kl.$isHashtagNode = function(c) {
    return c instanceof n;
  }, Kl.HashtagNode = n, Kl;
}
var Ul = {}, eg;
function CC() {
  if (eg)
    return Ul;
  eg = 1;
  var t = rn(), e = Bt();
  class n extends e.TextNode {
    static getType() {
      return "hashtag";
    }
    static clone(h) {
      return new n(h.__text, h.__key);
    }
    constructor(h, p) {
      super(h, p);
    }
    createDOM(h) {
      const p = super.createDOM(h);
      return t.addClassNamesToElement(p, h.theme.hashtag), p;
    }
    static importJSON(h) {
      const p = r(h.text);
      return p.setFormat(h.format), p.setDetail(h.detail), p.setMode(h.mode), p.setStyle(h.style), p;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "hashtag"
      };
    }
    canInsertTextBefore() {
      return !1;
    }
    isTextEntity() {
      return !0;
    }
  }
  function r(d = "") {
    return e.$applyNodeReplacement(new n(d));
  }
  function c(d) {
    return d instanceof n;
  }
  return Ul.$createHashtagNode = r, Ul.$isHashtagNode = c, Ul.HashtagNode = n, Ul;
}
const EC = process.env.NODE_ENV === "development" ? CC() : NC();
var TC = EC;
const xC = "_rtl_13v3w_295", vC = "_selected_13v3w_370", st = {
  "yext-default-richtextv2-theme__ul1": "_yext-default-richtextv2-theme__ul1_13v3w_17",
  "yext-default-richtextv2-theme__ul2": "_yext-default-richtextv2-theme__ul2_13v3w_25",
  "yext-default-richtextv2-theme__ul3": "_yext-default-richtextv2-theme__ul3_13v3w_33",
  "yext-default-richtextv2-theme__ltr": "_yext-default-richtextv2-theme__ltr_13v3w_55",
  "yext-default-richtextv2-theme__rtl": "_yext-default-richtextv2-theme__rtl_13v3w_58",
  "yext-default-richtextv2-theme__paragraph": "_yext-default-richtextv2-theme__paragraph_13v3w_61",
  "yext-default-richtextv2-theme__quote": "_yext-default-richtextv2-theme__quote_13v3w_70",
  "yext-default-richtextv2-theme__h1": "_yext-default-richtextv2-theme__h1_13v3w_81",
  "yext-default-richtextv2-theme__h2": "_yext-default-richtextv2-theme__h2_13v3w_89",
  "yext-default-richtextv2-theme__h3": "_yext-default-richtextv2-theme__h3_13v3w_97",
  "yext-default-richtextv2-theme__h4": "_yext-default-richtextv2-theme__h4_13v3w_105",
  "yext-default-richtextv2-theme__h5": "_yext-default-richtextv2-theme__h5_13v3w_113",
  "yext-default-richtextv2-theme__h6": "_yext-default-richtextv2-theme__h6_13v3w_121",
  "yext-default-richtextv2-theme__textBold": "_yext-default-richtextv2-theme__textBold_13v3w_130",
  "yext-default-richtextv2-theme__textItalic": "_yext-default-richtextv2-theme__textItalic_13v3w_133",
  "yext-default-richtextv2-theme__textUnderline": "_yext-default-richtextv2-theme__textUnderline_13v3w_136",
  "yext-default-richtextv2-theme__textStrikethrough": "_yext-default-richtextv2-theme__textStrikethrough_13v3w_139",
  "yext-default-richtextv2-theme__textUnderlineStrikethrough": "_yext-default-richtextv2-theme__textUnderlineStrikethrough_13v3w_142",
  "yext-default-richtextv2-theme__textSubscript": "_yext-default-richtextv2-theme__textSubscript_13v3w_145",
  "yext-default-richtextv2-theme__textSuperscript": "_yext-default-richtextv2-theme__textSuperscript_13v3w_149",
  "yext-default-richtextv2-theme__textCode": "_yext-default-richtextv2-theme__textCode_13v3w_153",
  "yext-default-richtextv2-theme__hashtag": "_yext-default-richtextv2-theme__hashtag_13v3w_159",
  "yext-default-richtextv2-theme__link": "_yext-default-richtextv2-theme__link_13v3w_163",
  "yext-default-richtextv2-theme__code": "_yext-default-richtextv2-theme__code_13v3w_171",
  "yext-default-richtextv2-theme__table": "_yext-default-richtextv2-theme__table_13v3w_199",
  "yext-default-richtextv2-theme__tableCell": "_yext-default-richtextv2-theme__tableCell_13v3w_208",
  "yext-default-richtextv2-theme__tableCellHeader": "_yext-default-richtextv2-theme__tableCellHeader_13v3w_218",
  "yext-default-richtextv2-theme__characterLimit": "_yext-default-richtextv2-theme__characterLimit_13v3w_222",
  "yext-default-richtextv2-theme__ol1": "_yext-default-richtextv2-theme__ol1_13v3w_226",
  "yext-default-richtextv2-theme__ol2": "_yext-default-richtextv2-theme__ol2_13v3w_233",
  "yext-default-richtextv2-theme__ol3": "_yext-default-richtextv2-theme__ol3_13v3w_240",
  "yext-default-richtextv2-theme__ol4": "_yext-default-richtextv2-theme__ol4_13v3w_247",
  "yext-default-richtextv2-theme__ol5": "_yext-default-richtextv2-theme__ol5_13v3w_254",
  "yext-default-richtextv2-theme__ul": "_yext-default-richtextv2-theme__ul_13v3w_17",
  "yext-default-richtextv2-theme__listItem": "_yext-default-richtextv2-theme__listItem_13v3w_267",
  "yext-default-richtextv2-theme__listItemChecked": "_yext-default-richtextv2-theme__listItemChecked_13v3w_270",
  "yext-default-richtextv2-theme__listItemUnchecked": "_yext-default-richtextv2-theme__listItemUnchecked_13v3w_271",
  rtl: xC,
  "yext-default-richtextv2-theme__nestedListItem": "_yext-default-richtextv2-theme__nestedListItem_13v3w_330",
  "yext-default-richtextv2-theme__tokenComment": "_yext-default-richtextv2-theme__tokenComment_13v3w_337",
  "yext-default-richtextv2-theme__tokenPunctuation": "_yext-default-richtextv2-theme__tokenPunctuation_13v3w_340",
  "yext-default-richtextv2-theme__tokenProperty": "_yext-default-richtextv2-theme__tokenProperty_13v3w_343",
  "yext-default-richtextv2-theme__tokenSelector": "_yext-default-richtextv2-theme__tokenSelector_13v3w_346",
  "yext-default-richtextv2-theme__tokenOperator": "_yext-default-richtextv2-theme__tokenOperator_13v3w_349",
  "yext-default-richtextv2-theme__tokenAttr": "_yext-default-richtextv2-theme__tokenAttr_13v3w_352",
  "yext-default-richtextv2-theme__tokenVariable": "_yext-default-richtextv2-theme__tokenVariable_13v3w_355",
  "yext-default-richtextv2-theme__tokenFunction": "_yext-default-richtextv2-theme__tokenFunction_13v3w_358",
  "yext-default-richtextv2-theme__mark": "_yext-default-richtextv2-theme__mark_13v3w_361",
  "yext-default-richtextv2-theme__markOverlap": "_yext-default-richtextv2-theme__markOverlap_13v3w_366",
  selected: vC,
  "yext-default-richtextv2-theme__embedBlock": "_yext-default-richtextv2-theme__embedBlock_13v3w_378",
  "yext-default-richtextv2-theme__embedBlockFocus": "_yext-default-richtextv2-theme__embedBlockFocus_13v3w_381",
  "yext-default-richtextv2-theme__image": "_yext-default-richtextv2-theme__image_13v3w_385"
}, SC = {
  characterLimit: st["yext-default-richtextv2-theme__characterLimit"],
  code: st["yext-default-richtextv2-theme__code"],
  codeHighlight: {
    atrule: st["yext-default-richtextv2-theme__tokenAttr"],
    attr: st["yext-default-richtextv2-theme__tokenAttr"],
    boolean: st["yext-default-richtextv2-theme__tokenProperty"],
    builtin: st["yext-default-richtextv2-theme__tokenSelector"],
    cdata: st["yext-default-richtextv2-theme__tokenComment"],
    char: st["yext-default-richtextv2-theme__tokenSelector"],
    class: st["yext-default-richtextv2-theme__tokenFunction"],
    "class-name": st["yext-default-richtextv2-theme__tokenFunction"],
    comment: st["yext-default-richtextv2-theme__tokenComment"],
    constant: st["yext-default-richtextv2-theme__tokenProperty"],
    deleted: st["yext-default-richtextv2-theme__tokenProperty"],
    doctype: st["yext-default-richtextv2-theme__tokenComment"],
    entity: st["yext-default-richtextv2-theme__tokenOperator"],
    function: st["yext-default-richtextv2-theme__tokenFunction"],
    important: st["yext-default-richtextv2-theme__tokenVariable"],
    inserted: st["yext-default-richtextv2-theme__tokenSelector"],
    keyword: st["yext-default-richtextv2-theme__tokenAttr"],
    namespace: st["yext-default-richtextv2-theme__tokenVariable"],
    number: st["yext-default-richtextv2-theme__tokenProperty"],
    operator: st["yext-default-richtextv2-theme__tokenOperator"],
    prolog: st["yext-default-richtextv2-theme__tokenComment"],
    property: st["yext-default-richtextv2-theme__tokenProperty"],
    punctuation: st["yext-default-richtextv2-theme__tokenPunctuation"],
    regex: st["yext-default-richtextv2-theme__tokenVariable"],
    selector: st["yext-default-richtextv2-theme__tokenSelector"],
    string: st["yext-default-richtextv2-theme__tokenSelector"],
    symbol: st["yext-default-richtextv2-theme__tokenProperty"],
    tag: st["yext-default-richtextv2-theme__tokenProperty"],
    url: st["yext-default-richtextv2-theme__tokenOperator"],
    variable: st["yext-default-richtextv2-theme__tokenVariable"]
  },
  embedBlock: {
    base: st["yext-default-richtextv2-theme__embedBlock"],
    focus: st["yext-default-richtextv2-theme__embedBlockFocus"]
  },
  hashtag: st["yext-default-richtextv2-theme__hashtag"],
  heading: {
    h1: st["yext-default-richtextv2-theme__h1"],
    h2: st["yext-default-richtextv2-theme__h2"],
    h3: st["yext-default-richtextv2-theme__h3"],
    h4: st["yext-default-richtextv2-theme__h4"],
    h5: st["yext-default-richtextv2-theme__h5"],
    h6: st["yext-default-richtextv2-theme__h6"]
  },
  image: st["yext-default-richtextv2-theme__image"],
  link: st["yext-default-richtextv2-theme__link"],
  list: {
    listitem: st["yext-default-richtextv2-theme__listItem"],
    listitemChecked: st["yext-default-richtextv2-theme__listItemChecked"],
    listitemUnchecked: st["yext-default-richtextv2-theme__listItemUnchecked"],
    nested: {
      listitem: st["yext-default-richtextv2-theme__nestedListItem"]
    },
    olDepth: [
      st["yext-default-richtextv2-theme__ol1"],
      st["yext-default-richtextv2-theme__ol2"],
      st["yext-default-richtextv2-theme__ol3"],
      st["yext-default-richtextv2-theme__ol4"],
      st["yext-default-richtextv2-theme__ol5"]
    ],
    ulDepth: [
      st["yext-default-richtextv2-theme__ul1"],
      st["yext-default-richtextv2-theme__ul2"],
      st["yext-default-richtextv2-theme__ul3"]
    ]
  },
  ltr: st["yext-default-richtextv2-theme__ltr"],
  mark: st["yext-default-richtextv2-theme__mark"],
  markOverlap: st["yext-default-richtextv2-theme__markOverlap"],
  paragraph: st["yext-default-richtextv2-theme__paragraph"],
  quote: st["yext-default-richtextv2-theme__quote"],
  rtl: st["yext-default-richtextv2-theme__rtl"],
  table: st["yext-default-richtextv2-theme__table"],
  tableCell: st["yext-default-richtextv2-theme__tableCell"],
  tableCellHeader: st["yext-default-richtextv2-theme__tableCellHeader"],
  text: {
    bold: st["yext-default-richtextv2-theme__textBold"],
    code: st["yext-default-richtextv2-theme__textCode"],
    italic: st["yext-default-richtextv2-theme__textItalic"],
    strikethrough: st["yext-default-richtextv2-theme__textStrikethrough"],
    subscript: st["yext-default-richtextv2-theme__textSubscript"],
    superscript: st["yext-default-richtextv2-theme__textSuperscript"],
    underline: st["yext-default-richtextv2-theme__textUnderline"],
    underlineStrikethrough: st["yext-default-richtextv2-theme__textUnderlineStrikethrough"]
  }
}, wC = SC;
var Vs = {}, bu = {}, tg;
function OC() {
  if (tg)
    return bu;
  tg = 1;
  var t = Yn(), e = Bt(), n = dn;
  function r(c, d) {
    return c.getEditorState().read(() => {
      let h = e.$getNodeByKey(d);
      return h === null ? !1 : h.isSelected();
    });
  }
  return bu.useLexicalNodeSelection = function(c) {
    let [d] = t.useLexicalComposerContext(), [h, p] = n.useState(() => r(d, c));
    n.useEffect(() => {
      let v = !0, O = d.registerUpdateListener(() => {
        v && p(r(d, c));
      });
      return () => {
        v = !1, O();
      };
    }, [d, c]);
    let N = n.useCallback((v) => {
      d.update(() => {
        let O = e.$getSelection();
        e.$isNodeSelection(O) || (O = e.$createNodeSelection(), e.$setSelection(O)), e.$isNodeSelection(O) && (v ? O.add(c) : O.delete(c));
      });
    }, [d, c]), x = n.useCallback(
      () => {
        d.update(() => {
          const v = e.$getSelection();
          e.$isNodeSelection(v) && v.clear();
        });
      },
      [d]
    );
    return [h, N, x];
  }, bu;
}
var Mu = {}, ng;
function DC() {
  if (ng)
    return Mu;
  ng = 1;
  var t = Yn(), e = Bt(), n = dn;
  function r(d, h) {
    return d.getEditorState().read(() => {
      const p = e.$getNodeByKey(h);
      return p === null ? !1 : p.isSelected();
    });
  }
  function c(d) {
    const [h] = t.useLexicalComposerContext(), [p, N] = n.useState(() => r(h, d));
    n.useEffect(() => {
      let O = !0;
      const M = h.registerUpdateListener(() => {
        O && N(r(h, d));
      });
      return () => {
        O = !1, M();
      };
    }, [h, d]);
    const x = n.useCallback((O) => {
      h.update(() => {
        let M = e.$getSelection();
        e.$isNodeSelection(M) || (M = e.$createNodeSelection(), e.$setSelection(M)), e.$isNodeSelection(M) && (O ? M.add(d) : M.delete(d));
      });
    }, [h, d]), v = n.useCallback(() => {
      h.update(() => {
        const O = e.$getSelection();
        e.$isNodeSelection(O) && O.clear();
      });
    }, [h]);
    return [p, x, v];
  }
  return Mu.useLexicalNodeSelection = c, Mu;
}
var Au, rg;
function Wp() {
  return rg || (rg = 1, Au = process.env.NODE_ENV === "development" ? DC() : OC()), Au;
}
var ig;
function RC() {
  if (ig)
    return Vs;
  ig = 1;
  var t = Yn(), e = Wp(), n = rn(), r = Bt(), c = dn;
  let d = r.createCommand("INSERT_HORIZONTAL_RULE_COMMAND");
  function h({ nodeKey: O }) {
    let [M] = t.useLexicalComposerContext(), [A, T, w] = e.useLexicalNodeSelection(O), P = c.useCallback((K) => (A && r.$isNodeSelection(r.$getSelection()) && (K.preventDefault(), K = r.$getNodeByKey(O), v(K) && K.remove()), !1), [A, O]);
    return c.useEffect(() => n.mergeRegister(M.registerCommand(r.CLICK_COMMAND, (K) => {
      let $ = M.getElementByKey(O);
      return K.target === $ ? (K.shiftKey || w(), T(!A), !0) : !1;
    }, r.COMMAND_PRIORITY_LOW), M.registerCommand(r.KEY_DELETE_COMMAND, P, r.COMMAND_PRIORITY_LOW), M.registerCommand(
      r.KEY_BACKSPACE_COMMAND,
      P,
      r.COMMAND_PRIORITY_LOW
    )), [w, M, A, O, P, T]), c.useEffect(() => {
      let K = M.getElementByKey(O);
      K !== null && (K.className = A ? "selected" : "");
    }, [M, A, O]), null;
  }
  class p extends r.DecoratorNode {
    static getType() {
      return "horizontalrule";
    }
    static clone(M) {
      return new p(M.__key);
    }
    static importJSON() {
      return x();
    }
    static importDOM() {
      return { hr: () => ({ conversion: N, priority: 0 }) };
    }
    exportJSON() {
      return { type: "horizontalrule", version: 1 };
    }
    exportDOM() {
      return { element: document.createElement("hr") };
    }
    createDOM() {
      return document.createElement("hr");
    }
    getTextContent() {
      return `
`;
    }
    isInline() {
      return !1;
    }
    updateDOM() {
      return !1;
    }
    decorate() {
      return c.createElement(h, { nodeKey: this.__key });
    }
  }
  function N() {
    return { node: x() };
  }
  function x() {
    return r.$applyNodeReplacement(new p());
  }
  function v(O) {
    return O instanceof p;
  }
  return Vs.$createHorizontalRuleNode = x, Vs.$isHorizontalRuleNode = v, Vs.HorizontalRuleNode = p, Vs.INSERT_HORIZONTAL_RULE_COMMAND = d, Vs;
}
var js = {}, og;
function bC() {
  if (og)
    return js;
  og = 1;
  var t = Yn(), e = Wp(), n = rn(), r = Bt(), c = dn;
  const d = r.createCommand("INSERT_HORIZONTAL_RULE_COMMAND");
  function h({
    nodeKey: O
  }) {
    const [M] = t.useLexicalComposerContext(), [A, T, w] = e.useLexicalNodeSelection(O), P = c.useCallback((K) => {
      if (A && r.$isNodeSelection(r.$getSelection())) {
        K.preventDefault();
        const $ = r.$getNodeByKey(O);
        v($) && $.remove();
      }
      return !1;
    }, [A, O]);
    return c.useEffect(() => n.mergeRegister(M.registerCommand(r.CLICK_COMMAND, (K) => {
      const $ = M.getElementByKey(O);
      return K.target === $ ? (K.shiftKey || w(), T(!A), !0) : !1;
    }, r.COMMAND_PRIORITY_LOW), M.registerCommand(r.KEY_DELETE_COMMAND, P, r.COMMAND_PRIORITY_LOW), M.registerCommand(r.KEY_BACKSPACE_COMMAND, P, r.COMMAND_PRIORITY_LOW)), [w, M, A, O, P, T]), c.useEffect(() => {
      const K = M.getElementByKey(O);
      K !== null && (K.className = A ? "selected" : "");
    }, [M, A, O]), null;
  }
  class p extends r.DecoratorNode {
    static getType() {
      return "horizontalrule";
    }
    static clone(M) {
      return new p(M.__key);
    }
    static importJSON(M) {
      return x();
    }
    static importDOM() {
      return {
        hr: () => ({
          conversion: N,
          priority: 0
        })
      };
    }
    exportJSON() {
      return {
        type: "horizontalrule",
        version: 1
      };
    }
    exportDOM() {
      return {
        element: document.createElement("hr")
      };
    }
    createDOM() {
      return document.createElement("hr");
    }
    getTextContent() {
      return `
`;
    }
    isInline() {
      return !1;
    }
    updateDOM() {
      return !1;
    }
    decorate() {
      return /* @__PURE__ */ c.createElement(h, {
        nodeKey: this.__key
      });
    }
  }
  function N() {
    return {
      node: x()
    };
  }
  function x() {
    return r.$applyNodeReplacement(new p());
  }
  function v(O) {
    return O instanceof p;
  }
  return js.$createHorizontalRuleNode = x, js.$isHorizontalRuleNode = v, js.HorizontalRuleNode = p, js.INSERT_HORIZONTAL_RULE_COMMAND = d, js;
}
const MC = process.env.NODE_ENV === "development" ? bC() : RC();
var AC = MC;
function kC(t, e) {
  return {
    namespace: "",
    editable: !1,
    onError: (n) => {
      throw n;
    },
    editorState: t,
    theme: e ?? wC,
    nodes: [
      Xh.HeadingNode,
      TC.HashtagNode,
      ol,
      cs.ListNode,
      cs.ListItemNode,
      Xh.QuoteNode,
      Vu.CodeNode,
      Vu.CodeHighlightNode,
      Ru.TableNode,
      Ru.TableCellNode,
      Ru.TableRowNode,
      Jh.AutoLinkNode,
      Jh.LinkNode,
      AC.HorizontalRuleNode
    ]
  };
}
const ku = {
  "editor-inner": "_editor-inner_1mmqo_6",
  "no-border": "_no-border_1mmqo_10"
};
function hS({
  serializedAST: t,
  nodeClassNames: e
}) {
  return /* @__PURE__ */ ht.jsx(
    lN.LexicalComposer,
    {
      initialConfig: kC(t, e),
      children: /* @__PURE__ */ ht.jsx("div", { className: `${ku["editor-inner"]} ${ku["no-border"]}`, children: /* @__PURE__ */ ht.jsxs("div", { className: ku["editor-inner"], children: [
        /* @__PURE__ */ ht.jsx(
          ON.RichTextPlugin,
          {
            contentEditable: /* @__PURE__ */ ht.jsx(
              MN.ContentEditable,
              {
                className: "editor-input",
                ariaLabel: "Lexical Rich Text"
              }
            ),
            ErrorBoundary: PN,
            placeholder: /* @__PURE__ */ ht.jsx("div", {})
          }
        ),
        /* @__PURE__ */ ht.jsx(iC, {}),
        /* @__PURE__ */ ht.jsx(KN.ListPlugin, {}),
        /* @__PURE__ */ ht.jsx(jN.LinkPlugin, {}),
        /* @__PURE__ */ ht.jsx(eC.TablePlugin, {}),
        /* @__PURE__ */ ht.jsx(cC, {}),
        /* @__PURE__ */ ht.jsx(yC, { maxDepth: 7 })
      ] }) })
    }
  );
}
function yd(t, e, n, r) {
  const c = t.length;
  let d = 0, h;
  if (e < 0 ? e = -e > c ? 0 : c + e : e = e > c ? c : e, n = n > 0 ? n : 0, r.length < 1e4)
    h = Array.from(r), h.unshift(e, n), [].splice.apply(t, h);
  else
    for (n && [].splice.apply(t, [e, n]); d < r.length; )
      h = r.slice(d, d + 1e4), h.unshift(e, 0), [].splice.apply(t, h), d += 1e4, e += 1e4;
}
function zl(t, e) {
  return t.length > 0 ? (yd(t, t.length, 0, e), t) : e;
}
const sg = {}.hasOwnProperty;
function LC(t) {
  const e = {};
  let n = -1;
  for (; ++n < t.length; )
    IC(e, t[n]);
  return e;
}
function IC(t, e) {
  let n;
  for (n in e) {
    const c = (sg.call(t, n) ? t[n] : void 0) || (t[n] = {}), d = e[n];
    let h;
    for (h in d) {
      sg.call(c, h) || (c[h] = []);
      const p = d[h];
      PC(
        // @ts-expect-error Looks like a list.
        c[h],
        Array.isArray(p) ? p : p ? [p] : []
      );
    }
  }
}
function PC(t, e) {
  let n = -1;
  const r = [];
  for (; ++n < e.length; )
    (e[n].add === "after" ? t : r).push(e[n]);
  yd(t, 0, 0, r);
}
const ro = {
  carriageReturn: -5,
  lineFeed: -4,
  carriageReturnLineFeed: -3,
  horizontalTab: -2,
  virtualSpace: -1,
  eof: null,
  nul: 0,
  soh: 1,
  stx: 2,
  etx: 3,
  eot: 4,
  enq: 5,
  ack: 6,
  bel: 7,
  bs: 8,
  ht: 9,
  // `\t`
  lf: 10,
  // `\n`
  vt: 11,
  // `\v`
  ff: 12,
  // `\f`
  cr: 13,
  // `\r`
  so: 14,
  si: 15,
  dle: 16,
  dc1: 17,
  dc2: 18,
  dc3: 19,
  dc4: 20,
  nak: 21,
  syn: 22,
  etb: 23,
  can: 24,
  em: 25,
  sub: 26,
  esc: 27,
  fs: 28,
  gs: 29,
  rs: 30,
  us: 31,
  space: 32,
  exclamationMark: 33,
  // `!`
  quotationMark: 34,
  // `"`
  numberSign: 35,
  // `#`
  dollarSign: 36,
  // `$`
  percentSign: 37,
  // `%`
  ampersand: 38,
  // `&`
  apostrophe: 39,
  // `'`
  leftParenthesis: 40,
  // `(`
  rightParenthesis: 41,
  // `)`
  asterisk: 42,
  // `*`
  plusSign: 43,
  // `+`
  comma: 44,
  // `,`
  dash: 45,
  // `-`
  dot: 46,
  // `.`
  slash: 47,
  // `/`
  digit0: 48,
  // `0`
  digit1: 49,
  // `1`
  digit2: 50,
  // `2`
  digit3: 51,
  // `3`
  digit4: 52,
  // `4`
  digit5: 53,
  // `5`
  digit6: 54,
  // `6`
  digit7: 55,
  // `7`
  digit8: 56,
  // `8`
  digit9: 57,
  // `9`
  colon: 58,
  // `:`
  semicolon: 59,
  // `;`
  lessThan: 60,
  // `<`
  equalsTo: 61,
  // `=`
  greaterThan: 62,
  // `>`
  questionMark: 63,
  // `?`
  atSign: 64,
  // `@`
  uppercaseA: 65,
  // `A`
  uppercaseB: 66,
  // `B`
  uppercaseC: 67,
  // `C`
  uppercaseD: 68,
  // `D`
  uppercaseE: 69,
  // `E`
  uppercaseF: 70,
  // `F`
  uppercaseG: 71,
  // `G`
  uppercaseH: 72,
  // `H`
  uppercaseI: 73,
  // `I`
  uppercaseJ: 74,
  // `J`
  uppercaseK: 75,
  // `K`
  uppercaseL: 76,
  // `L`
  uppercaseM: 77,
  // `M`
  uppercaseN: 78,
  // `N`
  uppercaseO: 79,
  // `O`
  uppercaseP: 80,
  // `P`
  uppercaseQ: 81,
  // `Q`
  uppercaseR: 82,
  // `R`
  uppercaseS: 83,
  // `S`
  uppercaseT: 84,
  // `T`
  uppercaseU: 85,
  // `U`
  uppercaseV: 86,
  // `V`
  uppercaseW: 87,
  // `W`
  uppercaseX: 88,
  // `X`
  uppercaseY: 89,
  // `Y`
  uppercaseZ: 90,
  // `Z`
  leftSquareBracket: 91,
  // `[`
  backslash: 92,
  // `\`
  rightSquareBracket: 93,
  // `]`
  caret: 94,
  // `^`
  underscore: 95,
  // `_`
  graveAccent: 96,
  // `` ` ``
  lowercaseA: 97,
  // `a`
  lowercaseB: 98,
  // `b`
  lowercaseC: 99,
  // `c`
  lowercaseD: 100,
  // `d`
  lowercaseE: 101,
  // `e`
  lowercaseF: 102,
  // `f`
  lowercaseG: 103,
  // `g`
  lowercaseH: 104,
  // `h`
  lowercaseI: 105,
  // `i`
  lowercaseJ: 106,
  // `j`
  lowercaseK: 107,
  // `k`
  lowercaseL: 108,
  // `l`
  lowercaseM: 109,
  // `m`
  lowercaseN: 110,
  // `n`
  lowercaseO: 111,
  // `o`
  lowercaseP: 112,
  // `p`
  lowercaseQ: 113,
  // `q`
  lowercaseR: 114,
  // `r`
  lowercaseS: 115,
  // `s`
  lowercaseT: 116,
  // `t`
  lowercaseU: 117,
  // `u`
  lowercaseV: 118,
  // `v`
  lowercaseW: 119,
  // `w`
  lowercaseX: 120,
  // `x`
  lowercaseY: 121,
  // `y`
  lowercaseZ: 122,
  // `z`
  leftCurlyBrace: 123,
  // `{`
  verticalBar: 124,
  // `|`
  rightCurlyBrace: 125,
  // `}`
  tilde: 126,
  // `~`
  del: 127,
  // Unicode Specials block.
  byteOrderMarker: 65279,
  // Unicode Specials block.
  replacementCharacter: 65533
  // ``
};
var lg = Object.prototype.hasOwnProperty;
function ag(t, e, n) {
  for (n of t.keys())
    if (Zl(n, e))
      return n;
}
function Zl(t, e) {
  var n, r, c;
  if (t === e)
    return !0;
  if (t && e && (n = t.constructor) === e.constructor) {
    if (n === Date)
      return t.getTime() === e.getTime();
    if (n === RegExp)
      return t.toString() === e.toString();
    if (n === Array) {
      if ((r = t.length) === e.length)
        for (; r-- && Zl(t[r], e[r]); )
          ;
      return r === -1;
    }
    if (n === Set) {
      if (t.size !== e.size)
        return !1;
      for (r of t)
        if (c = r, c && typeof c == "object" && (c = ag(e, c), !c) || !e.has(c))
          return !1;
      return !0;
    }
    if (n === Map) {
      if (t.size !== e.size)
        return !1;
      for (r of t)
        if (c = r[0], c && typeof c == "object" && (c = ag(e, c), !c) || !Zl(r[1], e.get(c)))
          return !1;
      return !0;
    }
    if (n === ArrayBuffer)
      t = new Uint8Array(t), e = new Uint8Array(e);
    else if (n === DataView) {
      if ((r = t.byteLength) === e.byteLength)
        for (; r-- && t.getInt8(r) === e.getInt8(r); )
          ;
      return r === -1;
    }
    if (ArrayBuffer.isView(t)) {
      if ((r = t.byteLength) === e.byteLength)
        for (; r-- && t[r] === e[r]; )
          ;
      return r === -1;
    }
    if (!n || typeof t == "object") {
      r = 0;
      for (n in t)
        if (lg.call(t, n) && ++r && !lg.call(e, n) || !(n in e) || !Zl(t[n], e[n]))
          return !1;
      return Object.keys(e).length === r;
    }
  }
  return t !== t && e !== e;
}
let ju, Kp, Up, zp, Gp = !0;
typeof process < "u" && ({ FORCE_COLOR: ju, NODE_DISABLE_COLORS: Kp, NO_COLOR: Up, TERM: zp } = process.env || {}, Gp = process.stdout && process.stdout.isTTY);
const Kt = {
  enabled: !Kp && Up == null && zp !== "dumb" && (ju != null && ju !== "0" || Gp),
  // modifiers
  reset: cn(0, 0),
  bold: cn(1, 22),
  dim: cn(2, 22),
  italic: cn(3, 23),
  underline: cn(4, 24),
  inverse: cn(7, 27),
  hidden: cn(8, 28),
  strikethrough: cn(9, 29),
  // colors
  black: cn(30, 39),
  red: cn(31, 39),
  green: cn(32, 39),
  yellow: cn(33, 39),
  blue: cn(34, 39),
  magenta: cn(35, 39),
  cyan: cn(36, 39),
  white: cn(37, 39),
  gray: cn(90, 39),
  grey: cn(90, 39),
  // background colors
  bgBlack: cn(40, 49),
  bgRed: cn(41, 49),
  bgGreen: cn(42, 49),
  bgYellow: cn(43, 49),
  bgBlue: cn(44, 49),
  bgMagenta: cn(45, 49),
  bgCyan: cn(46, 49),
  bgWhite: cn(47, 49)
};
function cg(t, e) {
  let n = 0, r, c = "", d = "";
  for (; n < t.length; n++)
    r = t[n], c += r.open, d += r.close, ~e.indexOf(r.close) && (e = e.replace(r.rgx, r.close + r.open));
  return c + e + d;
}
function $C(t, e) {
  let n = { has: t, keys: e };
  return n.reset = Kt.reset.bind(n), n.bold = Kt.bold.bind(n), n.dim = Kt.dim.bind(n), n.italic = Kt.italic.bind(n), n.underline = Kt.underline.bind(n), n.inverse = Kt.inverse.bind(n), n.hidden = Kt.hidden.bind(n), n.strikethrough = Kt.strikethrough.bind(n), n.black = Kt.black.bind(n), n.red = Kt.red.bind(n), n.green = Kt.green.bind(n), n.yellow = Kt.yellow.bind(n), n.blue = Kt.blue.bind(n), n.magenta = Kt.magenta.bind(n), n.cyan = Kt.cyan.bind(n), n.white = Kt.white.bind(n), n.gray = Kt.gray.bind(n), n.grey = Kt.grey.bind(n), n.bgBlack = Kt.bgBlack.bind(n), n.bgRed = Kt.bgRed.bind(n), n.bgGreen = Kt.bgGreen.bind(n), n.bgYellow = Kt.bgYellow.bind(n), n.bgBlue = Kt.bgBlue.bind(n), n.bgMagenta = Kt.bgMagenta.bind(n), n.bgCyan = Kt.bgCyan.bind(n), n.bgWhite = Kt.bgWhite.bind(n), n;
}
function cn(t, e) {
  let n = {
    open: `\x1B[${t}m`,
    close: `\x1B[${e}m`,
    rgx: new RegExp(`\\x1b\\[${e}m`, "g")
  };
  return function(r) {
    return this !== void 0 && this.has !== void 0 ? (~this.has.indexOf(t) || (this.has.push(t), this.keys.push(n)), r === void 0 ? this : Kt.enabled ? cg(this.keys, r + "") : r + "") : r === void 0 ? $C([t], [n]) : Kt.enabled ? cg([n], r + "") : r + "";
  };
}
function ko() {
}
ko.prototype = {
  diff: function(e, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, c = r.callback;
    typeof r == "function" && (c = r, r = {}), this.options = r;
    var d = this;
    function h(w) {
      return c ? (setTimeout(function() {
        c(void 0, w);
      }, 0), !0) : w;
    }
    e = this.castInput(e), n = this.castInput(n), e = this.removeEmpty(this.tokenize(e)), n = this.removeEmpty(this.tokenize(n));
    var p = n.length, N = e.length, x = 1, v = p + N;
    r.maxEditLength && (v = Math.min(v, r.maxEditLength));
    var O = [{
      newPos: -1,
      components: []
    }], M = this.extractCommon(O[0], n, e, 0);
    if (O[0].newPos + 1 >= p && M + 1 >= N)
      return h([{
        value: this.join(n),
        count: n.length
      }]);
    function A() {
      for (var w = -1 * x; w <= x; w += 2) {
        var P = void 0, K = O[w - 1], $ = O[w + 1], W = ($ ? $.newPos : 0) - w;
        K && (O[w - 1] = void 0);
        var H = K && K.newPos + 1 < p, z = $ && 0 <= W && W < N;
        if (!H && !z) {
          O[w] = void 0;
          continue;
        }
        if (!H || z && K.newPos < $.newPos ? (P = BC($), d.pushComponent(P.components, void 0, !0)) : (P = K, P.newPos++, d.pushComponent(P.components, !0, void 0)), W = d.extractCommon(P, n, e, w), P.newPos + 1 >= p && W + 1 >= N)
          return h(FC(d, P.components, n, e, d.useLongestToken));
        O[w] = P;
      }
      x++;
    }
    if (c)
      (function w() {
        setTimeout(function() {
          if (x > v)
            return c();
          A() || w();
        }, 0);
      })();
    else
      for (; x <= v; ) {
        var T = A();
        if (T)
          return T;
      }
  },
  pushComponent: function(e, n, r) {
    var c = e[e.length - 1];
    c && c.added === n && c.removed === r ? e[e.length - 1] = {
      count: c.count + 1,
      added: n,
      removed: r
    } : e.push({
      count: 1,
      added: n,
      removed: r
    });
  },
  extractCommon: function(e, n, r, c) {
    for (var d = n.length, h = r.length, p = e.newPos, N = p - c, x = 0; p + 1 < d && N + 1 < h && this.equals(n[p + 1], r[N + 1]); )
      p++, N++, x++;
    return x && e.components.push({
      count: x
    }), e.newPos = p, N;
  },
  equals: function(e, n) {
    return this.options.comparator ? this.options.comparator(e, n) : e === n || this.options.ignoreCase && e.toLowerCase() === n.toLowerCase();
  },
  removeEmpty: function(e) {
    for (var n = [], r = 0; r < e.length; r++)
      e[r] && n.push(e[r]);
    return n;
  },
  castInput: function(e) {
    return e;
  },
  tokenize: function(e) {
    return e.split("");
  },
  join: function(e) {
    return e.join("");
  }
};
function FC(t, e, n, r, c) {
  for (var d = 0, h = e.length, p = 0, N = 0; d < h; d++) {
    var x = e[d];
    if (x.removed) {
      if (x.value = t.join(r.slice(N, N + x.count)), N += x.count, d && e[d - 1].added) {
        var O = e[d - 1];
        e[d - 1] = e[d], e[d] = O;
      }
    } else {
      if (!x.added && c) {
        var v = n.slice(p, p + x.count);
        v = v.map(function(A, T) {
          var w = r[N + T];
          return w.length > A.length ? w : A;
        }), x.value = t.join(v);
      } else
        x.value = t.join(n.slice(p, p + x.count));
      p += x.count, x.added || (N += x.count);
    }
  }
  var M = e[h - 1];
  return h > 1 && typeof M.value == "string" && (M.added || M.removed) && t.equals("", M.value) && (e[h - 2].value += M.value, e.pop()), e;
}
function BC(t) {
  return {
    newPos: t.newPos,
    components: t.components.slice(0)
  };
}
var ug = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, dg = /\S/, Yp = new ko();
Yp.equals = function(t, e) {
  return this.options.ignoreCase && (t = t.toLowerCase(), e = e.toLowerCase()), t === e || this.options.ignoreWhitespace && !dg.test(t) && !dg.test(e);
};
Yp.tokenize = function(t) {
  for (var e = t.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), n = 0; n < e.length - 1; n++)
    !e[n + 1] && e[n + 2] && ug.test(e[n]) && ug.test(e[n + 2]) && (e[n] += e[n + 2], e.splice(n + 1, 2), n--);
  return e;
};
var Vp = new ko();
Vp.tokenize = function(t) {
  var e = [], n = t.split(/(\n|\r\n)/);
  n[n.length - 1] || n.pop();
  for (var r = 0; r < n.length; r++) {
    var c = n[r];
    r % 2 && !this.options.newlineIsToken ? e[e.length - 1] += c : (this.options.ignoreWhitespace && (c = c.trim()), e.push(c));
  }
  return e;
};
var HC = new ko();
HC.tokenize = function(t) {
  return t.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var WC = new ko();
WC.tokenize = function(t) {
  return t.split(/([{}:;,]|\s+)/);
};
function ic(t) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? ic = function(e) {
    return typeof e;
  } : ic = function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, ic(t);
}
var KC = Object.prototype.toString, Ql = new ko();
Ql.useLongestToken = !0;
Ql.tokenize = Vp.tokenize;
Ql.castInput = function(t) {
  var e = this.options, n = e.undefinedReplacement, r = e.stringifyReplacer, c = r === void 0 ? function(d, h) {
    return typeof h > "u" ? n : h;
  } : r;
  return typeof t == "string" ? t : JSON.stringify(qu(t, null, null, c), c, "  ");
};
Ql.equals = function(t, e) {
  return ko.prototype.equals.call(Ql, t.replace(/,([\r\n])/g, "$1"), e.replace(/,([\r\n])/g, "$1"));
};
function qu(t, e, n, r, c) {
  e = e || [], n = n || [], r && (t = r(c, t));
  var d;
  for (d = 0; d < e.length; d += 1)
    if (e[d] === t)
      return n[d];
  var h;
  if (KC.call(t) === "[object Array]") {
    for (e.push(t), h = new Array(t.length), n.push(h), d = 0; d < t.length; d += 1)
      h[d] = qu(t[d], e, n, r, c);
    return e.pop(), n.pop(), h;
  }
  if (t && t.toJSON && (t = t.toJSON()), ic(t) === "object" && t !== null) {
    e.push(t), h = {}, n.push(h);
    var p = [], N;
    for (N in t)
      t.hasOwnProperty(N) && p.push(N);
    for (p.sort(), d = 0; d < p.length; d += 1)
      N = p[d], h[N] = qu(t[N], e, n, r, N);
    e.pop(), n.pop();
  } else
    h = t;
  return h;
}
var Zu = new ko();
Zu.tokenize = function(t) {
  return t.slice();
};
Zu.join = Zu.removeEmpty = function(t) {
  return t;
};
Kt.red, Kt.grey, Kt.green;
Kt.dim().italic;
Kt.dim("");
Kt.dim("");
Kt.dim("");
function lc(t) {
  t = t.replace(/\r?\n/g, `
`);
  let e = t.match(/^[ \t]*(?=\S)/gm), n = 0, r = 1 / 0, c = (e || []).length;
  for (; n < c; n++)
    r = Math.min(r, e[n].length);
  return c && r ? t.replace(new RegExp(`^[ \\t]{${r}}`, "gm"), "") : t;
}
class UC extends Error {
  constructor(e = {}) {
    super(e.message), this.name = "Assertion", this.code = "ERR_ASSERTION", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), this.details = e.details || !1, this.generated = !!e.generated, this.operator = e.operator, this.expects = e.expects, this.actual = e.actual;
  }
}
function Qr(t, e, n, r, c, d, h) {
  if (t)
    return;
  let p = h || d;
  if (h instanceof Error)
    throw h;
  let N = c && c(e, n);
  throw new UC({ actual: e, expects: n, operator: r, message: p, details: N, generated: !h });
}
function Nc(t, e) {
  Qr(!!t, !1, !0, "ok", !1, "Expected value to be truthy", e);
}
function io(t, e) {
  Qr(!t, !0, !1, "not", !1, "Expected value to be falsey", e);
}
io.ok = io;
io.equal = function(t, e, n) {
  Qr(!Zl(t, e), t, e, "not.equal", !1, "Expected values not to be deeply equal", n);
};
io.type = function(t, e, n) {
  let r = typeof t;
  Qr(r !== e, r, e, "not.type", !1, `Expected "${r}" not to be "${e}"`, n);
};
io.instance = function(t, e, n) {
  let r = "`" + (e.name || e.constructor.name) + "`";
  Qr(!(t instanceof e), t, e, "not.instance", !1, `Expected value not to be an instance of ${r}`, n);
};
io.snapshot = function(t, e, n) {
  t = lc(t), e = lc(e), Qr(t !== e, t, e, "not.snapshot", !1, "Expected value not to match snapshot", n);
};
io.fixture = function(t, e, n) {
  t = lc(t), e = lc(e), Qr(t !== e, t, e, "not.fixture", !1, "Expected value not to match fixture", n);
};
io.match = function(t, e, n) {
  typeof e == "string" ? Qr(!t.includes(e), t, e, "not.match", !1, `Expected value not to include "${e}" substring`, n) : Qr(!e.test(t), t, e, "not.match", !1, `Expected value not to match \`${String(e)}\` pattern`, n);
};
io.throws = function(t, e, n) {
  !n && typeof e == "string" && (n = e, e = null);
  try {
    t();
  } catch (r) {
    typeof e == "function" ? Qr(!e(r), !0, !1, "not.throws", !1, "Expected function not to throw matching exception", n) : e instanceof RegExp ? Qr(!e.test(r.message), !0, !1, "not.throws", !1, `Expected function not to throw exception matching \`${String(e)}\` pattern`, n) : e || Qr(!1, !0, !1, "not.throws", !1, "Expected function not to throw", n);
  }
};
const zC = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, gS = Lo(/[A-Za-z]/), fg = Lo(/[\dA-Za-z]/), pS = Lo(/[#-'*+\--9=?A-Z^-~]/);
function mS(t) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    t !== null && (t < 32 || t === 127)
  );
}
const _S = Lo(/\d/), yS = Lo(/[\dA-Fa-f]/), NS = Lo(/[!-/:-@[-`{-~]/);
function CS(t) {
  return t !== null && t < -2;
}
function GC(t) {
  return t !== null && (t < 0 || t === 32);
}
function ES(t) {
  return t === -2 || t === -1 || t === 32;
}
const YC = Lo(zC), VC = Lo(/\s/);
function Lo(t) {
  return e;
  function e(n) {
    return n !== null && t.test(String.fromCharCode(n));
  }
}
function ac(t) {
  if (t === null || GC(t) || VC(t))
    return 1;
  if (YC(t))
    return 2;
}
const cc = {
  attentionSideBefore: 1,
  // Symbol to mark an attention sequence as before content: `*a`
  attentionSideAfter: 2,
  // Symbol to mark an attention sequence as after content: `a*`
  atxHeadingOpeningFenceSizeMax: 6,
  // 6 number signs is fine, 7 isnt.
  autolinkDomainSizeMax: 63,
  // 63 characters is fine, 64 is too many.
  autolinkSchemeSizeMax: 32,
  // 32 characters is fine, 33 is too many.
  cdataOpeningString: "CDATA[",
  // And preceded by `<![`.
  characterGroupWhitespace: 1,
  // Symbol used to indicate a character is whitespace
  characterGroupPunctuation: 2,
  // Symbol used to indicate a character is punctuation
  characterReferenceDecimalSizeMax: 7,
  // `&#9999999;`.
  characterReferenceHexadecimalSizeMax: 6,
  // `&#xff9999;`.
  characterReferenceNamedSizeMax: 31,
  // `&CounterClockwiseContourIntegral;`.
  codeFencedSequenceSizeMin: 3,
  // At least 3 ticks or tildes are needed.
  contentTypeDocument: "document",
  contentTypeFlow: "flow",
  contentTypeContent: "content",
  contentTypeString: "string",
  contentTypeText: "text",
  hardBreakPrefixSizeMin: 2,
  // At least 2 trailing spaces are needed.
  htmlRaw: 1,
  // Symbol for `<script>`
  htmlComment: 2,
  // Symbol for `<!---->`
  htmlInstruction: 3,
  // Symbol for `<?php?>`
  htmlDeclaration: 4,
  // Symbol for `<!doctype>`
  htmlCdata: 5,
  // Symbol for `<![CDATA[]]>`
  htmlBasic: 6,
  // Symbol for `<div`
  htmlComplete: 7,
  // Symbol for `<x>`
  htmlRawSizeMax: 8,
  // Length of `textarea`.
  linkResourceDestinationBalanceMax: 32,
  // See: <https://spec.commonmark.org/0.30/#link-destination>, <https://github.com/remarkjs/react-markdown/issues/658#issuecomment-984345577>
  linkReferenceSizeMax: 999,
  // See: <https://spec.commonmark.org/0.30/#link-label>
  listItemValueSizeMax: 10,
  // See: <https://spec.commonmark.org/0.30/#ordered-list-marker>
  numericBaseDecimal: 10,
  numericBaseHexadecimal: 16,
  tabSize: 4,
  // Tabs have a hard-coded size of 4, per CommonMark.
  thematicBreakMarkerCountMin: 3,
  // At least 3 asterisks, dashes, or underscores are needed.
  v8MaxSafeChunkSize: 1e4
  // V8 (and potentially others) have problems injecting giant arrays into other arrays, hence we operate in chunks.
};
function jC(t, e) {
  const n = this.previous, r = ac(n);
  return c;
  function c(h) {
    return Nc(h === ro.tilde, "expected `~`"), t.enter("tildeSequenceTemporary"), d(h);
  }
  function d(h) {
    if (h === ro.tilde)
      return t.consume(h), d;
    const p = t.exit("tildeSequenceTemporary"), N = ac(h);
    return p._open = !N || N === cc.characterGroupPunctuation && !!r, p._close = !r || r === cc.characterGroupPunctuation && !!N, e(h);
  }
}
function qC(t, e, n) {
  const r = [];
  let c = -1;
  for (; ++c < t.length; ) {
    const d = t[c].resolveAll;
    d && !r.includes(d) && (e = d(e, n), r.push(d));
  }
  return e;
}
const ZC = {
  // Generic type for data, such as in a title, a destination, etc.
  data: "data",
  // Generic type for syntactic whitespace (tabs, virtual spaces, spaces).
  // Such as, between a fenced code fence and an info string.
  whitespace: "whitespace",
  // Generic type for line endings (line feed, carriage return, carriage return +
  // line feed).
  lineEnding: "lineEnding",
  // A line ending, but ending a blank line.
  lineEndingBlank: "lineEndingBlank",
  // Generic type for whitespace (tabs, virtual spaces, spaces) at the start of a
  // line.
  linePrefix: "linePrefix",
  // Generic type for whitespace (tabs, virtual spaces, spaces) at the end of a
  // line.
  lineSuffix: "lineSuffix",
  // Whole ATX heading:
  //
  // ```markdown
  // #
  // ## Alpha
  // ### Bravo ###
  // ```
  //
  // Includes `atxHeadingSequence`, `whitespace`, `atxHeadingText`.
  atxHeading: "atxHeading",
  // Sequence of number signs in an ATX heading (`###`).
  atxHeadingSequence: "atxHeadingSequence",
  // Content in an ATX heading (`alpha`).
  // Includes text.
  atxHeadingText: "atxHeadingText",
  // Whole autolink (`<https://example.com>` or `<admin@example.com>`)
  // Includes `autolinkMarker` and `autolinkProtocol` or `autolinkEmail`.
  autolink: "autolink",
  // Email autolink w/o markers (`admin@example.com`)
  autolinkEmail: "autolinkEmail",
  // Marker around an `autolinkProtocol` or `autolinkEmail` (`<` or `>`).
  autolinkMarker: "autolinkMarker",
  // Protocol autolink w/o markers (`https://example.com`)
  autolinkProtocol: "autolinkProtocol",
  // A whole character escape (`\-`).
  // Includes `escapeMarker` and `characterEscapeValue`.
  characterEscape: "characterEscape",
  // The escaped character (`-`).
  characterEscapeValue: "characterEscapeValue",
  // A whole character reference (`&amp;`, `&#8800;`, or `&#x1D306;`).
  // Includes `characterReferenceMarker`, an optional
  // `characterReferenceMarkerNumeric`, in which case an optional
  // `characterReferenceMarkerHexadecimal`, and a `characterReferenceValue`.
  characterReference: "characterReference",
  // The start or end marker (`&` or `;`).
  characterReferenceMarker: "characterReferenceMarker",
  // Mark reference as numeric (`#`).
  characterReferenceMarkerNumeric: "characterReferenceMarkerNumeric",
  // Mark reference as numeric (`x` or `X`).
  characterReferenceMarkerHexadecimal: "characterReferenceMarkerHexadecimal",
  // Value of character reference w/o markers (`amp`, `8800`, or `1D306`).
  characterReferenceValue: "characterReferenceValue",
  // Whole fenced code:
  //
  // ````markdown
  // ```js
  // alert(1)
  // ```
  // ````
  codeFenced: "codeFenced",
  // A fenced code fence, including whitespace, sequence, info, and meta
  // (` ```js `).
  codeFencedFence: "codeFencedFence",
  // Sequence of grave accent or tilde characters (` ``` `) in a fence.
  codeFencedFenceSequence: "codeFencedFenceSequence",
  // Info word (`js`) in a fence.
  // Includes string.
  codeFencedFenceInfo: "codeFencedFenceInfo",
  // Meta words (`highlight="1"`) in a fence.
  // Includes string.
  codeFencedFenceMeta: "codeFencedFenceMeta",
  // A line of code.
  codeFlowValue: "codeFlowValue",
  // Whole indented code:
  //
  // ```markdown
  //     alert(1)
  // ```
  //
  // Includes `lineEnding`, `linePrefix`, and `codeFlowValue`.
  codeIndented: "codeIndented",
  // A text code (``` `alpha` ```).
  // Includes `codeTextSequence`, `codeTextData`, `lineEnding`, and can include
  // `codeTextPadding`.
  codeText: "codeText",
  codeTextData: "codeTextData",
  // A space or line ending right after or before a tick.
  codeTextPadding: "codeTextPadding",
  // A text code fence (` `` `).
  codeTextSequence: "codeTextSequence",
  // Whole content:
  //
  // ```markdown
  // [a]: b
  // c
  // =
  // d
  // ```
  //
  // Includes `paragraph` and `definition`.
  content: "content",
  // Whole definition:
  //
  // ```markdown
  // [micromark]: https://github.com/micromark/micromark
  // ```
  //
  // Includes `definitionLabel`, `definitionMarker`, `whitespace`,
  // `definitionDestination`, and optionally `lineEnding` and `definitionTitle`.
  definition: "definition",
  // Destination of a definition (`https://github.com/micromark/micromark` or
  // `<https://github.com/micromark/micromark>`).
  // Includes `definitionDestinationLiteral` or `definitionDestinationRaw`.
  definitionDestination: "definitionDestination",
  // Enclosed destination of a definition
  // (`<https://github.com/micromark/micromark>`).
  // Includes `definitionDestinationLiteralMarker` and optionally
  // `definitionDestinationString`.
  definitionDestinationLiteral: "definitionDestinationLiteral",
  // Markers of an enclosed definition destination (`<` or `>`).
  definitionDestinationLiteralMarker: "definitionDestinationLiteralMarker",
  // Unenclosed destination of a definition
  // (`https://github.com/micromark/micromark`).
  // Includes `definitionDestinationString`.
  definitionDestinationRaw: "definitionDestinationRaw",
  // Text in an destination (`https://github.com/micromark/micromark`).
  // Includes string.
  definitionDestinationString: "definitionDestinationString",
  // Label of a definition (`[micromark]`).
  // Includes `definitionLabelMarker` and `definitionLabelString`.
  definitionLabel: "definitionLabel",
  // Markers of a definition label (`[` or `]`).
  definitionLabelMarker: "definitionLabelMarker",
  // Value of a definition label (`micromark`).
  // Includes string.
  definitionLabelString: "definitionLabelString",
  // Marker between a label and a destination (`:`).
  definitionMarker: "definitionMarker",
  // Title of a definition (`"x"`, `'y'`, or `(z)`).
  // Includes `definitionTitleMarker` and optionally `definitionTitleString`.
  definitionTitle: "definitionTitle",
  // Marker around a title of a definition (`"`, `'`, `(`, or `)`).
  definitionTitleMarker: "definitionTitleMarker",
  // Data without markers in a title (`z`).
  // Includes string.
  definitionTitleString: "definitionTitleString",
  // Emphasis (`*alpha*`).
  // Includes `emphasisSequence` and `emphasisText`.
  emphasis: "emphasis",
  // Sequence of emphasis markers (`*` or `_`).
  emphasisSequence: "emphasisSequence",
  // Emphasis text (`alpha`).
  // Includes text.
  emphasisText: "emphasisText",
  // The character escape marker (`\`).
  escapeMarker: "escapeMarker",
  // A hard break created with a backslash (`\\n`).
  // Includes `escapeMarker` (does not include the line ending)
  hardBreakEscape: "hardBreakEscape",
  // A hard break created with trailing spaces (`  \n`).
  // Does not include the line ending.
  hardBreakTrailing: "hardBreakTrailing",
  // Flow HTML:
  //
  // ```markdown
  // <div
  // ```
  //
  // Inlcudes `lineEnding`, `htmlFlowData`.
  htmlFlow: "htmlFlow",
  htmlFlowData: "htmlFlowData",
  // HTML in text (the tag in `a <i> b`).
  // Includes `lineEnding`, `htmlTextData`.
  htmlText: "htmlText",
  htmlTextData: "htmlTextData",
  // Whole image (`![alpha](bravo)`, `![alpha][bravo]`, `![alpha][]`, or
  // `![alpha]`).
  // Includes `label` and an optional `resource` or `reference`.
  image: "image",
  // Whole link label (`[*alpha*]`).
  // Includes `labelLink` or `labelImage`, `labelText`, and `labelEnd`.
  label: "label",
  // Text in an label (`*alpha*`).
  // Includes text.
  labelText: "labelText",
  // Start a link label (`[`).
  // Includes a `labelMarker`.
  labelLink: "labelLink",
  // Start an image label (`![`).
  // Includes `labelImageMarker` and `labelMarker`.
  labelImage: "labelImage",
  // Marker of a label (`[` or `]`).
  labelMarker: "labelMarker",
  // Marker to start an image (`!`).
  labelImageMarker: "labelImageMarker",
  // End a label (`]`).
  // Includes `labelMarker`.
  labelEnd: "labelEnd",
  // Whole link (`[alpha](bravo)`, `[alpha][bravo]`, `[alpha][]`, or `[alpha]`).
  // Includes `label` and an optional `resource` or `reference`.
  link: "link",
  // Whole paragraph:
  //
  // ```markdown
  // alpha
  // bravo.
  // ```
  //
  // Includes text.
  paragraph: "paragraph",
  // A reference (`[alpha]` or `[]`).
  // Includes `referenceMarker` and an optional `referenceString`.
  reference: "reference",
  // A reference marker (`[` or `]`).
  referenceMarker: "referenceMarker",
  // Reference text (`alpha`).
  // Includes string.
  referenceString: "referenceString",
  // A resource (`(https://example.com "alpha")`).
  // Includes `resourceMarker`, an optional `resourceDestination` with an optional
  // `whitespace` and `resourceTitle`.
  resource: "resource",
  // A resource destination (`https://example.com`).
  // Includes `resourceDestinationLiteral` or `resourceDestinationRaw`.
  resourceDestination: "resourceDestination",
  // A literal resource destination (`<https://example.com>`).
  // Includes `resourceDestinationLiteralMarker` and optionally
  // `resourceDestinationString`.
  resourceDestinationLiteral: "resourceDestinationLiteral",
  // A resource destination marker (`<` or `>`).
  resourceDestinationLiteralMarker: "resourceDestinationLiteralMarker",
  // A raw resource destination (`https://example.com`).
  // Includes `resourceDestinationString`.
  resourceDestinationRaw: "resourceDestinationRaw",
  // Resource destination text (`https://example.com`).
  // Includes string.
  resourceDestinationString: "resourceDestinationString",
  // A resource marker (`(` or `)`).
  resourceMarker: "resourceMarker",
  // A resource title (`"alpha"`, `'alpha'`, or `(alpha)`).
  // Includes `resourceTitleMarker` and optionally `resourceTitleString`.
  resourceTitle: "resourceTitle",
  // A resource title marker (`"`, `'`, `(`, or `)`).
  resourceTitleMarker: "resourceTitleMarker",
  // Resource destination title (`alpha`).
  // Includes string.
  resourceTitleString: "resourceTitleString",
  // Whole setext heading:
  //
  // ```markdown
  // alpha
  // bravo
  // =====
  // ```
  //
  // Includes `setextHeadingText`, `lineEnding`, `linePrefix`, and
  // `setextHeadingLine`.
  setextHeading: "setextHeading",
  // Content in a setext heading (`alpha\nbravo`).
  // Includes text.
  setextHeadingText: "setextHeadingText",
  // Underline in a setext heading, including whitespace suffix (`==`).
  // Includes `setextHeadingLineSequence`.
  setextHeadingLine: "setextHeadingLine",
  // Sequence of equals or dash characters in underline in a setext heading (`-`).
  setextHeadingLineSequence: "setextHeadingLineSequence",
  // Strong (`**alpha**`).
  // Includes `strongSequence` and `strongText`.
  strong: "strong",
  // Sequence of strong markers (`**` or `__`).
  strongSequence: "strongSequence",
  // Strong text (`alpha`).
  // Includes text.
  strongText: "strongText",
  // Whole thematic break:
  //
  // ```markdown
  // * * *
  // ```
  //
  // Includes `thematicBreakSequence` and `whitespace`.
  thematicBreak: "thematicBreak",
  // A sequence of one or more thematic break markers (`***`).
  thematicBreakSequence: "thematicBreakSequence",
  // Whole block quote:
  //
  // ```markdown
  // > a
  // >
  // > b
  // ```
  //
  // Includes `blockQuotePrefix` and flow.
  blockQuote: "blockQuote",
  // The `>` or `> ` of a block quote.
  blockQuotePrefix: "blockQuotePrefix",
  // The `>` of a block quote prefix.
  blockQuoteMarker: "blockQuoteMarker",
  // The optional ` ` of a block quote prefix.
  blockQuotePrefixWhitespace: "blockQuotePrefixWhitespace",
  // Whole unordered list:
  //
  // ```markdown
  // - a
  //   b
  // ```
  //
  // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
  // lines.
  listOrdered: "listOrdered",
  // Whole ordered list:
  //
  // ```markdown
  // 1. a
  //    b
  // ```
  //
  // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
  // lines.
  listUnordered: "listUnordered",
  // The indent of further list item lines.
  listItemIndent: "listItemIndent",
  // A marker, as in, `*`, `+`, `-`, `.`, or `)`.
  listItemMarker: "listItemMarker",
  // The thing that starts a list item, such as `1. `.
  // Includes `listItemValue` if ordered, `listItemMarker`, and
  // `listItemPrefixWhitespace` (unless followed by a line ending).
  listItemPrefix: "listItemPrefix",
  // The whitespace after a marker.
  listItemPrefixWhitespace: "listItemPrefixWhitespace",
  // The numerical value of an ordered item.
  listItemValue: "listItemValue",
  // Internal types used for subtokenizers, compiled away
  chunkDocument: "chunkDocument",
  chunkContent: "chunkContent",
  chunkFlow: "chunkFlow",
  chunkText: "chunkText",
  chunkString: "chunkString"
};
function Nd(t, e) {
  return !!(t[0] === "enter" && t[1].type === `${e}SequenceTemporary` && t[1]._close);
}
function Cd(t, e) {
  return !!(t[0] === "exit" && t[1].type === `${e}SequenceTemporary` && t[1]._open);
}
function Ed(t, e, n, r, c, d) {
  const [h, p, N, x] = JC(
    t[e],
    t[n],
    c,
    d
  );
  t[e][1].end = Object.assign({}, h.start), t[n][1].start = Object.assign({}, p.end);
  let v = [];
  t[e][1].end.offset - t[e][1].start.offset && (v = zl(v, [
    ["enter", t[e][1], r],
    ["exit", t[e][1], r]
  ])), v = zl(v, [
    ["enter", x, r],
    ["enter", h, r],
    ["exit", h, r],
    ["enter", N, r]
  ]), v = zl(
    v,
    qC(
      r.parser.constructs.insideSpan.null,
      t.slice(e + 1, n),
      r
    )
  ), v = zl(v, [
    ["exit", N, r],
    ["enter", p, r],
    ["exit", p, r],
    ["exit", x, r]
  ]);
  let O = 0;
  return t[n][1].end.offset - t[n][1].start.offset && (O = 2, v = zl(v, [
    ["enter", t[n][1], r],
    ["exit", t[n][1], r]
  ])), yd(t, e - 1, n - e + 3, v), e + v.length - O - 2;
}
function JC(t, e, n, r) {
  const c = Object.assign({}, t[1].end), d = Object.assign({}, e[1].start);
  hg(c, -r), hg(d, r);
  const h = {
    type: `${n}Sequence`,
    start: c,
    end: Object.assign({}, t[1].end)
  }, p = {
    type: `${n}Sequence`,
    start: Object.assign({}, e[1].start),
    end: d
  }, N = {
    type: `${n}Text`,
    start: Object.assign({}, t[1].end),
    end: Object.assign({}, e[1].start)
  }, x = {
    type: `${n}`,
    start: Object.assign({}, h.start),
    end: Object.assign({}, p.end)
  };
  return [h, p, N, x];
}
function hg(t, e) {
  t.column += e, t.offset += e, t._bufferIndex += e;
}
function Td(t, e) {
  t.forEach((n) => {
    n[1].type === `${e}SequenceTemporary` && (n[1].type = ZC.data);
  });
}
function XC(t, e) {
  let n = -1;
  for (; ++n < t.length; )
    if (Nd(t[n], "tilde")) {
      let r = n;
      for (; r--; )
        if (Cd(t[r], "tilde")) {
          const c = QC(t[r], t[n]);
          n = Ed(
            t,
            r,
            n,
            e,
            c === 1 ? "subscript" : "strikethrough",
            c
          );
          break;
        }
    }
  return Td(t, "tilde"), t;
}
function QC(t, e) {
  const n = t[1].end.offset - t[1].start.offset, r = e[1].end.offset - e[1].start.offset;
  return n < 3 || r < 3 ? r < n ? r : n : r % 2 === 0 ? 2 : 1;
}
function eE() {
  const t = {
    tokenize: jC,
    resolveAll: XC
  };
  return {
    text: { [ro.tilde]: t },
    insideSpan: { null: [t] }
  };
}
function tE(t, e) {
  let n = -1;
  for (; ++n < t.length; )
    if (Nd(t[n], "superscript")) {
      let r = n;
      for (; r--; )
        if (Cd(t[r], "superscript")) {
          n = Ed(
            t,
            r,
            n,
            e,
            "superscript",
            1
          );
          break;
        }
    }
  return Td(t, "superscript"), t;
}
function nE(t, e) {
  return n;
  function n(c) {
    return Nc(c === ro.caret, "expected `^`"), t.enter("superscriptSequenceTemporary"), r(c);
  }
  function r(c) {
    if (c === ro.caret)
      return t.consume(c), r;
    const d = t.exit("superscriptSequenceTemporary");
    return d._open = !0, d._close = !0, e(c);
  }
}
function rE() {
  const t = {
    tokenize: nE,
    resolveAll: tE
  };
  return {
    text: { [ro.caret]: t },
    insideSpan: { null: [t] }
  };
}
function iE(t, e, n) {
  const r = this.previous, c = ac(r);
  let d = 0;
  return h;
  function h(N) {
    return Nc(N === ro.plusSign, "expected `+`"), t.enter("underlineSequenceTemporary"), p(N);
  }
  function p(N) {
    if (N === ro.plusSign)
      return t.consume(N), d++, p;
    if (d < 2)
      return n(N);
    const x = t.exit("underlineSequenceTemporary"), v = ac(N);
    return x._open = !v || v === cc.characterGroupPunctuation && !!c, x._close = !c || c === cc.characterGroupPunctuation && !!v, e(N);
  }
}
function oE(t, e) {
  let n = -1;
  for (; ++n < t.length; )
    if (Nd(t[n], "underline") && t[n][1].end.offset - t[n][1].start.offset > 1) {
      let r = n;
      for (; r--; )
        if (Cd(t[r], "underline") && t[r][1].end.offset - t[r][1].start.offset > 1) {
          n = Ed(
            t,
            r,
            n,
            e,
            "underline",
            2
          );
          break;
        }
    }
  return Td(t, "underline"), t;
}
function sE() {
  const t = {
    tokenize: iE,
    resolveAll: oE
  };
  return {
    text: { [ro.plusSign]: t },
    insideSpan: { null: [t] }
  };
}
function lE() {
  return LC([
    sE(),
    rE(),
    eE()
  ]);
}
const aE = {
  canContainEols: ["strikethrough"],
  enter: { strikethrough: cE },
  exit: { strikethrough: uE }
};
function cE(t) {
  this.enter({ type: "strikethrough", children: [] }, t);
}
function uE(t) {
  this.exit(t);
}
const dE = {
  canContainEols: ["subscript"],
  enter: { subscript: fE },
  exit: { subscript: hE }
};
function fE(t) {
  this.enter({ type: "subscript", children: [] }, t);
}
function hE(t) {
  this.exit(t);
}
const gE = {
  canContainEols: ["superscript"],
  enter: { superscript: pE },
  exit: { superscript: mE }
};
function pE(t) {
  this.enter({ type: "superscript", children: [] }, t);
}
function mE(t) {
  this.exit(t);
}
const _E = {
  canContainEols: ["underline"],
  enter: { underline: yE },
  exit: { underline: NE }
};
function yE(t) {
  this.enter({ type: "underline", children: [] }, t);
}
function NE(t) {
  this.exit(t);
}
function CE() {
  return [
    _E,
    aE,
    dE,
    gE
  ];
}
function EE() {
  const t = this.data();
  e("micromarkExtensions", lE()), e("fromMarkdownExtensions", CE());
  function e(n, r) {
    const c = t[n];
    c ? (Nc(Array.isArray(c)), c.push(r)) : t[n] = [r];
  }
}
function TE(t, e) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: t.wrap(t.all(e), !0)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function xE(t, e) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return t.patch(e, n), [t.applyData(e, n), { type: "text", value: `
` }];
}
function vE(t, e) {
  const n = e.value ? e.value + `
` : "", r = e.lang ? e.lang.match(/^[^ \t]+(?=[ \t]|$)/) : null, c = {};
  r && (c.className = ["language-" + r]);
  let d = {
    type: "element",
    tagName: "code",
    properties: c,
    children: [{ type: "text", value: n }]
  };
  return e.meta && (d.data = { meta: e.meta }), t.patch(e, d), d = t.applyData(e, d), d = { type: "element", tagName: "pre", properties: {}, children: [d] }, t.patch(e, d), d;
}
function SE(t, e) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function wE(t, e) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function ta(t) {
  const e = [];
  let n = -1, r = 0, c = 0;
  for (; ++n < t.length; ) {
    const d = t.charCodeAt(n);
    let h = "";
    if (d === 37 && fg(t.charCodeAt(n + 1)) && fg(t.charCodeAt(n + 2)))
      c = 2;
    else if (d < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(d)) || (h = String.fromCharCode(d));
    else if (d > 55295 && d < 57344) {
      const p = t.charCodeAt(n + 1);
      d < 56320 && p > 56319 && p < 57344 ? (h = String.fromCharCode(d, p), c = 1) : h = "";
    } else
      h = String.fromCharCode(d);
    h && (e.push(t.slice(r, n), encodeURIComponent(h)), r = n + c + 1, h = ""), c && (n += c, c = 0);
  }
  return e.join("") + t.slice(r);
}
function jp(t, e) {
  const n = String(e.identifier).toUpperCase(), r = ta(n.toLowerCase()), c = t.footnoteOrder.indexOf(n);
  let d;
  c === -1 ? (t.footnoteOrder.push(n), t.footnoteCounts[n] = 1, d = t.footnoteOrder.length) : (t.footnoteCounts[n]++, d = c + 1);
  const h = t.footnoteCounts[n], p = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + t.clobberPrefix + "fn-" + r,
      id: t.clobberPrefix + "fnref-" + r + (h > 1 ? "-" + h : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(d) }]
  };
  t.patch(e, p);
  const N = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [p]
  };
  return t.patch(e, N), t.applyData(e, N);
}
function OE(t, e) {
  const n = t.footnoteById;
  let r = 1;
  for (; r in n; )
    r++;
  const c = String(r);
  return n[c] = {
    type: "footnoteDefinition",
    identifier: c,
    children: [{ type: "paragraph", children: e.children }],
    position: e.position
  }, jp(t, {
    type: "footnoteReference",
    identifier: c,
    position: e.position
  });
}
function DE(t, e) {
  const n = {
    type: "element",
    tagName: "h" + e.depth,
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function RE(t, e) {
  if (t.dangerous) {
    const n = { type: "raw", value: e.value };
    return t.patch(e, n), t.applyData(e, n);
  }
  return null;
}
function qp(t, e) {
  const n = e.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (e.label || e.identifier) + "]"), e.type === "imageReference")
    return { type: "text", value: "![" + e.alt + r };
  const c = t.all(e), d = c[0];
  d && d.type === "text" ? d.value = "[" + d.value : c.unshift({ type: "text", value: "[" });
  const h = c[c.length - 1];
  return h && h.type === "text" ? h.value += r : c.push({ type: "text", value: r }), c;
}
function bE(t, e) {
  const n = t.definition(e.identifier);
  if (!n)
    return qp(t, e);
  const r = { src: ta(n.url || ""), alt: e.alt };
  n.title !== null && n.title !== void 0 && (r.title = n.title);
  const c = { type: "element", tagName: "img", properties: r, children: [] };
  return t.patch(e, c), t.applyData(e, c);
}
function ME(t, e) {
  const n = { src: ta(e.url) };
  e.alt !== null && e.alt !== void 0 && (n.alt = e.alt), e.title !== null && e.title !== void 0 && (n.title = e.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return t.patch(e, r), t.applyData(e, r);
}
function AE(t, e) {
  const n = { type: "text", value: e.value.replace(/\r?\n|\r/g, " ") };
  t.patch(e, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return t.patch(e, r), t.applyData(e, r);
}
function kE(t, e) {
  const n = t.definition(e.identifier);
  if (!n)
    return qp(t, e);
  const r = { href: ta(n.url || "") };
  n.title !== null && n.title !== void 0 && (r.title = n.title);
  const c = {
    type: "element",
    tagName: "a",
    properties: r,
    children: t.all(e)
  };
  return t.patch(e, c), t.applyData(e, c);
}
function LE(t, e) {
  const n = { href: ta(e.url) };
  e.title !== null && e.title !== void 0 && (n.title = e.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: t.all(e)
  };
  return t.patch(e, r), t.applyData(e, r);
}
function IE(t, e, n) {
  const r = t.all(e), c = n ? PE(n) : Zp(e), d = {}, h = [];
  if (typeof e.checked == "boolean") {
    const v = r[0];
    let O;
    v && v.type === "element" && v.tagName === "p" ? O = v : (O = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(O)), O.children.length > 0 && O.children.unshift({ type: "text", value: " " }), O.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: e.checked, disabled: !0 },
      children: []
    }), d.className = ["task-list-item"];
  }
  let p = -1;
  for (; ++p < r.length; ) {
    const v = r[p];
    (c || p !== 0 || v.type !== "element" || v.tagName !== "p") && h.push({ type: "text", value: `
` }), v.type === "element" && v.tagName === "p" && !c ? h.push(...v.children) : h.push(v);
  }
  const N = r[r.length - 1];
  N && (c || N.type !== "element" || N.tagName !== "p") && h.push({ type: "text", value: `
` });
  const x = { type: "element", tagName: "li", properties: d, children: h };
  return t.patch(e, x), t.applyData(e, x);
}
function PE(t) {
  let e = !1;
  if (t.type === "list") {
    e = t.spread || !1;
    const n = t.children;
    let r = -1;
    for (; !e && ++r < n.length; )
      e = Zp(n[r]);
  }
  return e;
}
function Zp(t) {
  const e = t.spread;
  return e ?? t.children.length > 1;
}
function $E(t, e) {
  const n = {}, r = t.all(e);
  let c = -1;
  for (typeof e.start == "number" && e.start !== 1 && (n.start = e.start); ++c < r.length; ) {
    const h = r[c];
    if (h.type === "element" && h.tagName === "li" && h.properties && Array.isArray(h.properties.className) && h.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const d = {
    type: "element",
    tagName: e.ordered ? "ol" : "ul",
    properties: n,
    children: t.wrap(r, !0)
  };
  return t.patch(e, d), t.applyData(e, d);
}
function FE(t, e) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function BE(t, e) {
  const n = { type: "root", children: t.wrap(t.all(e)) };
  return t.patch(e, n), t.applyData(e, n);
}
function HE(t, e) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
const xd = Jp("start"), vd = Jp("end");
function WE(t) {
  return { start: xd(t), end: vd(t) };
}
function Jp(t) {
  return e;
  function e(n) {
    const r = n && n.position && n.position[t] || {};
    return {
      // @ts-expect-error: in practice, null is allowed.
      line: r.line || null,
      // @ts-expect-error: in practice, null is allowed.
      column: r.column || null,
      // @ts-expect-error: in practice, null is allowed.
      offset: r.offset > -1 ? r.offset : null
    };
  }
}
function KE(t, e) {
  const n = t.all(e), r = n.shift(), c = [];
  if (r) {
    const h = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: t.wrap([r], !0)
    };
    t.patch(e.children[0], h), c.push(h);
  }
  if (n.length > 0) {
    const h = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: t.wrap(n, !0)
    }, p = xd(e.children[1]), N = vd(e.children[e.children.length - 1]);
    p.line && N.line && (h.position = { start: p, end: N }), c.push(h);
  }
  const d = {
    type: "element",
    tagName: "table",
    properties: {},
    children: t.wrap(c, !0)
  };
  return t.patch(e, d), t.applyData(e, d);
}
function UE(t, e, n) {
  const r = n ? n.children : void 0, d = (r ? r.indexOf(e) : 1) === 0 ? "th" : "td", h = n && n.type === "table" ? n.align : void 0, p = h ? h.length : e.children.length;
  let N = -1;
  const x = [];
  for (; ++N < p; ) {
    const O = e.children[N], M = {}, A = h ? h[N] : void 0;
    A && (M.align = A);
    let T = { type: "element", tagName: d, properties: M, children: [] };
    O && (T.children = t.all(O), t.patch(O, T), T = t.applyData(e, T)), x.push(T);
  }
  const v = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: t.wrap(x, !0)
  };
  return t.patch(e, v), t.applyData(e, v);
}
function zE(t, e) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
const gg = 9, pg = 32;
function GE(t) {
  const e = String(t), n = /\r?\n|\r/g;
  let r = n.exec(e), c = 0;
  const d = [];
  for (; r; )
    d.push(
      mg(e.slice(c, r.index), c > 0, !0),
      r[0]
    ), c = r.index + r[0].length, r = n.exec(e);
  return d.push(mg(e.slice(c), c > 0, !1)), d.join("");
}
function mg(t, e, n) {
  let r = 0, c = t.length;
  if (e) {
    let d = t.codePointAt(r);
    for (; d === gg || d === pg; )
      r++, d = t.codePointAt(r);
  }
  if (n) {
    let d = t.codePointAt(c - 1);
    for (; d === gg || d === pg; )
      c--, d = t.codePointAt(c - 1);
  }
  return c > r ? t.slice(r, c) : "";
}
function YE(t, e) {
  const n = { type: "text", value: GE(String(e.value)) };
  return t.patch(e, n), t.applyData(e, n);
}
function VE(t, e) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return t.patch(e, n), t.applyData(e, n);
}
const jE = {
  blockquote: TE,
  break: xE,
  code: vE,
  delete: SE,
  emphasis: wE,
  footnoteReference: jp,
  footnote: OE,
  heading: DE,
  html: RE,
  imageReference: bE,
  image: ME,
  inlineCode: AE,
  linkReference: kE,
  link: LE,
  listItem: IE,
  list: $E,
  paragraph: FE,
  root: BE,
  strong: HE,
  table: KE,
  tableCell: zE,
  tableRow: UE,
  text: YE,
  thematicBreak: VE,
  toml: Za,
  yaml: Za,
  definition: Za,
  footnoteDefinition: Za
};
function Za() {
  return null;
}
const Xp = (
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {AssertAnything}
   */
  function(t) {
    if (t == null)
      return XE;
    if (typeof t == "string")
      return JE(t);
    if (typeof t == "object")
      return Array.isArray(t) ? qE(t) : ZE(t);
    if (typeof t == "function")
      return Cc(t);
    throw new Error("Expected function, string, or object as test");
  }
);
function qE(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e[n] = Xp(t[n]);
  return Cc(r);
  function r(...c) {
    let d = -1;
    for (; ++d < e.length; )
      if (e[d].call(this, ...c))
        return !0;
    return !1;
  }
}
function ZE(t) {
  return Cc(e);
  function e(n) {
    let r;
    for (r in t)
      if (n[r] !== t[r])
        return !1;
    return !0;
  }
}
function JE(t) {
  return Cc(e);
  function e(n) {
    return n && n.type === t;
  }
}
function Cc(t) {
  return e;
  function e(n, ...r) {
    return !!(n && typeof n == "object" && "type" in n && t.call(this, n, ...r));
  }
}
function XE() {
  return !0;
}
const QE = !0, _g = !1, eT = "skip", tT = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor<Node>} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(t, e, n, r) {
    typeof e == "function" && typeof n != "function" && (r = n, n = e, e = null);
    const c = Xp(e), d = r ? -1 : 1;
    h(t, void 0, [])();
    function h(p, N, x) {
      const v = p && typeof p == "object" ? p : {};
      if (typeof v.type == "string") {
        const M = (
          // `hast`
          typeof v.tagName == "string" ? v.tagName : (
            // `xast`
            typeof v.name == "string" ? v.name : void 0
          )
        );
        Object.defineProperty(O, "name", {
          value: "node (" + (p.type + (M ? "<" + M + ">" : "")) + ")"
        });
      }
      return O;
      function O() {
        let M = [], A, T, w;
        if ((!e || c(p, N, x[x.length - 1] || null)) && (M = nT(n(p, x)), M[0] === _g))
          return M;
        if (p.children && M[0] !== eT)
          for (T = (r ? p.children.length : -1) + d, w = x.concat(p); T > -1 && T < p.children.length; ) {
            if (A = h(p.children[T], T, w)(), A[0] === _g)
              return A;
            T = typeof A[1] == "number" ? A[1] : T + d;
          }
        return M;
      }
    }
  }
);
function nT(t) {
  return Array.isArray(t) ? t : typeof t == "number" ? [QE, t] : [t];
}
const Qp = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(t, e, n, r) {
    typeof e == "function" && typeof n != "function" && (r = n, n = e, e = null), tT(t, e, c, r);
    function c(d, h) {
      const p = h[h.length - 1];
      return n(
        d,
        p ? p.children.indexOf(d) : null,
        p
      );
    }
  }
);
function rT(t) {
  return !t || !t.position || !t.position.start || !t.position.start.line || !t.position.start.column || !t.position.end || !t.position.end.line || !t.position.end.column;
}
const yg = {}.hasOwnProperty;
function iT(t) {
  const e = /* @__PURE__ */ Object.create(null);
  if (!t || !t.type)
    throw new Error("mdast-util-definitions expected node");
  return Qp(t, "definition", (r) => {
    const c = Ng(r.identifier);
    c && !yg.call(e, c) && (e[c] = r);
  }), n;
  function n(r) {
    const c = Ng(r);
    return c && yg.call(e, c) ? e[c] : null;
  }
}
function Ng(t) {
  return String(t || "").toUpperCase();
}
const uc = {}.hasOwnProperty;
function TS(t, e) {
  const n = e || {}, r = n.allowDangerousHtml || !1, c = {};
  return h.dangerous = r, h.clobberPrefix = n.clobberPrefix === void 0 || n.clobberPrefix === null ? "user-content-" : n.clobberPrefix, h.footnoteLabel = n.footnoteLabel || "Footnotes", h.footnoteLabelTagName = n.footnoteLabelTagName || "h2", h.footnoteLabelProperties = n.footnoteLabelProperties || {
    className: ["sr-only"]
  }, h.footnoteBackLabel = n.footnoteBackLabel || "Back to content", h.unknownHandler = n.unknownHandler, h.passThrough = n.passThrough, h.handlers = { ...jE, ...n.handlers }, h.definition = iT(t), h.footnoteById = c, h.footnoteOrder = [], h.footnoteCounts = {}, h.patch = oT, h.applyData = sT, h.one = p, h.all = N, h.wrap = aT, h.augment = d, Qp(t, "footnoteDefinition", (x) => {
    const v = String(x.identifier).toUpperCase();
    uc.call(c, v) || (c[v] = x);
  }), h;
  function d(x, v) {
    if (x && "data" in x && x.data) {
      const O = x.data;
      O.hName && (v.type !== "element" && (v = {
        type: "element",
        tagName: "",
        properties: {},
        children: []
      }), v.tagName = O.hName), v.type === "element" && O.hProperties && (v.properties = { ...v.properties, ...O.hProperties }), "children" in v && v.children && O.hChildren && (v.children = O.hChildren);
    }
    if (x) {
      const O = "type" in x ? x : { position: x };
      rT(O) || (v.position = { start: xd(O), end: vd(O) });
    }
    return v;
  }
  function h(x, v, O, M) {
    return Array.isArray(O) && (M = O, O = {}), d(x, {
      type: "element",
      tagName: v,
      properties: O || {},
      children: M || []
    });
  }
  function p(x, v) {
    return em(h, x, v);
  }
  function N(x) {
    return so(h, x);
  }
}
function oT(t, e) {
  t.position && (e.position = WE(t));
}
function sT(t, e) {
  let n = e;
  if (t && t.data) {
    const r = t.data.hName, c = t.data.hChildren, d = t.data.hProperties;
    typeof r == "string" && (n.type === "element" ? n.tagName = r : n = {
      type: "element",
      tagName: r,
      properties: {},
      children: []
    }), n.type === "element" && d && (n.properties = { ...n.properties, ...d }), "children" in n && n.children && c !== null && c !== void 0 && (n.children = c);
  }
  return n;
}
function em(t, e, n) {
  const r = e && e.type;
  if (!r)
    throw new Error("Expected node, got `" + e + "`");
  return uc.call(t.handlers, r) ? t.handlers[r](t, e, n) : t.passThrough && t.passThrough.includes(r) ? "children" in e ? { ...e, children: so(t, e) } : e : t.unknownHandler ? t.unknownHandler(t, e, n) : lT(t, e);
}
function so(t, e) {
  const n = [];
  if ("children" in e) {
    const r = e.children;
    let c = -1;
    for (; ++c < r.length; ) {
      const d = em(t, r[c], e);
      if (d) {
        if (c && r[c - 1].type === "break" && (!Array.isArray(d) && d.type === "text" && (d.value = d.value.replace(/^\s+/, "")), !Array.isArray(d) && d.type === "element")) {
          const h = d.children[0];
          h && h.type === "text" && (h.value = h.value.replace(/^\s+/, ""));
        }
        Array.isArray(d) ? n.push(...d) : n.push(d);
      }
    }
  }
  return n;
}
function lT(t, e) {
  const n = e.data || {}, r = "value" in e && !(uc.call(n, "hProperties") || uc.call(n, "hChildren")) ? { type: "text", value: e.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: so(t, e)
  };
  return t.patch(e, r), t.applyData(e, r);
}
function aT(t, e) {
  const n = [];
  let r = -1;
  for (e && n.push({ type: "text", value: `
` }); ++r < t.length; )
    r && n.push({ type: "text", value: `
` }), n.push(t[r]);
  return e && t.length > 0 && n.push({ type: "text", value: `
` }), n;
}
const cT = (t, e) => t(e, "i", so(t, e)), uT = (t, e) => t(e, "b", so(t, e)), dT = (t, e) => t(e, "u", so(t, e)), fT = (t, e) => t(e, "s", so(t, e)), hT = (t, e) => t(e, "sub", so(t, e)), gT = (t, e) => t(e, "sup", so(t, e)), pT = {
  emphasis: cT,
  strong: uT,
  underline: dT,
  strikethrough: fT,
  subscript: hT,
  superscript: gT
}, xS = (t) => {
  const [e, n] = dr();
  let r;
  return fr(() => {
    (async () => {
      if (!r)
        try {
          r = (await import("./index-2DYallF-.js")).default;
        } catch {
          throw new Error(
            "Failed to import React Markdown, cannot properly render LegacyRichText."
          );
        }
      const d = r({
        children: t.markdown,
        remarkPlugins: [EE],
        remarkRehypeOptions: {
          handlers: pT
        }
      });
      n(d);
    })();
  }, [t.markdown]), e || null;
};
class _s extends Error {
}
class mT extends _s {
  constructor(e) {
    super(`Invalid DateTime: ${e.toMessage()}`);
  }
}
class _T extends _s {
  constructor(e) {
    super(`Invalid Interval: ${e.toMessage()}`);
  }
}
class yT extends _s {
  constructor(e) {
    super(`Invalid Duration: ${e.toMessage()}`);
  }
}
class Js extends _s {
}
class tm extends _s {
  constructor(e) {
    super(`Invalid unit ${e}`);
  }
}
class wr extends _s {
}
class Do extends _s {
  constructor() {
    super("Zone is an abstract class");
  }
}
const rt = "numeric", yi = "short", Pr = "long", dc = {
  year: rt,
  month: rt,
  day: rt
}, nm = {
  year: rt,
  month: yi,
  day: rt
}, NT = {
  year: rt,
  month: yi,
  day: rt,
  weekday: yi
}, rm = {
  year: rt,
  month: Pr,
  day: rt
}, im = {
  year: rt,
  month: Pr,
  day: rt,
  weekday: Pr
}, om = {
  hour: rt,
  minute: rt
}, sm = {
  hour: rt,
  minute: rt,
  second: rt
}, lm = {
  hour: rt,
  minute: rt,
  second: rt,
  timeZoneName: yi
}, am = {
  hour: rt,
  minute: rt,
  second: rt,
  timeZoneName: Pr
}, cm = {
  hour: rt,
  minute: rt,
  hourCycle: "h23"
}, um = {
  hour: rt,
  minute: rt,
  second: rt,
  hourCycle: "h23"
}, dm = {
  hour: rt,
  minute: rt,
  second: rt,
  hourCycle: "h23",
  timeZoneName: yi
}, fm = {
  hour: rt,
  minute: rt,
  second: rt,
  hourCycle: "h23",
  timeZoneName: Pr
}, hm = {
  year: rt,
  month: rt,
  day: rt,
  hour: rt,
  minute: rt
}, gm = {
  year: rt,
  month: rt,
  day: rt,
  hour: rt,
  minute: rt,
  second: rt
}, pm = {
  year: rt,
  month: yi,
  day: rt,
  hour: rt,
  minute: rt
}, mm = {
  year: rt,
  month: yi,
  day: rt,
  hour: rt,
  minute: rt,
  second: rt
}, CT = {
  year: rt,
  month: yi,
  day: rt,
  weekday: yi,
  hour: rt,
  minute: rt
}, _m = {
  year: rt,
  month: Pr,
  day: rt,
  hour: rt,
  minute: rt,
  timeZoneName: yi
}, ym = {
  year: rt,
  month: Pr,
  day: rt,
  hour: rt,
  minute: rt,
  second: rt,
  timeZoneName: yi
}, Nm = {
  year: rt,
  month: Pr,
  day: rt,
  weekday: Pr,
  hour: rt,
  minute: rt,
  timeZoneName: Pr
}, Cm = {
  year: rt,
  month: Pr,
  day: rt,
  weekday: Pr,
  hour: rt,
  minute: rt,
  second: rt,
  timeZoneName: Pr
};
class na {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new Do();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new Do();
  }
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new Do();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(e, n) {
    throw new Do();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(e, n) {
    throw new Do();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(e) {
    throw new Do();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(e) {
    throw new Do();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new Do();
  }
}
let Lu = null;
class Ec extends na {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    return Lu === null && (Lu = new Ec()), Lu;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName(e, { format: n, locale: r }) {
    return Rm(e, n, r);
  }
  /** @override **/
  formatOffset(e, n) {
    return Jl(this.offset(e), n);
  }
  /** @override **/
  offset(e) {
    return -new Date(e).getTimezoneOffset();
  }
  /** @override **/
  equals(e) {
    return e.type === "system";
  }
  /** @override **/
  get isValid() {
    return !0;
  }
}
let oc = {};
function ET(t) {
  return oc[t] || (oc[t] = new Intl.DateTimeFormat("en-US", {
    hour12: !1,
    timeZone: t,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    era: "short"
  })), oc[t];
}
const TT = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function xT(t, e) {
  const n = t.format(e).replace(/\u200E/g, ""), r = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(n), [, c, d, h, p, N, x, v] = r;
  return [h, c, d, p, N, x, v];
}
function vT(t, e) {
  const n = t.formatToParts(e), r = [];
  for (let c = 0; c < n.length; c++) {
    const { type: d, value: h } = n[c], p = TT[d];
    d === "era" ? r[p] = h : At(p) || (r[p] = parseInt(h, 10));
  }
  return r;
}
let Ja = {};
class oo extends na {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(e) {
    return Ja[e] || (Ja[e] = new oo(e)), Ja[e];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    Ja = {}, oc = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(e) {
    return this.isValidZone(e);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(e) {
    if (!e)
      return !1;
    try {
      return new Intl.DateTimeFormat("en-US", { timeZone: e }).format(), !0;
    } catch {
      return !1;
    }
  }
  constructor(e) {
    super(), this.zoneName = e, this.valid = oo.isValidZone(e);
  }
  /** @override **/
  get type() {
    return "iana";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName(e, { format: n, locale: r }) {
    return Rm(e, n, r, this.name);
  }
  /** @override **/
  formatOffset(e, n) {
    return Jl(this.offset(e), n);
  }
  /** @override **/
  offset(e) {
    const n = new Date(e);
    if (isNaN(n))
      return NaN;
    const r = ET(this.name);
    let [c, d, h, p, N, x, v] = r.formatToParts ? vT(r, n) : xT(r, n);
    p === "BC" && (c = -Math.abs(c) + 1);
    const M = xc({
      year: c,
      month: d,
      day: h,
      hour: N === 24 ? 0 : N,
      minute: x,
      second: v,
      millisecond: 0
    });
    let A = +n;
    const T = A % 1e3;
    return A -= T >= 0 ? T : 1e3 + T, (M - A) / (60 * 1e3);
  }
  /** @override **/
  equals(e) {
    return e.type === "iana" && e.name === this.name;
  }
  /** @override **/
  get isValid() {
    return this.valid;
  }
}
let Cg = {};
function ST(t, e = {}) {
  const n = JSON.stringify([t, e]);
  let r = Cg[n];
  return r || (r = new Intl.ListFormat(t, e), Cg[n] = r), r;
}
let Ju = {};
function Xu(t, e = {}) {
  const n = JSON.stringify([t, e]);
  let r = Ju[n];
  return r || (r = new Intl.DateTimeFormat(t, e), Ju[n] = r), r;
}
let Qu = {};
function wT(t, e = {}) {
  const n = JSON.stringify([t, e]);
  let r = Qu[n];
  return r || (r = new Intl.NumberFormat(t, e), Qu[n] = r), r;
}
let ed = {};
function OT(t, e = {}) {
  const { base: n, ...r } = e, c = JSON.stringify([t, r]);
  let d = ed[c];
  return d || (d = new Intl.RelativeTimeFormat(t, e), ed[c] = d), d;
}
let jl = null;
function DT() {
  return jl || (jl = new Intl.DateTimeFormat().resolvedOptions().locale, jl);
}
let Eg = {};
function RT(t) {
  let e = Eg[t];
  if (!e) {
    const n = new Intl.Locale(t);
    e = "getWeekInfo" in n ? n.getWeekInfo() : n.weekInfo, Eg[t] = e;
  }
  return e;
}
function bT(t) {
  const e = t.indexOf("-x-");
  e !== -1 && (t = t.substring(0, e));
  const n = t.indexOf("-u-");
  if (n === -1)
    return [t];
  {
    let r, c;
    try {
      r = Xu(t).resolvedOptions(), c = t;
    } catch {
      const N = t.substring(0, n);
      r = Xu(N).resolvedOptions(), c = N;
    }
    const { numberingSystem: d, calendar: h } = r;
    return [c, d, h];
  }
}
function MT(t, e, n) {
  return (n || e) && (t.includes("-u-") || (t += "-u"), n && (t += `-ca-${n}`), e && (t += `-nu-${e}`)), t;
}
function AT(t) {
  const e = [];
  for (let n = 1; n <= 12; n++) {
    const r = Ot.utc(2009, n, 1);
    e.push(t(r));
  }
  return e;
}
function kT(t) {
  const e = [];
  for (let n = 1; n <= 7; n++) {
    const r = Ot.utc(2016, 11, 13 + n);
    e.push(t(r));
  }
  return e;
}
function Xa(t, e, n, r) {
  const c = t.listingMode();
  return c === "error" ? null : c === "en" ? n(e) : r(e);
}
function LT(t) {
  return t.numberingSystem && t.numberingSystem !== "latn" ? !1 : t.numberingSystem === "latn" || !t.locale || t.locale.startsWith("en") || new Intl.DateTimeFormat(t.intl).resolvedOptions().numberingSystem === "latn";
}
class IT {
  constructor(e, n, r) {
    this.padTo = r.padTo || 0, this.floor = r.floor || !1;
    const { padTo: c, floor: d, ...h } = r;
    if (!n || Object.keys(h).length > 0) {
      const p = { useGrouping: !1, ...r };
      r.padTo > 0 && (p.minimumIntegerDigits = r.padTo), this.inf = wT(e, p);
    }
  }
  format(e) {
    if (this.inf) {
      const n = this.floor ? Math.floor(e) : e;
      return this.inf.format(n);
    } else {
      const n = this.floor ? Math.floor(e) : Dd(e, 3);
      return Fn(n, this.padTo);
    }
  }
}
class PT {
  constructor(e, n, r) {
    this.opts = r, this.originalZone = void 0;
    let c;
    if (this.opts.timeZone)
      this.dt = e;
    else if (e.zone.type === "fixed") {
      const h = -1 * (e.offset / 60), p = h >= 0 ? `Etc/GMT+${h}` : `Etc/GMT${h}`;
      e.offset !== 0 && oo.create(p).valid ? (c = p, this.dt = e) : (c = "UTC", this.dt = e.offset === 0 ? e : e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
    } else
      e.zone.type === "system" ? this.dt = e : e.zone.type === "iana" ? (this.dt = e, c = e.zone.name) : (c = "UTC", this.dt = e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
    const d = { ...this.opts };
    d.timeZone = d.timeZone || c, this.dtf = Xu(n, d);
  }
  format() {
    return this.originalZone ? this.formatToParts().map(({ value: e }) => e).join("") : this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const e = this.dtf.formatToParts(this.dt.toJSDate());
    return this.originalZone ? e.map((n) => {
      if (n.type === "timeZoneName") {
        const r = this.originalZone.offsetName(this.dt.ts, {
          locale: this.dt.locale,
          format: this.opts.timeZoneName
        });
        return {
          ...n,
          value: r
        };
      } else
        return n;
    }) : e;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class $T {
  constructor(e, n, r) {
    this.opts = { style: "long", ...r }, !n && Om() && (this.rtf = OT(e, r));
  }
  format(e, n) {
    return this.rtf ? this.rtf.format(e, n) : rx(n, e, this.opts.numeric, this.opts.style !== "long");
  }
  formatToParts(e, n) {
    return this.rtf ? this.rtf.formatToParts(e, n) : [];
  }
}
const FT = {
  firstDay: 1,
  minimalDays: 4,
  weekend: [6, 7]
};
class Qt {
  static fromOpts(e) {
    return Qt.create(
      e.locale,
      e.numberingSystem,
      e.outputCalendar,
      e.weekSettings,
      e.defaultToEN
    );
  }
  static create(e, n, r, c, d = !1) {
    const h = e || kn.defaultLocale, p = h || (d ? "en-US" : DT()), N = n || kn.defaultNumberingSystem, x = r || kn.defaultOutputCalendar, v = td(c) || kn.defaultWeekSettings;
    return new Qt(p, N, x, v, h);
  }
  static resetCache() {
    jl = null, Ju = {}, Qu = {}, ed = {};
  }
  static fromObject({ locale: e, numberingSystem: n, outputCalendar: r, weekSettings: c } = {}) {
    return Qt.create(e, n, r, c);
  }
  constructor(e, n, r, c, d) {
    const [h, p, N] = bT(e);
    this.locale = h, this.numberingSystem = n || p || null, this.outputCalendar = r || N || null, this.weekSettings = c, this.intl = MT(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = { format: {}, standalone: {} }, this.monthsCache = { format: {}, standalone: {} }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = d, this.fastNumbersCached = null;
  }
  get fastNumbers() {
    return this.fastNumbersCached == null && (this.fastNumbersCached = LT(this)), this.fastNumbersCached;
  }
  listingMode() {
    const e = this.isEnglish(), n = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return e && n ? "en" : "intl";
  }
  clone(e) {
    return !e || Object.getOwnPropertyNames(e).length === 0 ? this : Qt.create(
      e.locale || this.specifiedLocale,
      e.numberingSystem || this.numberingSystem,
      e.outputCalendar || this.outputCalendar,
      td(e.weekSettings) || this.weekSettings,
      e.defaultToEN || !1
    );
  }
  redefaultToEN(e = {}) {
    return this.clone({ ...e, defaultToEN: !0 });
  }
  redefaultToSystem(e = {}) {
    return this.clone({ ...e, defaultToEN: !1 });
  }
  months(e, n = !1) {
    return Xa(this, e, Am, () => {
      const r = n ? { month: e, day: "numeric" } : { month: e }, c = n ? "format" : "standalone";
      return this.monthsCache[c][e] || (this.monthsCache[c][e] = AT((d) => this.extract(d, r, "month"))), this.monthsCache[c][e];
    });
  }
  weekdays(e, n = !1) {
    return Xa(this, e, Im, () => {
      const r = n ? { weekday: e, year: "numeric", month: "long", day: "numeric" } : { weekday: e }, c = n ? "format" : "standalone";
      return this.weekdaysCache[c][e] || (this.weekdaysCache[c][e] = kT(
        (d) => this.extract(d, r, "weekday")
      )), this.weekdaysCache[c][e];
    });
  }
  meridiems() {
    return Xa(
      this,
      void 0,
      () => Pm,
      () => {
        if (!this.meridiemCache) {
          const e = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [Ot.utc(2016, 11, 13, 9), Ot.utc(2016, 11, 13, 19)].map(
            (n) => this.extract(n, e, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(e) {
    return Xa(this, e, $m, () => {
      const n = { era: e };
      return this.eraCache[e] || (this.eraCache[e] = [Ot.utc(-40, 1, 1), Ot.utc(2017, 1, 1)].map(
        (r) => this.extract(r, n, "era")
      )), this.eraCache[e];
    });
  }
  extract(e, n, r) {
    const c = this.dtFormatter(e, n), d = c.formatToParts(), h = d.find((p) => p.type.toLowerCase() === r);
    return h ? h.value : null;
  }
  numberFormatter(e = {}) {
    return new IT(this.intl, e.forceSimple || this.fastNumbers, e);
  }
  dtFormatter(e, n = {}) {
    return new PT(e, this.intl, n);
  }
  relFormatter(e = {}) {
    return new $T(this.intl, this.isEnglish(), e);
  }
  listFormatter(e = {}) {
    return ST(this.intl, e);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  getWeekSettings() {
    return this.weekSettings ? this.weekSettings : Dm() ? RT(this.locale) : FT;
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(e) {
    return this.locale === e.locale && this.numberingSystem === e.numberingSystem && this.outputCalendar === e.outputCalendar;
  }
}
let Iu = null;
class hr extends na {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    return Iu === null && (Iu = new hr(0)), Iu;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(e) {
    return e === 0 ? hr.utcInstance : new hr(e);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(e) {
    if (e) {
      const n = e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (n)
        return new hr(vc(n[1], n[2]));
    }
    return null;
  }
  constructor(e) {
    super(), this.fixed = e;
  }
  /** @override **/
  get type() {
    return "fixed";
  }
  /** @override **/
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${Jl(this.fixed, "narrow")}`;
  }
  get ianaName() {
    return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${Jl(-this.fixed, "narrow")}`;
  }
  /** @override **/
  offsetName() {
    return this.name;
  }
  /** @override **/
  formatOffset(e, n) {
    return Jl(this.fixed, n);
  }
  /** @override **/
  get isUniversal() {
    return !0;
  }
  /** @override **/
  offset() {
    return this.fixed;
  }
  /** @override **/
  equals(e) {
    return e.type === "fixed" && e.fixed === this.fixed;
  }
  /** @override **/
  get isValid() {
    return !0;
  }
}
class BT extends na {
  constructor(e) {
    super(), this.zoneName = e;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return !1;
  }
  /** @override **/
  get isValid() {
    return !1;
  }
}
function Mo(t, e) {
  if (At(t) || t === null)
    return e;
  if (t instanceof na)
    return t;
  if (KT(t)) {
    const n = t.toLowerCase();
    return n === "default" ? e : n === "local" || n === "system" ? Ec.instance : n === "utc" || n === "gmt" ? hr.utcInstance : hr.parseSpecifier(n) || oo.create(t);
  } else
    return hs(t) ? hr.instance(t) : typeof t == "object" && "offset" in t && typeof t.offset == "function" ? t : new BT(t);
}
let Tg = () => Date.now(), xg = "system", vg = null, Sg = null, wg = null, Og = 60, Dg, Rg = null;
class kn {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return Tg;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(e) {
    Tg = e;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(e) {
    xg = e;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return Mo(xg, Ec.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return vg;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(e) {
    vg = e;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return Sg;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(e) {
    Sg = e;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return wg;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(e) {
    wg = e;
  }
  /**
   * @typedef {Object} WeekSettings
   * @property {number} firstDay
   * @property {number} minimalDays
   * @property {number[]} weekend
   */
  /**
   * @return {WeekSettings|null}
   */
  static get defaultWeekSettings() {
    return Rg;
  }
  /**
   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
   * how many days are required in the first week of a year.
   * Does not affect existing instances.
   *
   * @param {WeekSettings|null} weekSettings
   */
  static set defaultWeekSettings(e) {
    Rg = td(e);
  }
  /**
   * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return Og;
  }
  /**
   * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpreted as current century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(e) {
    Og = e % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return Dg;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(e) {
    Dg = e;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Qt.resetCache(), oo.resetCache();
  }
}
class _i {
  constructor(e, n) {
    this.reason = e, this.explanation = n;
  }
  toMessage() {
    return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason;
  }
}
const Em = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], Tm = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function Jr(t, e) {
  return new _i(
    "unit out of range",
    `you specified ${e} (of type ${typeof e}) as a ${t}, which is invalid`
  );
}
function Sd(t, e, n) {
  const r = new Date(Date.UTC(t, e - 1, n));
  t < 100 && t >= 0 && r.setUTCFullYear(r.getUTCFullYear() - 1900);
  const c = r.getUTCDay();
  return c === 0 ? 7 : c;
}
function xm(t, e, n) {
  return n + (ra(t) ? Tm : Em)[e - 1];
}
function vm(t, e) {
  const n = ra(t) ? Tm : Em, r = n.findIndex((d) => d < e), c = e - n[r];
  return { month: r + 1, day: c };
}
function wd(t, e) {
  return (t - e + 7) % 7 + 1;
}
function fc(t, e = 4, n = 1) {
  const { year: r, month: c, day: d } = t, h = xm(r, c, d), p = wd(Sd(r, c, d), n);
  let N = Math.floor((h - p + 14 - e) / 7), x;
  return N < 1 ? (x = r - 1, N = ea(x, e, n)) : N > ea(r, e, n) ? (x = r + 1, N = 1) : x = r, { weekYear: x, weekNumber: N, weekday: p, ...Sc(t) };
}
function bg(t, e = 4, n = 1) {
  const { weekYear: r, weekNumber: c, weekday: d } = t, h = wd(Sd(r, 1, e), n), p = Xs(r);
  let N = c * 7 + d - h - 7 + e, x;
  N < 1 ? (x = r - 1, N += Xs(x)) : N > p ? (x = r + 1, N -= Xs(r)) : x = r;
  const { month: v, day: O } = vm(x, N);
  return { year: x, month: v, day: O, ...Sc(t) };
}
function Pu(t) {
  const { year: e, month: n, day: r } = t, c = xm(e, n, r);
  return { year: e, ordinal: c, ...Sc(t) };
}
function Mg(t) {
  const { year: e, ordinal: n } = t, { month: r, day: c } = vm(e, n);
  return { year: e, month: r, day: c, ...Sc(t) };
}
function Ag(t, e) {
  if (!At(t.localWeekday) || !At(t.localWeekNumber) || !At(t.localWeekYear)) {
    if (!At(t.weekday) || !At(t.weekNumber) || !At(t.weekYear))
      throw new Js(
        "Cannot mix locale-based week fields with ISO-based week fields"
      );
    return At(t.localWeekday) || (t.weekday = t.localWeekday), At(t.localWeekNumber) || (t.weekNumber = t.localWeekNumber), At(t.localWeekYear) || (t.weekYear = t.localWeekYear), delete t.localWeekday, delete t.localWeekNumber, delete t.localWeekYear, {
      minDaysInFirstWeek: e.getMinDaysInFirstWeek(),
      startOfWeek: e.getStartOfWeek()
    };
  } else
    return { minDaysInFirstWeek: 4, startOfWeek: 1 };
}
function HT(t, e = 4, n = 1) {
  const r = Tc(t.weekYear), c = Xr(
    t.weekNumber,
    1,
    ea(t.weekYear, e, n)
  ), d = Xr(t.weekday, 1, 7);
  return r ? c ? d ? !1 : Jr("weekday", t.weekday) : Jr("week", t.weekNumber) : Jr("weekYear", t.weekYear);
}
function WT(t) {
  const e = Tc(t.year), n = Xr(t.ordinal, 1, Xs(t.year));
  return e ? n ? !1 : Jr("ordinal", t.ordinal) : Jr("year", t.year);
}
function Sm(t) {
  const e = Tc(t.year), n = Xr(t.month, 1, 12), r = Xr(t.day, 1, hc(t.year, t.month));
  return e ? n ? r ? !1 : Jr("day", t.day) : Jr("month", t.month) : Jr("year", t.year);
}
function wm(t) {
  const { hour: e, minute: n, second: r, millisecond: c } = t, d = Xr(e, 0, 23) || e === 24 && n === 0 && r === 0 && c === 0, h = Xr(n, 0, 59), p = Xr(r, 0, 59), N = Xr(c, 0, 999);
  return d ? h ? p ? N ? !1 : Jr("millisecond", c) : Jr("second", r) : Jr("minute", n) : Jr("hour", e);
}
function At(t) {
  return typeof t > "u";
}
function hs(t) {
  return typeof t == "number";
}
function Tc(t) {
  return typeof t == "number" && t % 1 === 0;
}
function KT(t) {
  return typeof t == "string";
}
function UT(t) {
  return Object.prototype.toString.call(t) === "[object Date]";
}
function Om() {
  try {
    return typeof Intl < "u" && !!Intl.RelativeTimeFormat;
  } catch {
    return !1;
  }
}
function Dm() {
  try {
    return typeof Intl < "u" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
  } catch {
    return !1;
  }
}
function zT(t) {
  return Array.isArray(t) ? t : [t];
}
function kg(t, e, n) {
  if (t.length !== 0)
    return t.reduce((r, c) => {
      const d = [e(c), c];
      return r && n(r[0], d[0]) === r[0] ? r : d;
    }, null)[1];
}
function GT(t, e) {
  return e.reduce((n, r) => (n[r] = t[r], n), {});
}
function tl(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function td(t) {
  if (t == null)
    return null;
  if (typeof t != "object")
    throw new wr("Week settings must be an object");
  if (!Xr(t.firstDay, 1, 7) || !Xr(t.minimalDays, 1, 7) || !Array.isArray(t.weekend) || t.weekend.some((e) => !Xr(e, 1, 7)))
    throw new wr("Invalid week settings");
  return {
    firstDay: t.firstDay,
    minimalDays: t.minimalDays,
    weekend: Array.from(t.weekend)
  };
}
function Xr(t, e, n) {
  return Tc(t) && t >= e && t <= n;
}
function YT(t, e) {
  return t - e * Math.floor(t / e);
}
function Fn(t, e = 2) {
  const n = t < 0;
  let r;
  return n ? r = "-" + ("" + -t).padStart(e, "0") : r = ("" + t).padStart(e, "0"), r;
}
function bo(t) {
  if (!(At(t) || t === null || t === ""))
    return parseInt(t, 10);
}
function ss(t) {
  if (!(At(t) || t === null || t === ""))
    return parseFloat(t);
}
function Od(t) {
  if (!(At(t) || t === null || t === "")) {
    const e = parseFloat("0." + t) * 1e3;
    return Math.floor(e);
  }
}
function Dd(t, e, n = !1) {
  const r = 10 ** e;
  return (n ? Math.trunc : Math.round)(t * r) / r;
}
function ra(t) {
  return t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0);
}
function Xs(t) {
  return ra(t) ? 366 : 365;
}
function hc(t, e) {
  const n = YT(e - 1, 12) + 1, r = t + (e - n) / 12;
  return n === 2 ? ra(r) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][n - 1];
}
function xc(t) {
  let e = Date.UTC(
    t.year,
    t.month - 1,
    t.day,
    t.hour,
    t.minute,
    t.second,
    t.millisecond
  );
  return t.year < 100 && t.year >= 0 && (e = new Date(e), e.setUTCFullYear(t.year, t.month - 1, t.day)), +e;
}
function Lg(t, e, n) {
  return -wd(Sd(t, 1, e), n) + e - 1;
}
function ea(t, e = 4, n = 1) {
  const r = Lg(t, e, n), c = Lg(t + 1, e, n);
  return (Xs(t) - r + c) / 7;
}
function nd(t) {
  return t > 99 ? t : t > kn.twoDigitCutoffYear ? 1900 + t : 2e3 + t;
}
function Rm(t, e, n, r = null) {
  const c = new Date(t), d = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  r && (d.timeZone = r);
  const h = { timeZoneName: e, ...d }, p = new Intl.DateTimeFormat(n, h).formatToParts(c).find((N) => N.type.toLowerCase() === "timezonename");
  return p ? p.value : null;
}
function vc(t, e) {
  let n = parseInt(t, 10);
  Number.isNaN(n) && (n = 0);
  const r = parseInt(e, 10) || 0, c = n < 0 || Object.is(n, -0) ? -r : r;
  return n * 60 + c;
}
function bm(t) {
  const e = Number(t);
  if (typeof t == "boolean" || t === "" || Number.isNaN(e))
    throw new wr(`Invalid unit value ${t}`);
  return e;
}
function gc(t, e) {
  const n = {};
  for (const r in t)
    if (tl(t, r)) {
      const c = t[r];
      if (c == null)
        continue;
      n[e(r)] = bm(c);
    }
  return n;
}
function Jl(t, e) {
  const n = Math.trunc(Math.abs(t / 60)), r = Math.trunc(Math.abs(t % 60)), c = t >= 0 ? "+" : "-";
  switch (e) {
    case "short":
      return `${c}${Fn(n, 2)}:${Fn(r, 2)}`;
    case "narrow":
      return `${c}${n}${r > 0 ? `:${r}` : ""}`;
    case "techie":
      return `${c}${Fn(n, 2)}${Fn(r, 2)}`;
    default:
      throw new RangeError(`Value format ${e} is out of range for property format`);
  }
}
function Sc(t) {
  return GT(t, ["hour", "minute", "second", "millisecond"]);
}
const VT = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
], Mm = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
], jT = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function Am(t) {
  switch (t) {
    case "narrow":
      return [...jT];
    case "short":
      return [...Mm];
    case "long":
      return [...VT];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const km = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
], Lm = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], qT = ["M", "T", "W", "T", "F", "S", "S"];
function Im(t) {
  switch (t) {
    case "narrow":
      return [...qT];
    case "short":
      return [...Lm];
    case "long":
      return [...km];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const Pm = ["AM", "PM"], ZT = ["Before Christ", "Anno Domini"], JT = ["BC", "AD"], XT = ["B", "A"];
function $m(t) {
  switch (t) {
    case "narrow":
      return [...XT];
    case "short":
      return [...JT];
    case "long":
      return [...ZT];
    default:
      return null;
  }
}
function QT(t) {
  return Pm[t.hour < 12 ? 0 : 1];
}
function ex(t, e) {
  return Im(e)[t.weekday - 1];
}
function tx(t, e) {
  return Am(e)[t.month - 1];
}
function nx(t, e) {
  return $m(e)[t.year < 0 ? 0 : 1];
}
function rx(t, e, n = "always", r = !1) {
  const c = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  }, d = ["hours", "minutes", "seconds"].indexOf(t) === -1;
  if (n === "auto" && d) {
    const O = t === "days";
    switch (e) {
      case 1:
        return O ? "tomorrow" : `next ${c[t][0]}`;
      case -1:
        return O ? "yesterday" : `last ${c[t][0]}`;
      case 0:
        return O ? "today" : `this ${c[t][0]}`;
    }
  }
  const h = Object.is(e, -0) || e < 0, p = Math.abs(e), N = p === 1, x = c[t], v = r ? N ? x[1] : x[2] || x[1] : N ? c[t][0] : t;
  return h ? `${p} ${v} ago` : `in ${p} ${v}`;
}
function Ig(t, e) {
  let n = "";
  for (const r of t)
    r.literal ? n += r.val : n += e(r.val);
  return n;
}
const ix = {
  D: dc,
  DD: nm,
  DDD: rm,
  DDDD: im,
  t: om,
  tt: sm,
  ttt: lm,
  tttt: am,
  T: cm,
  TT: um,
  TTT: dm,
  TTTT: fm,
  f: hm,
  ff: pm,
  fff: _m,
  ffff: Nm,
  F: gm,
  FF: mm,
  FFF: ym,
  FFFF: Cm
};
class sr {
  static create(e, n = {}) {
    return new sr(e, n);
  }
  static parseFormat(e) {
    let n = null, r = "", c = !1;
    const d = [];
    for (let h = 0; h < e.length; h++) {
      const p = e.charAt(h);
      p === "'" ? (r.length > 0 && d.push({ literal: c || /^\s+$/.test(r), val: r }), n = null, r = "", c = !c) : c || p === n ? r += p : (r.length > 0 && d.push({ literal: /^\s+$/.test(r), val: r }), r = p, n = p);
    }
    return r.length > 0 && d.push({ literal: c || /^\s+$/.test(r), val: r }), d;
  }
  static macroTokenToFormatOpts(e) {
    return ix[e];
  }
  constructor(e, n) {
    this.opts = n, this.loc = e, this.systemLoc = null;
  }
  formatWithSystemDefault(e, n) {
    return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(e, { ...this.opts, ...n }).format();
  }
  dtFormatter(e, n = {}) {
    return this.loc.dtFormatter(e, { ...this.opts, ...n });
  }
  formatDateTime(e, n) {
    return this.dtFormatter(e, n).format();
  }
  formatDateTimeParts(e, n) {
    return this.dtFormatter(e, n).formatToParts();
  }
  formatInterval(e, n) {
    return this.dtFormatter(e.start, n).dtf.formatRange(e.start.toJSDate(), e.end.toJSDate());
  }
  resolvedOptions(e, n) {
    return this.dtFormatter(e, n).resolvedOptions();
  }
  num(e, n = 0) {
    if (this.opts.forceSimple)
      return Fn(e, n);
    const r = { ...this.opts };
    return n > 0 && (r.padTo = n), this.loc.numberFormatter(r).format(e);
  }
  formatDateTimeFromString(e, n) {
    const r = this.loc.listingMode() === "en", c = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", d = (A, T) => this.loc.extract(e, A, T), h = (A) => e.isOffsetFixed && e.offset === 0 && A.allowZ ? "Z" : e.isValid ? e.zone.formatOffset(e.ts, A.format) : "", p = () => r ? QT(e) : d({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), N = (A, T) => r ? tx(e, A) : d(T ? { month: A } : { month: A, day: "numeric" }, "month"), x = (A, T) => r ? ex(e, A) : d(
      T ? { weekday: A } : { weekday: A, month: "long", day: "numeric" },
      "weekday"
    ), v = (A) => {
      const T = sr.macroTokenToFormatOpts(A);
      return T ? this.formatWithSystemDefault(e, T) : A;
    }, O = (A) => r ? nx(e, A) : d({ era: A }, "era"), M = (A) => {
      switch (A) {
        case "S":
          return this.num(e.millisecond);
        case "u":
        case "SSS":
          return this.num(e.millisecond, 3);
        case "s":
          return this.num(e.second);
        case "ss":
          return this.num(e.second, 2);
        case "uu":
          return this.num(Math.floor(e.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(e.millisecond / 100));
        case "m":
          return this.num(e.minute);
        case "mm":
          return this.num(e.minute, 2);
        case "h":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12);
        case "hh":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12, 2);
        case "H":
          return this.num(e.hour);
        case "HH":
          return this.num(e.hour, 2);
        case "Z":
          return h({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return h({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return h({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return e.zone.offsetName(e.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return e.zone.offsetName(e.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return e.zoneName;
        case "a":
          return p();
        case "d":
          return c ? d({ day: "numeric" }, "day") : this.num(e.day);
        case "dd":
          return c ? d({ day: "2-digit" }, "day") : this.num(e.day, 2);
        case "c":
          return this.num(e.weekday);
        case "ccc":
          return x("short", !0);
        case "cccc":
          return x("long", !0);
        case "ccccc":
          return x("narrow", !0);
        case "E":
          return this.num(e.weekday);
        case "EEE":
          return x("short", !1);
        case "EEEE":
          return x("long", !1);
        case "EEEEE":
          return x("narrow", !1);
        case "L":
          return c ? d({ month: "numeric", day: "numeric" }, "month") : this.num(e.month);
        case "LL":
          return c ? d({ month: "2-digit", day: "numeric" }, "month") : this.num(e.month, 2);
        case "LLL":
          return N("short", !0);
        case "LLLL":
          return N("long", !0);
        case "LLLLL":
          return N("narrow", !0);
        case "M":
          return c ? d({ month: "numeric" }, "month") : this.num(e.month);
        case "MM":
          return c ? d({ month: "2-digit" }, "month") : this.num(e.month, 2);
        case "MMM":
          return N("short", !1);
        case "MMMM":
          return N("long", !1);
        case "MMMMM":
          return N("narrow", !1);
        case "y":
          return c ? d({ year: "numeric" }, "year") : this.num(e.year);
        case "yy":
          return c ? d({ year: "2-digit" }, "year") : this.num(e.year.toString().slice(-2), 2);
        case "yyyy":
          return c ? d({ year: "numeric" }, "year") : this.num(e.year, 4);
        case "yyyyyy":
          return c ? d({ year: "numeric" }, "year") : this.num(e.year, 6);
        case "G":
          return O("short");
        case "GG":
          return O("long");
        case "GGGGG":
          return O("narrow");
        case "kk":
          return this.num(e.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(e.weekYear, 4);
        case "W":
          return this.num(e.weekNumber);
        case "WW":
          return this.num(e.weekNumber, 2);
        case "n":
          return this.num(e.localWeekNumber);
        case "nn":
          return this.num(e.localWeekNumber, 2);
        case "ii":
          return this.num(e.localWeekYear.toString().slice(-2), 2);
        case "iiii":
          return this.num(e.localWeekYear, 4);
        case "o":
          return this.num(e.ordinal);
        case "ooo":
          return this.num(e.ordinal, 3);
        case "q":
          return this.num(e.quarter);
        case "qq":
          return this.num(e.quarter, 2);
        case "X":
          return this.num(Math.floor(e.ts / 1e3));
        case "x":
          return this.num(e.ts);
        default:
          return v(A);
      }
    };
    return Ig(sr.parseFormat(n), M);
  }
  formatDurationFromString(e, n) {
    const r = (N) => {
      switch (N[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, c = (N) => (x) => {
      const v = r(x);
      return v ? this.num(N.get(v), x.length) : x;
    }, d = sr.parseFormat(n), h = d.reduce(
      (N, { literal: x, val: v }) => x ? N : N.concat(v),
      []
    ), p = e.shiftTo(...h.map(r).filter((N) => N));
    return Ig(d, c(p));
  }
}
const Fm = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function sl(...t) {
  const e = t.reduce((n, r) => n + r.source, "");
  return RegExp(`^${e}$`);
}
function ll(...t) {
  return (e) => t.reduce(
    ([n, r, c], d) => {
      const [h, p, N] = d(e, c);
      return [{ ...n, ...h }, p || r, N];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function al(t, ...e) {
  if (t == null)
    return [null, null];
  for (const [n, r] of e) {
    const c = n.exec(t);
    if (c)
      return r(c);
  }
  return [null, null];
}
function Bm(...t) {
  return (e, n) => {
    const r = {};
    let c;
    for (c = 0; c < t.length; c++)
      r[t[c]] = bo(e[n + c]);
    return [r, null, n + c];
  };
}
const Hm = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, ox = `(?:${Hm.source}?(?:\\[(${Fm.source})\\])?)?`, Rd = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, Wm = RegExp(`${Rd.source}${ox}`), bd = RegExp(`(?:T${Wm.source})?`), sx = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, lx = /(\d{4})-?W(\d\d)(?:-?(\d))?/, ax = /(\d{4})-?(\d{3})/, cx = Bm("weekYear", "weekNumber", "weekDay"), ux = Bm("year", "ordinal"), dx = /(\d{4})-(\d\d)-(\d\d)/, Km = RegExp(
  `${Rd.source} ?(?:${Hm.source}|(${Fm.source}))?`
), fx = RegExp(`(?: ${Km.source})?`);
function Qs(t, e, n) {
  const r = t[e];
  return At(r) ? n : bo(r);
}
function hx(t, e) {
  return [{
    year: Qs(t, e),
    month: Qs(t, e + 1, 1),
    day: Qs(t, e + 2, 1)
  }, null, e + 3];
}
function cl(t, e) {
  return [{
    hours: Qs(t, e, 0),
    minutes: Qs(t, e + 1, 0),
    seconds: Qs(t, e + 2, 0),
    milliseconds: Od(t[e + 3])
  }, null, e + 4];
}
function ia(t, e) {
  const n = !t[e] && !t[e + 1], r = vc(t[e + 1], t[e + 2]), c = n ? null : hr.instance(r);
  return [{}, c, e + 3];
}
function oa(t, e) {
  const n = t[e] ? oo.create(t[e]) : null;
  return [{}, n, e + 1];
}
const gx = RegExp(`^T?${Rd.source}$`), px = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function mx(t) {
  const [e, n, r, c, d, h, p, N, x] = t, v = e[0] === "-", O = N && N[0] === "-", M = (A, T = !1) => A !== void 0 && (T || A && v) ? -A : A;
  return [
    {
      years: M(ss(n)),
      months: M(ss(r)),
      weeks: M(ss(c)),
      days: M(ss(d)),
      hours: M(ss(h)),
      minutes: M(ss(p)),
      seconds: M(ss(N), N === "-0"),
      milliseconds: M(Od(x), O)
    }
  ];
}
const _x = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function Md(t, e, n, r, c, d, h) {
  const p = {
    year: e.length === 2 ? nd(bo(e)) : bo(e),
    month: Mm.indexOf(n) + 1,
    day: bo(r),
    hour: bo(c),
    minute: bo(d)
  };
  return h && (p.second = bo(h)), t && (p.weekday = t.length > 3 ? km.indexOf(t) + 1 : Lm.indexOf(t) + 1), p;
}
const yx = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function Nx(t) {
  const [
    ,
    e,
    n,
    r,
    c,
    d,
    h,
    p,
    N,
    x,
    v,
    O
  ] = t, M = Md(e, c, r, n, d, h, p);
  let A;
  return N ? A = _x[N] : x ? A = 0 : A = vc(v, O), [M, new hr(A)];
}
function Cx(t) {
  return t.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
const Ex = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, Tx = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, xx = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function Pg(t) {
  const [, e, n, r, c, d, h, p] = t;
  return [Md(e, c, r, n, d, h, p), hr.utcInstance];
}
function vx(t) {
  const [, e, n, r, c, d, h, p] = t;
  return [Md(e, p, n, r, c, d, h), hr.utcInstance];
}
const Sx = sl(sx, bd), wx = sl(lx, bd), Ox = sl(ax, bd), Dx = sl(Wm), Um = ll(
  hx,
  cl,
  ia,
  oa
), Rx = ll(
  cx,
  cl,
  ia,
  oa
), bx = ll(
  ux,
  cl,
  ia,
  oa
), Mx = ll(
  cl,
  ia,
  oa
);
function Ax(t) {
  return al(
    t,
    [Sx, Um],
    [wx, Rx],
    [Ox, bx],
    [Dx, Mx]
  );
}
function kx(t) {
  return al(Cx(t), [yx, Nx]);
}
function Lx(t) {
  return al(
    t,
    [Ex, Pg],
    [Tx, Pg],
    [xx, vx]
  );
}
function Ix(t) {
  return al(t, [px, mx]);
}
const Px = ll(cl);
function $x(t) {
  return al(t, [gx, Px]);
}
const Fx = sl(dx, fx), Bx = sl(Km), Hx = ll(
  cl,
  ia,
  oa
);
function Wx(t) {
  return al(
    t,
    [Fx, Um],
    [Bx, Hx]
  );
}
const $g = "Invalid Duration", zm = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
}, Kx = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...zm
}, qr = 146097 / 400, qs = 146097 / 4800, Ux = {
  years: {
    quarters: 4,
    months: 12,
    weeks: qr / 7,
    days: qr,
    hours: qr * 24,
    minutes: qr * 24 * 60,
    seconds: qr * 24 * 60 * 60,
    milliseconds: qr * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: qr / 28,
    days: qr / 4,
    hours: qr * 24 / 4,
    minutes: qr * 24 * 60 / 4,
    seconds: qr * 24 * 60 * 60 / 4,
    milliseconds: qr * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: qs / 7,
    days: qs,
    hours: qs * 24,
    minutes: qs * 24 * 60,
    seconds: qs * 24 * 60 * 60,
    milliseconds: qs * 24 * 60 * 60 * 1e3
  },
  ...zm
}, fs = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
], zx = fs.slice(0).reverse();
function Ro(t, e, n = !1) {
  const r = {
    values: n ? e.values : { ...t.values, ...e.values || {} },
    loc: t.loc.clone(e.loc),
    conversionAccuracy: e.conversionAccuracy || t.conversionAccuracy,
    matrix: e.matrix || t.matrix
  };
  return new Yt(r);
}
function Gm(t, e) {
  let n = e.milliseconds ?? 0;
  for (const r of zx.slice(1))
    e[r] && (n += e[r] * t[r].milliseconds);
  return n;
}
function Fg(t, e) {
  const n = Gm(t, e) < 0 ? -1 : 1;
  fs.reduceRight((r, c) => {
    if (At(e[c]))
      return r;
    if (r) {
      const d = e[r] * n, h = t[c][r], p = Math.floor(d / h);
      e[c] += p * n, e[r] -= p * h * n;
    }
    return c;
  }, null), fs.reduce((r, c) => {
    if (At(e[c]))
      return r;
    if (r) {
      const d = e[r] % 1;
      e[r] -= d, e[c] += d * t[r][c];
    }
    return c;
  }, null);
}
function Gx(t) {
  const e = {};
  for (const [n, r] of Object.entries(t))
    r !== 0 && (e[n] = r);
  return e;
}
class Yt {
  /**
   * @private
   */
  constructor(e) {
    const n = e.conversionAccuracy === "longterm" || !1;
    let r = n ? Ux : Kx;
    e.matrix && (r = e.matrix), this.values = e.values, this.loc = e.loc || Qt.create(), this.conversionAccuracy = n ? "longterm" : "casual", this.invalid = e.invalid || null, this.matrix = r, this.isLuxonDuration = !0;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(e, n) {
    return Yt.fromObject({ milliseconds: e }, n);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(e, n = {}) {
    if (e == null || typeof e != "object")
      throw new wr(
        `Duration.fromObject: argument expected to be an object, got ${e === null ? "null" : typeof e}`
      );
    return new Yt({
      values: gc(e, Yt.normalizeUnit),
      loc: Qt.fromObject(n),
      conversionAccuracy: n.conversionAccuracy,
      matrix: n.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(e) {
    if (hs(e))
      return Yt.fromMillis(e);
    if (Yt.isDuration(e))
      return e;
    if (typeof e == "object")
      return Yt.fromObject(e);
    throw new wr(
      `Unknown duration argument ${e} of type ${typeof e}`
    );
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(e, n) {
    const [r] = Ix(e);
    return r ? Yt.fromObject(r, n) : Yt.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(e, n) {
    const [r] = $x(e);
    return r ? Yt.fromObject(r, n) : Yt.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(e, n = null) {
    if (!e)
      throw new wr("need to specify a reason the Duration is invalid");
    const r = e instanceof _i ? e : new _i(e, n);
    if (kn.throwOnInvalid)
      throw new yT(r);
    return new Yt({ invalid: r });
  }
  /**
   * @private
   */
  static normalizeUnit(e) {
    const n = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[e && e.toLowerCase()];
    if (!n)
      throw new tm(e);
    return n;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(e) {
    return e && e.isLuxonDuration || !1;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(e, n = {}) {
    const r = {
      ...n,
      floor: n.round !== !1 && n.floor !== !1
    };
    return this.isValid ? sr.create(this.loc, r).formatDurationFromString(this, e) : $g;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(e = {}) {
    if (!this.isValid)
      return $g;
    const n = fs.map((r) => {
      const c = this.values[r];
      return At(c) ? null : this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...e, unit: r.slice(0, -1) }).format(c);
    }).filter((r) => r);
    return this.loc.listFormatter({ type: "conjunction", style: e.listStyle || "narrow", ...e }).format(n);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    return this.isValid ? { ...this.values } : {};
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid)
      return null;
    let e = "P";
    return this.years !== 0 && (e += this.years + "Y"), (this.months !== 0 || this.quarters !== 0) && (e += this.months + this.quarters * 3 + "M"), this.weeks !== 0 && (e += this.weeks + "W"), this.days !== 0 && (e += this.days + "D"), (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (e += "T"), this.hours !== 0 && (e += this.hours + "H"), this.minutes !== 0 && (e += this.minutes + "M"), (this.seconds !== 0 || this.milliseconds !== 0) && (e += Dd(this.seconds + this.milliseconds / 1e3, 3) + "S"), e === "P" && (e += "T0S"), e;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(e = {}) {
    if (!this.isValid)
      return null;
    const n = this.toMillis();
    return n < 0 || n >= 864e5 ? null : (e = {
      suppressMilliseconds: !1,
      suppressSeconds: !1,
      includePrefix: !1,
      format: "extended",
      ...e,
      includeOffset: !1
    }, Ot.fromMillis(n, { zone: "UTC" }).toISOTime(e));
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns a string representation of this Duration appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `Duration { values: ${JSON.stringify(this.values)} }` : `Duration { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? Gm(this.matrix, this.values) : NaN;
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(e) {
    if (!this.isValid)
      return this;
    const n = Yt.fromDurationLike(e), r = {};
    for (const c of fs)
      (tl(n.values, c) || tl(this.values, c)) && (r[c] = n.get(c) + this.get(c));
    return Ro(this, { values: r }, !0);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(e) {
    if (!this.isValid)
      return this;
    const n = Yt.fromDurationLike(e);
    return this.plus(n.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(e) {
    if (!this.isValid)
      return this;
    const n = {};
    for (const r of Object.keys(this.values))
      n[r] = bm(e(this.values[r], r));
    return Ro(this, { values: n }, !0);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(e) {
    return this[Yt.normalizeUnit(e)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(e) {
    if (!this.isValid)
      return this;
    const n = { ...this.values, ...gc(e, Yt.normalizeUnit) };
    return Ro(this, { values: n });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale: e, numberingSystem: n, conversionAccuracy: r, matrix: c } = {}) {
    const h = { loc: this.loc.clone({ locale: e, numberingSystem: n }), matrix: c, conversionAccuracy: r };
    return Ro(this, h);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(e) {
    return this.isValid ? this.shiftTo(e).get(e) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see third example)
   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid)
      return this;
    const e = this.toObject();
    return Fg(this.matrix, e), Ro(this, { values: e }, !0);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid)
      return this;
    const e = Gx(this.normalize().shiftToAll().toObject());
    return Ro(this, { values: e }, !0);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...e) {
    if (!this.isValid)
      return this;
    if (e.length === 0)
      return this;
    e = e.map((h) => Yt.normalizeUnit(h));
    const n = {}, r = {}, c = this.toObject();
    let d;
    for (const h of fs)
      if (e.indexOf(h) >= 0) {
        d = h;
        let p = 0;
        for (const x in r)
          p += this.matrix[x][h] * r[x], r[x] = 0;
        hs(c[h]) && (p += c[h]);
        const N = Math.trunc(p);
        n[h] = N, r[h] = (p * 1e3 - N * 1e3) / 1e3;
      } else
        hs(c[h]) && (r[h] = c[h]);
    for (const h in r)
      r[h] !== 0 && (n[d] += h === d ? r[h] : r[h] / this.matrix[d][h]);
    return Fg(this.matrix, n), Ro(this, { values: n }, !0);
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    return this.isValid ? this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ) : this;
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid)
      return this;
    const e = {};
    for (const n of Object.keys(this.values))
      e[n] = this.values[n] === 0 ? 0 : -this.values[n];
    return Ro(this, { values: e }, !0);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(e) {
    if (!this.isValid || !e.isValid || !this.loc.equals(e.loc))
      return !1;
    function n(r, c) {
      return r === void 0 || r === 0 ? c === void 0 || c === 0 : r === c;
    }
    for (const r of fs)
      if (!n(this.values[r], e.values[r]))
        return !1;
    return !0;
  }
}
const Zs = "Invalid Interval";
function Yx(t, e) {
  return !t || !t.isValid ? wn.invalid("missing or invalid start") : !e || !e.isValid ? wn.invalid("missing or invalid end") : e < t ? wn.invalid(
    "end before start",
    `The end of an interval must be after its start, but you had start=${t.toISO()} and end=${e.toISO()}`
  ) : null;
}
class wn {
  /**
   * @private
   */
  constructor(e) {
    this.s = e.start, this.e = e.end, this.invalid = e.invalid || null, this.isLuxonInterval = !0;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(e, n = null) {
    if (!e)
      throw new wr("need to specify a reason the Interval is invalid");
    const r = e instanceof _i ? e : new _i(e, n);
    if (kn.throwOnInvalid)
      throw new _T(r);
    return new wn({ invalid: r });
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(e, n) {
    const r = Yl(e), c = Yl(n), d = Yx(r, c);
    return d ?? new wn({
      start: r,
      end: c
    });
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(e, n) {
    const r = Yt.fromDurationLike(n), c = Yl(e);
    return wn.fromDateTimes(c, c.plus(r));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(e, n) {
    const r = Yt.fromDurationLike(n), c = Yl(e);
    return wn.fromDateTimes(c.minus(r), c);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(e, n) {
    const [r, c] = (e || "").split("/", 2);
    if (r && c) {
      let d, h;
      try {
        d = Ot.fromISO(r, n), h = d.isValid;
      } catch {
        h = !1;
      }
      let p, N;
      try {
        p = Ot.fromISO(c, n), N = p.isValid;
      } catch {
        N = !1;
      }
      if (h && N)
        return wn.fromDateTimes(d, p);
      if (h) {
        const x = Yt.fromISO(c, n);
        if (x.isValid)
          return wn.after(d, x);
      } else if (N) {
        const x = Yt.fromISO(r, n);
        if (x.isValid)
          return wn.before(p, x);
      }
    }
    return wn.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(e) {
    return e && e.isLuxonInterval || !1;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(e = "milliseconds") {
    return this.isValid ? this.toDuration(e).get(e) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
   * @return {number}
   */
  count(e = "milliseconds", n) {
    if (!this.isValid)
      return NaN;
    const r = this.start.startOf(e, n);
    let c;
    return n != null && n.useLocaleWeeks ? c = this.end.reconfigure({ locale: r.locale }) : c = this.end, c = c.startOf(e, n), Math.floor(c.diff(r, e).get(e)) + (c.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(e) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, e) : !1;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(e) {
    return this.isValid ? this.s > e : !1;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(e) {
    return this.isValid ? this.e <= e : !1;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(e) {
    return this.isValid ? this.s <= e && this.e > e : !1;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start: e, end: n } = {}) {
    return this.isValid ? wn.fromDateTimes(e || this.s, n || this.e) : this;
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...e) {
    if (!this.isValid)
      return [];
    const n = e.map(Yl).filter((h) => this.contains(h)).sort((h, p) => h.toMillis() - p.toMillis()), r = [];
    let { s: c } = this, d = 0;
    for (; c < this.e; ) {
      const h = n[d] || this.e, p = +h > +this.e ? this.e : h;
      r.push(wn.fromDateTimes(c, p)), c = p, d += 1;
    }
    return r;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(e) {
    const n = Yt.fromDurationLike(e);
    if (!this.isValid || !n.isValid || n.as("milliseconds") === 0)
      return [];
    let { s: r } = this, c = 1, d;
    const h = [];
    for (; r < this.e; ) {
      const p = this.start.plus(n.mapUnits((N) => N * c));
      d = +p > +this.e ? this.e : p, h.push(wn.fromDateTimes(r, d)), r = d, c += 1;
    }
    return h;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(e) {
    return this.isValid ? this.splitBy(this.length() / e).slice(0, e) : [];
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(e) {
    return this.e > e.s && this.s < e.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(e) {
    return this.isValid ? +this.e == +e.s : !1;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(e) {
    return this.isValid ? +e.e == +this.s : !1;
  }
  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(e) {
    return this.isValid ? this.s <= e.s && this.e >= e.e : !1;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(e) {
    return !this.isValid || !e.isValid ? !1 : this.s.equals(e.s) && this.e.equals(e.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(e) {
    if (!this.isValid)
      return this;
    const n = this.s > e.s ? this.s : e.s, r = this.e < e.e ? this.e : e.e;
    return n >= r ? null : wn.fromDateTimes(n, r);
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(e) {
    if (!this.isValid)
      return this;
    const n = this.s < e.s ? this.s : e.s, r = this.e > e.e ? this.e : e.e;
    return wn.fromDateTimes(n, r);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(e) {
    const [n, r] = e.sort((c, d) => c.s - d.s).reduce(
      ([c, d], h) => d ? d.overlaps(h) || d.abutsStart(h) ? [c, d.union(h)] : [c.concat([d]), h] : [c, h],
      [[], null]
    );
    return r && n.push(r), n;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(e) {
    let n = null, r = 0;
    const c = [], d = e.map((N) => [
      { time: N.s, type: "s" },
      { time: N.e, type: "e" }
    ]), h = Array.prototype.concat(...d), p = h.sort((N, x) => N.time - x.time);
    for (const N of p)
      r += N.type === "s" ? 1 : -1, r === 1 ? n = N.time : (n && +n != +N.time && c.push(wn.fromDateTimes(n, N.time)), n = null);
    return wn.merge(c);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...e) {
    return wn.xor([this].concat(e)).map((n) => this.intersection(n)).filter((n) => n && !n.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    return this.isValid ? `[${this.s.toISO()}  ${this.e.toISO()})` : Zs;
  }
  /**
   * Returns a string representation of this Interval appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }` : `Interval { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022  11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7  8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 78 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00  8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00  8:00 p
   * @return {string}
   */
  toLocaleString(e = dc, n = {}) {
    return this.isValid ? sr.create(this.s.loc.clone(n), e).formatInterval(this) : Zs;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(e) {
    return this.isValid ? `${this.s.toISO(e)}/${this.e.toISO(e)}` : Zs;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : Zs;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(e) {
    return this.isValid ? `${this.s.toISOTime(e)}/${this.e.toISOTime(e)}` : Zs;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  '  '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(e, { separator: n = "  " } = {}) {
    return this.isValid ? `${this.s.toFormat(e)}${n}${this.e.toFormat(e)}` : Zs;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(e, n) {
    return this.isValid ? this.e.diff(this.s, e, n) : Yt.invalid(this.invalidReason);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(e) {
    return wn.fromDateTimes(e(this.s), e(this.e));
  }
}
class Qa {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(e = kn.defaultZone) {
    const n = Ot.now().setZone(e).set({ month: 12 });
    return !e.isUniversal && n.offset !== n.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(e) {
    return oo.isValidZone(e);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(e) {
    return Mo(e, kn.defaultZone);
  }
  /**
   * Get the weekday on which the week starts according to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
   */
  static getStartOfWeek({ locale: e = null, locObj: n = null } = {}) {
    return (n || Qt.create(e)).getStartOfWeek();
  }
  /**
   * Get the minimum number of days necessary in a week before it is considered part of the next year according
   * to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number}
   */
  static getMinimumDaysInFirstWeek({ locale: e = null, locObj: n = null } = {}) {
    return (n || Qt.create(e)).getMinDaysInFirstWeek();
  }
  /**
   * Get the weekdays, which are considered the weekend according to the given locale
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
   */
  static getWeekendWeekdays({ locale: e = null, locObj: n = null } = {}) {
    return (n || Qt.create(e)).getWeekendDays().slice();
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'
   * @return {Array}
   */
  static months(e = "long", { locale: n = null, numberingSystem: r = null, locObj: c = null, outputCalendar: d = "gregory" } = {}) {
    return (c || Qt.create(n, r, d)).months(e);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(e = "long", { locale: n = null, numberingSystem: r = null, locObj: c = null, outputCalendar: d = "gregory" } = {}) {
    return (c || Qt.create(n, r, d)).months(e, !0);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''
   * @return {Array}
   */
  static weekdays(e = "long", { locale: n = null, numberingSystem: r = null, locObj: c = null } = {}) {
    return (c || Qt.create(n, r, null)).weekdays(e);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(e = "long", { locale: n = null, numberingSystem: r = null, locObj: c = null } = {}) {
    return (c || Qt.create(n, r, null)).weekdays(e, !0);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]
   * @return {Array}
   */
  static meridiems({ locale: e = null } = {}) {
    return Qt.create(e).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]
   * @return {Array}
   */
  static eras(e = "short", { locale: n = null } = {}) {
    return Qt.create(n, null, "gregory").eras(e);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
   * @example Info.features() //=> { relative: false, localeWeek: true }
   * @return {Object}
   */
  static features() {
    return { relative: Om(), localeWeek: Dm() };
  }
}
function Bg(t, e) {
  const n = (c) => c.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(), r = n(e) - n(t);
  return Math.floor(Yt.fromMillis(r).as("days"));
}
function Vx(t, e, n) {
  const r = [
    ["years", (N, x) => x.year - N.year],
    ["quarters", (N, x) => x.quarter - N.quarter + (x.year - N.year) * 4],
    ["months", (N, x) => x.month - N.month + (x.year - N.year) * 12],
    [
      "weeks",
      (N, x) => {
        const v = Bg(N, x);
        return (v - v % 7) / 7;
      }
    ],
    ["days", Bg]
  ], c = {}, d = t;
  let h, p;
  for (const [N, x] of r)
    n.indexOf(N) >= 0 && (h = N, c[N] = x(t, e), p = d.plus(c), p > e ? (c[N]--, t = d.plus(c), t > e && (p = t, c[N]--, t = d.plus(c))) : t = p);
  return [t, c, p, h];
}
function jx(t, e, n, r) {
  let [c, d, h, p] = Vx(t, e, n);
  const N = e - c, x = n.filter(
    (O) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(O) >= 0
  );
  x.length === 0 && (h < e && (h = c.plus({ [p]: 1 })), h !== c && (d[p] = (d[p] || 0) + N / (h - c)));
  const v = Yt.fromObject(d, r);
  return x.length > 0 ? Yt.fromMillis(N, r).shiftTo(...x).plus(v) : v;
}
const Ad = {
  arab: "[-]",
  arabext: "[-]",
  bali: "[-]",
  beng: "[-]",
  deva: "[-]",
  fullwide: "[-]",
  gujr: "[-]",
  hanidec: "[|||||||||]",
  khmr: "[-]",
  knda: "[-]",
  laoo: "[-]",
  limb: "[-]",
  mlym: "[-]",
  mong: "[-]",
  mymr: "[-]",
  orya: "[-]",
  tamldec: "[-]",
  telu: "[-]",
  thai: "[-]",
  tibt: "[-]",
  latn: "\\d"
}, Hg = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
}, qx = Ad.hanidec.replace(/[\[|\]]/g, "").split("");
function Zx(t) {
  let e = parseInt(t, 10);
  if (isNaN(e)) {
    e = "";
    for (let n = 0; n < t.length; n++) {
      const r = t.charCodeAt(n);
      if (t[n].search(Ad.hanidec) !== -1)
        e += qx.indexOf(t[n]);
      else
        for (const c in Hg) {
          const [d, h] = Hg[c];
          r >= d && r <= h && (e += r - d);
        }
    }
    return parseInt(e, 10);
  } else
    return e;
}
function pi({ numberingSystem: t }, e = "") {
  return new RegExp(`${Ad[t || "latn"]}${e}`);
}
const Jx = "missing Intl.DateTimeFormat.formatToParts support";
function Zt(t, e = (n) => n) {
  return { regex: t, deser: ([n]) => e(Zx(n)) };
}
const Xx = "", Ym = `[ ${Xx}]`, Vm = new RegExp(Ym, "g");
function Qx(t) {
  return t.replace(/\./g, "\\.?").replace(Vm, Ym);
}
function Wg(t) {
  return t.replace(/\./g, "").replace(Vm, " ").toLowerCase();
}
function mi(t, e) {
  return t === null ? null : {
    regex: RegExp(t.map(Qx).join("|")),
    deser: ([n]) => t.findIndex((r) => Wg(n) === Wg(r)) + e
  };
}
function Kg(t, e) {
  return { regex: t, deser: ([, n, r]) => vc(n, r), groups: e };
}
function ec(t) {
  return { regex: t, deser: ([e]) => e };
}
function ev(t) {
  return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function tv(t, e) {
  const n = pi(e), r = pi(e, "{2}"), c = pi(e, "{3}"), d = pi(e, "{4}"), h = pi(e, "{6}"), p = pi(e, "{1,2}"), N = pi(e, "{1,3}"), x = pi(e, "{1,6}"), v = pi(e, "{1,9}"), O = pi(e, "{2,4}"), M = pi(e, "{4,6}"), A = (P) => ({ regex: RegExp(ev(P.val)), deser: ([K]) => K, literal: !0 }), w = ((P) => {
    if (t.literal)
      return A(P);
    switch (P.val) {
      case "G":
        return mi(e.eras("short"), 0);
      case "GG":
        return mi(e.eras("long"), 0);
      case "y":
        return Zt(x);
      case "yy":
        return Zt(O, nd);
      case "yyyy":
        return Zt(d);
      case "yyyyy":
        return Zt(M);
      case "yyyyyy":
        return Zt(h);
      case "M":
        return Zt(p);
      case "MM":
        return Zt(r);
      case "MMM":
        return mi(e.months("short", !0), 1);
      case "MMMM":
        return mi(e.months("long", !0), 1);
      case "L":
        return Zt(p);
      case "LL":
        return Zt(r);
      case "LLL":
        return mi(e.months("short", !1), 1);
      case "LLLL":
        return mi(e.months("long", !1), 1);
      case "d":
        return Zt(p);
      case "dd":
        return Zt(r);
      case "o":
        return Zt(N);
      case "ooo":
        return Zt(c);
      case "HH":
        return Zt(r);
      case "H":
        return Zt(p);
      case "hh":
        return Zt(r);
      case "h":
        return Zt(p);
      case "mm":
        return Zt(r);
      case "m":
        return Zt(p);
      case "q":
        return Zt(p);
      case "qq":
        return Zt(r);
      case "s":
        return Zt(p);
      case "ss":
        return Zt(r);
      case "S":
        return Zt(N);
      case "SSS":
        return Zt(c);
      case "u":
        return ec(v);
      case "uu":
        return ec(p);
      case "uuu":
        return Zt(n);
      case "a":
        return mi(e.meridiems(), 0);
      case "kkkk":
        return Zt(d);
      case "kk":
        return Zt(O, nd);
      case "W":
        return Zt(p);
      case "WW":
        return Zt(r);
      case "E":
      case "c":
        return Zt(n);
      case "EEE":
        return mi(e.weekdays("short", !1), 1);
      case "EEEE":
        return mi(e.weekdays("long", !1), 1);
      case "ccc":
        return mi(e.weekdays("short", !0), 1);
      case "cccc":
        return mi(e.weekdays("long", !0), 1);
      case "Z":
      case "ZZ":
        return Kg(new RegExp(`([+-]${p.source})(?::(${r.source}))?`), 2);
      case "ZZZ":
        return Kg(new RegExp(`([+-]${p.source})(${r.source})?`), 2);
      case "z":
        return ec(/[a-z_+-/]{1,256}?/i);
      case " ":
        return ec(/[^\S\n\r]/);
      default:
        return A(P);
    }
  })(t) || {
    invalidReason: Jx
  };
  return w.token = t, w;
}
const nv = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function rv(t, e, n) {
  const { type: r, value: c } = t;
  if (r === "literal") {
    const N = /^\s+$/.test(c);
    return {
      literal: !N,
      val: N ? " " : c
    };
  }
  const d = e[r];
  let h = r;
  r === "hour" && (e.hour12 != null ? h = e.hour12 ? "hour12" : "hour24" : e.hourCycle != null ? e.hourCycle === "h11" || e.hourCycle === "h12" ? h = "hour12" : h = "hour24" : h = n.hour12 ? "hour12" : "hour24");
  let p = nv[h];
  if (typeof p == "object" && (p = p[d]), p)
    return {
      literal: !1,
      val: p
    };
}
function iv(t) {
  return [`^${t.map((n) => n.regex).reduce((n, r) => `${n}(${r.source})`, "")}$`, t];
}
function ov(t, e, n) {
  const r = t.match(e);
  if (r) {
    const c = {};
    let d = 1;
    for (const h in n)
      if (tl(n, h)) {
        const p = n[h], N = p.groups ? p.groups + 1 : 1;
        !p.literal && p.token && (c[p.token.val[0]] = p.deser(r.slice(d, d + N))), d += N;
      }
    return [r, c];
  } else
    return [r, {}];
}
function sv(t) {
  const e = (d) => {
    switch (d) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let n = null, r;
  return At(t.z) || (n = oo.create(t.z)), At(t.Z) || (n || (n = new hr(t.Z)), r = t.Z), At(t.q) || (t.M = (t.q - 1) * 3 + 1), At(t.h) || (t.h < 12 && t.a === 1 ? t.h += 12 : t.h === 12 && t.a === 0 && (t.h = 0)), t.G === 0 && t.y && (t.y = -t.y), At(t.u) || (t.S = Od(t.u)), [Object.keys(t).reduce((d, h) => {
    const p = e(h);
    return p && (d[p] = t[h]), d;
  }, {}), n, r];
}
let $u = null;
function lv() {
  return $u || ($u = Ot.fromMillis(1555555555555)), $u;
}
function av(t, e) {
  if (t.literal)
    return t;
  const n = sr.macroTokenToFormatOpts(t.val), r = Zm(n, e);
  return r == null || r.includes(void 0) ? t : r;
}
function jm(t, e) {
  return Array.prototype.concat(...t.map((n) => av(n, e)));
}
function qm(t, e, n) {
  const r = jm(sr.parseFormat(n), t), c = r.map((h) => tv(h, t)), d = c.find((h) => h.invalidReason);
  if (d)
    return { input: e, tokens: r, invalidReason: d.invalidReason };
  {
    const [h, p] = iv(c), N = RegExp(h, "i"), [x, v] = ov(e, N, p), [O, M, A] = v ? sv(v) : [null, null, void 0];
    if (tl(v, "a") && tl(v, "H"))
      throw new Js(
        "Can't include meridiem when specifying 24-hour format"
      );
    return { input: e, tokens: r, regex: N, rawMatches: x, matches: v, result: O, zone: M, specificOffset: A };
  }
}
function cv(t, e, n) {
  const { result: r, zone: c, specificOffset: d, invalidReason: h } = qm(t, e, n);
  return [r, c, d, h];
}
function Zm(t, e) {
  if (!t)
    return null;
  const r = sr.create(e, t).dtFormatter(lv()), c = r.formatToParts(), d = r.resolvedOptions();
  return c.map((h) => rv(h, t, d));
}
const Fu = "Invalid DateTime", Ug = 864e13;
function tc(t) {
  return new _i("unsupported zone", `the zone "${t.name}" is not supported`);
}
function Bu(t) {
  return t.weekData === null && (t.weekData = fc(t.c)), t.weekData;
}
function Hu(t) {
  return t.localWeekData === null && (t.localWeekData = fc(
    t.c,
    t.loc.getMinDaysInFirstWeek(),
    t.loc.getStartOfWeek()
  )), t.localWeekData;
}
function ls(t, e) {
  const n = {
    ts: t.ts,
    zone: t.zone,
    c: t.c,
    o: t.o,
    loc: t.loc,
    invalid: t.invalid
  };
  return new Ot({ ...n, ...e, old: n });
}
function Jm(t, e, n) {
  let r = t - e * 60 * 1e3;
  const c = n.offset(r);
  if (e === c)
    return [r, e];
  r -= (c - e) * 60 * 1e3;
  const d = n.offset(r);
  return c === d ? [r, c] : [t - Math.min(c, d) * 60 * 1e3, Math.max(c, d)];
}
function nc(t, e) {
  t += e * 60 * 1e3;
  const n = new Date(t);
  return {
    year: n.getUTCFullYear(),
    month: n.getUTCMonth() + 1,
    day: n.getUTCDate(),
    hour: n.getUTCHours(),
    minute: n.getUTCMinutes(),
    second: n.getUTCSeconds(),
    millisecond: n.getUTCMilliseconds()
  };
}
function sc(t, e, n) {
  return Jm(xc(t), e, n);
}
function zg(t, e) {
  const n = t.o, r = t.c.year + Math.trunc(e.years), c = t.c.month + Math.trunc(e.months) + Math.trunc(e.quarters) * 3, d = {
    ...t.c,
    year: r,
    month: c,
    day: Math.min(t.c.day, hc(r, c)) + Math.trunc(e.days) + Math.trunc(e.weeks) * 7
  }, h = Yt.fromObject({
    years: e.years - Math.trunc(e.years),
    quarters: e.quarters - Math.trunc(e.quarters),
    months: e.months - Math.trunc(e.months),
    weeks: e.weeks - Math.trunc(e.weeks),
    days: e.days - Math.trunc(e.days),
    hours: e.hours,
    minutes: e.minutes,
    seconds: e.seconds,
    milliseconds: e.milliseconds
  }).as("milliseconds"), p = xc(d);
  let [N, x] = Jm(p, n, t.zone);
  return h !== 0 && (N += h, x = t.zone.offset(N)), { ts: N, o: x };
}
function Gl(t, e, n, r, c, d) {
  const { setZone: h, zone: p } = n;
  if (t && Object.keys(t).length !== 0 || e) {
    const N = e || p, x = Ot.fromObject(t, {
      ...n,
      zone: N,
      specificOffset: d
    });
    return h ? x : x.setZone(p);
  } else
    return Ot.invalid(
      new _i("unparsable", `the input "${c}" can't be parsed as ${r}`)
    );
}
function rc(t, e, n = !0) {
  return t.isValid ? sr.create(Qt.create("en-US"), {
    allowZ: n,
    forceSimple: !0
  }).formatDateTimeFromString(t, e) : null;
}
function Wu(t, e) {
  const n = t.c.year > 9999 || t.c.year < 0;
  let r = "";
  return n && t.c.year >= 0 && (r += "+"), r += Fn(t.c.year, n ? 6 : 4), e ? (r += "-", r += Fn(t.c.month), r += "-", r += Fn(t.c.day)) : (r += Fn(t.c.month), r += Fn(t.c.day)), r;
}
function Gg(t, e, n, r, c, d) {
  let h = Fn(t.c.hour);
  return e ? (h += ":", h += Fn(t.c.minute), (t.c.millisecond !== 0 || t.c.second !== 0 || !n) && (h += ":")) : h += Fn(t.c.minute), (t.c.millisecond !== 0 || t.c.second !== 0 || !n) && (h += Fn(t.c.second), (t.c.millisecond !== 0 || !r) && (h += ".", h += Fn(t.c.millisecond, 3))), c && (t.isOffsetFixed && t.offset === 0 && !d ? h += "Z" : t.o < 0 ? (h += "-", h += Fn(Math.trunc(-t.o / 60)), h += ":", h += Fn(Math.trunc(-t.o % 60))) : (h += "+", h += Fn(Math.trunc(t.o / 60)), h += ":", h += Fn(Math.trunc(t.o % 60)))), d && (h += "[" + t.zone.ianaName + "]"), h;
}
const Xm = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, uv = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, dv = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, Qm = ["year", "month", "day", "hour", "minute", "second", "millisecond"], fv = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
], hv = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function gv(t) {
  const e = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[t.toLowerCase()];
  if (!e)
    throw new tm(t);
  return e;
}
function Yg(t) {
  switch (t.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return gv(t);
  }
}
function Vg(t, e) {
  const n = Mo(e.zone, kn.defaultZone), r = Qt.fromObject(e), c = kn.now();
  let d, h;
  if (At(t.year))
    d = c;
  else {
    for (const x of Qm)
      At(t[x]) && (t[x] = Xm[x]);
    const p = Sm(t) || wm(t);
    if (p)
      return Ot.invalid(p);
    const N = n.offset(c);
    [d, h] = sc(t, N, n);
  }
  return new Ot({ ts: d, zone: n, loc: r, o: h });
}
function jg(t, e, n) {
  const r = At(n.round) ? !0 : n.round, c = (h, p) => (h = Dd(h, r || n.calendary ? 0 : 2, !0), e.loc.clone(n).relFormatter(n).format(h, p)), d = (h) => n.calendary ? e.hasSame(t, h) ? 0 : e.startOf(h).diff(t.startOf(h), h).get(h) : e.diff(t, h).get(h);
  if (n.unit)
    return c(d(n.unit), n.unit);
  for (const h of n.units) {
    const p = d(h);
    if (Math.abs(p) >= 1)
      return c(p, h);
  }
  return c(t > e ? -0 : 0, n.units[n.units.length - 1]);
}
function qg(t) {
  let e = {}, n;
  return t.length > 0 && typeof t[t.length - 1] == "object" ? (e = t[t.length - 1], n = Array.from(t).slice(0, t.length - 1)) : n = Array.from(t), [e, n];
}
class Ot {
  /**
   * @access private
   */
  constructor(e) {
    const n = e.zone || kn.defaultZone;
    let r = e.invalid || (Number.isNaN(e.ts) ? new _i("invalid input") : null) || (n.isValid ? null : tc(n));
    this.ts = At(e.ts) ? kn.now() : e.ts;
    let c = null, d = null;
    if (!r)
      if (e.old && e.old.ts === this.ts && e.old.zone.equals(n))
        [c, d] = [e.old.c, e.old.o];
      else {
        const p = n.offset(this.ts);
        c = nc(this.ts, p), r = Number.isNaN(c.year) ? new _i("invalid input") : null, c = r ? null : c, d = r ? null : p;
      }
    this._zone = n, this.loc = e.loc || Qt.create(), this.invalid = r, this.weekData = null, this.localWeekData = null, this.c = c, this.o = d, this.isLuxonDateTime = !0;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new Ot({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [e, n] = qg(arguments), [r, c, d, h, p, N, x] = n;
    return Vg({ year: r, month: c, day: d, hour: h, minute: p, second: N, millisecond: x }, e);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [e, n] = qg(arguments), [r, c, d, h, p, N, x] = n;
    return e.zone = hr.utcInstance, Vg({ year: r, month: c, day: d, hour: h, minute: p, second: N, millisecond: x }, e);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(e, n = {}) {
    const r = UT(e) ? e.valueOf() : NaN;
    if (Number.isNaN(r))
      return Ot.invalid("invalid input");
    const c = Mo(n.zone, kn.defaultZone);
    return c.isValid ? new Ot({
      ts: r,
      zone: c,
      loc: Qt.fromObject(n)
    }) : Ot.invalid(tc(c));
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(e, n = {}) {
    if (hs(e))
      return e < -Ug || e > Ug ? Ot.invalid("Timestamp out of range") : new Ot({
        ts: e,
        zone: Mo(n.zone, kn.defaultZone),
        loc: Qt.fromObject(n)
      });
    throw new wr(
      `fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`
    );
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(e, n = {}) {
    if (hs(e))
      return new Ot({
        ts: e * 1e3,
        zone: Mo(n.zone, kn.defaultZone),
        loc: Qt.fromObject(n)
      });
    throw new wr("fromSeconds requires a numerical input");
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.localWeekYear - a week year, according to the locale
   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
   * @return {DateTime}
   */
  static fromObject(e, n = {}) {
    e = e || {};
    const r = Mo(n.zone, kn.defaultZone);
    if (!r.isValid)
      return Ot.invalid(tc(r));
    const c = Qt.fromObject(n), d = gc(e, Yg), { minDaysInFirstWeek: h, startOfWeek: p } = Ag(d, c), N = kn.now(), x = At(n.specificOffset) ? r.offset(N) : n.specificOffset, v = !At(d.ordinal), O = !At(d.year), M = !At(d.month) || !At(d.day), A = O || M, T = d.weekYear || d.weekNumber;
    if ((A || v) && T)
      throw new Js(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (M && v)
      throw new Js("Can't mix ordinal dates with month/day");
    const w = T || d.weekday && !A;
    let P, K, $ = nc(N, x);
    w ? (P = fv, K = uv, $ = fc($, h, p)) : v ? (P = hv, K = dv, $ = Pu($)) : (P = Qm, K = Xm);
    let W = !1;
    for (const G of P) {
      const j = d[G];
      At(j) ? W ? d[G] = K[G] : d[G] = $[G] : W = !0;
    }
    const H = w ? HT(d, h, p) : v ? WT(d) : Sm(d), z = H || wm(d);
    if (z)
      return Ot.invalid(z);
    const te = w ? bg(d, h, p) : v ? Mg(d) : d, [re, ue] = sc(te, x, r), q = new Ot({
      ts: re,
      zone: r,
      o: ue,
      loc: c
    });
    return d.weekday && A && e.weekday !== q.weekday ? Ot.invalid(
      "mismatched weekday",
      `you can't specify both a weekday of ${d.weekday} and a date of ${q.toISO()}`
    ) : q;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(e, n = {}) {
    const [r, c] = Ax(e);
    return Gl(r, c, n, "ISO 8601", e);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(e, n = {}) {
    const [r, c] = kx(e);
    return Gl(r, c, n, "RFC 2822", e);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(e, n = {}) {
    const [r, c] = Lx(e);
    return Gl(r, c, n, "HTTP", n);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(e, n, r = {}) {
    if (At(e) || At(n))
      throw new wr("fromFormat requires an input string and a format");
    const { locale: c = null, numberingSystem: d = null } = r, h = Qt.fromOpts({
      locale: c,
      numberingSystem: d,
      defaultToEN: !0
    }), [p, N, x, v] = cv(h, e, n);
    return v ? Ot.invalid(v) : Gl(p, N, r, `format ${n}`, e, x);
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(e, n, r = {}) {
    return Ot.fromFormat(e, n, r);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(e, n = {}) {
    const [r, c] = Wx(e);
    return Gl(r, c, n, "SQL", e);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(e, n = null) {
    if (!e)
      throw new wr("need to specify a reason the DateTime is invalid");
    const r = e instanceof _i ? e : new _i(e, n);
    if (kn.throwOnInvalid)
      throw new mT(r);
    return new Ot({ invalid: r });
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(e) {
    return e && e.isLuxonDateTime || !1;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(e, n = {}) {
    const r = Zm(e, Qt.fromObject(n));
    return r ? r.map((c) => c ? c.val : null).join("") : null;
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(e, n = {}) {
    return jm(sr.parseFormat(e), Qt.fromObject(n)).map((c) => c.val).join("");
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(e) {
    return this[e];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? Bu(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? Bu(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? Bu(this).weekday : NaN;
  }
  /**
   * Returns true if this date is on a weekend according to the locale, false otherwise
   * @returns {boolean}
   */
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }
  /**
   * Get the day of the week according to the locale.
   * 1 is the first day of the week and 7 is the last day of the week.
   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
   * @returns {number}
   */
  get localWeekday() {
    return this.isValid ? Hu(this).weekday : NaN;
  }
  /**
   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
   * because the week can start on different days of the week (see localWeekday) and because a different number of days
   * is required for a week to count as the first week of a year.
   * @returns {number}
   */
  get localWeekNumber() {
    return this.isValid ? Hu(this).weekNumber : NaN;
  }
  /**
   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
   * differently, see localWeekNumber.
   * @returns {number}
   */
  get localWeekYear() {
    return this.isValid ? Hu(this).weekYear : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? Pu(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Qa.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Qa.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Qa.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Qa.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "short",
      locale: this.locale
    }) : null;
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "long",
      locale: this.locale
    }) : null;
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    return this.isOffsetFixed ? !1 : this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
  }
  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed)
      return [this];
    const e = 864e5, n = 6e4, r = xc(this.c), c = this.zone.offset(r - e), d = this.zone.offset(r + e), h = this.zone.offset(r - c * n), p = this.zone.offset(r - d * n);
    if (h === p)
      return [this];
    const N = r - h * n, x = r - p * n, v = nc(N, h), O = nc(x, p);
    return v.hour === O.hour && v.minute === O.minute && v.second === O.second && v.millisecond === O.millisecond ? [ls(this, { ts: N }), ls(this, { ts: x })] : [this];
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return ra(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return hc(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? Xs(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? ea(this.weekYear) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's local week year
   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
   * @type {number}
   */
  get weeksInLocalWeekYear() {
    return this.isValid ? ea(
      this.localWeekYear,
      this.loc.getMinDaysInFirstWeek(),
      this.loc.getStartOfWeek()
    ) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(e = {}) {
    const { locale: n, numberingSystem: r, calendar: c } = sr.create(
      this.loc.clone(e),
      e
    ).resolvedOptions(this);
    return { locale: n, numberingSystem: r, outputCalendar: c };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(e = 0, n = {}) {
    return this.setZone(hr.instance(e), n);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(kn.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(e, { keepLocalTime: n = !1, keepCalendarTime: r = !1 } = {}) {
    if (e = Mo(e, kn.defaultZone), e.equals(this.zone))
      return this;
    if (e.isValid) {
      let c = this.ts;
      if (n || r) {
        const d = e.offset(this.ts), h = this.toObject();
        [c] = sc(h, d, e);
      }
      return ls(this, { ts: c, zone: e });
    } else
      return Ot.invalid(tc(e));
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale: e, numberingSystem: n, outputCalendar: r } = {}) {
    const c = this.loc.clone({ locale: e, numberingSystem: n, outputCalendar: r });
    return ls(this, { loc: c });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(e) {
    return this.reconfigure({ locale: e });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   *
   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
   * They cannot be mixed with ISO-week units like `weekday`.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(e) {
    if (!this.isValid)
      return this;
    const n = gc(e, Yg), { minDaysInFirstWeek: r, startOfWeek: c } = Ag(n, this.loc), d = !At(n.weekYear) || !At(n.weekNumber) || !At(n.weekday), h = !At(n.ordinal), p = !At(n.year), N = !At(n.month) || !At(n.day), x = p || N, v = n.weekYear || n.weekNumber;
    if ((x || h) && v)
      throw new Js(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (N && h)
      throw new Js("Can't mix ordinal dates with month/day");
    let O;
    d ? O = bg(
      { ...fc(this.c, r, c), ...n },
      r,
      c
    ) : At(n.ordinal) ? (O = { ...this.toObject(), ...n }, At(n.day) && (O.day = Math.min(hc(O.year, O.month), O.day))) : O = Mg({ ...Pu(this.c), ...n });
    const [M, A] = sc(O, this.o, this.zone);
    return ls(this, { ts: M, o: A });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(e) {
    if (!this.isValid)
      return this;
    const n = Yt.fromDurationLike(e);
    return ls(this, zg(this, n));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(e) {
    if (!this.isValid)
      return this;
    const n = Yt.fromDurationLike(e).negate();
    return ls(this, zg(this, n));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(e, { useLocaleWeeks: n = !1 } = {}) {
    if (!this.isValid)
      return this;
    const r = {}, c = Yt.normalizeUnit(e);
    switch (c) {
      case "years":
        r.month = 1;
      case "quarters":
      case "months":
        r.day = 1;
      case "weeks":
      case "days":
        r.hour = 0;
      case "hours":
        r.minute = 0;
      case "minutes":
        r.second = 0;
      case "seconds":
        r.millisecond = 0;
        break;
    }
    if (c === "weeks")
      if (n) {
        const d = this.loc.getStartOfWeek(), { weekday: h } = this;
        h < d && (r.weekNumber = this.weekNumber - 1), r.weekday = d;
      } else
        r.weekday = 1;
    if (c === "quarters") {
      const d = Math.ceil(this.month / 3);
      r.month = (d - 1) * 3 + 1;
    }
    return this.set(r);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(e, n) {
    return this.isValid ? this.plus({ [e]: 1 }).startOf(e, n).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(e, n = {}) {
    return this.isValid ? sr.create(this.loc.redefaultToEN(n)).formatDateTimeFromString(this, e) : Fu;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 aot 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(e = dc, n = {}) {
    return this.isValid ? sr.create(this.loc.clone(n), e).formatDateTime(this) : Fu;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(e = {}) {
    return this.isValid ? sr.create(this.loc.clone(e), e).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format: e = "extended",
    suppressSeconds: n = !1,
    suppressMilliseconds: r = !1,
    includeOffset: c = !0,
    extendedZone: d = !1
  } = {}) {
    if (!this.isValid)
      return null;
    const h = e === "extended";
    let p = Wu(this, h);
    return p += "T", p += Gg(this, h, n, r, c, d), p;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format: e = "extended" } = {}) {
    return this.isValid ? Wu(this, e === "extended") : null;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return rc(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds: e = !1,
    suppressSeconds: n = !1,
    includeOffset: r = !0,
    includePrefix: c = !1,
    extendedZone: d = !1,
    format: h = "extended"
  } = {}) {
    return this.isValid ? (c ? "T" : "") + Gg(
      this,
      h === "extended",
      n,
      e,
      r,
      d
    ) : null;
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return rc(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return rc(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    return this.isValid ? Wu(this, !0) : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset: e = !0, includeZone: n = !1, includeOffsetSpace: r = !0 } = {}) {
    let c = "HH:mm:ss.SSS";
    return (n || e) && (r && (c += " "), n ? c += "z" : e && (c += "ZZ")), rc(this, c, !0);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(e = {}) {
    return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(e)}` : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : Fu;
  }
  /**
   * Returns a string representation of this DateTime appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }` : `DateTime { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(e = {}) {
    if (!this.isValid)
      return {};
    const n = { ...this.c };
    return e.includeConfig && (n.outputCalendar = this.outputCalendar, n.numberingSystem = this.loc.numberingSystem, n.locale = this.loc.locale), n;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(e, n = "milliseconds", r = {}) {
    if (!this.isValid || !e.isValid)
      return Yt.invalid("created by diffing an invalid DateTime");
    const c = { locale: this.locale, numberingSystem: this.numberingSystem, ...r }, d = zT(n).map(Yt.normalizeUnit), h = e.valueOf() > this.valueOf(), p = h ? this : e, N = h ? e : this, x = jx(p, N, d, c);
    return h ? x.negate() : x;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(e = "milliseconds", n = {}) {
    return this.diff(Ot.now(), e, n);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(e) {
    return this.isValid ? wn.fromDateTimes(this, e) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(e, n, r) {
    if (!this.isValid)
      return !1;
    const c = e.valueOf(), d = this.setZone(e.zone, { keepLocalTime: !0 });
    return d.startOf(n, r) <= c && c <= d.endOf(n, r);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(e) {
    return this.isValid && e.isValid && this.valueOf() === e.valueOf() && this.zone.equals(e.zone) && this.loc.equals(e.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 da"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(e = {}) {
    if (!this.isValid)
      return null;
    const n = e.base || Ot.fromObject({}, { zone: this.zone }), r = e.padding ? this < n ? -e.padding : e.padding : 0;
    let c = ["years", "months", "days", "hours", "minutes", "seconds"], d = e.unit;
    return Array.isArray(e.unit) && (c = e.unit, d = void 0), jg(n, this.plus(r), {
      ...e,
      numeric: "always",
      units: c,
      unit: d
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(e = {}) {
    return this.isValid ? jg(e.base || Ot.fromObject({}, { zone: this.zone }), this, {
      ...e,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: !0
    }) : null;
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...e) {
    if (!e.every(Ot.isDateTime))
      throw new wr("min requires all arguments be DateTimes");
    return kg(e, (n) => n.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...e) {
    if (!e.every(Ot.isDateTime))
      throw new wr("max requires all arguments be DateTimes");
    return kg(e, (n) => n.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(e, n, r = {}) {
    const { locale: c = null, numberingSystem: d = null } = r, h = Qt.fromOpts({
      locale: c,
      numberingSystem: d,
      defaultToEN: !0
    });
    return qm(h, e, n);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(e, n, r = {}) {
    return Ot.fromFormatExplain(e, n, r);
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return dc;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return nm;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return NT;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return rm;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return im;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return om;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return sm;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return lm;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return am;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return cm;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return um;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return dm;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return fm;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return hm;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return gm;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return pm;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return mm;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return CT;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return _m;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return ym;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return Nm;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return Cm;
  }
}
function Yl(t) {
  if (Ot.isDateTime(t))
    return t;
  if (t && t.valueOf && hs(t.valueOf()))
    return Ot.fromJSDate(t);
  if (t && typeof t == "object")
    return Ot.fromObject(t);
  throw new wr(
    `Unknown datetime argument: ${t}, of type ${typeof t}`
  );
}
var Jt = /* @__PURE__ */ ((t) => (t.Monday = "MONDAY", t.Tuesday = "TUESDAY", t.Wednesday = "WEDNESDAY", t.Thursday = "THURSDAY", t.Friday = "FRIDAY", t.Saturday = "SATURDAY", t.Sunday = "SUNDAY", t))(Jt || {});
function kd(t) {
  const e = {
    1: Jt.Monday,
    2: Jt.Tuesday,
    3: Jt.Wednesday,
    4: Jt.Thursday,
    5: Jt.Friday,
    6: Jt.Saturday,
    7: Jt.Sunday
  };
  if (t.weekday in e)
    return e[t.weekday];
  throw new Error(`Invalid DateTime.weekday property: ${t}, ${t.weekday}`);
}
function Hi(t) {
  return {
    [Jt.Monday]: "Monday",
    [Jt.Tuesday]: "Tuesday",
    [Jt.Wednesday]: "Wednesday",
    [Jt.Thursday]: "Thursday",
    [Jt.Friday]: "Friday",
    [Jt.Saturday]: "Saturday",
    [Jt.Sunday]: "Sunday"
  }[t];
}
class Zg {
  /**
   * @param date - DateTime the DateTime for the day on which the interval starts
   * @param interval - the Yext Streams interval data
   */
  constructor(e, n, r) {
    $n(this, "end");
    $n(this, "start");
    this.end = e.setZone(r), this.start = e.setZone(r), [n.start, n.end].forEach((N) => {
      if (N.split(":").length !== 2)
        throw new Error(
          'expected interval start and end data to be in the format "HH:MM"'
        );
    });
    const [c, d] = n.start.split(":"), [h, p] = n.end.split(":");
    this.end = this.end.set({
      hour: Number(h),
      minute: Number(p)
    }), this.start = this.start.set({
      hour: Number(c),
      minute: Number(d)
    }), this.end < this.start && (this.end = this.end.plus({ days: 1 })), this.end.minute === 59 && (this.end = this.end.set({ minute: 60 }));
  }
  /**
   * @param date - A moment in time
   * @returns boolean - True if the given moment is within the interval
   */
  contains(e) {
    return this.start <= e && e < this.end;
  }
  /**
   * @param opts - intl.DateTimeFormatOptions
   * @param locale - defaults to 'en-US'
   * @returns string - representation of this interval's start time
   */
  getStartTime(e, n) {
    const r = {
      hour: "numeric",
      minute: "numeric",
      ...n
    };
    return this.start.setLocale(e || "en-US").toLocaleString(r);
  }
  /**
   * @param opts - intl.DateTimeFormatOptions
   * @param locale - defaults to 'en-US'
   * @returns string representation of this interval's end time
   */
  getEndTime(e, n) {
    const r = {
      hour: "numeric",
      minute: "numeric",
      ...n
    };
    return this.end.setLocale(e || "en-US").toLocaleString(r);
  }
  /**
   * @returns boolean if this interval and 'other' have the same start/end
   */
  timeIsEqualTo(e) {
    const n = this.getStartTime() === e.getStartTime(), r = this.getEndTime() === e.getEndTime();
    return n && r;
  }
  /**
   * @returns boolean if this interval is 24 hours
   */
  is24h() {
    const e = this.start.minute === 0 && this.start.hour === 0, n = this.end.minute === 0 && this.end.hour === 0, r = this.end.day - this.start.day === 1 || this.end.day === 1;
    return e && n && r;
  }
}
class e_ {
  /**
   * @param hours - Hours object in the format returned by Yext Streams
   */
  constructor(e, n) {
    $n(this, "holidayHoursByDate");
    $n(this, "hours");
    $n(this, "timezone");
    this.holidayHoursByDate = Object.fromEntries(
      (e.holidayHours || []).map((r) => [r.date, r])
    ), this.hours = e, this.timezone = n;
  }
  /**
   * @param date - A moment in time
   * @returns HoursInterval? The first interval that contains the given moment, null if none
   */
  getInterval(e) {
    if (this.isTemporarilyClosedAt(e))
      return null;
    let n = e;
    n = n.minus({ days: 1 });
    for (const r of [n, e]) {
      const c = this.getHours(r);
      if (c && !c.isClosed)
        for (const d of c.openIntervals || []) {
          const h = new Zg(
            r,
            d,
            this.timezone
          );
          if (h.contains(e))
            return h;
        }
    }
    return null;
  }
  /**
   * @returns HoursInterval? The first interval that contains the current time, null if none
   */
  getCurrentInterval() {
    return this.getInterval(Ot.now());
  }
  /**
   * @param date - A moment in time
   * @returns HoursInterval? The next interval that hasn't started as of the given moment
   */
  getIntervalAfter(e) {
    const n = this.getIntervalsForNDays(8, e), r = (d, h) => d.start === h.start ? 0 : d.start > h.start ? 1 : -1, c = n.sort(r);
    for (const [d, h] of c.entries())
      if (h.contains(e) && c.length > d + 1)
        return c[d + 1];
    for (const d of c)
      if (d.start > e)
        return d;
    return null;
  }
  /*
   * @param {number} n number of days to check
   * @param {DateTime} startDate first day to check
   * @returns {HoursInterval[]} list of intervals in range [startDate, startDate+7]
   */
  getIntervalsForNDays(e, n) {
    const r = [];
    for (let c = 0; c < e; c++) {
      let d = n;
      d = d.plus({ days: c });
      const h = this.getHours(d);
      h && !h.isClosed && r.push(
        ...h.openIntervals.map(
          (p) => new Zg(d, p, this.timezone)
        )
      );
    }
    return r;
  }
  /**
   * @param date - The day to get the hours for
   * @returns Object? The daily holiday hours object from the original Streams response for the
   *   given date, null if none
   */
  getHolidayHours(e) {
    return this.isTemporarilyClosedAt(e) ? null : this.holidayHoursByDate[(e.toISO() || "").replace(/T.*/, "")] || null;
  }
  /**
   * @param date - The day to get the hours for
   * @returns Object? The daily normal hours object from the original Streams response for the
   *   given date, null if none
   */
  getNormalHours(e) {
    if (this.isTemporarilyClosedAt(e))
      return null;
    const n = Hi(kd(e)).toLowerCase();
    return this.hours[n];
  }
  /**
   * @param date - The day to get the hours for
   * @returns Object? The daily hours object from the original Streams response for the given
   *   date, null if none
   */
  getHours(e) {
    const n = this.getHolidayHours(e);
    return !n || n.isRegularHours ? this.getNormalHours(e) : n;
  }
  /**
   * @returns HoursInterval? The next interval that hasn't started as of the current time
   */
  getNextInterval() {
    return this.getIntervalAfter(Ot.now());
  }
  /**
   * @param date - A day
   * @returns Boolean True if the given day has holiday hours
   */
  isHoliday(e) {
    return !!this.getHolidayHours(e);
  }
  /**
   * Yext platform uses the field `hours.reopenDate` to indicate an entity is
   *  temporarily closed for more than one day.
   * @returns Boolean True if the given date is before 'reopenDate'
   */
  isTemporarilyClosedAt(e) {
    if (!this.hours.reopenDate)
      return !1;
    const n = this.hours.reopenDate.split("-");
    if (n.length === 3) {
      const [r, c, d] = n, h = Ot.fromObject(
        { year: Number(r), month: Number(c), day: Number(d) },
        { zone: this.timezone }
      );
      if (e < h)
        return !0;
    }
    return !1;
  }
  /**
   * @param date - A moment in time
   * @returns Boolean True if the given moment falls within any interval
   */
  isOpenAt(e) {
    return this.isTemporarilyClosedAt(e) ? !1 : !!this.getInterval(e);
  }
  /**
   * @returns Boolean True if the current time falls within any interval
   */
  isOpenNow() {
    return this.isOpenAt(Ot.now());
  }
}
function pv(t, e) {
  const n = [...t];
  return e = e % n.length, n.concat(n.splice(0, n.length - e));
}
function mv(t, e) {
  if (t.length != e.length)
    return !1;
  for (const [n, r] of t.entries())
    if (!r.timeIsEqualTo(e[n]))
      return !1;
  return !0;
}
function sa(t) {
  var e, n;
  return ((n = (e = t == null ? void 0 : t.currentInterval) == null ? void 0 : e.is24h) == null ? void 0 : n.call(e)) || !1;
}
function la(t) {
  return !t.futureInterval;
}
function _v(t) {
  return sa(t) ? /* @__PURE__ */ ht.jsx("span", { className: "HoursStatus-current", children: "Open 24 Hours" }) : la(t) ? /* @__PURE__ */ ht.jsx("span", { className: "HoursStatus-current", children: "Temporarily Closed" }) : /* @__PURE__ */ ht.jsx("span", { className: "HoursStatus-current", children: t.isOpen ? "Open Now" : "Closed" });
}
function yv(t) {
  return sa(t) || la(t) ? null : /* @__PURE__ */ ht.jsx("span", { className: "HoursStatus-separator", children: "  " });
}
function Nv(t) {
  return sa(t) || la(t) ? null : /* @__PURE__ */ ht.jsx("span", { className: "HoursStatus-future", children: t.isOpen ? "Closes at" : "Opens at" });
}
function Cv(t) {
  if (sa(t) || la(t))
    return null;
  let e = "";
  if (t.isOpen) {
    const n = t.currentInterval;
    e += n ? n.getEndTime("en-US", t.timeOptions) : "";
  } else {
    const n = t.futureInterval;
    e += n ? n.getStartTime("en-US", t.timeOptions) : "";
  }
  return /* @__PURE__ */ ht.jsxs("span", { className: "HoursStatus-time", children: [
    " ",
    e
  ] });
}
function Ev(t) {
  var r, c;
  if (sa(t) || la(t))
    return null;
  const e = {
    weekday: "long",
    ...t.dayOptions ?? {}
  };
  let n = "";
  if (t.isOpen) {
    const d = t.currentInterval;
    n += ((r = d == null ? void 0 : d.end) == null ? void 0 : r.setLocale("en-US").toLocaleString(e)) || "";
  } else {
    const d = t.futureInterval;
    n += ((c = d == null ? void 0 : d.start) == null ? void 0 : c.setLocale("en-US").toLocaleString(e)) || "";
  }
  return /* @__PURE__ */ ht.jsxs("span", { className: "HoursStatus-dayOfWeek", children: [
    " ",
    n
  ] });
}
function Tv(t, e) {
  const n = t.currentTemplate || _v, r = t.separatorTemplate || yv, c = t.futureTemplate || Nv, d = t.timeTemplate || Cv, h = t.dayOfWeekTemplate || Ev;
  return /* @__PURE__ */ ht.jsxs("div", { className: Xl("HoursStatus", (e == null ? void 0 : e.className) || ""), children: [
    n(t),
    r(t),
    c(t),
    d(t),
    h(t)
  ] });
}
const vS = (t) => {
  const [e, n] = dr(!1), [r, c] = dr(!1);
  fr(() => {
    c(!0);
  }, []);
  const d = t.statusTemplate || Tv, h = new e_(t.hours, t.timezone), p = h.isOpenNow(), N = h.getCurrentInterval(), x = h.getNextInterval(), v = (N == null ? void 0 : N.end) || (x == null ? void 0 : x.start);
  if (v && !e) {
    n(!0);
    const M = v.toMillis() - Ot.now().toMillis();
    setTimeout(() => n(!1), M);
  }
  const O = {
    isOpen: p,
    currentInterval: N,
    futureInterval: x,
    ...t
  };
  return /* @__PURE__ */ ht.jsx(ht.Fragment, { children: r && d(O, t) });
};
function xv(t, e) {
  const n = [];
  return t.forEach((r) => {
    const c = n[n.length - 1];
    c ? mv(c.intervals, r.intervals) ? (c.endDay = r.endDay, c.isToday = c.isToday || r.isToday) : n.push({
      ...r
    }) : n.push({
      ...r
    });
  }), n.map((r) => {
    const c = e && Hi(r.startDay) in e ? e[Hi(r.startDay)] || "" : Hi(r.startDay), d = e && Hi(r.endDay) in e ? e[Hi(r.endDay)] || "" : Hi(r.endDay);
    return {
      ...r,
      dayOfWeek: "Collapsed",
      dayName: r.startDay === r.endDay ? `${c}` : `${c} - ${d}`
    };
  });
}
function vv(t, e) {
  const n = [], r = t.intervals.length > 0 && t.intervals[0].is24h();
  return t.intervals.length === 0 ? n.push("Closed") : r ? n.push("Open 24 hours") : t.intervals.forEach((c) => {
    const d = c.getStartTime("en-US", e), h = c.getEndTime("en-US", e);
    n.push(`${d} - ${h}`);
  }), n;
}
function Sv(t, e, n) {
  const r = [];
  for (let c = 1; c <= 7; c++) {
    const d = Ot.fromObject({ weekday: c }), h = kd(d);
    r.push({
      startDay: h,
      endDay: h,
      dayName: n && Hi(h) in n ? n[Hi(h)] || "" : Hi(h),
      intervals: t.filter((p) => p.start.weekday === c),
      isToday: e.weekday === c
    });
  }
  return r;
}
const SS = (t) => {
  const [e, n] = dr(!1);
  fr(() => {
    n(!0);
  }, []);
  const r = new e_(
    t.hours,
    Intl.DateTimeFormat().resolvedOptions().timeZone
  ), c = Ot.now(), d = r.getIntervalsForNDays(7, c);
  let h = Sv(d, c, t.dayOfWeekNames);
  function p(v) {
    return v ? {
      today: kd(c),
      monday: Jt.Monday,
      tuesday: Jt.Tuesday,
      wednesday: Jt.Wednesday,
      thursday: Jt.Thursday,
      friday: Jt.Friday,
      saturday: Jt.Saturday,
      sunday: Jt.Sunday
    }[v] : Jt.Sunday;
  }
  let N = [
    Jt.Sunday,
    Jt.Monday,
    Jt.Tuesday,
    Jt.Wednesday,
    Jt.Thursday,
    Jt.Friday,
    Jt.Saturday
  ];
  const x = N.indexOf(
    p(t.startOfWeek)
  );
  return N = pv(N, 7 - x), h.sort(
    (v, O) => N.indexOf(v.startDay) - N.indexOf(O.startDay)
  ), t.collapseDays && (h = xv(h, t.dayOfWeekNames)), /* @__PURE__ */ ht.jsx(ht.Fragment, { children: e && /* @__PURE__ */ ht.jsx("div", { className: Xl("HoursTable", t.className), children: h.map((v) => {
    const M = (t.intervalStringsBuilderFn || vv)(
      v,
      t.timeOptions
    );
    return /* @__PURE__ */ ht.jsxs(
      "div",
      {
        className: Xl("HoursTable-row", { "is-today": v.isToday }),
        children: [
          /* @__PURE__ */ ht.jsx("span", { className: "HoursTable-day", children: v.dayName }),
          /* @__PURE__ */ ht.jsx("span", { className: "HoursTable-intervals", children: M.map((A, T) => /* @__PURE__ */ ht.jsx("span", { className: "HoursTable-interval", children: A }, T)) })
        ]
      },
      v.dayName
    );
  }) }) });
}, rd = Math.log2(1.6745627884839434), wv = 4, Ov = 19, id = "js-baidu-neg-lng-fix";
let t_;
const Dv = new Promise((t) => t_ = t), Rv = "https://api.map.baidu.com/geoconv/v1/";
let Vl = [];
const bv = "gcj02ToBD09Callback_b872c21c";
let Mv = 0, Jg;
async function n_(t) {
  return await new Promise((e, n) => {
    Vl.push({ coordinates: t, resolve: e, reject: n }), Vl.length === 1 && (Jg = setTimeout(r, 100)), Vl.length > 40 && (clearTimeout(Jg), r());
    function r() {
      const c = Vl;
      Vl = [];
      const d = [].concat(
        ...c.map((N) => N.coordinates)
      ), h = bv + "_" + Mv++, p = document.createElement("script");
      window[h] = (N) => {
        if (N.status) {
          const O = new Error(
            `Unable to convert coordinates to BD-09: Received status code ${N.status}${N.message ? ": " + N.message : ""}`
          );
          c.forEach((M) => M.reject(O));
        }
        const x = N.result.map(
          (O) => new nn(O.y, O.x)
        );
        let v = 0;
        c.forEach((O) => {
          O.resolve(
            x.slice(
              v,
              v += O.coordinates.length
            )
          );
        }), delete window[h], p.parentNode.removeChild(p);
      }, Dv.then((N) => {
        const x = {
          ak: N,
          callback: h,
          coords: d.map(
            (v) => `${v.longitude},${v.latitude}`
          ).join(";"),
          from: 3,
          to: 5
        };
        p.src = Rv + "?" + Object.entries(x).map(([v, O]) => v + "=" + O).join("&"), document.head.appendChild(p);
      });
    }
  });
}
class Av extends il {
  /**
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(e) {
    super(e);
    const n = !!(window.MSInputMethodContext && document.documentMode);
    this._wrapper = e.wrapper, this.map = new BMap.Map(this._wrapper, {
      enableMapClick: e.controlEnabled,
      // A side effect of the negative pin longitude glitch is that pins don't render at higher zoom levels.
      // For IE, 15 and above is broken. For other browsers, 19 and above.
      maxZoom: n ? 14 : 18,
      ...e.providerOptions
    }), e.controlEnabled ? (this.map.enableScrollWheelZoom(), this.map.addControl(
      new BMap.NavigationControl({
        anchor: BMAP_ANCHOR_TOP_RIGHT,
        type: BMAP_NAVIGATION_CONTROL_ZOOM
      })
    )) : (this.map.disableDragging(), this.map.disableDoubleClickZoom(), this.map.disablePinchToZoom()), this.map.addEventListener("movestart", () => this._panStartHandler()), this.map.addEventListener("moveend", () => this._panHandler()), this.map.addEventListener("zoomstart", () => this._panStartHandler()), this.map.addEventListener("zoomend", () => {
      this._wrapper.dataset.baiduZoom = this.map.getZoom(), this._panHandler();
    }), this._centerReady = Promise.resolve();
  }
  /**
   * @inheritdoc
   */
  getCenter() {
    return new nn(this.map.getCenter());
  }
  /**
   * @inheritdoc
   */
  getZoom() {
    return this.map.getZoom() - rd;
  }
  /**
   * @inheritdoc
   */
  setCenter(e, n) {
    this._centerReady = n_([e]).then(([r]) => {
      const c = new BMap.Point(
        r.longitude,
        r.latitude
      );
      this.map.panTo(c, { noAnimation: !n });
    });
  }
  /**
   * @inheritdoc
   */
  setZoom(e, n) {
    this._centerReady.then(() => {
      this.map.setViewport(
        {
          center: this.map.getCenter(),
          zoom: Math.floor(e + rd)
          // Baidu only allows integer zoom
        },
        { enableAnimation: n }
      );
    });
  }
}
class kv extends _c {
  /**
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(e) {
    super(e), this._wrapper = null, this._zIndex = 0, this._wrapperClass = "", this._originalWrapperClass = "", this._element = this._pinEl, this._coordinateReady = Promise.resolve(), this._negativeLngFix = !1;
    const n = this;
    class r extends BMap.Marker {
      initialize(h) {
        return n._wrapper = super.initialize(h), n._wrapper && (n._wrapper.style.zIndex = n._zIndex, n._originalWrapperClass = n._wrapper.getAttribute("class"), n._wrapper.setAttribute("class", n._getClass()), n._wrapper.appendChild(n._element), n.addListeners()), n._wrapper;
      }
      draw() {
        if (n._wrapper) {
          const h = n._wrapper.style.zIndex;
          super.draw(), n._wrapper.style.height = "", n._wrapper.style.width = "", n._wrapper.style.pointerEvents = "none", n._wrapper.style.zIndex = h;
        } else
          super.draw();
      }
    }
    this.pin = new r(new BMap.Point(0, 0));
    const c = new BMap.Icon(
      "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
      { height: 0, width: 0 }
    );
    this.pin.setIcon(c), this.pin.setShadow(c);
  }
  /**
   * @inheritdoc
   */
  addListeners() {
    super.addListeners(), this._wrapper.addEventListener("touchend", () => this._clickHandler());
  }
  /**
   * @inheritdoc
   */
  setCoordinate(e) {
    this._coordinateReady = n_([e]).then(
      ([n]) => {
        this._negativeLngFix = n.longitude < 0, this.pin.setPosition(
          new BMap.Point(
            n.longitude + (this._negativeLngFix ? 180 : 0),
            n.latitude
          )
        ), this._wrapper && this._wrapper.classList[this._negativeLngFix ? "add" : "remove"](
          id
        );
      }
    );
  }
  /**
   * @inheritdoc
   */
  setMap(e, n) {
    this._coordinateReady.then(() => {
      n && n.getProviderMap().map.removeOverlay(this.pin), e && e.getProviderMap().map.addOverlay(this.pin);
    });
  }
  /**
   * @inheritdoc
   */
  setProperties(e) {
    super.setProperties(e), this._wrapperClass = e.getClass(), this._element = e.getElement() || this._pinEl, this._zIndex = e.getZIndex(), this._wrapper && this._wrapper.setAttribute("class", this._getClass());
  }
  /**
   * Get the class attribute value for the pin element
   * @protected
   * @returns {string}
   */
  _getClass() {
    return `${this._originalWrapperClass} ${this._negativeLngFix ? id : ""} ${this._wrapperClass}`;
  }
}
const Lv = "https://api.map.baidu.com/getscript";
function Iv(t, e, n, { params: r = {}, version: c = "3.0" } = {}) {
  window.BMAP_PROTOCOL = "https", window.BMap_loadScriptTime = (/* @__PURE__ */ new Date()).getTime();
  const d = n, h = {
    ak: d,
    v: c,
    ...r
  };
  t_(d);
  const p = document.createElement("script");
  p.src = Lv + "?" + Object.entries(h).map(([v, O]) => v + "=" + O).join("&"), p.onload = () => t(), document.head.appendChild(p);
  let N = "";
  for (let v = wv; v <= Ov; v++) {
    const O = 2 ** (v - rd + 7);
    N += `[data-baidu-zoom="${v}"] .${id}{transform:translateX(-${O}px);}`;
  }
  const x = document.createElement("style");
  x.innerHTML = N, document.head.appendChild(x);
}
const wS = new ps().withLoadFunction(Iv).withMapClass(Av).withPinClass(kv).withProviderName("Baidu").build();
let r_;
function Pv() {
  class t extends Microsoft.Maps.CustomOverlay {
    constructor() {
      super({ beneathLabels: !1 }), this._container = document.createElement("div"), this._map = null, this._pins = /* @__PURE__ */ new Set(), this._viewChangeEventHandler = null, this._container.style.position = "absolute", this._container.style.left = "0", this._container.style.top = "0";
    }
    addPin(n) {
      this._pins.add(n), n._wrapper.style.position = "absolute", this._container.appendChild(n._wrapper), this._map && this.updatePinPosition(n);
    }
    onAdd() {
      this._map = this.getMap(), this.setHtmlElement(this._container);
    }
    onLoad() {
      this._viewChangeEventHandler = Microsoft.Maps.Events.addHandler(
        this._map,
        "viewchange",
        () => this.updatePinPositions()
      ), this.updatePinPositions();
    }
    onRemove() {
      Microsoft.Maps.Events.removeHandler(this._viewChangeEventHandler), this._map = null;
    }
    removePin(n) {
      this._pins.delete(n), this._container.removeChild(n._wrapper);
    }
    updatePinPosition(n) {
      if (!this._map)
        return;
      const r = this._map.tryLocationToPixel(
        n._location,
        Microsoft.Maps.PixelReference.control
      );
      n._wrapper.style.left = r.x + "px", n._wrapper.style.top = r.y + "px";
    }
    updatePinPositions() {
      this._pins.forEach((n) => this.updatePinPosition(n));
    }
  }
  r_ = t;
}
class $v extends il {
  /**
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(e) {
    super(e), this.wrapper = e.wrapper, this.map = new Microsoft.Maps.Map(this.wrapper, {
      disablePanning: !e.controlEnabled,
      disableZooming: !e.controlEnabled,
      showLocateMeButton: !1,
      showMapTypeSelector: !1,
      showScalebar: !1,
      showTrafficButton: !1,
      ...e.providerOptions
    }), this.pinOverlay = new r_(this.map), this.map.layers.insert(this.pinOverlay), Microsoft.Maps.Events.addHandler(
      this.map,
      "viewchangestart",
      () => this._panStartHandler()
    ), Microsoft.Maps.Events.addHandler(
      this.map,
      "viewchangeend",
      () => this._panHandler()
    );
  }
  /**
   * @inheritdoc
   */
  getCenter() {
    return new nn(this.map.getCenter());
  }
  /**
   * @inheritdoc
   */
  getZoom() {
    return this.map.getZoom();
  }
  /**
   * @inheritdoc
   */
  setCenter(e, n) {
    const r = new Microsoft.Maps.Location(
      e.latitude,
      e.longitude
    );
    this.map.setView({ center: r }), this.pinOverlay.updatePinPositions();
  }
  /**
   * @inheritdoc
   */
  setZoom(e, n) {
    this.map.setView({ zoom: Math.floor(e) }), this.pinOverlay.updatePinPositions();
  }
}
class Fv extends _c {
  /**
   * Bing pins need global callbacks to complete initialization.
   * This function provides a unique ID to include in the name of the callback.
   * @returns {number} An ID for the pin unique across all instances of {@link module:@yext/components-maps~BingPin BingPin}
   */
  static getId() {
    return this._pinId = (this._pinId || 0) + 1, this._pinId;
  }
  /**
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(e) {
    super(e), this._map = null, this._location = new Microsoft.Maps.Location(0, 0);
  }
  /**
   * @inheritdoc
   */
  setCoordinate(e) {
    this._location = new Microsoft.Maps.Location(
      e.latitude,
      e.longitude
    ), this._map && this._map.getProviderMap().pinOverlay.updatePinPosition(this);
  }
  /**
   * @inheritdoc
   */
  setMap(e, n) {
    n && n.getProviderMap().pinOverlay.removePin(this), e && e.getProviderMap().pinOverlay.addPin(this), this._map = e;
  }
}
const Xg = "BingMapsCallback_593d7d33", Bv = "https://www.bing.com/api/maps/mapcontrol";
function Hv(t, e, n, { params: r = {} } = {}) {
  window[Xg] = () => {
    Pv(), t();
  };
  const c = {
    callback: Xg,
    key: n,
    ...r
  };
  dp(
    Bv + "?" + Object.entries(c).map(([d, h]) => d + "=" + h).join("&")
  );
}
const OS = new ps().withLoadFunction(Hv).withMapClass($v).withPinClass(Fv).withProviderName("Bing").build();
class Wv extends il {
  /**
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(e) {
    if (super(e), this.map = new mapboxgl.Map({
      container: e.wrapper,
      interactive: e.controlEnabled,
      style: "mapbox://styles/mapbox/streets-v9",
      ...e.providerOptions
    }), e.controlEnabled) {
      const n = new mapboxgl.NavigationControl({
        showCompass: !1
      });
      this.map.addControl(n);
    }
    this.map.on("movestart", () => this._panStartHandler()), this.map.on("moveend", () => this._panHandler());
  }
  /**
   * @inheritdoc
   */
  getCenter() {
    return new nn(this.map.getCenter());
  }
  /**
   * @inheritdoc
   */
  getZoom() {
    return this.map.getZoom() + 1;
  }
  /**
   * @inheritdoc
   */
  setCenter(e, n) {
    const r = new mapboxgl.LngLat(
      e.longitude,
      e.latitude
    );
    this.map[n ? "panTo" : "setCenter"](r);
  }
  /**
   * @inheritdoc
   */
  setZoom(e, n) {
    this.map[n ? "zoomTo" : "setZoom"](e - 1);
  }
  /**
   * @inheritdoc
   */
  setZoomCenter(e, n, r) {
    const c = new mapboxgl.LngLat(
      n.longitude,
      n.latitude
    );
    this.map[r ? "easeTo" : "jumpTo"]({ center: c, zoom: e - 1 });
  }
}
class Kv extends _c {
  /**
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(e) {
    super(e), this._wrapper.style.position = "relative", this.pin = new mapboxgl.Marker({
      anchor: "top-left",
      element: this._wrapper
    });
  }
  /**
   * @inheritdoc
   */
  setCoordinate(e) {
    this.pin.setLngLat(
      new mapboxgl.LngLat(e.longitude, e.latitude)
    );
  }
  /**
   * @inheritdoc
   */
  setMap(e, n) {
    e ? this.pin.addTo(e.getProviderMap().map) : this.pin.remove();
  }
}
function Uv(t, e, n, { version: r = "v1.13.0" } = {}) {
  const c = `https://api.mapbox.com/mapbox-gl-js/${r}/mapbox-gl`, d = document.createElement("link");
  d.rel = "stylesheet", d.href = c + ".css";
  const h = document.createElement("script");
  h.src = c + ".js", h.onload = () => {
    mapboxgl.accessToken = n, t();
  }, document.head.appendChild(d), document.head.appendChild(h);
}
const DS = new ps().withLoadFunction(Uv).withMapClass(Wv).withPinClass(Kv).withProviderName("Mapbox").build();
let i_ = class extends il {
  /**
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(e) {
    super(e), this._initMap(e), e.controlEnabled && this.map.zoomControl.setPosition("topright"), this.map.on("movestart", () => this._panStartHandler()), this.map.on("moveend", () => this._panHandler());
  }
  /**
   * @inheritdoc
   */
  getCenter() {
    return new nn(this.map.getCenter());
  }
  /**
   * @inheritdoc
   */
  getZoom() {
    return this.map.getZoom();
  }
  /**
   * @inheritdoc
   */
  setCenter(e, n) {
    const r = new L.latLng(e.latitude, e.longitude);
    this.map.panTo(r, { animate: n });
  }
  /**
   * @inheritdoc
   */
  setZoom(e, n) {
    this.map.setZoom(e, { animate: n });
  }
  /**
   * @inheritdoc
   */
  setZoomCenter(e, n, r) {
    const c = new L.latLng(n.latitude, n.longitude);
    this.map.setView(c, e, { animate: r });
  }
  /**
   * Initialize the Leaflet map
   * @protected
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  _initMap(e) {
    this.map = new L.map(e.wrapper, {
      boxZoom: e.controlEnabled,
      doubleClickZoom: e.controlEnabled,
      dragging: e.controlEnabled,
      zoom: 0,
      zoomControl: e.controlEnabled,
      zoomSnap: 0,
      ...e.providerOptions
    });
    const n = e.providerOptions, r = n.tileLayerSrc || "https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token={accessToken}", c = n.tileLayerOptions || {
      attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery  <a href="https://www.mapbox.com/">Mapbox</a>',
      id: "mapbox/streets-v11"
    };
    c.accessToken = this.constructor.apiKey, L.tileLayer(r, c).addTo(this.map);
  }
}, zv = class extends ad {
  /**
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(e) {
    super(e), this.pin = new L.marker(), this.pin.on("click", () => this._clickHandler()), this.pin.on("mouseover", () => this._hoverHandler(!0)), this.pin.on("mouseout", () => this._hoverHandler(!1));
  }
  /**
   * @inheritdoc
   */
  setCoordinate(e) {
    const n = new L.latLng(e.latitude, e.longitude);
    this.pin.setLatLng(n);
  }
  /**
   * @inheritdoc
   */
  setMap(e, n) {
    e ? this.pin.addTo(e.getProviderMap().map) : this.pin.remove();
  }
  /**
   * @inheritdoc
   */
  setProperties(e) {
    const n = e.getWidth(), r = e.getHeight(), c = e.getAnchorX(), d = e.getAnchorY();
    this.pin.setIcon(
      new L.icon({
        iconUrl: this._icons[e.getIcon()],
        iconSize: [n, r],
        iconAnchor: [c * n, d * r],
        className: e.getClass()
      })
    ), this.pin.setZIndexOffset(e.getZIndex());
  }
};
function Gv(t, e, n, { version: r = "1.7.1" } = {}) {
  const c = `https://unpkg.com/leaflet@${r}/dist/leaflet`;
  i_.apiKey = n;
  const d = document.createElement("link");
  d.rel = "stylesheet", d.href = c + ".css";
  const h = document.createElement("script");
  h.src = c + ".js", h.onload = () => t(), document.head.appendChild(d), document.head.appendChild(h);
}
const o_ = new ps().withLoadFunction(Gv).withMapClass(i_).withPinClass(zv).withProviderName("Leaflet").build(), Yv = o_.getMapClass(), Vv = o_.getPinClass();
class jv extends Yv {
  /**
   * @inheritdoc
   */
  _initMap(e) {
    this.map = L.mapquest.map(e.wrapper, {
      boxZoom: e.controlEnabled,
      center: new L.latLng(0, 0),
      doubleClickZoom: e.controlEnabled,
      dragging: e.controlEnabled,
      layers: L.mapquest.tileLayer("map"),
      zoom: 0,
      zoomControl: e.controlEnabled,
      zoomSnap: 0,
      ...e.providerOptions
    });
  }
}
class qv extends Vv {
}
function Zv(t, e, n, { version: r = "v1.3.2" } = {}) {
  const c = `https://api.mqcdn.com/sdk/mapquest-js/${r}/mapquest-maps`, d = document.createElement("link");
  d.rel = "stylesheet", d.href = c + ".css";
  const h = document.createElement("script");
  h.src = c + ".js", h.onload = () => {
    L.mapquest.key = n, t();
  }, document.head.appendChild(d), document.head.appendChild(h);
}
const MS = new ps().withLoadFunction(Zv).withMapClass(jv).withPinClass(qv).withProviderName("MapQuest").build();
export {
  tS as A,
  sS as B,
  lp as C,
  nS as D,
  us as E,
  $y as F,
  aS as G,
  _p as H,
  lS as I,
  uS as J,
  dd as K,
  V_ as L,
  lf as M,
  fS as N,
  dS as O,
  Qy as P,
  hS as Q,
  xS as R,
  vS as S,
  SS as T,
  Jt as U,
  wS as V,
  OS as W,
  gp as X,
  DS as Y,
  o_ as Z,
  MS as _,
  CS as a,
  ac as b,
  TS as c,
  gS as d,
  fg as e,
  mS as f,
  sd as g,
  pS as h,
  NS as i,
  yS as j,
  _S as k,
  GC as l,
  ES as m,
  ta as n,
  LC as o,
  zl as p,
  eS as q,
  qC as r,
  yd as s,
  Sy as t,
  op as u,
  Qp as v,
  mc as w,
  rS as x,
  iS as y,
  oS as z
};
