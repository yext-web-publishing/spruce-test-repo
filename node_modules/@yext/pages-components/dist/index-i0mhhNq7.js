var Sg = Object.defineProperty;
var wg = (e, t, r) => t in e ? Sg(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var Ln = (e, t, r) => (wg(e, typeof t != "symbol" ? t + "" : t, r), r);
import * as Og from "react";
import rn, { createElement as Rg, createContext as ia, useContext as Fo, useState as Tr, useRef as Ac, useEffect as fr, Fragment as Dg, useMemo as Kf } from "react";
import Hf, { createPortal as Ag } from "react-dom";
var Cc = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function bc(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Nc = { exports: {} }, Zs = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Nu;
function bg() {
  return Nu || (Nu = 1, process.env.NODE_ENV !== "production" && function() {
    var e = rn, t = Symbol.for("react.element"), r = Symbol.for("react.portal"), o = Symbol.for("react.fragment"), f = Symbol.for("react.strict_mode"), h = Symbol.for("react.profiler"), C = Symbol.for("react.provider"), T = Symbol.for("react.context"), O = Symbol.for("react.forward_ref"), S = Symbol.for("react.suspense"), x = Symbol.for("react.suspense_list"), D = Symbol.for("react.memo"), k = Symbol.for("react.lazy"), H = Symbol.for("react.offscreen"), N = Symbol.iterator, v = "@@iterator";
    function F(ye) {
      if (ye === null || typeof ye != "object")
        return null;
      var Ge = N && ye[N] || ye[v];
      return typeof Ge == "function" ? Ge : null;
    }
    var U = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function I(ye) {
      {
        for (var Ge = arguments.length, et = new Array(Ge > 1 ? Ge - 1 : 0), _t = 1; _t < Ge; _t++)
          et[_t - 1] = arguments[_t];
        K("error", ye, et);
      }
    }
    function K(ye, Ge, et) {
      {
        var _t = U.ReactDebugCurrentFrame, It = _t.getStackAddendum();
        It !== "" && (Ge += "%s", et = et.concat([It]));
        var Ft = et.map(function(Lt) {
          return String(Lt);
        });
        Ft.unshift("Warning: " + Ge), Function.prototype.apply.call(console[ye], console, Ft);
      }
    }
    var B = !1, z = !1, te = !1, re = !1, de = !1, V;
    V = Symbol.for("react.module.reference");
    function G(ye) {
      return !!(typeof ye == "string" || typeof ye == "function" || ye === o || ye === h || de || ye === f || ye === S || ye === x || re || ye === H || B || z || te || typeof ye == "object" && ye !== null && (ye.$$typeof === k || ye.$$typeof === D || ye.$$typeof === C || ye.$$typeof === T || ye.$$typeof === O || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      ye.$$typeof === V || ye.getModuleId !== void 0));
    }
    function q(ye, Ge, et) {
      var _t = ye.displayName;
      if (_t)
        return _t;
      var It = Ge.displayName || Ge.name || "";
      return It !== "" ? et + "(" + It + ")" : et;
    }
    function me(ye) {
      return ye.displayName || "Context";
    }
    function pe(ye) {
      if (ye == null)
        return null;
      if (typeof ye.tag == "number" && I("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof ye == "function")
        return ye.displayName || ye.name || null;
      if (typeof ye == "string")
        return ye;
      switch (ye) {
        case o:
          return "Fragment";
        case r:
          return "Portal";
        case h:
          return "Profiler";
        case f:
          return "StrictMode";
        case S:
          return "Suspense";
        case x:
          return "SuspenseList";
      }
      if (typeof ye == "object")
        switch (ye.$$typeof) {
          case T:
            var Ge = ye;
            return me(Ge) + ".Consumer";
          case C:
            var et = ye;
            return me(et._context) + ".Provider";
          case O:
            return q(ye, ye.render, "ForwardRef");
          case D:
            var _t = ye.displayName || null;
            return _t !== null ? _t : pe(ye.type) || "Memo";
          case k: {
            var It = ye, Ft = It._payload, Lt = It._init;
            try {
              return pe(Lt(Ft));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Z = Object.assign, ee = 0, P, w, j, ne, Y, W, Q;
    function b() {
    }
    b.__reactDisabledLog = !0;
    function g() {
      {
        if (ee === 0) {
          P = console.log, w = console.info, j = console.warn, ne = console.error, Y = console.group, W = console.groupCollapsed, Q = console.groupEnd;
          var ye = {
            configurable: !0,
            enumerable: !0,
            value: b,
            writable: !0
          };
          Object.defineProperties(console, {
            info: ye,
            log: ye,
            warn: ye,
            error: ye,
            group: ye,
            groupCollapsed: ye,
            groupEnd: ye
          });
        }
        ee++;
      }
    }
    function _() {
      {
        if (ee--, ee === 0) {
          var ye = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Z({}, ye, {
              value: P
            }),
            info: Z({}, ye, {
              value: w
            }),
            warn: Z({}, ye, {
              value: j
            }),
            error: Z({}, ye, {
              value: ne
            }),
            group: Z({}, ye, {
              value: Y
            }),
            groupCollapsed: Z({}, ye, {
              value: W
            }),
            groupEnd: Z({}, ye, {
              value: Q
            })
          });
        }
        ee < 0 && I("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var A = U.ReactCurrentDispatcher, J;
    function ce(ye, Ge, et) {
      {
        if (J === void 0)
          try {
            throw Error();
          } catch (It) {
            var _t = It.stack.trim().match(/\n( *(at )?)/);
            J = _t && _t[1] || "";
          }
        return `
` + J + ye;
      }
    }
    var ge = !1, ae;
    {
      var Te = typeof WeakMap == "function" ? WeakMap : Map;
      ae = new Te();
    }
    function Me(ye, Ge) {
      if (!ye || ge)
        return "";
      {
        var et = ae.get(ye);
        if (et !== void 0)
          return et;
      }
      var _t;
      ge = !0;
      var It = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Ft;
      Ft = A.current, A.current = null, g();
      try {
        if (Ge) {
          var Lt = function() {
            throw Error();
          };
          if (Object.defineProperty(Lt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Lt, []);
            } catch (Kn) {
              _t = Kn;
            }
            Reflect.construct(ye, [], Lt);
          } else {
            try {
              Lt.call();
            } catch (Kn) {
              _t = Kn;
            }
            ye.call(Lt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Kn) {
            _t = Kn;
          }
          ye();
        }
      } catch (Kn) {
        if (Kn && _t && typeof Kn.stack == "string") {
          for (var Mt = Kn.stack.split(`
`), cn = _t.stack.split(`
`), Zt = Mt.length - 1, jt = cn.length - 1; Zt >= 1 && jt >= 0 && Mt[Zt] !== cn[jt]; )
            jt--;
          for (; Zt >= 1 && jt >= 0; Zt--, jt--)
            if (Mt[Zt] !== cn[jt]) {
              if (Zt !== 1 || jt !== 1)
                do
                  if (Zt--, jt--, jt < 0 || Mt[Zt] !== cn[jt]) {
                    var Rn = `
` + Mt[Zt].replace(" at new ", " at ");
                    return ye.displayName && Rn.includes("<anonymous>") && (Rn = Rn.replace("<anonymous>", ye.displayName)), typeof ye == "function" && ae.set(ye, Rn), Rn;
                  }
                while (Zt >= 1 && jt >= 0);
              break;
            }
        }
      } finally {
        ge = !1, A.current = Ft, _(), Error.prepareStackTrace = It;
      }
      var ir = ye ? ye.displayName || ye.name : "", Xr = ir ? ce(ir) : "";
      return typeof ye == "function" && ae.set(ye, Xr), Xr;
    }
    function ze(ye, Ge, et) {
      return Me(ye, !1);
    }
    function oe(ye) {
      var Ge = ye.prototype;
      return !!(Ge && Ge.isReactComponent);
    }
    function ie(ye, Ge, et) {
      if (ye == null)
        return "";
      if (typeof ye == "function")
        return Me(ye, oe(ye));
      if (typeof ye == "string")
        return ce(ye);
      switch (ye) {
        case S:
          return ce("Suspense");
        case x:
          return ce("SuspenseList");
      }
      if (typeof ye == "object")
        switch (ye.$$typeof) {
          case O:
            return ze(ye.render);
          case D:
            return ie(ye.type, Ge, et);
          case k: {
            var _t = ye, It = _t._payload, Ft = _t._init;
            try {
              return ie(Ft(It), Ge, et);
            } catch {
            }
          }
        }
      return "";
    }
    var ue = Object.prototype.hasOwnProperty, we = {}, Le = U.ReactDebugCurrentFrame;
    function Be(ye) {
      if (ye) {
        var Ge = ye._owner, et = ie(ye.type, ye._source, Ge ? Ge.type : null);
        Le.setExtraStackFrame(et);
      } else
        Le.setExtraStackFrame(null);
    }
    function Ye(ye, Ge, et, _t, It) {
      {
        var Ft = Function.call.bind(ue);
        for (var Lt in ye)
          if (Ft(ye, Lt)) {
            var Mt = void 0;
            try {
              if (typeof ye[Lt] != "function") {
                var cn = Error((_t || "React class") + ": " + et + " type `" + Lt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof ye[Lt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw cn.name = "Invariant Violation", cn;
              }
              Mt = ye[Lt](Ge, Lt, _t, et, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Zt) {
              Mt = Zt;
            }
            Mt && !(Mt instanceof Error) && (Be(It), I("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", _t || "React class", et, Lt, typeof Mt), Be(null)), Mt instanceof Error && !(Mt.message in we) && (we[Mt.message] = !0, Be(It), I("Failed %s type: %s", et, Mt.message), Be(null));
          }
      }
    }
    var st = Array.isArray;
    function pt(ye) {
      return st(ye);
    }
    function at(ye) {
      {
        var Ge = typeof Symbol == "function" && Symbol.toStringTag, et = Ge && ye[Symbol.toStringTag] || ye.constructor.name || "Object";
        return et;
      }
    }
    function ve(ye) {
      try {
        return se(ye), !1;
      } catch {
        return !0;
      }
    }
    function se(ye) {
      return "" + ye;
    }
    function he(ye) {
      if (ve(ye))
        return I("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", at(ye)), se(ye);
    }
    var Oe = U.ReactCurrentOwner, be = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Re, He, Ve;
    Ve = {};
    function Qe(ye) {
      if (ue.call(ye, "ref")) {
        var Ge = Object.getOwnPropertyDescriptor(ye, "ref").get;
        if (Ge && Ge.isReactWarning)
          return !1;
      }
      return ye.ref !== void 0;
    }
    function ct(ye) {
      if (ue.call(ye, "key")) {
        var Ge = Object.getOwnPropertyDescriptor(ye, "key").get;
        if (Ge && Ge.isReactWarning)
          return !1;
      }
      return ye.key !== void 0;
    }
    function At(ye, Ge) {
      if (typeof ye.ref == "string" && Oe.current && Ge && Oe.current.stateNode !== Ge) {
        var et = pe(Oe.current.type);
        Ve[et] || (I('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', pe(Oe.current.type), ye.ref), Ve[et] = !0);
      }
    }
    function je(ye, Ge) {
      {
        var et = function() {
          Re || (Re = !0, I("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ge));
        };
        et.isReactWarning = !0, Object.defineProperty(ye, "key", {
          get: et,
          configurable: !0
        });
      }
    }
    function qe(ye, Ge) {
      {
        var et = function() {
          He || (He = !0, I("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ge));
        };
        et.isReactWarning = !0, Object.defineProperty(ye, "ref", {
          get: et,
          configurable: !0
        });
      }
    }
    var nt = function(ye, Ge, et, _t, It, Ft, Lt) {
      var Mt = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: ye,
        key: Ge,
        ref: et,
        props: Lt,
        // Record the component responsible for creating this element.
        _owner: Ft
      };
      return Mt._store = {}, Object.defineProperty(Mt._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Mt, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: _t
      }), Object.defineProperty(Mt, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: It
      }), Object.freeze && (Object.freeze(Mt.props), Object.freeze(Mt)), Mt;
    };
    function gt(ye, Ge, et, _t, It) {
      {
        var Ft, Lt = {}, Mt = null, cn = null;
        et !== void 0 && (he(et), Mt = "" + et), ct(Ge) && (he(Ge.key), Mt = "" + Ge.key), Qe(Ge) && (cn = Ge.ref, At(Ge, It));
        for (Ft in Ge)
          ue.call(Ge, Ft) && !be.hasOwnProperty(Ft) && (Lt[Ft] = Ge[Ft]);
        if (ye && ye.defaultProps) {
          var Zt = ye.defaultProps;
          for (Ft in Zt)
            Lt[Ft] === void 0 && (Lt[Ft] = Zt[Ft]);
        }
        if (Mt || cn) {
          var jt = typeof ye == "function" ? ye.displayName || ye.name || "Unknown" : ye;
          Mt && je(Lt, jt), cn && qe(Lt, jt);
        }
        return nt(ye, Mt, cn, It, _t, Oe.current, Lt);
      }
    }
    var Ct = U.ReactCurrentOwner, xt = U.ReactDebugCurrentFrame;
    function St(ye) {
      if (ye) {
        var Ge = ye._owner, et = ie(ye.type, ye._source, Ge ? Ge.type : null);
        xt.setExtraStackFrame(et);
      } else
        xt.setExtraStackFrame(null);
    }
    var wt;
    wt = !1;
    function Et(ye) {
      return typeof ye == "object" && ye !== null && ye.$$typeof === t;
    }
    function Yt() {
      {
        if (Ct.current) {
          var ye = pe(Ct.current.type);
          if (ye)
            return `

Check the render method of \`` + ye + "`.";
        }
        return "";
      }
    }
    function Dt(ye) {
      {
        if (ye !== void 0) {
          var Ge = ye.fileName.replace(/^.*[\\\/]/, ""), et = ye.lineNumber;
          return `

Check your code at ` + Ge + ":" + et + ".";
        }
        return "";
      }
    }
    var Kt = {};
    function bt(ye) {
      {
        var Ge = Yt();
        if (!Ge) {
          var et = typeof ye == "string" ? ye : ye.displayName || ye.name;
          et && (Ge = `

Check the top-level render call using <` + et + ">.");
        }
        return Ge;
      }
    }
    function nr(ye, Ge) {
      {
        if (!ye._store || ye._store.validated || ye.key != null)
          return;
        ye._store.validated = !0;
        var et = bt(Ge);
        if (Kt[et])
          return;
        Kt[et] = !0;
        var _t = "";
        ye && ye._owner && ye._owner !== Ct.current && (_t = " It was passed a child from " + pe(ye._owner.type) + "."), St(ye), I('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', et, _t), St(null);
      }
    }
    function gr(ye, Ge) {
      {
        if (typeof ye != "object")
          return;
        if (pt(ye))
          for (var et = 0; et < ye.length; et++) {
            var _t = ye[et];
            Et(_t) && nr(_t, Ge);
          }
        else if (Et(ye))
          ye._store && (ye._store.validated = !0);
        else if (ye) {
          var It = F(ye);
          if (typeof It == "function" && It !== ye.entries)
            for (var Ft = It.call(ye), Lt; !(Lt = Ft.next()).done; )
              Et(Lt.value) && nr(Lt.value, Ge);
        }
      }
    }
    function Ci(ye) {
      {
        var Ge = ye.type;
        if (Ge == null || typeof Ge == "string")
          return;
        var et;
        if (typeof Ge == "function")
          et = Ge.propTypes;
        else if (typeof Ge == "object" && (Ge.$$typeof === O || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Ge.$$typeof === D))
          et = Ge.propTypes;
        else
          return;
        if (et) {
          var _t = pe(Ge);
          Ye(et, ye.props, "prop", _t, ye);
        } else if (Ge.PropTypes !== void 0 && !wt) {
          wt = !0;
          var It = pe(Ge);
          I("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", It || "Unknown");
        }
        typeof Ge.getDefaultProps == "function" && !Ge.getDefaultProps.isReactClassApproved && I("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Ho(ye) {
      {
        for (var Ge = Object.keys(ye.props), et = 0; et < Ge.length; et++) {
          var _t = Ge[et];
          if (_t !== "children" && _t !== "key") {
            St(ye), I("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", _t), St(null);
            break;
          }
        }
        ye.ref !== null && (St(ye), I("Invalid attribute `ref` supplied to `React.Fragment`."), St(null));
      }
    }
    function Uo(ye, Ge, et, _t, It, Ft) {
      {
        var Lt = G(ye);
        if (!Lt) {
          var Mt = "";
          (ye === void 0 || typeof ye == "object" && ye !== null && Object.keys(ye).length === 0) && (Mt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var cn = Dt(It);
          cn ? Mt += cn : Mt += Yt();
          var Zt;
          ye === null ? Zt = "null" : pt(ye) ? Zt = "array" : ye !== void 0 && ye.$$typeof === t ? (Zt = "<" + (pe(ye.type) || "Unknown") + " />", Mt = " Did you accidentally export a JSX literal instead of a component?") : Zt = typeof ye, I("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Zt, Mt);
        }
        var jt = gt(ye, Ge, et, It, Ft);
        if (jt == null)
          return jt;
        if (Lt) {
          var Rn = Ge.children;
          if (Rn !== void 0)
            if (_t)
              if (pt(Rn)) {
                for (var ir = 0; ir < Rn.length; ir++)
                  gr(Rn[ir], ye);
                Object.freeze && Object.freeze(Rn);
              } else
                I("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              gr(Rn, ye);
        }
        return ye === o ? Ho(jt) : Ci(jt), jt;
      }
    }
    function on(ye, Ge, et) {
      return Uo(ye, Ge, et, !0);
    }
    function rr(ye, Ge, et) {
      return Uo(ye, Ge, et, !1);
    }
    var Fr = rr, Wo = on;
    Zs.Fragment = o, Zs.jsx = Fr, Zs.jsxs = Wo;
  }()), Zs;
}
var Xs = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Eu;
function Mg() {
  if (Eu)
    return Xs;
  Eu = 1;
  var e = rn, t = Symbol.for("react.element"), r = Symbol.for("react.fragment"), o = Object.prototype.hasOwnProperty, f = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, h = { key: !0, ref: !0, __self: !0, __source: !0 };
  function C(T, O, S) {
    var x, D = {}, k = null, H = null;
    S !== void 0 && (k = "" + S), O.key !== void 0 && (k = "" + O.key), O.ref !== void 0 && (H = O.ref);
    for (x in O)
      o.call(O, x) && !h.hasOwnProperty(x) && (D[x] = O[x]);
    if (T && T.defaultProps)
      for (x in O = T.defaultProps, O)
        D[x] === void 0 && (D[x] = O[x]);
    return { $$typeof: t, type: T, key: k, ref: H, props: D, _owner: f.current };
  }
  return Xs.Fragment = r, Xs.jsx = C, Xs.jsxs = C, Xs;
}
process.env.NODE_ENV === "production" ? Nc.exports = Mg() : Nc.exports = bg();
var yt = Nc.exports;
function Lg(e) {
  switch (e) {
    case "AD":
    case "AM":
    case "AT":
    case "AX":
    case "AZ":
    case "BA":
    case "BY":
    case "CY":
    case "CZ":
    case "DK":
    case "DZ":
    case "EC":
    case "EH":
    case "ET":
    case "FI":
    case "FR":
    case "GE":
    case "GF":
    case "GI":
    case "GP":
    case "GW":
    case "HT":
    case "KE":
    case "KV":
    case "KW":
    case "LA":
    case "LU":
    case "MC":
    case "MD":
    case "ME":
    case "MG":
    case "MK":
    case "MQ":
    case "MZ":
    case "NC":
    case "NL":
    case "NO":
    case "PL":
    case "PT":
    case "PY":
    case "RE":
    case "RS":
    case "SA":
    case "SE":
    case "SJ":
    case "SM":
    case "SN":
    case "TC":
    case "TJ":
    case "TM":
    case "TN":
    case "TZ":
    case "UY":
    case "VG":
    case "ZM":
      return [["line1"], ["line2"], ["postalCode", "city"], ["countryCode"]];
    case "AF":
    case "IR":
      return [
        ["line1"],
        ["line2"],
        ["city"],
        ["region"],
        ["postalCode"],
        ["countryCode"]
      ];
    case "AG":
    case "AO":
    case "AW":
    case "BJ":
    case "BO":
    case "BS":
    case "BZ":
    case "CI":
    case "CW":
    case "DJ":
    case "FJ":
    case "GA":
    case "GH":
    case "GM":
    case "GY":
    case "JM":
    case "KI":
    case "LY":
    case "MW":
    case "NA":
    case "NR":
    case "PS":
    case "QA":
    case "RW":
    case "SC":
    case "SR":
    case "SX":
    case "TG":
    case "TT":
    case "UG":
    case "VU":
      return [["line1"], ["line2"], ["city"], ["countryCode"]];
    case "AL":
    case "EE":
    case "IS":
      return [["line1"], ["line2"], ["postalCode", "city"]];
    case "AR":
      return [
        ["line1"],
        ["line2"],
        ["postalCode", "city", ",", "region"],
        ["countryCode"]
      ];
    case "AS":
    case "BB":
    case "BD":
    case "BM":
    case "BN":
    case "BT":
    case "CR":
    case "DO":
    case "FK":
    case "FM":
    case "GR":
    case "GU":
    case "JO":
    case "KZ":
    case "LB":
    case "LK":
    case "LS":
    case "MA":
    case "MH":
    case "MM":
    case "MR":
    case "MT":
    case "MV":
    case "NG":
    case "PG":
    case "PK":
    case "PR":
    case "RO":
    case "SG":
    case "VC":
    case "WS":
      return [["line1"], ["line2"], ["city", "postalCode"], ["countryCode"]];
    case "AU":
    case "CA":
    case "SZ":
    case "US":
    case "VI":
      return [
        ["line1"],
        ["line2"],
        ["city", ",", "region", "postalCode"],
        ["countryCode"]
      ];
    case "BE":
    case "PE":
      return [
        ["line1"],
        ["line2"],
        ["postalCode", "sublocality", "city"],
        ["countryCode"]
      ];
    case "BF":
    case "BI":
    case "BQ":
    case "BW":
    case "CF":
    case "CG":
    case "CM":
    case "DM":
    case "ER":
    case "GQ":
    case "KM":
    case "ML":
    case "SY":
    case "TD":
    case "ZW":
      return [["line1"], ["line2"], ["city"], ["region"], ["countryCode"]];
    case "BG":
      return [["line1"], ["postalCode", "region"], ["countryCode"]];
    case "BH":
      return [["line1"], ["line2"], ["sublocality", "city"], ["countryCode"]];
    case "BR":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["city", "region"],
        ["postalCode"],
        ["countryCode"]
      ];
    case "CH":
    case "DE":
    case "GT":
    case "IT":
    case "LI":
    case "MY":
    case "NI":
    case "OM":
    case "SK":
    case "VA":
      return [
        ["line1"],
        ["line2"],
        ["postalCode", "city", "region"],
        ["countryCode"]
      ];
    case "CL":
    case "PF":
      return [
        ["line1"],
        ["line2"],
        ["city", "postalCode", "region"],
        ["countryCode"]
      ];
    case "CN":
      return [
        ["region", "city", "sublocality"],
        ["line1"],
        ["line2"],
        ["countryCode"]
      ];
    case "CO":
    case "ID":
    case "IQ":
    case "KH":
    case "MP":
    case "NP":
    case "PW":
    case "UA":
      return [
        ["line1"],
        ["line2"],
        ["city", "region", "postalCode"],
        ["countryCode"]
      ];
    case "EG":
      return [
        ["line1"],
        ["line2"],
        ["sublocality", "city", "region", "postalCode"],
        ["countryCode"]
      ];
    case "ES":
    case "IL":
      return [
        ["line1"],
        ["line2"],
        ["city", "postalCode"],
        ["region"],
        ["countryCode"]
      ];
    case "GB":
    case "MN":
    case "ZA":
      return [
        ["line1"],
        ["line2"],
        ["sublocality", "city", "postalCode"],
        ["countryCode"]
      ];
    case "GG":
    case "IM":
    case "JE":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["city"],
        ["postalCode"],
        ["countryCode"]
      ];
    case "GN":
      return [["line1", "line2", "city"], ["countryCode"]];
    case "HK":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["city"],
        ["region"],
        ["countryCode"]
      ];
    case "HR":
      return [["line1"], ["postalCode", "city", "region"], ["countryCode"]];
    case "HU":
    case "SI":
      return [["postalCode", "city"], ["line1"], ["line2"], ["countryCode"]];
    case "IE":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["city", "region", "postalCode"],
        ["countryCode"]
      ];
    case "IN":
    case "VE":
      return [
        ["line1"],
        ["line2"],
        ["city", "postalCode"],
        ["region"],
        ["countryCode"]
      ];
    case "JP":
      return [
        ["line2"],
        ["line1", "sublocality"],
        ["city", "region"],
        ["postalCode"],
        ["countryCode"]
      ];
    case "KR":
      return [
        ["countryCode"],
        ["region", "city", "sublocality", "line1"],
        ["line2"],
        ["postalCode"]
      ];
    case "KY":
      return [["line1"], ["line2"], ["postalCode"], ["countryCode"]];
    case "LT":
      return [
        ["line1"],
        ["postalCode", "city", "sublocality", "region"],
        ["countryCode"]
      ];
    case "LV":
      return [["line1"], ["city", ",", "postalCode"], ["countryCode"]];
    case "MO":
      return [["line1"], ["line2"], ["sublocality"], ["city"], ["countryCode"]];
    case "MU":
      return [
        ["line1"],
        ["line2"],
        ["city"],
        ["region", "postalCode"],
        ["countryCode"]
      ];
    case "MX":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["postalCode", "city", ",", "region"],
        ["countryCode"]
      ];
    case "NE":
    case "SD":
      return [
        ["line1"],
        ["line2"],
        ["postalCode"],
        ["city"],
        ["region"],
        ["countryCode"]
      ];
    case "NZ":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["city"],
        ["postalCode"],
        ["countryCode"]
      ];
    case "PH":
    case "TW":
    case "VN":
      return [
        ["line1"],
        ["line2"],
        ["sublocality", "city"],
        ["region", "postalCode"],
        ["countryCode"]
      ];
    case "RU":
      return [["line1"], ["line2"], ["city"], ["postalCode"], ["countryCode"]];
    case "SB":
    case "SL":
    case "ST":
    case "TL":
    case "TO":
    case "TV":
      return [["line1"], ["line2"], ["city", ",", "region"], ["countryCode"]];
    case "TH":
    case "TR":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["postalCode", "city"],
        ["countryCode"]
      ];
    case "UZ":
      return [["line1"], ["line2"], ["region", "postalCode"], ["countryCode"]];
  }
  return [
    ["line1", "line2"],
    ["city", "region", "postalCode"],
    ["countryCode"]
  ];
}
const Pg = {
  GOOGLEMYBUSINESS: "GOOGLEMYBUSINESS"
}, Tu = {
  GOOGLE: "google",
  APPLE: "apple",
  BING: "bing"
}, Ig = (e, t) => {
  const o = {
    region: "localizedRegionName",
    countryCode: "localizedCountryName"
  }[e];
  return o && t[o];
}, $C = (e, t = [], r, o = {
  route: !1
}) => {
  const f = "Failed to construct query for maps service.";
  let h = e && xu([
    e.line1,
    e.line2,
    e.city,
    e.region,
    e.postalCode,
    e.countryCode
  ]);
  switch (o.provider) {
    case Tu.APPLE: {
      if (!h) {
        console.warn(
          `${f} Check that you've provided a valid Yext Address.`
        );
        break;
      }
      return kg(h, o.route);
    }
    case Tu.BING: {
      if (h = e && xu([
        e.line1,
        e.city,
        e.region,
        e.postalCode
      ]), !h) {
        console.warn(
          `${f} Check that you've provided a valid Yext Address.`
        );
        break;
      }
      return $g(h, o.route);
    }
    default: {
      const C = t.find(
        (T) => {
          var O;
          return ((O = T == null ? void 0 : T.publisher) == null ? void 0 : O.toUpperCase()) === Pg.GOOGLEMYBUSINESS;
        }
      );
      if (C != null && C.listingUrl)
        return C.listingUrl;
      if (r)
        return Fg(r, h, o.route);
      if (!h) {
        console.warn(
          `${f} Check that you've provided a valid Yext Address, Yext ListingType, or Google Place ID.`
        );
        break;
      }
      return Bg(h, o.route);
    }
  }
}, kg = (e, t) => t ? `https://maps.apple.com/?daddr=${e}` : `https://maps.apple.com/?address=${e}`, $g = (e, t) => t ? `https://bing.com/maps/default.aspx?rtp=adr.${e}` : `https://bing.com/maps/default.aspx?where1=${e}`, Fg = (e, t, r) => {
  const o = t ? `&query=${t}` : "";
  return r ? `https://maps.google.com/maps/dir/?api=1${o}&destination_place_id=${e}&destination=direct` : o ? `https://maps.google.com/maps/search/?api=1${o}&query_place_id=${e}` : `https://maps.google.com/maps/dir/?api=1&destination_place_id=${e}&destination=direct`;
}, Bg = (e, t) => t ? `https://maps.google.com/maps/dir/?api=1&destination=${e}` : `https://maps.google.com/maps/search/?api=1&query=${e}`, xu = (e = []) => {
  if (!e.length)
    return "";
  const t = e.filter(Boolean).join(", ");
  return encodeURI(t);
}, FC = ({
  address: e,
  lines: t,
  separator: r = ",",
  ...o
}) => {
  const f = (t || Lg(e.countryCode)).map(
    (h) => /* @__PURE__ */ yt.jsx(
      Kg,
      {
        address: e,
        line: h,
        separator: r
      },
      h.toString()
    )
  );
  return /* @__PURE__ */ Rg("div", { ...o, key: e.toString() }, f);
}, Kg = ({
  address: e,
  line: t,
  separator: r
}) => {
  const o = [];
  for (const f of t) {
    if (f === ",") {
      o.push(/* @__PURE__ */ yt.jsx("span", { children: r }, f));
      continue;
    }
    const h = e[f];
    if (!h)
      continue;
    const C = Ig(f, e);
    if (C) {
      o.push(
        /* @__PURE__ */ yt.jsxs(Og.Fragment, { children: [
          " ",
          /* @__PURE__ */ yt.jsx("abbr", { title: C, children: h })
        ] }, f)
      );
      continue;
    }
    o.push(/* @__PURE__ */ yt.jsx("span", { children: " " + h }, f));
  }
  return /* @__PURE__ */ yt.jsx("div", { className: "address-line", children: o });
};
var Cs = {};
Object.defineProperty(Cs, "__esModule", {
  value: !0
});
var Hg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
  return typeof e;
} : function(e) {
  return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
}, Ug = typeof window < "u" && typeof window.document < "u", Wg = typeof process < "u" && process.versions != null && process.versions.node != null, zg = (typeof self > "u" ? "undefined" : Hg(self)) === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope", Gg = typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom")), Yg = typeof Deno < "u" && typeof Deno.version < "u" && typeof Deno.version.deno < "u", vu = Cs.isBrowser = Ug;
Cs.isWebWorker = zg;
var jg = Cs.isNode = Wg;
Cs.isJsDom = Gg;
var qg = Cs.isDeno = Yg;
class Vg {
  constructor() {
    Ln(this, "name");
    /**
     * Whether or not the current runtime is being executed server-side or client-side. If the runtime
     * is node or deno then isServerSide will be true. When the runtime is browser isServerSide is
     * false.
     */
    Ln(this, "isServerSide");
    Ln(this, "version");
    var t;
    qg ? (this.name = "deno", this.version = "", vu && (this.version = ((t = window.Deno) == null ? void 0 : t.version.deno) || ""), this.isServerSide = !0) : jg ? (this.name = "node", this.version = process.versions.node, this.isServerSide = !0) : vu ? (this.name = "browser", this.version = navigator.userAgent, this.isServerSide = !1) : (this.name = "unknown", this.version = "", this.isServerSide = !1);
  }
  getNodeMajorVersion() {
    if (this.name !== "node")
      throw new Error("Not running in Node.");
    return +this.version.split(".")[0];
  }
}
const ys = () => new Vg(), Jg = (...e) => {
  var o;
  if (ys().name !== "browser")
    return !1;
  const r = (o = window == null ? void 0 : window.location) == null ? void 0 : o.hostname;
  return e.length === 0 ? r !== "localhost" && !r.includes("preview.pagescdn.com") : e.some((f) => f == null ? void 0 : f.includes(r));
};
var Ec = { exports: {} };
(function(e, t) {
  var r = typeof self < "u" ? self : Cc, o = function() {
    function h() {
      this.fetch = !1, this.DOMException = r.DOMException;
    }
    return h.prototype = r, new h();
  }();
  (function(h) {
    (function(C) {
      var T = {
        searchParams: "URLSearchParams" in h,
        iterable: "Symbol" in h && "iterator" in Symbol,
        blob: "FileReader" in h && "Blob" in h && function() {
          try {
            return new Blob(), !0;
          } catch {
            return !1;
          }
        }(),
        formData: "FormData" in h,
        arrayBuffer: "ArrayBuffer" in h
      };
      function O(Z) {
        return Z && DataView.prototype.isPrototypeOf(Z);
      }
      if (T.arrayBuffer)
        var S = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ], x = ArrayBuffer.isView || function(Z) {
          return Z && S.indexOf(Object.prototype.toString.call(Z)) > -1;
        };
      function D(Z) {
        if (typeof Z != "string" && (Z = String(Z)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(Z))
          throw new TypeError("Invalid character in header field name");
        return Z.toLowerCase();
      }
      function k(Z) {
        return typeof Z != "string" && (Z = String(Z)), Z;
      }
      function H(Z) {
        var ee = {
          next: function() {
            var P = Z.shift();
            return { done: P === void 0, value: P };
          }
        };
        return T.iterable && (ee[Symbol.iterator] = function() {
          return ee;
        }), ee;
      }
      function N(Z) {
        this.map = {}, Z instanceof N ? Z.forEach(function(ee, P) {
          this.append(P, ee);
        }, this) : Array.isArray(Z) ? Z.forEach(function(ee) {
          this.append(ee[0], ee[1]);
        }, this) : Z && Object.getOwnPropertyNames(Z).forEach(function(ee) {
          this.append(ee, Z[ee]);
        }, this);
      }
      N.prototype.append = function(Z, ee) {
        Z = D(Z), ee = k(ee);
        var P = this.map[Z];
        this.map[Z] = P ? P + ", " + ee : ee;
      }, N.prototype.delete = function(Z) {
        delete this.map[D(Z)];
      }, N.prototype.get = function(Z) {
        return Z = D(Z), this.has(Z) ? this.map[Z] : null;
      }, N.prototype.has = function(Z) {
        return this.map.hasOwnProperty(D(Z));
      }, N.prototype.set = function(Z, ee) {
        this.map[D(Z)] = k(ee);
      }, N.prototype.forEach = function(Z, ee) {
        for (var P in this.map)
          this.map.hasOwnProperty(P) && Z.call(ee, this.map[P], P, this);
      }, N.prototype.keys = function() {
        var Z = [];
        return this.forEach(function(ee, P) {
          Z.push(P);
        }), H(Z);
      }, N.prototype.values = function() {
        var Z = [];
        return this.forEach(function(ee) {
          Z.push(ee);
        }), H(Z);
      }, N.prototype.entries = function() {
        var Z = [];
        return this.forEach(function(ee, P) {
          Z.push([P, ee]);
        }), H(Z);
      }, T.iterable && (N.prototype[Symbol.iterator] = N.prototype.entries);
      function v(Z) {
        if (Z.bodyUsed)
          return Promise.reject(new TypeError("Already read"));
        Z.bodyUsed = !0;
      }
      function F(Z) {
        return new Promise(function(ee, P) {
          Z.onload = function() {
            ee(Z.result);
          }, Z.onerror = function() {
            P(Z.error);
          };
        });
      }
      function U(Z) {
        var ee = new FileReader(), P = F(ee);
        return ee.readAsArrayBuffer(Z), P;
      }
      function I(Z) {
        var ee = new FileReader(), P = F(ee);
        return ee.readAsText(Z), P;
      }
      function K(Z) {
        for (var ee = new Uint8Array(Z), P = new Array(ee.length), w = 0; w < ee.length; w++)
          P[w] = String.fromCharCode(ee[w]);
        return P.join("");
      }
      function B(Z) {
        if (Z.slice)
          return Z.slice(0);
        var ee = new Uint8Array(Z.byteLength);
        return ee.set(new Uint8Array(Z)), ee.buffer;
      }
      function z() {
        return this.bodyUsed = !1, this._initBody = function(Z) {
          this._bodyInit = Z, Z ? typeof Z == "string" ? this._bodyText = Z : T.blob && Blob.prototype.isPrototypeOf(Z) ? this._bodyBlob = Z : T.formData && FormData.prototype.isPrototypeOf(Z) ? this._bodyFormData = Z : T.searchParams && URLSearchParams.prototype.isPrototypeOf(Z) ? this._bodyText = Z.toString() : T.arrayBuffer && T.blob && O(Z) ? (this._bodyArrayBuffer = B(Z.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : T.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(Z) || x(Z)) ? this._bodyArrayBuffer = B(Z) : this._bodyText = Z = Object.prototype.toString.call(Z) : this._bodyText = "", this.headers.get("content-type") || (typeof Z == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : T.searchParams && URLSearchParams.prototype.isPrototypeOf(Z) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, T.blob && (this.blob = function() {
          var Z = v(this);
          if (Z)
            return Z;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }, this.arrayBuffer = function() {
          return this._bodyArrayBuffer ? v(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(U);
        }), this.text = function() {
          var Z = v(this);
          if (Z)
            return Z;
          if (this._bodyBlob)
            return I(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(K(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, T.formData && (this.formData = function() {
          return this.text().then(V);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      var te = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function re(Z) {
        var ee = Z.toUpperCase();
        return te.indexOf(ee) > -1 ? ee : Z;
      }
      function de(Z, ee) {
        ee = ee || {};
        var P = ee.body;
        if (Z instanceof de) {
          if (Z.bodyUsed)
            throw new TypeError("Already read");
          this.url = Z.url, this.credentials = Z.credentials, ee.headers || (this.headers = new N(Z.headers)), this.method = Z.method, this.mode = Z.mode, this.signal = Z.signal, !P && Z._bodyInit != null && (P = Z._bodyInit, Z.bodyUsed = !0);
        } else
          this.url = String(Z);
        if (this.credentials = ee.credentials || this.credentials || "same-origin", (ee.headers || !this.headers) && (this.headers = new N(ee.headers)), this.method = re(ee.method || this.method || "GET"), this.mode = ee.mode || this.mode || null, this.signal = ee.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && P)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(P);
      }
      de.prototype.clone = function() {
        return new de(this, { body: this._bodyInit });
      };
      function V(Z) {
        var ee = new FormData();
        return Z.trim().split("&").forEach(function(P) {
          if (P) {
            var w = P.split("="), j = w.shift().replace(/\+/g, " "), ne = w.join("=").replace(/\+/g, " ");
            ee.append(decodeURIComponent(j), decodeURIComponent(ne));
          }
        }), ee;
      }
      function G(Z) {
        var ee = new N(), P = Z.replace(/\r?\n[\t ]+/g, " ");
        return P.split(/\r?\n/).forEach(function(w) {
          var j = w.split(":"), ne = j.shift().trim();
          if (ne) {
            var Y = j.join(":").trim();
            ee.append(ne, Y);
          }
        }), ee;
      }
      z.call(de.prototype);
      function q(Z, ee) {
        ee || (ee = {}), this.type = "default", this.status = ee.status === void 0 ? 200 : ee.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in ee ? ee.statusText : "OK", this.headers = new N(ee.headers), this.url = ee.url || "", this._initBody(Z);
      }
      z.call(q.prototype), q.prototype.clone = function() {
        return new q(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new N(this.headers),
          url: this.url
        });
      }, q.error = function() {
        var Z = new q(null, { status: 0, statusText: "" });
        return Z.type = "error", Z;
      };
      var me = [301, 302, 303, 307, 308];
      q.redirect = function(Z, ee) {
        if (me.indexOf(ee) === -1)
          throw new RangeError("Invalid status code");
        return new q(null, { status: ee, headers: { location: Z } });
      }, C.DOMException = h.DOMException;
      try {
        new C.DOMException();
      } catch {
        C.DOMException = function(ee, P) {
          this.message = ee, this.name = P;
          var w = Error(ee);
          this.stack = w.stack;
        }, C.DOMException.prototype = Object.create(Error.prototype), C.DOMException.prototype.constructor = C.DOMException;
      }
      function pe(Z, ee) {
        return new Promise(function(P, w) {
          var j = new de(Z, ee);
          if (j.signal && j.signal.aborted)
            return w(new C.DOMException("Aborted", "AbortError"));
          var ne = new XMLHttpRequest();
          function Y() {
            ne.abort();
          }
          ne.onload = function() {
            var W = {
              status: ne.status,
              statusText: ne.statusText,
              headers: G(ne.getAllResponseHeaders() || "")
            };
            W.url = "responseURL" in ne ? ne.responseURL : W.headers.get("X-Request-URL");
            var Q = "response" in ne ? ne.response : ne.responseText;
            P(new q(Q, W));
          }, ne.onerror = function() {
            w(new TypeError("Network request failed"));
          }, ne.ontimeout = function() {
            w(new TypeError("Network request failed"));
          }, ne.onabort = function() {
            w(new C.DOMException("Aborted", "AbortError"));
          }, ne.open(j.method, j.url, !0), j.credentials === "include" ? ne.withCredentials = !0 : j.credentials === "omit" && (ne.withCredentials = !1), "responseType" in ne && T.blob && (ne.responseType = "blob"), j.headers.forEach(function(W, Q) {
            ne.setRequestHeader(Q, W);
          }), j.signal && (j.signal.addEventListener("abort", Y), ne.onreadystatechange = function() {
            ne.readyState === 4 && j.signal.removeEventListener("abort", Y);
          }), ne.send(typeof j._bodyInit > "u" ? null : j._bodyInit);
        });
      }
      return pe.polyfill = !0, h.fetch || (h.fetch = pe, h.Headers = N, h.Request = de, h.Response = q), C.Headers = N, C.Request = de, C.Response = q, C.fetch = pe, Object.defineProperty(C, "__esModule", { value: !0 }), C;
    })({});
  })(o), o.fetch.ponyfill = !0, delete o.fetch.polyfill;
  var f = o;
  t = f.fetch, t.default = f.fetch, t.fetch = f.fetch, t.Headers = f.Headers, t.Request = f.Request, t.Response = f.Response, e.exports = t;
})(Ec, Ec.exports);
var Zg = Ec.exports;
const Su = /* @__PURE__ */ bc(Zg);
var Xg = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.post = function(t, r, o) {
      var f = JSON.stringify(r), h = {
        method: "POST",
        headers: o,
        body: f,
        keepalive: !0
      };
      return typeof window < "u" && window.fetch ? window.fetch(t, h) : Su(t, h);
    }, e.prototype.get = function(t) {
      var r = {
        method: "GET",
        mode: "no-cors",
        keepalive: !0
      };
      return typeof window < "u" && window.fetch ? window.fetch(t, r) : Su(t, r);
    }, e;
  }()
), Qg = {
  US: {
    PRODUCTION: "https://us.yextevents.com",
    SANDBOX: "https://sbx.us.yextevents.com"
  },
  EU: {
    PRODUCTION: "https://eu.yextevents.com",
    SANDBOX: void 0
  }
}, ep = {
  US: {
    PRODUCTION: "https://realtimeanalytics.yext.com",
    SANDBOX: "https://sandbox-realtimeanalytics.yext.com"
  },
  EU: {
    PRODUCTION: void 0,
    SANDBOX: void 0
  }
};
function tp(e, t) {
  var r = t ? Mc(e) : ip(e);
  return "".concat(r, "/store_pagespixel");
}
function np() {
  var e = Mc("US", "PRODUCTION");
  return "".concat(e, "/conversiontracking/conversion");
}
function rp() {
  var e = Mc("US", "PRODUCTION");
  return "".concat(e, "/listings");
}
function Mc(e, t) {
  return Uf(ep, e, t, !0);
}
function ip(e, t) {
  return Uf(Qg, e, t);
}
function Uf(e, t, r, o) {
  t === void 0 && (t = "US"), r === void 0 && (r = "PRODUCTION"), o === void 0 && (o = !1);
  var f = e[t][r];
  if (!f)
    throw Error('The combination of the environment: "'.concat(r, '", region: "').concat(t, '",') + 'and conversionTrackingEnabled: "'.concat(o, '" is unsupported.'));
  return f;
}
var wu;
(function(e) {
  e.AllTabNavigation = "ALL_TAB_NAVIGATION", e.VerticalTabNavigation = "VERTICAL_TAB_NAVIGATION", e.ScrollToBottomOfPage = "SCROLL_TO_BOTTOM_OF_PAGE", e.QuestionFocus = "QUESTION_FOCUS", e.QuestionSubmit = "QUESTION_SUBMIT", e.RowExpand = "ROW_EXPAND", e.RowCollapse = "ROW_COLLAPSE", e.ThumbsUp = "THUMBS_UP", e.ThumbsDown = "THUMBS_DOWN", e.VoiceStart = "VOICE_START", e.VoiceStop = "VOICE_STOP", e.SearchBarImpression = "SEARCH_BAR_IMPRESSION", e.SearchClearButton = "SEARCH_CLEAR_BUTTON", e.Paginate = "PAGINATE", e.AutocompleteSelection = "AUTO_COMPLETE_SELECTION", e.VerticalViewAll = "VERTICAL_VIEW_ALL", e.CtaClick = "CTA_CLICK", e.TitleClick = "TITLE_CLICK", e.TapToCall = "TAP_TO_CALL", e.OrderNow = "ORDER_NOW", e.AddToCart = "ADD_TO_CART", e.ApplyNow = "APPLY_NOW", e.DrivingDirections = "DRIVING_DIRECTIONS", e.ViewWebsite = "VIEW_WEBSITE", e.Email = "EMAIL", e.BookAppointment = "BOOK_APPOINTMENT", e.Rsvp = "RSVP", e.ResultsHidden = "RESULTS_HIDDEN", e.ResultsUnhidden = "RESULTS_UNHIDDEN", e.FollowUpQuery = "FOLLOW_UP_QUERY";
})(wu || (wu = {}));
var $r;
(function(e) {
  e.PageView = "PAGE_VIEW", e.CTA = "CTA_CLICK", e.Website = "WEBSITE", e.DrivingDirection = "DRIVING_DIRECTIONS", e.PhoneCall = "CALL";
})($r || ($r = {}));
$r.CTA;
$r.Website;
$r.DrivingDirection;
var op = {
  eventType: $r.PageView
};
$r.PhoneCall;
var Ou;
(function(e) {
  e.Production = "PRODUCTION", e.Sandbox = "SANDBOX";
})(Ou || (Ou = {}));
var Ru;
(function(e) {
  e.US = "US", e.EU = "EU";
})(Ru || (Ru = {}));
var ol = "_yfpc", Aa = "__temp__", Wf = "y_source";
function zf() {
  return Date.now() + Math.floor(1e3 * Math.random());
}
var ba = function(e, t, r, o) {
  function f(h) {
    return h instanceof r ? h : new r(function(C) {
      C(h);
    });
  }
  return new (r || (r = Promise))(function(h, C) {
    function T(x) {
      try {
        S(o.next(x));
      } catch (D) {
        C(D);
      }
    }
    function O(x) {
      try {
        S(o.throw(x));
      } catch (D) {
        C(D);
      }
    }
    function S(x) {
      x.done ? h(x.value) : f(x.value).then(T, O);
    }
    S((o = o.apply(e, t || [])).next());
  });
}, Ma = function(e, t) {
  var r = { label: 0, sent: function() {
    if (h[0] & 1)
      throw h[1];
    return h[1];
  }, trys: [], ops: [] }, o, f, h, C;
  return C = { next: T(0), throw: T(1), return: T(2) }, typeof Symbol == "function" && (C[Symbol.iterator] = function() {
    return this;
  }), C;
  function T(S) {
    return function(x) {
      return O([S, x]);
    };
  }
  function O(S) {
    if (o)
      throw new TypeError("Generator is already executing.");
    for (; r; )
      try {
        if (o = 1, f && (h = S[0] & 2 ? f.return : S[0] ? f.throw || ((h = f.return) && h.call(f), 0) : f.next) && !(h = h.call(f, S[1])).done)
          return h;
        switch (f = 0, h && (S = [S[0] & 2, h.value]), S[0]) {
          case 0:
          case 1:
            h = S;
            break;
          case 4:
            return r.label++, { value: S[1], done: !1 };
          case 5:
            r.label++, f = S[1], S = [0];
            continue;
          case 7:
            S = r.ops.pop(), r.trys.pop();
            continue;
          default:
            if (h = r.trys, !(h = h.length > 0 && h[h.length - 1]) && (S[0] === 6 || S[0] === 2)) {
              r = 0;
              continue;
            }
            if (S[0] === 3 && (!h || S[1] > h[0] && S[1] < h[3])) {
              r.label = S[1];
              break;
            }
            if (S[0] === 6 && r.label < h[1]) {
              r.label = h[1], h = S;
              break;
            }
            if (h && r.label < h[2]) {
              r.label = h[2], r.ops.push(S);
              break;
            }
            h[2] && r.ops.pop(), r.trys.pop();
            continue;
        }
        S = t.call(e, r);
      } catch (x) {
        S = [6, x], f = 0;
      } finally {
        o = h = 0;
      }
    if (S[0] & 5)
      throw S[1];
    return { value: S[0] ? S[1] : void 0, done: !0 };
  }
}, sp = (
  /** @class */
  function() {
    function e(t, r) {
      this.httpRequesterService = t, this.debug = r, this._debug = r, this._conversionTrackingEndpoint = np(), this._conversionTrackingListingsEndpoint = rp();
    }
    return e.prototype.printEvent = function(t, r) {
      this._debug && console.log("%c[YextAnalytics]%c- Tracked ".concat(r, " event: ").concat(t), "background: white; color: blue;", "");
    }, e.prototype.handleRequest = function(t) {
      return ba(this, void 0, void 0, function() {
        var r, o;
        return Ma(this, function(f) {
          switch (f.label) {
            case 0:
              return [4, this.httpRequesterService.get(t.toString())];
            case 1:
              return r = f.sent(), r.status !== 200 && !(r.type === "opaqueredirect" || r.type === "opaque") ? [4, r.text()] : [3, 3];
            case 2:
              throw o = f.sent(), new Error(o);
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.formatBaseEvent = function(t, r) {
      r.set(ol, t.cookieId), t.referrer && r.set("referrer", t.referrer), r.set("v", zf().toString()), r.set("location", t.location);
    }, e.prototype.trackConversion = function(t) {
      return ba(this, void 0, void 0, function() {
        var r, o;
        return Ma(this, function(f) {
          switch (f.label) {
            case 0:
              return r = new URL(this._conversionTrackingEndpoint), o = new URLSearchParams(), o.set("cid", t.cid), t.cv && o.set("cv", t.cv), e.formatBaseEvent(t, o), r.search = o.toString(), [4, this.handleRequest(r.toString())];
            case 1:
              return f.sent(), this.printEvent(t.cid, "Conversion"), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.trackListings = function(t) {
      return ba(this, void 0, void 0, function() {
        var r, o;
        return Ma(this, function(f) {
          switch (f.label) {
            case 0:
              return r = new URL(this._conversionTrackingListingsEndpoint), o = new URLSearchParams(), o.set(Wf, t.source), e.formatBaseEvent(t, o), r.search = o.toString(), [4, this.handleRequest(r.toString())];
            case 1:
              return f.sent(), this.printEvent(t.source, "Listings Click"), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.setDebugEnabled = function(t) {
      this._debug = t;
    }, e;
  }()
), Du = function(e, t, r, o) {
  function f(h) {
    return h instanceof r ? h : new r(function(C) {
      C(h);
    });
  }
  return new (r || (r = Promise))(function(h, C) {
    function T(x) {
      try {
        S(o.next(x));
      } catch (D) {
        C(D);
      }
    }
    function O(x) {
      try {
        S(o.throw(x));
      } catch (D) {
        C(D);
      }
    }
    function S(x) {
      x.done ? h(x.value) : f(x.value).then(T, O);
    }
    S((o = o.apply(e, t || [])).next());
  });
}, Au = function(e, t) {
  var r = { label: 0, sent: function() {
    if (h[0] & 1)
      throw h[1];
    return h[1];
  }, trys: [], ops: [] }, o, f, h, C;
  return C = { next: T(0), throw: T(1), return: T(2) }, typeof Symbol == "function" && (C[Symbol.iterator] = function() {
    return this;
  }), C;
  function T(S) {
    return function(x) {
      return O([S, x]);
    };
  }
  function O(S) {
    if (o)
      throw new TypeError("Generator is already executing.");
    for (; r; )
      try {
        if (o = 1, f && (h = S[0] & 2 ? f.return : S[0] ? f.throw || ((h = f.return) && h.call(f), 0) : f.next) && !(h = h.call(f, S[1])).done)
          return h;
        switch (f = 0, h && (S = [S[0] & 2, h.value]), S[0]) {
          case 0:
          case 1:
            h = S;
            break;
          case 4:
            return r.label++, { value: S[1], done: !1 };
          case 5:
            r.label++, f = S[1], S = [0];
            continue;
          case 7:
            S = r.ops.pop(), r.trys.pop();
            continue;
          default:
            if (h = r.trys, !(h = h.length > 0 && h[h.length - 1]) && (S[0] === 6 || S[0] === 2)) {
              r = 0;
              continue;
            }
            if (S[0] === 3 && (!h || S[1] > h[0] && S[1] < h[3])) {
              r.label = S[1];
              break;
            }
            if (S[0] === 6 && r.label < h[1]) {
              r.label = h[1], h = S;
              break;
            }
            if (h && r.label < h[2]) {
              r.label = h[2], r.ops.push(S);
              break;
            }
            h[2] && r.ops.pop(), r.trys.pop();
            continue;
        }
        S = t.call(e, r);
      } catch (x) {
        S = [6, x], f = 0;
      } finally {
        o = h = 0;
      }
    if (S[0] & 5)
      throw S[1];
    return { value: S[0] ? S[1] : void 0, done: !0 };
  }
}, lp = "sites", xn;
(function(e) {
  e.BusinessId = "businessids", e.Product = "product", e.SiteId = "siteId", e.IsStaging = "isStaging", e.CacheBuster = "v", e.UrlPath = "pageurl", e.Referrer = "pagesReferrer", e.EventType = "eventType", e.PageSetId = "pageSetId", e.EntityInternalId = "ids", e.DirectoryId = "directoryId", e.SearchId = "searchId", e.StaticPageId = "staticPageId", e.PageType = "pageType", e.VisitorId = "visitorId", e.VisitorMethod = "visitorIdMethod", e.PageDomain = "pageDomain";
})(xn || (xn = {}));
var Ns = /* @__PURE__ */ new Map();
Ns.set($r.PageView, "pageview");
Ns.set($r.CTA, "calltoactionclick");
Ns.set($r.PhoneCall, "phonecall");
Ns.set($r.DrivingDirection, "drivingdirection");
Ns.set($r.Website, "clicktowebsite");
function ap(e) {
  var t = Ns.get(e);
  return typeof t == "string" ? t : e;
}
var cp = (
  /** @class */
  function() {
    function e(t, r) {
      this.config = t, this.httpRequesterService = r, this.setVisitor(t.visitor), this._debug = t.debug, this._conversionTracker = new sp(this.httpRequesterService, this._debug), this._hasTrackedListings = !1, this._region = t.region;
      try {
        this._pageUrl = new URL(t.pageUrl);
      } catch {
        throw new Error("pageUrl property must be a valid URL, was: '".concat(t.pageUrl, "'"));
      }
      if (t.pageDomain)
        try {
          this._pageDomain = new URL(t.pageDomain);
        } catch {
          console.warn("pageDomain '".concat(t.pageDomain, "' is not a valid URL."), "It will not be included as a query param sent to the API.");
        }
    }
    return e.prototype.printEvent = function(t) {
      this._debug && console.log("%c[YextAnalytics]%c- Tracked Pages event: ".concat(t.eventType), "background: white; color: blue;", "");
    }, e.prototype.urlParameters = function(t) {
      var r = new URLSearchParams();
      return r.set(xn.BusinessId, this.config.businessId.toString()), r.set(xn.Product, lp), r.set(xn.SiteId, this.config.siteId.toString()), r.set(xn.IsStaging, (!this.config.production).toString()), r.set(xn.EventType, ap(t.eventType)), r.set(xn.PageType, this.config.pageType.name), this.config.pageType.name === "entity" ? (r.set(xn.PageSetId, this.config.pageType.pageSetId), r.set(xn.EntityInternalId, this.config.pageType.id.toString())) : this.config.pageType.name === "directory" ? (r.set(xn.DirectoryId, this.config.pageType.directoryId), r.set(xn.EntityInternalId, this.config.pageType.id.toString())) : this.config.pageType.name === "locator" ? r.set(xn.SearchId, this.config.pageType.searchId) : xn.StaticPageId in this.config.pageType && r.set(xn.StaticPageId, this.config.pageType.staticPageId), r.set(xn.CacheBuster, zf().toString()), r.set(xn.UrlPath, this._pageUrl.pathname), r.set(xn.Referrer, this.config.referrer), this._pageDomain && r.set(xn.PageDomain, this._pageDomain.toString()), this._conversionTrackingEnabled && this._cookieID && r.set(ol, this._cookieID), this._visitor && (r.set(xn.VisitorId, this._visitor.id), this._visitor.idMethod && r.set(xn.VisitorMethod, this._visitor.idMethod)), r;
    }, e.prototype.pageView = function() {
      return Du(this, void 0, void 0, function() {
        var t;
        return Au(this, function(r) {
          switch (r.label) {
            case 0:
              return t = this._pageUrl.searchParams.get(Wf), this._conversionTrackingEnabled && this._cookieID && !this._hasTrackedListings && t ? [4, this._conversionTracker.trackListings({
                cookieId: this._cookieID,
                location: this._pageUrl.toString(),
                source: t
              })] : [3, 2];
            case 1:
              r.sent(), this._hasTrackedListings = !0, r.label = 2;
            case 2:
              return [2, this.track(op)];
          }
        });
      });
    }, e.prototype.track = function(t, r) {
      return Du(this, void 0, void 0, function() {
        var o, f, h, C;
        return Au(this, function(T) {
          switch (T.label) {
            case 0:
              return o = tp(this._region, this._conversionTrackingEnabled), f = new URL(o), f.search = this.urlParameters(t).toString(), [4, this.httpRequesterService.get(f.toString())];
            case 1:
              return h = T.sent(), h.status !== 200 && !(h.type == "opaque" || h.type == "opaqueredirect") ? [4, h.text()] : [3, 3];
            case 2:
              throw C = T.sent(), new Error(C);
            case 3:
              return this.printEvent(t), this._conversionTrackingEnabled && this._cookieID && r ? [4, this._conversionTracker.trackConversion({
                cid: r.cid,
                cv: r.cv,
                cookieId: this._cookieID,
                location: this._pageUrl.toString()
              })] : [3, 5];
            case 4:
              T.sent(), T.label = 5;
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.setDebugEnabled = function(t) {
      this._debug = t, this._conversionTracker && this._conversionTracker.setDebugEnabled(t);
    }, e.prototype.setVisitor = function(t) {
      this._visitor = t;
    }, e.prototype.setConversionTrackingEnabled = function(t, r) {
      this._conversionTrackingEnabled = t, this._cookieID = r;
    }, e;
  }()
);
var up = (
  /** @class */
  function() {
    function e(t, r) {
      t === void 0 && (t = window), r === void 0 && (r = document), this._outerWindow = t, this._outerDocument = r;
    }
    return e.prototype.setAndGetYextCookie = function() {
      var t = this.fetchCookie();
      return t || (t = e.generateRandomCookie().toString()), this.setCookieAndRemoveOldCookies(t), t;
    }, e.generateRandomCookie = function() {
      return Math.floor(Math.random() * (/* @__PURE__ */ new Date()).getTime());
    }, e.prototype.fetchCookie = function() {
      var t = this, r = "", o = function(f) {
        if (t.canSetCookieWithDomain(f)) {
          var h = t.removeCookieByDomain(f);
          return h && (r = h, t.setCookie(r, f)), !0;
        }
      };
      return this.forEachDomainIncreasingSpecificity(o), r || o(""), r;
    }, e.prototype.forEachDomainIncreasingSpecificity = function(t) {
      for (var r = !1, o = this._outerDocument.location.hostname.split(".").reverse(), f = "", h = 0; h < o.length; h++)
        if (f = "." + o[h] + f, t(f)) {
          r = !0;
          break;
        }
      r || t("");
    }, e.prototype.removeCookieByDomain = function(t) {
      var r = this.persistentCookies();
      this.clearCookie(t);
      var o = this.persistentCookies();
      return o.length < r.length && e.listDifference(r, o)[0] || "";
    }, e.listDifference = function(t, r) {
      for (var o = Array.from(t), f = 0; f < r.length; f++) {
        var h = o.indexOf(r[f]);
        h !== -1 && o.splice(h, 1);
      }
      return o;
    }, e.prototype.persistentCookies = function() {
      return this.allCookies().filter(function(t) {
        return t !== Aa;
      });
    }, e.prototype.allCookies = function() {
      var t = [];
      return this.forEachCookieNameValue(function(r, o) {
        r === ol && t.push(o);
      }), t;
    }, e.prototype.forEachCookieNameValue = function(t) {
      this._outerDocument.cookie.split(";").forEach(function(r) {
        var o = r.split("="), f = o[0], h = o[1];
        f && h && t(f.trim(), h.trim());
      });
    }, e.prototype.setCookieAndRemoveOldCookies = function(t) {
      var r = this, o = !1, f = this.allCookies().length, h = 0;
      this.forEachDomainIncreasingSpecificity(function(C) {
        if (o ? r.removeCookieByDomain(C) && h++ : r.canSetCookieWithDomain(C) && (r.removeCookieByDomain(C) && h++, r.setCookie(t, C), o = !0), h >= f && o)
          return !0;
      });
    }, e.prototype.canSetCookieWithDomain = function(t) {
      var r = this.removeCookieByDomain(t), o = this.allCookies();
      this.setCookie(Aa, t);
      var f = this.allCookies();
      return o.length < f.length ? (r ? this.setCookie(r, t) : this.clearCookie(t), !0) : !1;
    }, e.prototype.setCookie = function(t, r) {
      this._outerDocument.cookie = this.formatCookie(ol, t, r);
    }, e.prototype.formatCookie = function(t, r, o, f) {
      f === void 0 && (f = "/");
      var h = t + "=" + r, C = /* @__PURE__ */ new Date();
      return C.setTime(C.getTime() + 90 * 24 * 60 * 60 * 1e3), h += ";path=" + f, h += ";expires=" + C.toUTCString(), o && (h += ";domain=" + o), h += ";samesite=None;", this._outerWindow.location.protocol === "https:" && (h += " Secure "), h;
    }, e.prototype.clearCookie = function(t, r) {
      t === void 0 && (t = ""), r === void 0 && (r = "/");
      var o = /* @__PURE__ */ new Date(0), f = ol + "=" + Aa;
      f += ";path=" + r, f += ";expires=" + o.toUTCString(), t && (f += ";domain=" + t + ";"), f += ";samesite=None;", this._outerWindow.location.protocol === "https:" && (f += " Secure "), this._outerDocument.cookie = f;
    }, e;
  }()
);
function dp(e) {
  var t = new Xg();
  return new cp(e, t);
}
function Gf(e) {
  return e.toLowerCase().trim().replace(/[^\w\s-]|[\s-]+/g, "");
}
function Tc(e, t) {
  return [e, t].filter((r) => !!r).map((r) => Gf(r)).join("_");
}
class fp {
  /**
   * Creates an Analytics instance, will fire a pageview event if requireOptin
   * is false
   *
   * @param templateData - template data object from the pages system
   * @param requireOptIn - boolean, set to true if you require user opt in before tracking analytics
   */
  constructor(t, r, o, f = []) {
    Ln(this, "_optedIn");
    Ln(this, "_conversionTrackingEnabled", !1);
    Ln(this, "_cookieManager");
    Ln(this, "_analyticsReporter");
    Ln(this, "_pageViewFired", !1);
    Ln(this, "_enableDebugging", !1);
    this.templateData = t, this.pageDomain = o, this.productionDomains = f, this._optedIn = !r, this.makeReporter(), this.pageView();
  }
  calculatePageType() {
    var f, h, C, T;
    const t = !!((h = (f = this.templateData.document) == null ? void 0 : f.__) != null && h.staticPage), r = !!((T = (C = this.templateData.document) == null ? void 0 : C.__) != null && T.entityPageSet);
    let o;
    if (t)
      o = {
        name: "static",
        staticPageId: this.templateData.document.__.name
      };
    else if (r)
      o = {
        name: "entity",
        pageSetId: this.templateData.document.__.name,
        id: this.templateData.document.uid
      };
    else
      throw new Error("invalid document type");
    return o;
  }
  makeReporter() {
    if (ys().name !== "browser" || !this._optedIn)
      return;
    const t = Jg(...this.productionDomains);
    this._analyticsReporter = dp({
      businessId: this.templateData.document.businessId,
      pageType: this.calculatePageType(),
      pageUrl: window.location.href,
      production: t,
      referrer: document.referrer,
      siteId: this.templateData.document.siteId,
      pageDomain: this.pageDomain
    }), this.setDebugEnabled(this._enableDebugging);
  }
  canTrack() {
    return ys().name === "browser" && this._optedIn && !!this._analyticsReporter;
  }
  setupConversionTracking() {
    var t;
    this._cookieManager = new up(), (t = this._analyticsReporter) == null || t.setConversionTrackingEnabled(
      !0,
      this._cookieManager.setAndGetYextCookie()
    );
  }
  /** {@inheritDoc AnalyticsMethods.enableConversionTracking} */
  enableTrackingCookie() {
    this._conversionTrackingEnabled = !0, this.canTrack() && this.setupConversionTracking();
  }
  /** {@inheritDoc AnalyticsMethods.identify} */
  identify(t) {
    var r;
    this.canTrack() && ((r = this._analyticsReporter) == null || r.setVisitor(t));
  }
  /** {@inheritDoc AnalyticsMethods.async} */
  async optIn() {
    this._optedIn = !0, this.makeReporter(), this._conversionTrackingEnabled && !this._cookieManager && this.setupConversionTracking(), this._pageViewFired || await this.pageView();
  }
  /** {@inheritDoc AnalyticsMethods.async} */
  async pageView() {
    var t;
    if (!this.canTrack())
      return Promise.resolve(void 0);
    await ((t = this._analyticsReporter) == null ? void 0 : t.pageView()), this._pageViewFired = !0;
  }
  /** {@inheritDoc AnalyticsMethods.track} */
  async track(t, r) {
    var o;
    if (!this.canTrack())
      return Promise.resolve();
    await ((o = this._analyticsReporter) == null ? void 0 : o.track(
      { eventType: Gf(t) },
      r
    ));
  }
  /** {@inheritDoc AnalyticsMethods.setDebugEnabled} */
  setDebugEnabled(t) {
    var r;
    this._enableDebugging = t, (r = this._analyticsReporter) == null || r.setDebugEnabled(t);
  }
  /** {@inheritDoc AnalyticsMethods.trackClick} */
  trackClick(t, r) {
    return (o) => {
      if (!this.canTrack())
        return Promise.resolve();
      if (o.target === null || o.defaultPrevented)
        return this.track(t, r);
      const f = o.target;
      if (f.href === null || f.href === void 0)
        return this.track(t, r);
      const h = new URL(f.href);
      if (h.protocol === "mailto:" || h.protocol === "tel:" || // eslint-disable-next-line no-script-url
      h.protocol === "javascript:" || h.hostname === window.location.hostname)
        return this.track(t, r);
      if (f.target && !f.target.match(/^_(self|parent|top)$/i) || o.ctrlKey || o.shiftKey || o.metaKey)
        return this.track(t, r);
      o.preventDefault();
      const T = () => {
        window.location.assign(h);
      }, O = new Promise((S) => {
        setTimeout(() => {
          S();
        }, 1e3);
      });
      return Promise.race([this.track(t, r), O]).then(T).catch(T);
    };
  }
}
const Yf = ia(null), jf = ia({ name: "" }), qf = () => Fo(jf).name;
function BC(e) {
  const t = qf(), [r] = Tr({
    name: Tc(t, e.name)
  });
  return /* @__PURE__ */ yt.jsx(jf.Provider, { value: r, children: e.children });
}
function oa() {
  const e = Fo(Yf);
  if (!e)
    return e;
  ys().name === "browser" && !window.setAnalyticsOptIn && (window.setAnalyticsOptIn = async () => {
    await e.optIn();
  });
  const t = qf();
  return {
    trackClick(r, o) {
      return e.trackClick(Tc(t, r), o);
    },
    setDebugEnabled(r) {
      return e.setDebugEnabled(r);
    },
    enableTrackingCookie() {
      return e.enableTrackingCookie();
    },
    identify(r) {
      return e.identify(r);
    },
    optIn() {
      return e.optIn();
    },
    pageView() {
      return e.pageView();
    },
    track(r, o) {
      return e.track(Tc(t, r), o);
    }
  };
}
const KC = () => {
  var e;
  return (e = oa()) == null ? void 0 : e.track;
}, HC = () => {
  var e;
  return (e = oa()) == null ? void 0 : e.pageView;
}, UC = () => {
  var e;
  return (e = oa()) == null ? void 0 : e.identify;
};
function WC(e) {
  var D;
  const {
    children: t,
    requireOptIn: r,
    enableTrackingCookie: o,
    enableDebugging: f,
    templateData: h,
    pageDomain: C,
    productionDomains: T
  } = e, O = Ac(null);
  O.current === null && (O.current = new fp(
    h,
    r,
    C,
    T
  ));
  const S = O.current;
  o && S.enableTrackingCookie();
  let x = hp();
  return ys().name === "node" && (x = x || ((D = process.env) == null ? void 0 : D.NODE_ENV) === "development"), S.setDebugEnabled(f ?? x), /* @__PURE__ */ yt.jsx(Yf.Provider, { value: S, children: t });
}
function hp() {
  return ys().name !== "browser" || typeof window === void 0 ? !1 : !!new URL(window.location.href).searchParams.get("xYextDebug");
}
const ko = {
  /**
   * The the default layout if one is not specified. An image will be scaled down to fit the
   * container but not exceed the absolute size of the image.
   */
  INTRINSIC: "intrinsic",
  /**
   * Shows the image in a fixed size. `width` or `height` must be passed in. If both `width` and
   * `height` are passed in, but the aspect ratio does not match the aspect ratio of the image,
   * the image will be centered. This behavior can be adjusted using the `objectFit` and
   * `objectPosition` props of the `style` rpop.
   */
  FIXED: "fixed",
  /** Shows the image in a fixed aspect ratio. The `aspectRatio` prop must be provided. */
  ASPECT: "aspect",
  /** Always fills the image to 100% of the container's width. */
  FILL: "fill"
}, Vf = /(https?:\/\/a.mktgcdn.com\/p(?<env>-sandbox|-qa|-dev)?\/)(?<uuid>.+)\/(.*)/, zC = ({
  image: e,
  className: t,
  width: r,
  height: o,
  aspectRatio: f,
  layout: h = ko.INTRINSIC,
  placeholder: C,
  imgOverrides: T,
  style: O = {},
  loading: S = "lazy"
}) => {
  const x = Ac(null), [D, k] = Tr(!1), H = "image" in e ? e.image : e;
  fr(() => {
    var V;
    (V = x.current) != null && V.complete && k(!0);
  }, []), gp(
    h,
    H.width,
    H.height,
    r,
    o,
    f
  );
  const N = Math.abs(H.width);
  N || console.warn("Invalid image width.");
  const v = Math.abs(H.height);
  v || console.warn("Invalid image height.");
  const F = pp(H.url);
  if (!F)
    return /* @__PURE__ */ yt.jsx(yt.Fragment, { children: C != null && C });
  const U = r && r > 0 ? r : void 0, I = o && o > 0 ? o : void 0, { src: K, imgStyle: B, widths: z } = mp(
    h,
    N,
    v,
    F,
    O,
    H.url,
    U,
    I,
    f
  ), te = z.map(
    (V) => `${xc(
      F,
      V,
      v / N * V,
      H.url
    )} ${V}w`
  ).join(", "), re = [640, 768, 1024, 1280, 1536], de = z.map(
    (V, G) => G === z.length - 1 ? `${V}px` : `(max-width: ${re[G]}px) ${V}px`
  ).join(", ");
  return /* @__PURE__ */ yt.jsxs(yt.Fragment, { children: [
    !D && C != null && C,
    /* @__PURE__ */ yt.jsx(
      "img",
      {
        ref: x,
        style: B,
        src: K,
        className: t,
        width: U,
        height: I,
        srcSet: te,
        sizes: de,
        loading: S,
        alt: H.alternateText || "",
        ...T
      }
    )
  ] });
}, gp = (e, t, r, o, f, h) => {
  if (t < 0 && console.warn(`Invalid image width: ${t}.`), r < 0 && console.warn(`Invalid image height: ${r}.`), e === ko.FIXED) {
    if (!o && !f) {
      console.warn(
        "Using fixed layout but neither width nor height is passed as props."
      );
      return;
    }
    o && o < 0 && console.warn(`Using fixed layout but width is invalid: ${o}.`), f && f < 0 && console.warn(`Using fixed layout but height is invalid: ${f}.`);
    return;
  }
  (o || f) && console.warn(
    "Width or height is passed in but layout is not fixed. These will have no impact. If you want to have a fixed height or width then set layout to fixed."
  ), e === ko.ASPECT && !h && console.warn(
    "Using aspect layout but aspectRatio is not passed as a prop."
  );
}, pp = (e) => {
  var r;
  const t = e.match(Vf);
  return (r = t == null ? void 0 : t.groups) != null && r.uuid ? t.groups.uuid : (console.error(`Invalid image url: ${e}.`), "");
}, _p = (e) => {
  var r;
  const t = e.match(Vf);
  return (r = t == null ? void 0 : t.groups) == null ? void 0 : r.env;
}, xc = (e, t, r, o) => {
  const f = _p(o);
  return `https://dynl.mktgcdn.com/${f ? `p${f}` : "p"}/${e}/${Math.round(
    t
  )}x${Math.round(r)}`;
}, mp = (e, t, r, o, f, h, C, T, O) => {
  let S = [100, 320, 640, 960, 1280, 1920], x = xc(o, 500, 500, h);
  const D = { ...f };
  switch (D.objectFit = D.objectFit || "cover", D.objectPosition = D.objectPosition || "center", e) {
    case ko.INTRINSIC:
      D.maxWidth = t, D.width = "100%", D.aspectRatio = O ? `${O}` : `${t} / ${r}`;
      break;
    case ko.FIXED: {
      const { fixedWidth: k, fixedHeight: H, fixedWidths: N } = yp(
        t,
        r,
        S,
        C,
        T
      );
      D.width = k, D.height = H, S = N, x = xc(o, k, H, h);
      break;
    }
    case ko.ASPECT:
      D.aspectRatio = O ? `${O}` : `${t} / ${r}`;
      break;
    case ko.FILL:
      D.width = "100%", D.aspectRatio = O ? `${O}` : `${t} / ${r}`;
      break;
    default:
      console.warn(`Unrecognized layout: ${e}.`);
      break;
  }
  return { src: x, imgStyle: D, widths: S };
}, yp = (e, t, r, o, f) => o && f ? {
  fixedWidth: o,
  fixedHeight: f,
  fixedWidths: [o]
} : o ? {
  fixedWidth: o,
  fixedHeight: o * t / e,
  fixedWidths: [o]
} : f ? {
  fixedWidth: f / t * e,
  fixedHeight: f,
  fixedWidths: [f / t * e]
} : {
  fixedWidth: e,
  fixedHeight: t,
  fixedWidths: r
};
var Jf = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(e) {
  (function() {
    var t = {}.hasOwnProperty;
    function r() {
      for (var o = [], f = 0; f < arguments.length; f++) {
        var h = arguments[f];
        if (h) {
          var C = typeof h;
          if (C === "string" || C === "number")
            o.push(h);
          else if (Array.isArray(h)) {
            if (h.length) {
              var T = r.apply(null, h);
              T && o.push(T);
            }
          } else if (C === "object") {
            if (h.toString !== Object.prototype.toString && !h.toString.toString().includes("[native code]")) {
              o.push(h.toString());
              continue;
            }
            for (var O in h)
              t.call(h, O) && h[O] && o.push(O);
          }
        }
      }
      return o.join(" ");
    }
    e.exports ? (r.default = r, e.exports = r) : window.classNames = r;
  })();
})(Jf);
var Cp = Jf.exports;
const Ql = /* @__PURE__ */ bc(Cp), Np = (e) => e.linkType === "Email" || !e.linkType && Zf(e.link) ? `mailto:${e.link}` : e.linkType === "Phone" ? `tel:${e.link}` : e.link, Zf = (e) => /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(e), Ep = (e) => {
  let t = "";
  for (let r = e.length - 1; r >= 0; t += e[r--])
    ;
  return t;
}, Tp = (e) => "href" in e, xp = rn.forwardRef(
  function(t, r) {
    const o = Tp(t) ? { link: t.href } : t.cta, { children: f, onClick: h, className: C, eventName: T, cta: O, ...S } = t, x = T || (O ? "cta" : "link"), D = oa(), k = t.obfuscate || t.obfuscate !== !1 && Zf(o.link), [H, N] = Tr(!1), v = async (B) => {
      if (N(!0), D !== null)
        try {
          await D.trackClick(x, t.conversionDetails)(B);
        } catch {
          console.error("Failed to report click Analytics Event");
        }
      h && h(B);
    }, F = !f && !o.label, U = !H && k, I = {
      ...t.style,
      unicodeBidi: "bidi-override",
      direction: F && U ? "rtl" : "ltr"
    }, K = U ? Ep(o.link) : o.link;
    return /* @__PURE__ */ yt.jsx(
      "a",
      {
        className: Ql("Link", C),
        href: H || !k ? Np(o) : "obfuscate",
        onClick: v,
        rel: t.target && !t.rel ? "noopener" : void 0,
        ref: r,
        style: I,
        ...S,
        children: f || o.label || K
      }
    );
  }
), GC = {
  URL: "URL",
  Email: "Email",
  Phone: "Phone"
}, nn = Object.freeze({
  DEGREE: Symbol("deg"),
  KILOMETER: Symbol("km"),
  MILE: Symbol("mi"),
  RADIAN: Symbol("r")
}), Ir = Object.freeze({
  MERCATOR: Symbol("mercator"),
  SPHERICAL: Symbol("spherical")
}), La = 3959, Pa = 6371, vp = ["latitude", "lat"], Sp = ["longitude", "lon", "lng", "long"];
function bu(e, t) {
  for (const r of t)
    if (e[r] || e[r] === 0)
      return e[r];
}
function Mu(e) {
  switch (typeof e) {
    case "string":
    case "number":
      const t = Number.parseFloat(e);
      if (Number.isNaN(t))
        throw new Error(`'${e}' must be convertible to a Number'`);
      return t;
    default:
      throw new Error(
        `typeof '${e}' must be a number or a string that can be converted to a number, is '${typeof e}'`
      );
  }
}
function $o(e) {
  return e * Math.PI / 180;
}
function Mi(e) {
  return e / Math.PI * 180;
}
function wp(e, t) {
  const r = $o(e.latitude), o = $o(t.latitude), f = o - r, h = $o(t.longitude - e.longitude), C = Math.pow(Math.sin(f / 2), 2) + Math.cos(r) * Math.cos(o) * Math.pow(Math.sin(h / 2), 2);
  return 2 * Math.atan2(Math.sqrt(C), Math.sqrt(1 - C));
}
function Op(e, t) {
  const r = Math.tan(Math.PI / 360 * (e + 90)), o = Math.tan(Math.PI / 360 * (t + 90));
  return Math.log(o / r);
}
function Rp(e, t) {
  const o = Math.tan(Math.PI / 360 * (e + 90)) * Math.pow(Math.E, t);
  return Math.atan(o) * 360 / Math.PI - 90;
}
class Vt {
  /**
   * Constructor takes either 1 or 2 arguments.
   * 2 arguments: latitude and longitude.
   * 1 argument: an object with at least one {@link module:@yext/components-geo~Coordinate~LATITUDE_ALIASES latitude alias}
   * and one one {@link module:@yext/components-geo~CoordinateCoordinate~LONGITUDE_ALIASES longitude alias}.
   * @param {number|Object} latitudeOrObject
   * @param {number} [longitude] Optional only if the first argument is a {@link module:@yext/components-geo~Coordinate Coordinate}-like object
   */
  constructor(t, r) {
    let o = t;
    typeof t == "object" && (o = bu(t, vp), r = bu(t, Sp), o = typeof o == "function" ? o() : o, r = typeof r == "function" ? r() : r), this.latitude = o, this.longitude = r;
  }
  /**
   * Degrees latitude in the range [-90, 90].
   * If setting a value outside this range, it will be set to -90 or 90, whichever is closer.
   * @type {number}
   */
  get latitude() {
    return this._lat;
  }
  /**
   * Degrees longitude in the range [-Infinity, Infinity].
   * @type {number}
   */
  get longitude() {
    return this._lon;
  }
  /**
   * Degrees longitude in the range [-180, 180).
   * If the coordinate's longitude is outside this range, the equivalent value within it is used.
   * Examples: 123 => 123, 270 => -90, -541 => 179
   * @type {number}
   */
  get normalLon() {
    return ((this._lon + 180) % 360 + 360) % 360 - 180;
  }
  set latitude(t) {
    this._lat = Math.max(-90, Math.min(Mu(t), 90));
  }
  set longitude(t) {
    this._lon = Mu(t);
  }
  /**
   * Add distance to the coordinate to change its position.
   * @param {number} latDist latitude distance
   * @param {number} lonDist longitude distance
   * @param {module:@yext/components-geo~Unit} [unit=Unit.DEGREE] The unit of latDist and lonDist
   * @param {module:@yext/components-geo~Projection} [projection=Projection.SPHERICAL] The projection of Earth (not relevant when using a physical distance unit, e.g. Mile)
   */
  add(t, r, o = nn.DEGREE, f = Ir.SPHERICAL) {
    if (f === Ir.MERCATOR && (o === nn.DEGREE || o === nn.RADIAN)) {
      const h = o === nn.DEGREE ? $o(t) : t, C = o === nn.DEGREE ? r : Mi(r);
      this.latitude = Rp(this.latitude, h), this.longitude += C;
    } else
      switch (o) {
        case nn.DEGREE:
          this.latitude += t, this.longitude += r;
          break;
        case nn.KILOMETER:
          this.latitude += Mi(t) * Pa, this.longitude += Mi(r) * Pa * Math.cos($o(this.latitude));
          break;
        case nn.MILE:
          this.latitude += Mi(t) * La, this.longitude += Mi(r) * La * Math.cos($o(this.latitude));
          break;
        case nn.RADIAN:
          this.latitude += Mi(t), this.longitude += Mi(r);
          break;
        default:
          throw new Error(`unit unhandled: ${o}`);
      }
  }
  /**
   * Calculate the distance from this coordinate to another coordinate.
   * @param {module:@yext/components-geo~Coordinate} coordinate
   * @param {module:@yext/components-geo~Unit} [unit=Unit.MILE] The unit of distance
   * @param {module:@yext/components-geo~Projection} [projection=Projection.SPHERICAL] The projection of Earth (not relevant when using a physical distance unit, e.g. Mile)
   * @returns {number} Distance in the requested unit
   */
  distanceTo(t, r = nn.MILE, o = Ir.SPHERICAL) {
    if (o === Ir.MERCATOR && (r === nn.DEGREE || r === nn.RADIAN)) {
      const f = Op(
        this.latitude,
        t.latitude
      ), h = Math.abs(t.normalLon - this.normalLon), C = $o(
        Math.min(h, 360 - h)
      ), T = Math.sqrt(Math.pow(f, 2) + Math.pow(C, 2));
      switch (r) {
        case nn.DEGREE:
          return Mi(T);
        case nn.RADIAN:
          return T;
        default:
          throw new Error(`unit unhandled: ${r}`);
      }
    } else {
      const f = wp(this, t);
      switch (r) {
        case nn.DEGREE:
          return Mi(f);
        case nn.KILOMETER:
          return f * Pa;
        case nn.MILE:
          return f * La;
        case nn.RADIAN:
          return f;
        default:
          throw new Error(`unit unhandled: ${r}`);
      }
    }
  }
  /**
   * Test if this coordinate has the same latitude and longitude as another.
   * @param {module:@yext/components-geo~Coordinate} coordinate
   * @returns {boolean}
   */
  equals(t) {
    return t && t.latitude === this.latitude && t.longitude === this.longitude;
  }
  /**
   * Get the coordinate as a string that can be used in a search query.
   * Example: {latitude: -45, longitude: 123} => '-45,123'
   * @returns {string}
   */
  searchQueryString() {
    return `${this.latitude},${this.longitude}`;
  }
}
function Xf(e, t = () => null) {
  const r = document.createElement("script");
  r.async = !0, r.onload = t, r.src = e, document.head.appendChild(r);
}
const er = {
  UNDEFINED: "undefined",
  NULL: "object",
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#null
  BOOLEAN: "boolean",
  NUMBER: "number",
  BIGINT: "bigint",
  STRING: "string",
  SYMBOL: "symbol",
  FUNCTION: "function",
  OBJECT: "object"
};
function hr(e, t) {
  if (typeof t != "string")
    throw new Error("Assertion error: 'type' must be a string");
  if (typeof e !== t)
    throw new Error(
      `Expected an object of type '${t}' but received '${typeof e}'`
    );
}
function tr(e, t) {
  let r;
  try {
    r = e instanceof t;
  } catch {
    throw new Error(
      "Assertion error: 'instanceClass' is not a valid constructor"
    );
  }
  if (!r)
    throw new Error(
      `Expected an instance of '${t.name}' but received '${e.constructor.name}'`
    );
}
class Qf {
  /**
   * @param {module:@yext/components-maps~MapProvider} provider
   * @param {HTMLElement} wrapper The wrapper element that the map will be inserted into
   */
  constructor(t, r) {
    tr(t, Ko), tr(r, HTMLElement), this.providerMapClass = t.getMapClass(), this.wrapper = r, this.controlEnabled = !0, this.panHandler = () => null, this.panStartHandler = () => null, this.providerOptions = {};
  }
  /**
   * @param {boolean} controlEnabled Whether the user can interact with the map
   * @returns {module:@yext/components-maps~ProviderMapOptions}
   */
  withControlEnabled(t) {
    return this.controlEnabled = t, this;
  }
  /**
   * @param {function} panHandler Function called after the map bounds change
   * @returns {module:@yext/components-maps~ProviderMapOptions}
   */
  withPanHandler(t) {
    return hr(t, er.FUNCTION), this.panHandler = t, this;
  }
  /**
   * @param {function} panStartHandler Function called before the map bounds change
   * @returns {module:@yext/components-maps~ProviderMapOptions}
   */
  withPanStartHandler(t) {
    return hr(t, er.FUNCTION), this.panStartHandler = t, this;
  }
  /**
   * @param {Object} providerOptions A free-form object used to set any additional provider-specific
   *   options, usually by passing the object to the map's constructor
   * @returns {module:@yext/components-maps~ProviderMapOptions}
   */
  withProviderOptions(t) {
    return this.providerOptions = t, this;
  }
  /**
   * @returns {module:@yext/components-maps~ProviderMap} An instance of a subclass of {@link module:@yext/components-maps~ProviderMap ProviderMap}
   *   for the given {@link module:@yext/components-maps~MapProvider MapProvider}
   */
  build() {
    const t = this.providerMapClass;
    return new t(this);
  }
}
class Es {
  /**
   * The constructor creates a map instance using the provider's API and initializes it with all the
   * given options. See {@link module:@yext/components-maps~ProviderMapOptions ProviderMapOptions}
   * for the supported options.
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(t) {
    tr(t, Qf), this._panHandler = t.panHandler, this._panStartHandler = t.panStartHandler;
  }
  /**
   * @returns {module:@yext/components-tsx-geo~Coordinate} The current center of the map
   */
  getCenter() {
    throw new Error("not implemented");
  }
  /**
   * Zoom level complies with the specifications in {@link module:@yext/components-maps~Map#getZoom Map#getZoom}
   * @returns {number} The current zoom level of the map
   */
  getZoom() {
    throw new Error("not implemented");
  }
  /**
   * @param {module:@yext/components-tsx-geo~Coordinate} coordinate The new center for the map
   * @param {boolean} animated Whether to transition smoothly to the new center
   */
  setCenter(t, r) {
    throw new Error("not implemented");
  }
  /**
   * Zoom level complies with the specifications in {@link module:@yext/components-maps~Map#getZoom Map#getZoom}
   * @param {number} zoom The new zoom level for the map
   * @param {boolean} animated Whether to transition smoothly to the new zoom
   */
  setZoom(t, r) {
    throw new Error("not implemented");
  }
  /**
   * @param {number} zoom
   * @param {Object} center Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @param {boolean} animated Whether to transition smoothly to the new bounds
   * @see module:@yext/components-maps~ProviderMap#setZoom
   * @see module:@yext/components-maps~ProviderMap#setCenter
   */
  setZoomCenter(t, r, o) {
    this.setZoom(t, o), this.setCenter(r, o);
  }
}
class eh {
  /**
   * @param {module:@yext/components-maps~MapProvider} provider
   */
  constructor(t) {
    tr(t, Ko), this.providerPinClass = t.getPinClass(), this.clickHandler = () => null, this.focusHandler = (r) => null, this.hoverHandler = (r) => null, this.icons = {};
  }
  /**
   * @param {import('./mapPin.js').PinClickHandler} clickHandler Function called when the pin is clicked
   * @returns {module:@yext/components-maps~ProviderPinOptions}
   */
  withClickHandler(t) {
    return hr(t, er.FUNCTION), this.clickHandler = t, this;
  }
  /**
   * @param {import('./mapPin.js').PinFocusHandler} focusHandler Function called when the pin becomes (un)focused
   * @returns {module:@yext/components-maps~ProviderPinOptions}
   */
  withFocusHandler(t) {
    return hr(t, er.FUNCTION), this.focusHandler = t, this;
  }
  /**
   * @param {import('./mapPin.js').PinHoverHandler} hoverHandler Function called when the pin becomes (un)hovered
   * @returns {module:@yext/components-maps~ProviderPinOptions}
   */
  withHoverHandler(t) {
    return hr(t, er.FUNCTION), this.hoverHandler = t, this;
  }
  /**
   * Similar to {@link module:@yext/components-maps~MapPinOptions#withIcon MapPinOptions#withIcon},
   * but all icons are given as a map of key => icon. If a provider pin instance needs an icon to be
   * a specialized class rather than a simple URL, the icons in this object can be converted in this
   * function and assigned back to the icons object instead of being recreated from the URL every
   * time the pin's icon changes.
   * @param {Object<string,string>} icons Map of a string key to the URL or data URI of an image
   * @returns {module:@yext/components-maps~ProviderPinOptions}
   */
  withIcons(t) {
    return this.icons = t, this;
  }
  /**
   * @returns {module:@yext/components-maps~ProviderPin} An instance of a subclass of {@link module:@yext/components-maps~ProviderPin ProviderPin}
   *   for the given {@link module:@yext/components-maps~MapProvider MapProvider}
   */
  build() {
    const t = this.providerPinClass;
    return new t(this);
  }
}
class Lc {
  /**
   * The constructor creates a pin instance using the provider's API and initializes it with all the
   * given options. See {@link module:@yext/components-maps~ProviderPinOptions ProviderPinOptions}
   * for the supported options.
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(t) {
    tr(t, eh), this._clickHandler = t.clickHandler, this._focusHandler = t.focusHandler, this._hoverHandler = t.hoverHandler, this._icons = t.icons;
  }
  /**
   * @param {module:@yext/components-tsx-geo~Coordinate} coordinate The position of the pin
   */
  setCoordinate(t) {
    throw new Error("not implemented");
  }
  /**
   * Remove the pin from its current map and, if newMap is not null, add it to the new map.
   * @param {?module:@yext/components-maps~Map} newMap The new map -- if null, the pin will not be
   *   shown on any map
   * @param {?module:@yext/components-maps~Map} currentMap The current map -- if null, the pin is
   *   not shown on any map
   */
  setMap(t, r) {
    throw new Error("not implemented");
  }
  /**
   * Apply the given properties to modify the appearance of the pin.
   * @param {module:@yext/components-maps~PinProperties} pinProperties
   * @see module:@yext/components-maps~PinProperties
   */
  setProperties(t) {
    throw new Error("not implemented");
  }
}
const Dp = Object.freeze({
  backgroundPosition: "center",
  backgroundRepeat: "no-repeat",
  backgroundSize: "contain",
  left: "0",
  outline: "none",
  pointerEvents: "auto",
  position: "absolute",
  top: "0"
});
class sa extends Lc {
  /**
   * This is the base style applied to pin elements. It is a map from CSS property to value, such
   * as 'position': 'absolute'
   * @type {Object}
   */
  static get baseStyle() {
    return Dp;
  }
  /**
   * After instatiating a {@link module:@yext/components-maps~ProviderPin ProviderPin}, this creates
   * a wrapper element and a default pin element.
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(t) {
    super(t), this._pinEl = document.createElement("button"), Object.assign(this._pinEl.style, this.constructor.baseStyle), this._pinAlt = document.createElement("span"), this._pinAlt.classList.add("sr-only"), this._pinEl.appendChild(this._pinAlt), this._wrapper = document.createElement("div"), this._wrapper.style.pointerEvents = "none", this._wrapper.appendChild(this._pinEl), this.addListeners();
  }
  /**
   * Adds click, hover, and focus event listeners to the wrapper element
   */
  addListeners() {
    this._wrapper.addEventListener("click", () => this._clickHandler()), this._wrapper.addEventListener("focusin", () => this._focusHandler(!0)), this._wrapper.addEventListener("focusout", () => this._focusHandler(!1)), this._wrapper.addEventListener("mouseover", () => this._hoverHandler(!0)), this._wrapper.addEventListener("mouseout", () => this._hoverHandler(!1));
  }
  /**
   * @returns {HTMLElement} HTML button element for pin element
   */
  getPinElement() {
    return this._pinEl;
  }
  /**
   * @returns {HTMLElement} HTML button element for wrapper element
   */
  getWrapperElement() {
    return this._wrapper;
  }
  /**
   * @param {module:@yext/components-maps~PinProperties} pinProperties
   * @see module:@yext/components-maps~ProviderPin#setProperties
   */
  setProperties(t) {
    this.setElementProperties(t);
    const r = t.getClass(), o = t.getElement() || this._pinEl, f = t.getZIndex();
    o.style.pointerEvents = "auto", this._wrapper && (this._wrapper.style.zIndex = f, this._wrapper.setAttribute("class", r), o !== this._wrapper.children[0] && (this._wrapper.children[0].style.pointerEvents = "", this._wrapper.removeChild(this._wrapper.children[0]), this._wrapper.appendChild(o)));
  }
  /**
   * Sets properties used specifically by the pin element
   * @param {module:@yext/components-maps~PinProperties} pinProperties
   */
  setElementProperties(t) {
    const r = t.getAnchorX(), o = t.getAnchorY(), f = t.getHeight(), h = this._icons[t.getIcon()], C = t.getSRText(), T = t.getWidth();
    Object.assign(this._pinEl.style, {
      backgroundImage: h ? `url("${h}")` : "",
      height: f + "px",
      transform: `translate(${-100 * r}%, ${-100 * o}%)`,
      width: T + "px"
    }), this._pinAlt.innerText = C;
  }
}
class Bo {
  constructor() {
    this.loadFunction = (t, r, o, f) => t(), this.mapClass = Es, this.pinClass = Lc, this.providerName = "";
  }
  /**
   * @param {module:@yext/components-maps~ProviderLoadFunction} loadFunction
   * @returns {module:@yext/components-maps~MapProviderOptions}
   */
  withLoadFunction(t) {
    return hr(t, er.FUNCTION), this.loadFunction = t, this;
  }
  /**
   * @param {module:@yext/components-maps~ProviderMap} mapClass Subclass of {@link module:@yext/components-maps~ProviderMap ProviderMap}
   *   for the provider
   * @returns {module:@yext/components-maps~MapProviderOptions}
   */
  withMapClass(t) {
    return this.mapClass = t, this;
  }
  /**
   * @param {module:@yext/components-maps~ProviderPin} pinClass Subclass of {@link module:@yext/components-maps~ProviderPin ProviderPin}
   *   for the provider
   * @returns {module:@yext/components-maps~MapProviderOptions}
   */
  withPinClass(t) {
    return this.pinClass = t, this;
  }
  /**
   * @param {string} providerName Name of the map provider
   * @returns {module:@yext/components-maps~MapProviderOptions}
   */
  withProviderName(t) {
    return this.providerName = t, this;
  }
  /**
   * @returns {module:@yext/components-maps~MapProvider}
   */
  build() {
    return new Ko(this);
  }
}
class Ko {
  /**
   * @param {module:@yext/components-maps~MapProviderOptions} options
   */
  constructor(t) {
    tr(t, Bo), this._loadFunction = t.loadFunction, this._mapClass = t.mapClass, this._pinClass = t.pinClass, this._providerName = t.providerName, this._loadPromise = new Promise((r, o) => {
      this._resolveLoad = r, this._rejectLoad = o;
    }), this._apiKey = "", this._loadInvoked = !1, this._loaded = !1, this._options = {};
  }
  /**
   * Returns true if the map provider has been successfully loaded
   * @type {boolean}
   */
  get loaded() {
    return this._loaded;
  }
  /**
   * @returns {module:@yext/components-maps~ProviderMap}
   * @see module:@yext/components-maps~MapProviderOptions#withMapClass
   */
  getMapClass() {
    return this._mapClass;
  }
  /**
   * @returns {module:@yext/components-maps~ProviderPin}
   * @see module:@yext/components-maps~MapProviderOptions#withPinClass
   */
  getPinClass() {
    return this._pinClass;
  }
  /**
   * @returns {string}
   * @see module:@yext/components-maps~MapProviderOptions#withProviderName
   */
  getProviderName() {
    return this._providerName;
  }
  /**
   * Call {@link module:@yext/components-maps~MapPinOptions~loadFunction MapPinOptions~loadFunction}
   * and resolve or reject when loading succeeds or fails
   * @async
   * @param {string} [apiKey] Provider API key -- uses value from {@link module:@yext/components-maps~MapProvider#setLoadOptions MapProvider#setLoadOptions}
   *   if not passed
   * @param {Object} [options] Additional provider-specific options -- uses value from {@link module:@yext/components-maps~MapProvider#setLoadOptions MapProvider#setLoadOptions}
   *   if not passed
   */
  async load(t = this._apiKey, r = this._options) {
    this._loadInvoked || (this._loadInvoked = !0, this._loadFunction(this._resolveLoad, this._rejectLoad, t, r)), await this.ready(), this._loaded = !0;
  }
  /**
   * Resolves or rejects when the map provider has loaded successfully or unsuccessfully
   * @async
   */
  async ready() {
    await this._loadPromise;
  }
  /**
   * Set the API key and provider options used on load. Does nothing if load was already called.
   * @param {string} apiKey Provider API key
   * @param {?Object} [options=null] Additional provider-specific options
   */
  setLoadOptions(t, r = null) {
    this._loadInvoked || (this._apiKey = t, this._options = r || this._options);
  }
}
const Lu = {
  GEOCODER: "geocoder",
  PLACES: "places"
};
class Ap extends Es {
  /**
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(t) {
    super(t), this.map = new google.maps.Map(t.wrapper, {
      disableDefaultUI: !t.controlEnabled,
      fullscreenControl: !1,
      gestureHandling: t.controlEnabled ? "auto" : "none",
      mapTypeControl: !1,
      rotateControl: !1,
      scaleControl: !1,
      streetViewControl: !1,
      zoomControl: t.controlEnabled,
      zoomControlOptions: {
        position: google.maps.ControlPosition.RIGHT_TOP
      },
      ...t.providerOptions
    }), this._moving = !1, google.maps.event.addListener(this.map, "bounds_changed", () => {
      this._moving || (this._moving = !0, this._panStartHandler());
    }), google.maps.event.addListener(this.map, "idle", () => {
      this._moving = !1, this._panHandler();
    });
  }
  /**
   * @inheritdoc
   */
  getCenter() {
    return new Vt(this.map.getCenter());
  }
  /**
   * @inheritdoc
   */
  getZoom() {
    return this.map.getZoom();
  }
  /**
   * @inheritdoc
   */
  setCenter(t, r) {
    const o = new google.maps.LatLng(
      t.latitude,
      t.longitude
    );
    r ? this.map.panTo(o) : this.map.setCenter(o);
  }
  /**
   * @inheritdoc
   */
  setZoom(t, r) {
    this.map.setZoom(Math.floor(t));
  }
  /**
   * @inheritdoc
   */
  setZoomCenter(t, r, o) {
    this.setCenter(r, o), this.setZoom(t, o);
  }
}
class bp extends sa {
  /**
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(t) {
    super(t), this._wrapper.style.position = "absolute", google.maps.OverlayView.preventMapHitsAndGesturesFrom(this._wrapper);
    const r = this;
    class o extends google.maps.OverlayView {
      draw() {
        var C;
        const h = (C = this.getProjection()) == null ? void 0 : C.fromLatLngToDivPixel(
          r._latLng
        );
        h && (r._wrapper.style.left = h.x + "px", r._wrapper.style.top = h.y + "px");
      }
      onAdd() {
        this.getPanes().floatPane.appendChild(r._wrapper);
      }
      onRemove() {
        var h;
        (h = r._wrapper.parentNode) == null || h.removeChild(r._wrapper);
      }
    }
    this.pin = new o();
  }
  /**
   * @inheritdoc
   */
  setCoordinate(t) {
    this._latLng = new google.maps.LatLng(
      t.latitude,
      t.longitude
    ), this.pin.draw();
  }
  /**
   * @inheritdoc
   */
  setMap(t, r) {
    this.pin.setMap(t ? t.getProviderMap().map : null);
  }
}
const Pu = "GoogleMapsCallback_b7d77ff2", Mp = "https://maps.googleapis.com/maps/api/js";
function Lp(e, t, r, {
  autocomplete: o = !1,
  channel: f = window.location.hostname,
  client: h,
  language: C,
  region: T,
  libraries: O = [],
  params: S = {}
} = {}) {
  window[Pu] = e, o && O.push(Lu.GEOCODER, Lu.PLACES);
  const x = {
    callback: Pu,
    channel: f,
    libraries: O.join(","),
    ...S
  };
  r && (x.key = r), h && (x.client = h), C && (x.language = C), T && (x.region = T), Xf(
    Mp + "?" + Object.entries(x).map(([D, k]) => D + "=" + k).join("&")
  );
}
const th = new Bo().withLoadFunction(Lp).withMapClass(Ap).withPinClass(bp).withProviderName("Google").build();
class Po {
  /**
   * Create a new {@link module:@yext/components-geo~GeoBounds GeoBounds} with minimal area that
   * contains all the given coordinates
   * @param {module:@yext/components-geo~Coordinate[]} coordinates
   * @returns {module:@yext/components-geo~GeoBounds}
   */
  static fit(t) {
    const r = t.map((S) => S.latitude), o = Math.max(...r), f = Math.min(...r), h = t.map((S) => S.normalLon).sort((S, x) => S - x), C = h.map((S, x) => ({ distance: (x < h.length - 1 ? h[x + 1] : h[0] + 360) - S, index: x })).reduce(
      (S, x) => x.distance > S.distance ? x : S
    ).index, T = h[C], O = h[(C + 1) % h.length];
    return new this(new Vt(f, O), new Vt(o, T));
  }
  /**
   * @param {module:@yext/components-geo~Coordinate} sw Southwest coordinate
   * @param {module:@yext/components-geo~Coordinate} ne Northeast coordinate
   */
  constructor(t, r) {
    this._ne = new Vt(r), this._sw = new Vt(t);
  }
  /**
   * Northeast coordinate
   * @type {module:@yext/components-geo~Coordinate}
   */
  get ne() {
    return this._ne;
  }
  /**
   * Southwest coordinate
   * @type {module:@yext/components-geo~Coordinate}
   */
  get sw() {
    return this._sw;
  }
  set ne(t) {
    this._ne = new Vt(t);
  }
  set sw(t) {
    this._sw = new Vt(t);
  }
  /**
   * Whether the coordinate lies within the region defined by the bounds.
   * {@link module:@yext/components-geo~Coordinate#normalLon Normalized longitudes} are used for the
   * bounds and the coordinate.
   * @param {module:@yext/components-geo~Coordinate} coordinate
   * @returns {boolean}
   */
  contains(t) {
    const r = this._sw.latitude <= t.latitude && t.latitude <= this._ne.latitude, o = this._ne.longitude - this._sw.longitude >= 360, f = this._sw.normalLon <= this._ne.normalLon ? this._sw.normalLon <= t.normalLon && t.normalLon <= this._ne.normalLon : this._sw.normalLon <= t.normalLon || t.normalLon <= this._ne.normalLon;
    return r && (o || f);
  }
  /**
   * Extend the bounds if necessary so that the coordinate is contained by them.
   * @param {module:@yext/components-geo~Coordinate} coordinate
   */
  extend(t) {
    if (this._ne.latitude = Math.max(this._ne.latitude, t.latitude), this._sw.latitude = Math.min(this._sw.latitude, t.latitude), !this.contains(t)) {
      const r = ((t.longitude - this._ne.longitude) % 360 + 360) % 360, o = ((this._sw.longitude - t.longitude) % 360 + 360) % 360;
      r < o ? this._ne.longitude += r : this._sw.longitude -= o;
    }
  }
  /**
   * Calculate the center of the bounds using the given projection.
   * To find the visual center on a Mercator map, use Projection.MERCATOR.
   * To find the center for geolocation or geosearch purposes, use Projection.SPHERICAL.
   * @param {module:@yext/components-geo~Projection} [projection=Projection.SPHERICAL]
   * @returns {module:@yext/components-geo~Coordinate}
   */
  getCenter(t = Ir.SPHERICAL) {
    const r = new Vt(this._ne.latitude, this._sw.longitude), o = this._sw.distanceTo(r, nn.DEGREE, t), f = (r.longitude + this._ne.longitude) / 2 + (this._ne.longitude < r.longitude ? 180 : 0);
    return r.add(-o / 2, 0, nn.DEGREE, t), r.longitude = f, r;
  }
}
class Pp {
  constructor() {
    this._anchorX = 0.5, this._anchorY = 1, this._height = 39, this._icon = "default", this._srText = "map pin", this._width = 33, this._zIndex = 0, this._class = "", this._element = null;
  }
  /**
   * @returns {number} The point in the pin that should be positioned over the coordinate, from 0
   *   (left edge) to 1 (right edge)
   */
  getAnchorX() {
    return this._anchorX;
  }
  /**
   * @returns {number} The point in the pin that should be positioned over the coordinate, from 0
   *   (top edge) to 1 (bottom edge)
   */
  getAnchorY() {
    return this._anchorY;
  }
  /**
   * {@link module:@yext/components-maps~HTMLProviderPin HTMLProviderPins} only
   * @returns {string} The class of the wrapper element for an HTML pin
   */
  getClass() {
    return this._class;
  }
  /**
   * {@link module:@yext/components-maps~HTMLProviderPin HTMLProviderPins} only
   * @returns {string} The HTML pin element
   */
  getElement() {
    return this._element;
  }
  /**
   * @returns {number} The pixel height of the pin
   */
  getHeight() {
    return this._height;
  }
  /**
   * This returns a string key that can be used with {@link module:@yext/components-maps~MapPin#getIcon MapPin#getIcon}
   * to get the icon image for a pin.
   * @returns {string} The unique name of the icon
   */
  getIcon() {
    return this._icon;
  }
  /**
   * @returns {string} The text that a screen reader reads when focused on the pin
   */
  getSRText() {
    return this._srText;
  }
  /**
   * @returns {number} The pixel width of the pin
   */
  getWidth() {
    return this._width;
  }
  /**
   * @returns {number} The z-index of the pin
   */
  getZIndex() {
    return this._zIndex;
  }
  /**
   * @param {number} anchorX
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getAnchorX
   */
  setAnchorX(t) {
    return this._anchorX = t, this;
  }
  /**
   * @param {number} anchorY
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getAnchorY
   */
  setAnchorY(t) {
    return this._anchorY = t, this;
  }
  /**
   * @param {string} className
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getClass
   */
  setClass(t) {
    return this._class = t, this;
  }
  /**
   * @param {HTMLElement} element
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getElement
   */
  setElement(t) {
    return this._element = t, this;
  }
  /**
   * @param {number} height
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getHeight
   */
  setHeight(t) {
    return this._height = t, this;
  }
  /**
   * @param {string} icon
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getIcon
   */
  setIcon(t) {
    return this._icon = t, this;
  }
  /**
   * @param {string} srText
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getSRText
   */
  setSRText(t) {
    return this._srText = t, this;
  }
  /**
   * @param {number} width
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getWidth
   */
  setWidth(t) {
    return this._width = t, this;
  }
  /**
   * @param {number} zIndex
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getZIndex
   */
  setZIndex(t) {
    return this._zIndex = t, this;
  }
}
class Pc {
  /**
   * Initialize with default options
   */
  constructor() {
    this.coordinate = new Vt(0, 0), this.hideOffscreen = !1, this.icons = {}, this.propertiesForStatus = (t) => new Pp(), this.provider = null, this.type = "";
  }
  /**
   * @param {Object} coordinate Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withCoordinate(t) {
    return this.coordinate = new Vt(t), this;
  }
  /**
   * @param {boolean} hideOffscreen If true, the pin will only be rendered if it's in the visible
   *   portion of the map to improve performance
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withHideOffscreen(t) {
    return this.hideOffscreen = t, this;
  }
  /**
   * @param {string} key The unique name for the icon, used in {@link module:@yext/components-maps~PinProperties#getIcon PinProperties#getIcon}
   *   and {@link module:@yext/components-maps~PinProperties#setIcon PinProperties#setIcon}
   * @param {string} icon The URL or data URI of the icon image
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withIcon(t, r) {
    return this.icons[t] = r, this;
  }
  /**
   * @param {module:@yext/components-maps~PinPropertiesForStatus} propertiesForStatus
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withPropertiesForStatus(t) {
    return hr(t, er.FUNCTION), this.propertiesForStatus = t, this;
  }
  /**
   * @param {module:@yext/components-maps~MapProvider} provider
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withProvider(t) {
    return tr(t, Ko), this.provider = t, this;
  }
  /**
   * @param {string} type A string describing the type of the pin
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withType(t) {
    return this.type = t, this;
  }
  /**
   * @returns {module:@yext/components-maps~MapPin}
   */
  build() {
    return new Ip(this);
  }
}
class Ip {
  /**
   * @param {module:@yext/components-maps~MapPinOptions} options
   */
  constructor(t) {
    if (tr(t, Pc), tr(t.provider, Ko), !t.provider.loaded)
      throw new Error(
        `MapProvider '${t.provider.getProviderName()}' is not loaded. The MapProvider must be loaded before calling MapPin constructor.`
      );
    this._coordinate = t.coordinate, this._hideOffscreen = t.hideOffscreen, this._icons = { ...t.icons }, this._propertiesForStatus = t.propertiesForStatus, this._type = t.type, this._clickHandler = () => null, this._focusHandler = (r) => this._hoverHandler(r), this._hoverHandler = (r) => null, this._hidden = !1, this._cancelHiddenUpdater = () => null, this._map = null, this._pin = new eh(t.provider).withIcons({ ...this._icons }).withClickHandler(() => this._clickHandler()).withFocusHandler((r) => this._focusHandler(r)).withHoverHandler((r) => this._hoverHandler(r)).build(), this._pin.setCoordinate(t.coordinate), this._status = {}, this.setStatus(this._status);
  }
  /**
   * @returns {module:@yext/components-tsx-geo~Coordinate} The coordinate of the pin
   */
  getCoordinate() {
    return this._coordinate;
  }
  /**
   * Get the icon for a string key, such as 'default', 'hovered', or 'selected'
   * @param {string} key The unique name of the icon
   * @returns {string} The URL or data URI of the icon image
   * @see module:@yext/components-maps~MapPinOptions#withIcon
   */
  getIcon(t) {
    return this._icons[t];
  }
  /**
   * @returns {module:@yext/components-maps~Map} The map that the pin is currently on, or null if
   * not on a map
   */
  getMap() {
    return this._map;
  }
  /**
   * Intended for internal use only
   * @returns {module:@yext/components-maps~ProviderPin} The pin's {@link module:@yext/components-maps~ProviderPin ProviderPin}
   *   instance
   */
  getProviderPin() {
    return this._pin;
  }
  /**
   * @returns {string} The string describing the type of pin
   */
  getType() {
    return this._type;
  }
  /**
   * Remove this pin from its current map, if on one.
   */
  remove() {
    this.setMap(null);
  }
  /**
   * Set a handler function for when the pin is clicked, replacing any previously set click handler.
   * @param {module:@yext/components-maps~PinClickHandler} clickHandler
   */
  setClickHandler(t) {
    hr(t, er.FUNCTION), this._clickHandler = t;
  }
  /**
   * @param {Object} coordinate Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   */
  setCoordinate(t) {
    this._coordinate = new Vt(t), this._pin.setCoordinate(this._coordinate), this._hideOffscreen && this._hideIfOffscreen();
  }
  /**
   * Set a handler function for when the pin is (un)focused, replacing any previously set focus handler.
   * @param {module:@yext/components-maps~PinFocusHandler} focusHandler
   */
  setFocusHandler(t) {
    hr(t, er.FUNCTION), this._focusHandler = t;
  }
  /**
   * Set a handler function for when the pin is (un)hovered, replacing any previously set hover handler.
   * @param {module:@yext/components-maps~PinHoverHandler} hoverHandler
   */
  setHoverHandler(t) {
    hr(t, er.FUNCTION), this._hoverHandler = t;
  }
  /**
   * Add the pin to a map, removing it from its current map if on one.
   * @param {?Map} map
   */
  setMap(t) {
    if (t !== this._map && (t !== null && tr(t, rh), this._pin.setMap(t, this._hidden ? null : this._map), this._map = t, this._hidden = !1, this._cancelHiddenUpdater(), t && this._hideOffscreen)) {
      let r = !1;
      const o = new Promise((f) => {
        this._cancelHiddenUpdater = () => {
          r = !0, f();
        };
      });
      (async () => {
        for (; !r; )
          this._hideIfOffscreen(), await Promise.race([o, t.moving()]), await Promise.race([o, t.idle()]);
      })();
    }
  }
  /**
   * Assign all properties in an object to the pin's status.
   * Example: if the pin's status is { a: true, b: true }, passing in { a: false, c: true } will
   * change the pin's status to { a: false, b: true, c: true }
   * @param {Object} status
   */
  setStatus(t) {
    Object.assign(this._status, t), this._pin.setProperties(this._propertiesForStatus(this._status));
  }
  /**
   * Add or remove the pin from the map based on whether its coordinate is within the current bounds
   * @protected
   */
  _hideIfOffscreen() {
    if (this._map) {
      const t = this._map.getBounds().contains(this._coordinate);
      this._hidden && t ? this._pin.setMap(this._map, null) : !this._hidden && !t && this._pin.setMap(null, this._map), this._hidden = !t;
    }
  }
}
const io = 0.98;
function ql(e, t) {
  return Math.max(typeof e == er.FUNCTION ? e() : e || 0, 0) / t;
}
class nh {
  /**
   * Initialize with default options
   */
  constructor() {
    this.controlEnabled = !0, this.defaultCenter = new Vt(39.83, -98.58), this.defaultZoom = 4, this.legendPins = [], this.padding = {
      bottom: () => 50,
      left: () => 50,
      right: () => 50,
      top: () => 50
    }, this.panHandler = (t, r) => null, this.panStartHandler = (t) => null, this.provider = null, this.providerOptions = {}, this.singlePinZoom = 14, this.wrapper = null;
  }
  /**
   * @param {boolean} controlEnabled Whether the user can move and zoom the map
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withControlEnabled(t) {
    return this.controlEnabled = t, this;
  }
  /**
   * @param {module:@yext/components-tsx-geo~Coordinate} defaultCenter The center on initial load and
   *   when calling {@link module:@yext/components-maps~Map#fitCoordinates Map#fitCoordinates} with an empty array
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withDefaultCenter(t) {
    return this.defaultCenter = new Vt(t), this;
  }
  /**
   * @param {number} defaultZoom The zoom on initial load and when calling {@link module:@yext/components-maps~Map#fitCoordinates Map#fitCoordinates}
   *   with an empty array
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withDefaultZoom(t) {
    return this.defaultZoom = t, this;
  }
  /**
   * @todo GENERATOR TODO Map legend not yet implemented
   * @param {module:@yext/components-maps~MapPin[]} legendPins Pins used to construct the map legend
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withLegendPins(t) {
    return this.legendPins = Array.from(t), this;
  }
  /**
   * Padding is used by {@link module:@yext/components-maps~Map#fitCoordinates Map#fitCoordinates}.
   * Padding can either be constant values or funtions that return a padding value.
   * See {@link module:@yext/components-maps~Map#setPadding Map#setPadding} for more information.
   * @param {Object} padding
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.bottom Minimum number of
   *   pixels between the map's bottom edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.left Minimum number of
   *   pixels between the map's left edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.right Minimum number of
   *   pixels between the map's right edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.top Minimum number of
   *   pixels between the map's top edge and a pin
   * @returns {module:@yext/components-maps~MapOptions}
   * @see module:@yext/components-maps~Map#setPadding
   */
  withPadding(t) {
    return this.padding = t, this;
  }
  /**
   * @param {module:@yext/components-maps~PanHandler} panHandler
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withPanHandler(t) {
    return hr(t, er.FUNCTION), this.panHandler = t, this;
  }
  /**
   * @param {module:@yext/components-maps~PanStartHandler} panStartHandler
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withPanStartHandler(t) {
    return hr(t, er.FUNCTION), this.panStartHandler = t, this;
  }
  /**
   * The {@link module:@yext/components-maps~MapProvider MapProvider} must be loaded before
   * constructing the {@link module:@yext/components-maps~Map Map}.
   * @param {module:@yext/components-maps~MapProvider} provider
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withProvider(t) {
    return tr(t, Ko), this.provider = t, this;
  }
  /**
   * @param {Object} providerOptions A free-form object used to set any additional provider-specific
   *   options in the {@link module:@yext/components-maps~ProviderMap ProviderMap}
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withProviderOptions(t) {
    return this.providerOptions = t, this;
  }
  /**
   * @param {number} singlePinZoom The zoom when calling {@link module:@yext/components-maps~Map#fitCoordinates Map#fitCoordinates}
   *   with an array containing one coordinate
   * @returns {MapOptions}
   */
  withSinglePinZoom(t) {
    return this.singlePinZoom = t, this;
  }
  /**
   * @param {HTMLElement} wrapper The wrapper element that the map will be inserted into. The
   *   existing contents of the element will be removed.
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withWrapper(t) {
    return tr(t, HTMLElement), this.wrapper = t, this;
  }
  /**
   * @returns {module:@yext/components-maps~Map}
   */
  build() {
    return new rh(this);
  }
}
let rh = class {
  /**
   * The {@link module:@yext/components-maps~MapProvider MapProvider} for the map must be loaded
   * before calling this constructor.
   * @param {module:@yext/components-maps~MapOptions} options
   */
  constructor(t) {
    if (tr(t, nh), tr(t.provider, Ko), tr(t.wrapper, HTMLElement), !t.provider.loaded)
      throw new Error(
        `MapProvider '${t.provider.getProviderName()}' is not loaded. The MapProvider must be loaded before calling Map constructor.`
      );
    for (this._defaultCenter = t.defaultCenter, this._defaultZoom = t.defaultZoom, this._legendPins = t.legendPins, this._provider = t.provider, this._singlePinZoom = t.singlePinZoom, this._wrapper = t.wrapper, this._padding = {}, this.setPadding(t.padding), this._cachedBounds = null, this._resolveIdle = () => null, this._resolveMoving = () => null, this._idlePromise = Promise.resolve(), this._setIdle(), this.setPanHandler(t.panHandler), this.setPanStartHandler(t.panStartHandler); this._wrapper.firstChild; )
      this._wrapper.removeChild(this._wrapper.lastChild);
    this._panHandlerRunning = !1, this._panStartHandlerRunning = !1, this._map = new Qf(t.provider, this._wrapper).withControlEnabled(t.controlEnabled).withPanHandler(() => this.panHandler()).withPanStartHandler(() => this.panStartHandler()).withProviderOptions(t.providerOptions).build(), this.setZoomCenter(this._defaultZoom, this._defaultCenter), this._currentBounds = this.getBounds();
  }
  /**
   * Set the map bounds so that all the given coordinates are within the {@link module:@yext/components-maps~MapOptions#withPadding padded}
   * view.
   * @param {module:@yext/components-tsx-geo~Coordinate[]} coordinates
   * @param {boolean} [animated=false] Whether to transition smoothly to the new bounds
   * @param {number} [maxZoom=singlePinZoom] The max zoom level after fitting. Uses {@link module:@yext/components-maps~MapOptions#withSinglePinZoom singlePinZoom}
   *   by default.
   */
  fitCoordinates(t, r = !1, o = this._singlePinZoom) {
    t.length ? this.setBounds(
      Po.fit(t),
      r,
      this._padding,
      o
    ) : this.setZoomCenter(this._defaultZoom, this._defaultCenter, r);
  }
  /**
   * Get the current visible region of the map. If the map is zoomed out to show multiple copies of
   * the world, the longitude bounds will be outside [-180, 180) but the center will always be
   * within [-180, 180).
   * @returns {module:@yext/components-tsx-geo~GeoBounds}
   */
  getBounds() {
    if (!this._cachedBounds) {
      const t = this._wrapper.offsetHeight, r = this._wrapper.offsetWidth, o = this.getZoom(), f = this.getCenter(), h = 360 / Math.pow(2, o + 8), C = r * h, T = t * h;
      this._cachedBounds = new Po(f, f), this._cachedBounds.ne.add(
        T / 2,
        C / 2,
        nn.DEGREE,
        Ir.MERCATOR
      ), this._cachedBounds.sw.add(
        -T / 2,
        -C / 2,
        nn.DEGREE,
        Ir.MERCATOR
      ), this.moving().then(() => this._cachedBounds = null);
    }
    return new Po(this._cachedBounds.sw, this._cachedBounds.ne);
  }
  /**
   * @returns {module:@yext/components-tsx-geo~Coordinate} The center of the current visible region of
   *   the map
   */
  getCenter() {
    return this._map.getCenter();
  }
  /**
   * Intended for internal use only
   * @returns {module:@yext/components-maps~ProviderMap} The map's {@link module:@yext/components-maps~ProviderMap ProviderMap}
   *   instance
   */
  getProviderMap() {
    return this._map;
  }
  /**
   * To standardize zoom for all providers, zoom level is calculated with this formula:
   * zoom = log2(pixel width of equator) - 8.
   * At zoom = 0, the entire world is 256 pixels wide.
   * At zoom = 1, the entire world is 512 pixels wide.
   * Zoom 2 → 1024 pixels, zoom 3 → 2056 pixels, etc.
   * Negative and non-integer zoom levels are valid and follow the formula.
   * @returns {number} The current zoom level of the map
   */
  getZoom() {
    return this._map.getZoom();
  }
  /**
   * Returns when the map is not moving.
   * Use map.idle().then(callback) to run callback immediately if the map is currently idle or once
   * the map becomes idle if it's not.
   */
  async idle() {
    await this._idlePromise;
  }
  /**
   * Returns when the map is moving.
   * Use map.moving().then(callback) to run callback immediately if the map is currently moving or
   * once the map starts moving if it's not.
   */
  async moving() {
    await this._movingPromise;
  }
  /**
   * @returns {module:@yext/components-maps~MapPinOptions} A {@link module:@yext/components-maps~MapPinOptions MapPinOptions}
   *   instance with the same provider as this map
   */
  newPinOptions() {
    return new Pc().withProvider(this._provider);
  }
  /**
   * Called when the map has finished moving, at most once per animation frame.
   * Passes the current and previous bounds to the custom pan handler given by {@link module:@yext/components-maps~MapOptions#withPanHandler MapOptions#withPanHandler}
   */
  panHandler() {
    this._panHandlerRunning || (this._panHandlerRunning = !0, requestAnimationFrame(() => {
      const t = this._currentBounds;
      this._currentBounds = this.getBounds(), this._panHandler(
        t,
        new Po(
          new Vt(this._currentBounds.sw),
          new Vt(this._currentBounds.ne)
        )
      ), this._panHandlerRunning = !1;
    }), this._setIdle());
  }
  /**
   * Called when the map has started moving, at most once per animation frame.
   * Passes the current bounds to the custom pan handler given by {@link module:@yext/components-maps~MapOptions#withPanStartHandler MapOptions#withPanStartHandler}
   */
  panStartHandler() {
    this._panStartHandlerRunning || (this._panStartHandlerRunning = !0, requestAnimationFrame(() => {
      this._panStartHandler(
        new Po(
          new Vt(this._currentBounds.sw),
          new Vt(this._currentBounds.ne)
        )
      ), this._panStartHandlerRunning = !1;
    }), this._setMoving());
  }
  /**
   * @param {Object} bounds
   * @param {Object} bounds.ne The northeast corner of the bounds -- must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @param {Object} bounds.sw The southwest corner of the bounds -- must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @param {boolean} [animated=false] Whether to transition smoothly to the new bounds
   * @param {Object} [padding={}]
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.bottom Minimum number of
   *   pixels between the map's bottom edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.left Minimum number of
   *   pixels between the map's left edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.right Minimum number of
   *   pixels between the map's right edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.top Minimum number of
   *   pixels between the map's top edge and a pin
   * @param {number} [maxZoom=Infinity]
   */
  setBounds({ ne: t, sw: r }, o = !1, f = {}, h = 1 / 0) {
    const C = this._wrapper.offsetHeight, T = this._wrapper.offsetWidth;
    if (!C || !T)
      return;
    let O = ql(f.bottom, C), S = ql(f.left, T), x = ql(f.right, T), D = ql(f.top, C), k = S + x, H = O + D;
    k > io && (S *= io / k, x *= io / k, k = io), H > io && (O *= io / H, D *= io / H, H = io);
    const N = C * (1 - H), v = T * (1 - k), F = new Po(r, t), U = new Vt(F.ne.latitude, F.sw.longitude), I = F.sw.distanceTo(U, nn.DEGREE, Ir.MERCATOR), K = (F.ne.longitude - U.longitude + 360) % 360;
    let B = Math.max(I, K * N / v) / (1 - H), z = Math.max(K, I * v / N) / (1 - k), te = Math.log2(T * 360 / z) - 8;
    te > h && (te = h, z = T * 360 / 2 ** (te + 8), B = z * C / T);
    const re = F.getCenter(Ir.MERCATOR), de = (D - O) / 2 * B, V = (x - S) / 2 * z;
    re.add(de, V, nn.DEGREE, Ir.MERCATOR), this.setZoomCenter(te, re, o);
  }
  /**
   * @param {Object} coordinate Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @param {boolean} [animated=false] Whether to transition smoothly to the new center
   */
  setCenter(t, r = !1) {
    this._map.setCenter(new Vt(t), r);
  }
  /**
   * Padding is used by {@link module:@yext/components-maps~Map#fitCoordinates Map#fitCoordinates}.
   * Padding can either be constant values or funtions that return a padding value.
   * Constant values are good if the map should always have the same padding on every breakpoint.
   * Functions are useful if the map should have different padding at different breakpoints/layouts.
   * The function can check window.innerWidth or any other condition before returning a number.
   * @param {Object} padding
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.bottom Minimum number of
   *   pixels between the map's bottom edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.left Minimum number of
   *   pixels between the map's left edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.right Minimum number of
   *   pixels between the map's right edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.top Minimum number of
   *   pixels between the map's top edge and a pin
   * @returns {module:@yext/components-maps~Map}
   */
  setPadding({
    bottom: t = this._padding.bottom,
    left: r = this._padding.left,
    right: o = this._padding.right,
    top: f = this._padding.top
  }) {
    return this._padding = { bottom: t, left: r, right: o, top: f }, this;
  }
  /**
   * @param {module:@yext/components-maps~Map~panHandler} panHandler
   */
  setPanHandler(t) {
    hr(t, er.FUNCTION), this._panHandler = t;
  }
  /**
   * @param {module:@yext/components-maps~Map~panStartHandler} panStartHandler
   */
  setPanStartHandler(t) {
    hr(t, er.FUNCTION), this._panStartHandler = t;
  }
  /**
   * @param {number} zoom
   * @param {boolean} [animated=false] Whether to transition smoothly to the new zoom
   * @see module:@yext/components-maps~Map#getZoom
   */
  setZoom(t, r = !1) {
    this._map.setZoom(t, r);
  }
  /**
   * @param {number} zoom
   * @param {Object} center Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @param {boolean} [animated=false] Whether to transition smoothly to the new bounds
   * @see module:@yext/components-maps~Map#setZoom
   * @see module:@yext/components-maps~Map#setCenter
   */
  setZoomCenter(t, r, o = !1) {
    this._map.setZoomCenter(t, r, o);
  }
  /**
   * Set the map state to idle
   * @protected
   */
  _setIdle() {
    this._resolveMoving(), this._movingPromise = new Promise(
      (t) => this._resolveMoving = t
    ), this._resolveIdle();
  }
  /**
   * Set the map state to moving
   * @protected
   */
  _setMoving() {
    this._resolveIdle(), this._idlePromise = new Promise((t) => this._resolveIdle = t), this._resolveMoving();
  }
};
const la = ia(null);
function jC() {
  const e = Fo(la);
  if (!e || e.map === void 0)
    throw new Error("Attempted to call useMapContext() outside of <Map>.");
  return e.map;
}
const ih = ({
  apiKey: e,
  bounds: t,
  children: r,
  className: o,
  clientKey: f,
  controls: h,
  defaultCenter: C,
  defaultZoom: T,
  mapRef: O,
  padding: S,
  panStartHandler: x,
  panHandler: D,
  provider: k,
  providerOptions: H = {},
  singleZoom: N
}) => {
  const v = Ac(null), [F, U] = Tr(C), [I, K] = Tr(!1), [B, z] = Tr(), [te, re] = Tr(T), de = (V, G) => {
    D(V, G), U(G.getCenter());
  };
  return fr(() => {
    !I || !B || re(B.getZoom());
  }, [F]), fr(() => {
    if (!t || !I || !B)
      return;
    const V = t.map((G) => new Vt(G));
    B.fitCoordinates(V);
  }, [JSON.stringify(t), B]), fr(() => {
    if (!I || B)
      return;
    const V = new nh().withControlEnabled(h).withDefaultCenter(F).withDefaultZoom(te).withPadding(S).withPanHandler(de).withPanStartHandler(x).withProvider(k).withProviderOptions(H).withSinglePinZoom(N).withWrapper(v.current).build();
    z(V), O && (O.current = V);
  }, [I]), fr(() => {
    I || B || !v.current || k.load(e, {
      ...H,
      ...f && { client: f }
    }).then(() => K(!0));
  }, []), /* @__PURE__ */ yt.jsx(
    "div",
    {
      className: Ql(
        {
          "is-loaded": I
        },
        o
      ),
      id: "map",
      ref: v,
      "data-testid": "map",
      children: B && /* @__PURE__ */ yt.jsx(la.Provider, { value: { map: B, provider: k }, children: r })
    }
  );
};
ih.defaultProps = {
  controls: !0,
  defaultCenter: { latitude: 39.83, longitude: -98.58 },
  defaultZoom: 4,
  padding: { bottom: 50, left: 50, right: 50, top: 50 },
  panHandler: () => null,
  panStartHandler: () => null,
  provider: th,
  providerOptions: {},
  singleZoom: 14
};
const kp = ({ count: e }) => /* @__PURE__ */ yt.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "22",
    height: "22",
    viewBox: "0 0 22 22",
    children: /* @__PURE__ */ yt.jsxs("g", { fill: "none", fillRule: "evenodd", children: [
      /* @__PURE__ */ yt.jsx(
        "circle",
        {
          fill: "red",
          fillRule: "nonzero",
          stroke: "white",
          cx: "11",
          cy: "11",
          r: "11"
        }
      ),
      /* @__PURE__ */ yt.jsx(
        "text",
        {
          fill: "white",
          fontFamily: "Arial-BoldMT,Arial",
          fontSize: "12",
          fontWeight: "bold",
          children: /* @__PURE__ */ yt.jsx("tspan", { x: "50%", y: "15", textAnchor: "middle", children: e })
        }
      )
    ] })
  }
), Ic = ia(
  null
);
function qC() {
  const e = Fo(Ic);
  if (!e)
    throw new Error(
      "Attempted to call useClustererContext() outside of <Clusterer>."
    );
  return e;
}
const VC = ({
  clusterRadius: e = 50,
  children: t,
  ClusterTemplate: r = kp
}) => {
  const { map: o } = Fo(la), [f, h] = Tr([]), [C, T] = Tr(), [O, S] = Tr([]), [x, D] = Tr([]);
  return fr(() => {
    T($p(f, o.getZoom(), e));
  }, [f, o.getZoom()]), fr(() => {
    D(() => []), S(() => []), (C == null ? void 0 : C.length) !== 0 && (C == null || C.forEach((k) => {
      if (k.length === 1) {
        k[0].pin.setMap(o);
        return;
      }
      if (k.length > 1) {
        const H = Po.fit(
          k.map((v) => v.pin.getCoordinate())
        ).getCenter(Ir.MERCATOR), N = `cluster-{${H._lat},${H._lon}}`;
        k.forEach((v) => v.pin.setMap(null)), S((v) => [...v, N]), D((v) => [
          ...v,
          /* @__PURE__ */ yt.jsx(
            kc,
            {
              coordinate: H,
              id: N,
              onClick: () => o.fitCoordinates(
                k.map((F) => F.pin.getCoordinate()),
                !0,
                1 / 0
              ),
              children: /* @__PURE__ */ yt.jsx(r, { count: k.length })
            },
            N
          )
        ]);
      }
    }));
  }, [C]), /* @__PURE__ */ yt.jsx(
    Ic.Provider,
    {
      value: {
        clusters: C ?? [],
        clusterIds: O,
        setPinStore: h
      },
      children: /* @__PURE__ */ yt.jsxs(yt.Fragment, { children: [
        x.map((k, H) => /* @__PURE__ */ yt.jsx(Dg, { children: k }, H)),
        t
      ] })
    }
  );
}, $p = (e, t, r) => {
  const o = r * Math.PI / 2 ** (t + 7), f = e.map((T, O) => [O]), h = [];
  e.forEach((T, O) => {
    for (let S = O; S < e.length; S++)
      S !== O && new Vt(T.pin.getCoordinate()).distanceTo(
        new Vt(e[S].pin.getCoordinate()),
        nn.RADIAN,
        Ir.MERCATOR
      ) <= o && (f[O].push(S), f[S].push(O));
  });
  let C = 1;
  for (; C; ) {
    C = 0;
    let T;
    if (f.forEach((x, D) => {
      x.length > C && (C = x.length, T = D);
    }), !C)
      break;
    const O = f[T ?? 0], S = [];
    f[T ?? 0] = [];
    for (const x of O) {
      const D = f[x];
      S.push(e[x]), f[x] = [], D.forEach(
        (k) => f[k].splice(
          f[k].indexOf(x),
          1
        )
      );
    }
    h.push(S);
  }
  return h;
}, Fp = /* @__PURE__ */ yt.jsx(
  "svg",
  {
    width: "30",
    height: "38",
    viewBox: "0 0 30 38",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ yt.jsx(
      "path",
      {
        d: "M30 15.0882C30 23.4212 23.3333 30.7353 15 38C7.22222 31.2941 0 23.4212 0 15.0882C0 6.75523 6.71573 0 15 0C23.2843 0 30 6.75523 30 15.0882Z",
        fill: "red"
      }
    )
  }
), kc = ({
  children: e,
  coordinate: t,
  hideOffscreen: r,
  id: o,
  icon: f,
  onClick: h,
  onFocus: C,
  onHover: T,
  zIndex: O
}) => {
  const { map: S, provider: x } = Fo(la), D = Fo(Ic), k = Kf(() => new Pc().withCoordinate(t).withHideOffscreen(r).withProvider(x).build(), []);
  fr(() => {
    if (O !== 0 && !O)
      return;
    const N = k.getProviderPin().getWrapperElement();
    N && (N.style.zIndex = O.toString());
  }, [O]), fr(() => {
    k.setMap(S), k.setClickHandler(() => h(o)), k.setFocusHandler((v) => C(v, o)), k.setHoverHandler((v) => T(v, o));
    const N = D == null ? void 0 : D.clusterIds.includes(o);
    return D && !N && D.setPinStore((v) => [
      ...v,
      {
        pin: k,
        id: o
      }
    ]), () => {
      k.setMap(null), D && D.setPinStore(
        (v) => v.filter((F) => F.id !== o)
      );
    };
  }, []);
  const H = e || f;
  if (H) {
    const N = k.getProviderPin().getPinElement();
    return Object.assign(N.style, {
      height: "auto",
      width: "auto"
    }), Ag(H, N);
  }
  return null;
};
kc.defaultProps = {
  hideOffscreen: !1,
  icon: Fp,
  onClick: () => null,
  onHover: () => null,
  onFocus: () => null
};
const Bp = ({
  children: e,
  coordinate: t,
  linkSameTab: r,
  pinUrl: o,
  onClick: f = () => null,
  onHover: h = () => null,
  onFocus: C = () => null,
  ...T
}) => /* @__PURE__ */ yt.jsx(ih, { bounds: [t], ...T, children: /* @__PURE__ */ yt.jsx(
  kc,
  {
    coordinate: t,
    id: "location-map-marker",
    onClick: f,
    onHover: h,
    onFocus: C,
    children: o ? /* @__PURE__ */ yt.jsx(xp, { href: o, target: r ? "_self" : "_blank", children: e }) : e || void 0
  }
) });
Bp.defaultProps = {
  controls: !0,
  panHandler: () => null,
  provider: th,
  singleZoom: 16
};
var Ia = {}, Qs = {}, Iu;
function Kp() {
  if (Iu)
    return Qs;
  Iu = 1;
  var e = rn;
  function t(o) {
    let f = new URLSearchParams();
    f.append("code", o);
    for (let h = 1; h < arguments.length; h++)
      f.append("v", arguments[h]);
    throw Error(`Minified Lexical error #${o}; visit https://lexical.dev/docs/error?${f} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  let r = e.createContext(null);
  return Qs.LexicalComposerContext = r, Qs.createLexicalComposerContext = function(o, f) {
    let h = null;
    return o != null && (h = o[1]), { getTheme: function() {
      return f ?? (h != null ? h.getTheme() : null);
    } };
  }, Qs.useLexicalComposerContext = function() {
    let o = e.useContext(r);
    return o == null && t(8), o;
  }, Qs;
}
var el = {}, ku;
function Hp() {
  if (ku)
    return el;
  ku = 1;
  var e = rn;
  const t = /* @__PURE__ */ e.createContext(null);
  function r(f, h) {
    let C = null;
    f != null && (C = f[1]);
    function T() {
      return h ?? (C != null ? C.getTheme() : null);
    }
    return {
      getTheme: T
    };
  }
  function o() {
    const f = e.useContext(t);
    if (f == null)
      throw Error("LexicalComposerContext.useLexicalComposerContext: cannot find a LexicalComposerContext");
    return f;
  }
  return el.LexicalComposerContext = t, el.createLexicalComposerContext = r, el.useLexicalComposerContext = o, el;
}
var ka, $u;
function kn() {
  return $u || ($u = 1, ka = process.env.NODE_ENV === "development" ? Hp() : Kp()), ka;
}
var ke = {}, Fu;
function Up() {
  if (Fu)
    return ke;
  Fu = 1;
  let e = {}, t = {}, r = {}, o = {}, f = {}, h = {}, C = {}, T = {}, O = {}, S = {}, x = {}, D = {}, k = {}, H = {}, N = {}, v = {}, F = {}, U = {}, I = {}, K = {}, B = {}, z = {}, te = {}, re = {}, de = {}, V = {}, G = {}, q = {}, me = {}, pe = {}, Z = {}, ee = {}, P = {}, w = {}, j = {}, ne = {};
  function Y(l) {
    let n = new URLSearchParams();
    n.append("code", l);
    for (let s = 1; s < arguments.length; s++)
      n.append("v", arguments[s]);
    throw Error(`Minified Lexical error #${l}; visit https://lexical.dev/docs/error?${n} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  let W = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Q = W && "documentMode" in document ? document.documentMode : null, b = W && /Mac|iPod|iPhone|iPad/.test(navigator.platform), g = W && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), _ = W && "InputEvent" in window && !Q ? "getTargetRanges" in new window.InputEvent("input") : !1, A = W && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), J = W && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, ce = W && /Android/.test(navigator.userAgent), ge = W && /^(?=.*Chrome).*/i.test(navigator.userAgent), ae = W && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !ge, Te = A || J || ae ? " " : "​", Me = g ? " " : Te, ze = /^[^A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02b8\u0300-\u0590\u0800-\u1fff\u200e\u2c00-\ufb1c\ufe00-\ufe6f\ufefd-\uffff]*[\u0591-\u07ff\ufb1d-\ufdfd\ufe70-\ufefc]/, oe = /^[^\u0591-\u07ff\ufb1d-\ufdfd\ufe70-\ufefc]*[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02b8\u0300-\u0590\u0800-\u1fff\u200e\u2c00-\ufb1c\ufe00-\ufe6f\ufefd-\uffff]/, ie = { bold: 1, code: 16, highlight: 128, italic: 2, strikethrough: 4, subscript: 32, superscript: 64, underline: 8 }, ue = { directionless: 1, unmergeable: 2 }, we = { center: 2, end: 6, justify: 4, left: 1, right: 3, start: 5 }, Le = { 2: "center", 6: "end", 4: "justify", 1: "left", 3: "right", 5: "start" }, Be = { normal: 0, segmented: 2, token: 1 }, Ye = { 0: "normal", 2: "segmented", 1: "token" }, st = !1, pt = 0;
  function at(l) {
    pt = l.timeStamp;
  }
  function ve(l, n, s) {
    return n.__lexicalLineBreak === l || l[`__lexicalKey_${s._key}`] !== void 0;
  }
  function se(l) {
    return l.getEditorState().read(() => {
      let n = Wt();
      return n !== null ? n.clone() : null;
    });
  }
  function he(l, n, s) {
    st = !0;
    let d = 100 < performance.now() - pt;
    try {
      Jn(l, () => {
        let m = Wt() || se(l);
        var E = /* @__PURE__ */ new Map(), R = l.getRootElement(), X = l._editorState, _e = l._blockCursorElement;
        let Se = !1, Fe = "";
        for (var Ue = 0; Ue < n.length; Ue++) {
          var Pe = n[Ue], De = Pe.type, Xe = Pe.target, lt = gr(Xe, X);
          if (!(lt === null && Xe !== R || Qt(lt))) {
            if (De === "characterData") {
              if (Pe = d && ut(lt))
                e: {
                  Pe = m, De = Xe;
                  var Nt = lt;
                  if (vt(Pe)) {
                    var Ot = Pe.anchor.getNode();
                    if (Ot.is(Nt) && Pe.format !== Ot.getFormat()) {
                      Pe = !1;
                      break e;
                    }
                  }
                  Pe = De.nodeType === 3 && Nt.isAttached();
                }
              Pe && (Nt = xr(l._window), De = Pe = null, Nt !== null && Nt.anchorNode === Xe && (Pe = Nt.anchorOffset, De = Nt.focusOffset), Xe = Xe.nodeValue, Xe !== null && _t(lt, Xe, Pe, De, !1));
            } else if (De === "childList") {
              for (Se = !0, De = Pe.addedNodes, Nt = 0; Nt < De.length; Nt++) {
                Ot = De[Nt];
                var sn = nr(Ot), Xn = Ot.parentNode;
                Xn == null || Ot === _e || sn !== null || Ot.nodeName === "BR" && ve(Ot, Xn, l) || (g && (sn = Ot.innerText || Ot.nodeValue) && (Fe += sn), Xn.removeChild(Ot));
              }
              if (Pe = Pe.removedNodes, De = Pe.length, 0 < De) {
                for (Nt = 0, Ot = 0; Ot < De; Ot++)
                  Xn = Pe[Ot], (Xn.nodeName === "BR" && ve(Xn, Xe, l) || _e === Xn) && (Xe.appendChild(Xn), Nt++);
                De !== Nt && (Xe === R && (lt = X._nodeMap.get("root")), E.set(Xe, lt));
              }
            }
          }
        }
        if (0 < E.size)
          for (let [
            Ar,
            jr
          ] of E)
            if (Je(jr))
              for (E = jr.getChildrenKeys(), R = Ar.firstChild, X = 0; X < E.length; X++)
                _e = l.getElementByKey(E[X]), _e !== null && (R == null ? (Ar.appendChild(_e), R = _e) : R !== _e && Ar.replaceChild(_e, R), R = R.nextSibling);
            else
              ut(jr) && jr.markDirty();
        if (E = s.takeRecords(), 0 < E.length) {
          for (R = 0; R < E.length; R++)
            for (_e = E[R], X = _e.addedNodes, _e = _e.target, Ue = 0; Ue < X.length; Ue++)
              lt = X[Ue], Xe = lt.parentNode, Xe == null || lt.nodeName !== "BR" || ve(lt, _e, l) || Xe.removeChild(lt);
          s.takeRecords();
        }
        m !== null && (Se && (m.dirty = !0, rr(m)), g && Zt(l) && m.insertRawText(Fe));
      });
    } finally {
      st = !1;
    }
  }
  function Oe(l) {
    let n = l._observer;
    if (n !== null) {
      let s = n.takeRecords();
      he(l, s, n);
    }
  }
  function be(l) {
    pt === 0 && Kn(l).addEventListener("textInput", at, !0), l._observer = new MutationObserver((n, s) => {
      he(l, n, s);
    });
  }
  function Re(l, n) {
    let s = l.__mode, d = l.__format;
    l = l.__style;
    let m = n.__mode, E = n.__format;
    return n = n.__style, (s === null || s === m) && (d === null || d === E) && (l === null || l === n);
  }
  function He(l, n) {
    let s = l.mergeWithSibling(n), d = Xt()._normalizedNodes;
    return d.add(l.__key), d.add(n.__key), s;
  }
  function Ve(l) {
    if (l.__text === "" && l.isSimpleText() && !l.isUnmergeable())
      l.remove();
    else {
      for (var n; (n = l.getPreviousSibling()) !== null && ut(n) && n.isSimpleText() && !n.isUnmergeable(); )
        if (n.__text === "")
          n.remove();
        else {
          Re(n, l) && (l = He(n, l));
          break;
        }
      for (var s; (s = l.getNextSibling()) !== null && ut(s) && s.isSimpleText() && !s.isUnmergeable(); )
        if (s.__text === "")
          s.remove();
        else {
          Re(l, s) && He(l, s);
          break;
        }
    }
  }
  function Qe(l) {
    return ct(l.anchor), ct(l.focus), l;
  }
  function ct(l) {
    for (; l.type === "element"; ) {
      var n = l.getNode(), s = l.offset;
      if (s === n.getChildrenSize() ? (n = n.getChildAtIndex(s - 1), s = !0) : (n = n.getChildAtIndex(s), s = !1), ut(n)) {
        l.set(n.__key, s ? n.getTextContentSize() : 0, "text");
        break;
      } else if (!Je(n))
        break;
      l.set(n.__key, s ? n.getChildrenSize() : 0, "element");
    }
  }
  let At = 1, je = typeof queueMicrotask == "function" ? queueMicrotask : (l) => {
    Promise.resolve().then(l);
  };
  function qe(l) {
    let n = document.activeElement;
    if (n === null)
      return !1;
    let s = n.nodeName;
    return Qt(gr(l)) && (s === "INPUT" || s === "TEXTAREA" || n.contentEditable === "true" && n.__lexicalEditor == null);
  }
  function nt(l, n, s) {
    let d = l.getRootElement();
    try {
      return d !== null && d.contains(n) && d.contains(s) && n !== null && !qe(n) && gt(n) === l;
    } catch {
      return !1;
    }
  }
  function gt(l) {
    for (; l != null; ) {
      let n = l.__lexicalEditor;
      if (n != null)
        return n;
      l = ir(l);
    }
    return null;
  }
  function Ct(l) {
    return l.isToken() || l.isSegmented();
  }
  function xt(l) {
    for (; l != null; ) {
      if (l.nodeType === 3)
        return l;
      l = l.firstChild;
    }
    return null;
  }
  function St(l, n, s) {
    let d = ie[n];
    return s !== null && (l & d) === (s & d) || (l ^= d, n === "subscript" ? l &= ~ie.superscript : n === "superscript" && (l &= ~ie.subscript)), l;
  }
  function wt(l, n) {
    if (n != null)
      l.__key = n;
    else {
      Un(), 99 < Ji && Y(14), n = Xt();
      var s = lr(), d = "" + At++;
      s._nodeMap.set(d, l), Je(l) ? n._dirtyElements.set(d, !0) : n._dirtyLeaves.add(d), n._cloneNotNeeded.add(d), n._dirtyType = 1, l.__key = d;
    }
  }
  function Et(l) {
    var n = l.getParent();
    if (n !== null) {
      let m = l.getWritable();
      n = n.getWritable();
      var s = l.getPreviousSibling();
      if (l = l.getNextSibling(), s === null)
        if (l !== null) {
          var d = l.getWritable();
          n.__first = l.__key, d.__prev = null;
        } else
          n.__first = null;
      else {
        if (d = s.getWritable(), l !== null) {
          let E = l.getWritable();
          E.__prev = d.__key, d.__next = E.__key;
        } else
          d.__next = null;
        m.__prev = null;
      }
      l === null ? s !== null ? (l = s.getWritable(), n.__last = s.__key, l.__next = null) : n.__last = null : (l = l.getWritable(), s !== null ? (s = s.getWritable(), s.__next = l.__key, l.__prev = s.__key) : l.__prev = null, m.__next = null), n.__size--, m.__parent = null;
    }
  }
  function Yt(l) {
    99 < Ji && Y(14);
    var n = l.getLatest(), s = n.__parent, d = lr();
    let m = Xt(), E = d._nodeMap;
    if (d = m._dirtyElements, s !== null)
      e:
        for (; s !== null; ) {
          if (d.has(s))
            break e;
          let R = E.get(s);
          if (R === void 0)
            break;
          d.set(s, !1), s = R.__parent;
        }
    n = n.__key, m._dirtyType = 1, Je(l) ? d.set(n, !0) : m._dirtyLeaves.add(n);
  }
  function Dt(l) {
    Un();
    var n = Xt();
    let s = n._compositionKey;
    l !== s && (n._compositionKey = l, s !== null && (n = bt(s), n !== null && n.getWritable()), l !== null && (l = bt(l), l !== null && l.getWritable()));
  }
  function Kt() {
    return Yr() ? null : Xt()._compositionKey;
  }
  function bt(l, n) {
    return l = (n || lr())._nodeMap.get(l), l === void 0 ? null : l;
  }
  function nr(l, n) {
    let s = Xt();
    return l = l[`__lexicalKey_${s._key}`], l !== void 0 ? bt(l, n) : null;
  }
  function gr(l, n) {
    for (; l != null; ) {
      let s = nr(l, n);
      if (s !== null)
        return s;
      l = ir(l);
    }
    return null;
  }
  function Ci(l) {
    let n = Object.assign({}, l._decorators);
    return l._pendingDecorators = n;
  }
  function Ho(l) {
    return l.read(() => on().getTextContent());
  }
  function Uo(l, n) {
    Jn(l, () => {
      var s = lr();
      if (!s.isEmpty())
        if (n === "root")
          on().markDirty();
        else {
          s = s._nodeMap;
          for (let [, d] of s)
            d.markDirty();
        }
    }, l._pendingEditorState === null ? { tag: "history-merge" } : void 0);
  }
  function on() {
    return lr()._nodeMap.get("root");
  }
  function rr(l) {
    Un();
    let n = lr();
    l !== null && (l.dirty = !0, l.setCachedNodes(null)), n._selection = l;
  }
  function Fr(l) {
    var n = Xt(), s;
    e: {
      for (s = l; s != null; ) {
        let d = s[`__lexicalKey_${n._key}`];
        if (d !== void 0) {
          s = d;
          break e;
        }
        s = ir(s);
      }
      s = null;
    }
    return s === null ? (n = n.getRootElement(), l === n ? bt("root") : null) : bt(s);
  }
  function Wo(l) {
    return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(l);
  }
  function ye(l) {
    let n = [];
    for (; l !== null; )
      n.push(l), l = l._parentEditor;
    return n;
  }
  function Ge() {
    return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 5);
  }
  function et(l, n, s) {
    if (n = xr(n._window), n !== null) {
      var d = n.anchorNode, { anchorOffset: m, focusOffset: E } = n;
      if (d !== null && (n = d.nodeType === 3 ? d.nodeValue : null, d = gr(d), n !== null && ut(d))) {
        if (n === Te && s) {
          let R = s.length;
          n = s, E = m = R;
        }
        n !== null && _t(d, n, m, E, l);
      }
    }
  }
  function _t(l, n, s, d, m) {
    let E = l;
    if (E.isAttached() && (m || !E.isDirty())) {
      let Se = E.isComposing(), Fe = n;
      if ((Se || m) && n[n.length - 1] === Te && (Fe = n.slice(0, -1)), n = E.getTextContent(), m || Fe !== n)
        if (Fe === "")
          if (Dt(null), A || J || ae)
            E.remove();
          else {
            let Ue = Xt();
            setTimeout(() => {
              Ue.update(() => {
                E.isAttached() && E.remove();
              });
            }, 20);
          }
        else {
          m = E.getParent(), n = Si();
          var R = E.getTextContentSize(), X = Kt(), _e = E.getKey();
          E.isToken() || X !== null && _e === X && !Se || vt(n) && (m !== null && !m.canInsertTextBefore() && n.anchor.offset === 0 || n.anchor.key === l.__key && n.anchor.offset === 0 && !E.canInsertTextBefore() || n.focus.key === l.__key && n.focus.offset === R && !E.canInsertTextAfter()) ? E.markDirty() : (l = Wt(), vt(l) && s !== null && d !== null && (l.setTextNodeRange(E, s, E, d), E.isSegmented() && (s = E.getTextContent(), s = An(s), E.replace(s), E = s)), E.setTextContent(Fe));
        }
    }
  }
  function It(l, n) {
    if (n.isSegmented())
      return !0;
    if (!l.isCollapsed())
      return !1;
    l = l.anchor.offset;
    let s = n.getParentOrThrow(), d = n.isToken();
    return l === 0 ? ((l = !n.canInsertTextBefore() || !s.canInsertTextBefore() || d) || (n = n.getPreviousSibling(), l = (ut(n) || Je(n) && n.isInline()) && !n.canInsertTextAfter()), l) : l === n.getTextContentSize() ? !n.canInsertTextAfter() || !s.canInsertTextAfter() || d : !1;
  }
  function Ft(l, n) {
    l.__lexicalClassNameCache === void 0 && (l.__lexicalClassNameCache = {});
    let s = l.__lexicalClassNameCache, d = s[n];
    return d !== void 0 ? d : (l = l[n], typeof l == "string" ? (l = l.split(" "), s[n] = l) : l);
  }
  function Lt(l, n, s, d, m) {
    s.size !== 0 && (s = d.__type, d = d.__key, n = n.get(s), n === void 0 && Y(33, s), s = n.klass, n = l.get(s), n === void 0 && (n = /* @__PURE__ */ new Map(), l.set(s, n)), l = n.get(d), s = l === "destroyed" && m === "created", (l === void 0 || s) && n.set(d, s ? "updated" : m));
  }
  function Mt(l, n, s) {
    let d = l.getParent(), m = s;
    return d !== null && (n && s === 0 ? (m = l.getIndexWithinParent(), l = d) : n || s !== l.getChildrenSize() || (m = l.getIndexWithinParent() + 1, l = d)), l.getChildAtIndex(n ? m - 1 : m);
  }
  function cn(l, n) {
    var s = l.offset;
    return l.type === "element" ? (l = l.getNode(), Mt(l, n, s)) : (l = l.getNode(), n && s === 0 || !n && s === l.getTextContentSize() ? (s = n ? l.getPreviousSibling() : l.getNextSibling(), s === null ? Mt(l.getParentOrThrow(), n, l.getIndexWithinParent() + (n ? 0 : 1)) : s) : null);
  }
  function Zt(l) {
    return l = (l = Kn(l).event) && l.inputType, l === "insertFromPaste" || l === "insertFromPasteAsQuotation";
  }
  function jt(l) {
    return !Yn(l) && !l.isLastChild() && !l.isInline();
  }
  function Rn(l, n) {
    return l = l._keyToDOMMap.get(n), l === void 0 && Y(75, n), l;
  }
  function ir(l) {
    return l = l.assignedSlot || l.parentElement, l !== null && l.nodeType === 11 ? l.host : l;
  }
  function Xr(l, n) {
    for (l = l.getParent(); l !== null; ) {
      if (l.is(n))
        return !0;
      l = l.getParent();
    }
    return !1;
  }
  function Kn(l) {
    return l = l._window, l === null && Y(78), l;
  }
  function xs(l) {
    for (l = l.getParentOrThrow(); l !== null && !Br(l); )
      l = l.getParentOrThrow();
    return l;
  }
  function Br(l) {
    return Yn(l) || Je(l) && l.isShadowRoot();
  }
  function vs(l) {
    return l = l.constructor.clone(l), wt(l, null), l;
  }
  function Ni(l) {
    var n = Xt();
    let s = l.constructor.getType();
    return n = n._nodes.get(s), n === void 0 && Y(97), n = n.replace, n !== null ? (n = n(l), n instanceof l.constructor || Y(98), n) : l;
  }
  function zo(l, n) {
    l = l.getParent(), !Yn(l) || Je(n) || Qt(n) || Y(99);
  }
  function Ss(l) {
    return (Qt(l) || Je(l) && !l.canBeEmpty()) && !l.isInline();
  }
  function ws(l, n, s) {
    s.style.removeProperty("caret-color"), n._blockCursorElement = null, n = l.parentElement, n !== null && n.removeChild(l);
  }
  function xr(l) {
    return W ? (l || window).getSelection() : null;
  }
  function Go(l, n) {
    for (; l !== on() && l != null; ) {
      if (n(l))
        return l;
      l = l.getParent();
    }
    return null;
  }
  function ua(l) {
    let n = [], s = [l];
    for (; 0 < s.length; ) {
      let d = s.pop();
      d === void 0 && Y(112), Je(d) && s.unshift(...d.getChildren()), d !== l && n.push(d);
    }
    return n;
  }
  function Bi(l) {
    return l.nodeType === 1;
  }
  function Kr(l) {
    if (Qt(l) && !l.isInline())
      return !0;
    if (!Je(l) || Br(l))
      return !1;
    var n = l.getFirstChild();
    return n = n === null || ri(n) || ut(n) || n.isInline(), !l.isInline() && l.canBeEmpty() !== !1 && n;
  }
  function ao(l, n) {
    for (; l !== null && l.getParent() !== null && !n(l); )
      l = l.getParentOrThrow();
    return n(l) ? l : null;
  }
  function cl(l, n, s, d, m, E) {
    for (l = l.getFirstChild(); l !== null; ) {
      let R = l.__key;
      l.__parent === n && (Je(l) && cl(l, R, s, d, m, E), s.has(R) || E.delete(R), m.push(R)), l = l.getNextSibling();
    }
  }
  function Os(l, n, s, d) {
    l = l._nodeMap, n = n._nodeMap;
    let m = [];
    for (let [E] of d) {
      let R = n.get(E);
      R === void 0 || R.isAttached() || (Je(R) && cl(R, E, l, n, m, d), l.has(E) || d.delete(E), m.push(E));
    }
    for (let E of m)
      n.delete(E);
    for (let E of s)
      d = n.get(E), d === void 0 || d.isAttached() || (l.has(E) || s.delete(E), n.delete(E));
  }
  let Cn = "", Sn = "", pr = "", Qr, Dn, co, ei = !1, Ki = !1, Yo, un = null, vr, gn, ti, or, jo, Hi;
  function qo(l, n) {
    let s = ti.get(l);
    if (n !== null) {
      let d = Ds(l);
      d.parentNode === n && n.removeChild(d);
    }
    or.has(l) || Dn._keyToDOMMap.delete(l), Je(s) && (l = uo(s, ti), Hn(l, 0, l.length - 1, null)), s !== void 0 && Lt(Hi, co, Yo, s, "destroyed");
  }
  function Hn(l, n, s, d) {
    for (; n <= s; ++n) {
      let m = l[n];
      m !== void 0 && qo(m, d);
    }
  }
  function ni(l, n) {
    l.setProperty("text-align", n);
  }
  function _r(l, n) {
    var s = Qr.theme.indent;
    if (typeof s == "string") {
      let d = l.classList.contains(s);
      0 < n && !d ? l.classList.add(s) : 1 > n && d && l.classList.remove(s);
    }
    s = getComputedStyle(l).getPropertyValue("--lexical-indent-base-value") || "40px", l.style.setProperty("padding-inline-start", n === 0 ? "" : `calc(${n} * ${s})`);
  }
  function ul(l, n) {
    l = l.style, n === 0 ? ni(l, "") : n === 1 ? ni(l, "left") : n === 2 ? ni(l, "center") : n === 3 ? ni(l, "right") : n === 4 ? ni(l, "justify") : n === 5 ? ni(l, "start") : n === 6 && ni(l, "end");
  }
  function Hr(l, n, s) {
    let d = or.get(l);
    d === void 0 && Y(60);
    let m = d.createDOM(Qr, Dn);
    var E = Dn._keyToDOMMap;
    if (m["__lexicalKey_" + Dn._key] = l, E.set(l, m), ut(d) ? m.setAttribute("data-lexical-text", "true") : Qt(d) && m.setAttribute("data-lexical-decorator", "true"), Je(d)) {
      if (l = d.__indent, E = d.__size, l !== 0 && _r(m, l), E !== 0) {
        --E, l = uo(d, or);
        var R = Sn;
        Sn = "", Vo(l, d, 0, E, m, null), Jo(d, m), Sn = R;
      }
      l = d.__format, l !== 0 && ul(m, l), d.isInline() || Rs(null, d, m), jt(d) && (Cn += `

`, pr += `

`);
    } else
      E = d.getTextContent(), Qt(d) ? (R = d.decorate(Dn, Qr), R !== null && Zo(l, R), m.contentEditable = "false") : ut(d) && (d.isDirectionless() || (Sn += E)), Cn += E, pr += E;
    return n !== null && (s != null ? n.insertBefore(m, s) : (s = n.__lexicalLineBreak, s != null ? n.insertBefore(m, s) : n.appendChild(m))), Lt(Hi, co, Yo, d, "created"), m;
  }
  function Vo(l, n, s, d, m, E) {
    let R = Cn;
    for (Cn = ""; s <= d; ++s)
      Hr(l[s], m, E);
    jt(n) && (Cn += `

`), m.__lexicalTextContent = Cn, Cn = R + Cn;
  }
  function dl(l, n) {
    return l = n.get(l), ri(l) || Qt(l) && l.isInline();
  }
  function Rs(l, n, s) {
    l = l !== null && (l.__size === 0 || dl(l.__last, ti)), n = n.__size === 0 || dl(n.__last, or), l ? n || (n = s.__lexicalLineBreak, n != null && s.removeChild(n), s.__lexicalLineBreak = null) : n && (n = document.createElement("br"), s.__lexicalLineBreak = n, s.appendChild(n));
  }
  function Jo(l, n) {
    var s = n.__lexicalDir;
    if (n.__lexicalDirTextContent !== Sn || s !== un) {
      let E = Sn === "";
      if (E)
        var d = un;
      else
        d = Sn, d = ze.test(d) ? "rtl" : oe.test(d) ? "ltr" : null;
      if (d !== s) {
        let R = n.classList, X = Qr.theme;
        var m = s !== null ? X[s] : void 0;
        let _e = d !== null ? X[d] : void 0;
        m !== void 0 && (typeof m == "string" && (m = m.split(" "), m = X[s] = m), R.remove(...m)), d === null || E && d === "ltr" ? n.removeAttribute("dir") : (_e !== void 0 && (typeof _e == "string" && (s = _e.split(" "), _e = X[d] = s), _e !== void 0 && R.add(..._e)), n.dir = d), Ki || (l.getWritable().__dir = d);
      }
      un = d, n.__lexicalDirTextContent = Sn, n.__lexicalDir = d;
    }
  }
  function uo(l, n) {
    let s = [];
    for (l = l.__first; l !== null; ) {
      let d = n.get(l);
      d === void 0 && Y(101), s.push(l), l = d.__next;
    }
    return s;
  }
  function Ui(l, n) {
    var s = ti.get(l), d = or.get(l);
    s !== void 0 && d !== void 0 || Y(61);
    var m = ei || gn.has(l) || vr.has(l);
    let E = Rn(Dn, l);
    if (s === d && !m)
      return Je(s) ? (d = E.__lexicalTextContent, d !== void 0 && (Cn += d, pr += d), d = E.__lexicalDirTextContent, d !== void 0 && (Sn += d)) : (d = s.getTextContent(), ut(s) && !s.isDirectionless() && (Sn += d), pr += d, Cn += d), E;
    if (s !== d && m && Lt(Hi, co, Yo, d, "updated"), d.updateDOM(s, E, Qr))
      return d = Hr(l, null, null), n === null && Y(62), n.replaceChild(d, E), qo(l, null), d;
    if (Je(s) && Je(d)) {
      if (l = d.__indent, l !== s.__indent && _r(E, l), l = d.__format, l !== s.__format && ul(E, l), m) {
        l = d, m = Sn, Sn = "", n = Cn;
        var R = s.__size, X = l.__size;
        if (Cn = "", R === 1 && X === 1) {
          var _e = s.__first, Se = l.__first;
          if (_e === Se)
            Ui(_e, E);
          else {
            var Fe = Ds(_e);
            Se = Hr(Se, null, null), E.replaceChild(Se, Fe), qo(_e, null);
          }
        } else {
          Se = uo(s, ti);
          var Ue = uo(l, or);
          if (R === 0)
            X !== 0 && Vo(Ue, l, 0, X - 1, E, null);
          else if (X === 0)
            R !== 0 && (_e = E.__lexicalLineBreak == null, Hn(Se, 0, R - 1, _e ? null : E), _e && (E.textContent = ""));
          else {
            var Pe = Se;
            Se = Ue, Ue = R - 1, R = X - 1;
            let Xe = E.firstChild, lt = 0;
            for (X = 0; lt <= Ue && X <= R; ) {
              var De = Pe[lt];
              let Nt = Se[X];
              if (De === Nt)
                Xe = fo(Ui(Nt, E)), lt++, X++;
              else {
                _e === void 0 && (_e = new Set(Pe)), Fe === void 0 && (Fe = new Set(Se));
                let Ot = Fe.has(De), sn = _e.has(Nt);
                Ot ? (sn ? (De = Rn(Dn, Nt), De === Xe ? Xe = fo(Ui(Nt, E)) : (Xe != null ? E.insertBefore(De, Xe) : E.appendChild(De), Ui(Nt, E)), lt++) : Hr(Nt, E, Xe), X++) : (Xe = fo(Ds(De)), qo(De, E), lt++);
              }
            }
            _e = lt > Ue, Fe = X > R, _e && !Fe ? (_e = Se[R + 1], _e = _e === void 0 ? null : Dn.getElementByKey(_e), Vo(Se, l, X, R, E, _e)) : Fe && !_e && Hn(Pe, lt, Ue, E);
          }
        }
        jt(l) && (Cn += `

`), E.__lexicalTextContent = Cn, Cn = n + Cn, Jo(l, E), Sn = m, Yn(d) || d.isInline() || Rs(s, d, E);
      }
      jt(d) && (Cn += `

`, pr += `

`);
    } else
      s = d.getTextContent(), Qt(d) ? (m = d.decorate(
        Dn,
        Qr
      ), m !== null && Zo(l, m)) : ut(d) && !d.isDirectionless() && (Sn += s), Cn += s, pr += s;
    return !Ki && Yn(d) && d.__cachedText !== pr && (d = d.getWritable(), d.__cachedText = pr), E;
  }
  function Zo(l, n) {
    let s = Dn._pendingDecorators, d = Dn._decorators;
    if (s === null) {
      if (d[l] === n)
        return;
      s = Ci(Dn);
    }
    s[l] = n;
  }
  function fo(l) {
    return l = l.nextSibling, l !== null && l === Dn._blockCursorElement && (l = l.nextSibling), l;
  }
  function Ds(l) {
    let n = jo.get(l);
    return n === void 0 && Y(75, l), n;
  }
  let Ur = Object.freeze({}), As = [["keydown", _a], ["pointerdown", fa], ["compositionstart", ga], ["compositionend", pa], ["input", ha], ["click", da], ["cut", Ur], ["copy", Ur], ["dragstart", Ur], ["dragover", Ur], ["dragend", Ur], ["paste", Ur], ["focus", Ur], ["blur", Ur], ["drop", Ur]];
  _ && As.push(["beforeinput", (l, n) => Nl(l, n)]);
  let ho = 0, fl = 0, hl = 0, Wi = null, go = 0, bs = !1, Ms = !1, po = !1, _o = !1, gl = [0, "", 0, "root", 0];
  function pl(l, n, s, d, m) {
    let E = l.anchor, R = l.focus, X = E.getNode();
    var _e = Xt();
    let Se = xr(_e._window), Fe = Se !== null ? Se.anchorNode : null, Ue = E.key;
    _e = _e.getElementByKey(Ue);
    let Pe = s.length;
    return Ue !== R.key || !ut(X) || (!m && (!_ || hl < d + 50) || X.isDirty() && 2 > Pe || Wo(s)) && E.offset !== R.offset && !X.isComposing() || Ct(X) || X.isDirty() && 1 < Pe || (m || !_) && _e !== null && !X.isComposing() && Fe !== xt(_e) || Se !== null && n !== null && (!n.collapsed || n.startContainer !== Se.anchorNode || n.startOffset !== Se.anchorOffset) || X.getFormat() !== l.format || X.getStyle() !== l.style || It(l, X);
  }
  function _l(l, n) {
    return l !== null && l.nodeValue !== null && l.nodeType === 3 && n !== 0 && n !== l.nodeValue.length;
  }
  function ml(l, n, s) {
    let { anchorNode: d, anchorOffset: m, focusNode: E, focusOffset: R } = l;
    bs && (bs = !1, _l(d, m) && _l(E, R)) || Jn(n, () => {
      if (!s)
        rr(null);
      else if (nt(n, d, E)) {
        var X = Wt();
        if (vt(X)) {
          var _e = X.anchor, Se = _e.getNode();
          if (X.isCollapsed()) {
            l.type === "Range" && l.anchorNode === l.focusNode && (X.dirty = !0);
            var Fe = Kn(n).event;
            Fe = Fe ? Fe.timeStamp : performance.now();
            let [Pe, De, Xe, lt, Nt] = gl;
            var Ue = on();
            Ue = n.isComposing() === !1 && Ue.getTextContent() === "", Fe < Nt + 200 && _e.offset === Xe && _e.key === lt ? (X.format = Pe, X.style = De) : _e.type === "text" ? (X.format = Se.getFormat(), X.style = Se.getStyle()) : _e.type !== "element" || Ue || (X.format = 0, X.style = "");
          } else {
            _e = 255, Se = !1, Fe = X.getNodes(), Ue = Fe.length;
            for (let Pe = 0; Pe < Ue; Pe++) {
              let De = Fe[Pe];
              if (ut(De) && (Se = !0, _e &= De.getFormat(), _e === 0))
                break;
            }
            X.format = Se ? _e : 0;
          }
        }
        rt(n, e, void 0);
      }
    });
  }
  function da(l, n) {
    Jn(n, () => {
      let s = Wt();
      var d = xr(n._window);
      let m = Si();
      if (d)
        if (vt(s)) {
          let R = s.anchor;
          var E = R.getNode();
          R.type === "element" && R.offset === 0 && s.isCollapsed() && !Yn(E) && on().getChildrenSize() === 1 && E.getTopLevelElementOrThrow().isEmpty() && m !== null && s.is(m) ? (d.removeAllRanges(), s.dirty = !0) : l.detail !== 3 || s.isCollapsed() || (d = s.focus.getNode(), E !== d && (Je(E) ? E.select(0) : E.getParentOrThrow().select(0)));
        } else
          l.pointerType === "touch" && (E = d.anchorNode, E !== null && (E = E.nodeType, E === 1 || E === 3)) && (d = bn(m, d, n), rr(d));
      rt(n, t, l);
    });
  }
  function fa(l, n) {
    let s = l.target;
    l = l.pointerType, s instanceof Node && l !== "touch" && Jn(n, () => {
      Qt(gr(s)) || (Ms = !0);
    });
  }
  function yl(l) {
    return l.getTargetRanges ? (l = l.getTargetRanges(), l.length === 0 ? null : l[0]) : null;
  }
  function Cl(l, n) {
    return l !== n || Je(l) || Je(n) || !l.isToken() || !n.isToken();
  }
  function Nl(l, n) {
    let s = l.inputType, d = yl(l);
    s === "deleteCompositionText" || g && Zt(n) || s !== "insertCompositionText" && Jn(n, () => {
      let m = Wt();
      if (s === "deleteContentBackward") {
        if (m === null) {
          var E = Si();
          if (!vt(E))
            return;
          rr(E.clone());
        }
        if (vt(m)) {
          ce && Dt(m.anchor.key), fl === 229 && l.timeStamp < ho + 30 && n.isComposing() && m.anchor.key === m.focus.key ? (Dt(null), ho = 0, setTimeout(() => {
            Jn(n, () => {
              Dt(null);
            });
          }, 30), vt(m) && (E = m.anchor.getNode(), E.markDirty(), m.format = E.getFormat(), m.style = E.getStyle()), 1 >= m.anchor.getNode().getTextContent().length && (l.preventDefault(), rt(n, r, !0))) : (l.preventDefault(), rt(n, r, !0));
          return;
        }
      }
      if (vt(m)) {
        E = l.data, Wi !== null && et(!1, n, Wi), m.dirty && Wi === null || !m.isCollapsed() || Yn(m.anchor.getNode()) || d === null || m.applyDOMRange(d), Wi = null;
        var R = m.focus, X = m.anchor.getNode();
        if (R = R.getNode(), s === "insertText" || s === "insertTranspose")
          E === `
` ? (l.preventDefault(), rt(n, o, !1)) : E === `

` ? (l.preventDefault(), rt(n, f, void 0)) : E == null && l.dataTransfer ? (E = l.dataTransfer.getData("text/plain"), l.preventDefault(), m.insertRawText(E)) : E != null && pl(m, d, E, l.timeStamp, !0) ? (l.preventDefault(), rt(n, h, E)) : Wi = E, hl = l.timeStamp;
        else
          switch (l.preventDefault(), s) {
            case "insertFromYank":
            case "insertFromDrop":
            case "insertReplacementText":
              rt(n, h, l);
              break;
            case "insertFromComposition":
              Dt(null), rt(n, h, l);
              break;
            case "insertLineBreak":
              Dt(null), rt(n, o, !1);
              break;
            case "insertParagraph":
              Dt(null), po && !J ? (po = !1, rt(n, o, !1)) : rt(n, f, void 0);
              break;
            case "insertFromPaste":
            case "insertFromPasteAsQuotation":
              rt(n, C, l);
              break;
            case "deleteByComposition":
              Cl(X, R) && rt(n, T, l);
              break;
            case "deleteByDrag":
            case "deleteByCut":
              rt(n, T, l);
              break;
            case "deleteContent":
              rt(n, r, !1);
              break;
            case "deleteWordBackward":
              rt(n, O, !0);
              break;
            case "deleteWordForward":
              rt(n, O, !1);
              break;
            case "deleteHardLineBackward":
            case "deleteSoftLineBackward":
              rt(n, S, !0);
              break;
            case "deleteContentForward":
            case "deleteHardLineForward":
            case "deleteSoftLineForward":
              rt(n, S, !1);
              break;
            case "formatStrikeThrough":
              rt(n, x, "strikethrough");
              break;
            case "formatBold":
              rt(n, x, "bold");
              break;
            case "formatItalic":
              rt(n, x, "italic");
              break;
            case "formatUnderline":
              rt(n, x, "underline");
              break;
            case "historyUndo":
              rt(n, D, void 0);
              break;
            case "historyRedo":
              rt(n, k, void 0);
          }
      }
    });
  }
  function ha(l, n) {
    l.stopPropagation(), Jn(n, () => {
      var s = Wt(), d = l.data, m = yl(l);
      if (d != null && vt(s) && pl(s, m, d, l.timeStamp, !1)) {
        _o && (Ls(n, d), _o = !1);
        var E = s.anchor, R = E.getNode();
        if (m = xr(n._window), m === null)
          return;
        let X = E.offset;
        (E = _ && !s.isCollapsed() && ut(R) && m.anchorNode !== null) && (R = R.getTextContent().slice(0, X) + d + R.getTextContent().slice(X + s.focus.offset), m = m.anchorNode, E = R === (m.nodeType === 3 ? m.nodeValue : null)), E || rt(n, h, d), d = d.length, g && 1 < d && l.inputType === "insertCompositionText" && !n.isComposing() && (s.anchor.offset -= d), A || J || ae || !n.isComposing() || (ho = 0, Dt(null));
      } else
        et(!1, n, d !== null ? d : void 0), _o && (Ls(n, d || void 0), _o = !1);
      Un(), s = Xt(), Oe(s);
    }), Wi = null;
  }
  function ga(l, n) {
    Jn(n, () => {
      let s = Wt();
      if (vt(s) && !n.isComposing()) {
        let d = s.anchor, m = s.anchor.getNode();
        Dt(d.key), (l.timeStamp < ho + 30 || d.type === "element" || !s.isCollapsed() || m.getFormat() !== s.format || m.getStyle() !== s.style) && rt(n, h, Me);
      }
    });
  }
  function Ls(l, n) {
    var s = l._compositionKey;
    if (Dt(null), s !== null && n != null) {
      if (n === "") {
        n = bt(s), l = xt(l.getElementByKey(s)), l !== null && l.nodeValue !== null && ut(n) && _t(n, l.nodeValue, null, null, !0);
        return;
      }
      if (n[n.length - 1] === `
` && (s = Wt(), vt(s))) {
        n = s.focus, s.anchor.set(n.key, n.offset, n.type), rt(l, B, null);
        return;
      }
    }
    et(!0, l, n);
  }
  function pa(l, n) {
    g ? _o = !0 : Jn(n, () => {
      Ls(n, l.data);
    });
  }
  function _a(l, n) {
    if (ho = l.timeStamp, fl = l.keyCode, !n.isComposing()) {
      var { keyCode: s, shiftKey: d, ctrlKey: m, metaKey: E, altKey: R } = l;
      if (!rt(n, H, l)) {
        if (s !== 39 || m || E || R)
          if (s !== 39 || R || d || !m && !E)
            if (s !== 37 || m || E || R)
              if (s !== 37 || R || d || !m && !E)
                if (s !== 38 || m || E)
                  if (s !== 40 || m || E)
                    if (s === 13 && d)
                      po = !0, rt(n, B, l);
                    else if (s === 32)
                      rt(n, z, l);
                    else if (b && m && s === 79)
                      l.preventDefault(), po = !0, rt(n, o, !0);
                    else if (s !== 13 || d) {
                      var X = b ? R || E ? !1 : s === 8 || s === 72 && m : m || R || E ? !1 : s === 8;
                      X ? s === 8 ? rt(n, te, l) : (l.preventDefault(), rt(n, r, !0)) : s === 27 ? rt(
                        n,
                        re,
                        l
                      ) : (X = b ? d || R || E ? !1 : s === 46 || s === 68 && m : m || R || E ? !1 : s === 46, X ? s === 46 ? rt(n, de, l) : (l.preventDefault(), rt(n, r, !1)) : s === 8 && (b ? R : m) ? (l.preventDefault(), rt(n, O, !0)) : s === 46 && (b ? R : m) ? (l.preventDefault(), rt(n, O, !1)) : b && E && s === 8 ? (l.preventDefault(), rt(n, S, !0)) : b && E && s === 46 ? (l.preventDefault(), rt(n, S, !1)) : s === 66 && !R && (b ? E : m) ? (l.preventDefault(), rt(n, x, "bold")) : s === 85 && !R && (b ? E : m) ? (l.preventDefault(), rt(n, x, "underline")) : s === 73 && !R && (b ? E : m) ? (l.preventDefault(), rt(n, x, "italic")) : s !== 9 || R || m || E ? s === 90 && !d && (b ? E : m) ? (l.preventDefault(), rt(n, D, void 0)) : (X = b ? s === 90 && E && d : s === 89 && m || s === 90 && m && d, X ? (l.preventDefault(), rt(n, k, void 0)) : Eo(n._editorState._selection) ? (X = d ? !1 : s === 67 ? b ? E : m : !1, X ? (l.preventDefault(), rt(n, Z, l)) : (X = d ? !1 : s === 88 ? b ? E : m : !1, X ? (l.preventDefault(), rt(n, ee, l)) : s === 65 && (b ? E : m) && (l.preventDefault(), rt(n, P, l)))) : !g && s === 65 && (b ? E : m) && (l.preventDefault(), rt(n, P, l))) : rt(n, V, l));
                    } else
                      po = !1, rt(n, B, l);
                  else
                    rt(n, K, l);
                else
                  rt(n, I, l);
              else
                rt(n, U, l);
            else
              rt(n, F, l);
          else
            rt(n, v, l);
        else
          rt(n, N, l);
        (m || d || R || E) && rt(n, ne, l);
      }
    }
  }
  function El(l) {
    let n = l.__lexicalEventHandles;
    return n === void 0 && (n = [], l.__lexicalEventHandles = n), n;
  }
  let zi = /* @__PURE__ */ new Map();
  function Tl(l) {
    l = l.target;
    let n = xr(l == null ? null : l.nodeType === 9 ? l.defaultView : l.ownerDocument.defaultView);
    if (n !== null) {
      var s = gt(n.anchorNode);
      if (s !== null) {
        Ms && (Ms = !1, Jn(s, () => {
          var R = Si(), X = n.anchorNode;
          X !== null && (X = X.nodeType, X === 1 || X === 3) && (R = bn(R, n, s), rr(R));
        })), l = ye(s), l = l[l.length - 1];
        var d = l._key, m = zi.get(d), E = m || l;
        E !== s && ml(n, E, !1), ml(n, s, !0), s !== l ? zi.set(d, s) : m && zi.delete(d);
      }
    }
  }
  function ma(l, n) {
    go === 0 && l.ownerDocument.addEventListener("selectionchange", Tl), go++, l.__lexicalEditor = n;
    let s = El(l);
    for (let d = 0; d < As.length; d++) {
      let [m, E] = As[d], R = typeof E == "function" ? (X) => {
        X._lexicalHandled !== !0 && (X._lexicalHandled = !0, n.isEditable() && E(X, n));
      } : (X) => {
        if (X._lexicalHandled !== !0 && (X._lexicalHandled = !0, n.isEditable()))
          switch (m) {
            case "cut":
              return rt(n, ee, X);
            case "copy":
              return rt(n, Z, X);
            case "paste":
              return rt(n, C, X);
            case "dragstart":
              return rt(n, q, X);
            case "dragover":
              return rt(n, me, X);
            case "dragend":
              return rt(
                n,
                pe,
                X
              );
            case "focus":
              return rt(n, w, X);
            case "blur":
              return rt(n, j, X);
            case "drop":
              return rt(n, G, X);
          }
      };
      l.addEventListener(m, R), s.push(() => {
        l.removeEventListener(m, R);
      });
    }
  }
  function Ps(l, n, s) {
    Un();
    var d = l.__key;
    let m = l.getParent();
    if (m !== null) {
      var E = Wt();
      if (vt(E) && Je(l)) {
        var { anchor: R, focus: X } = E, _e = R.getNode(), Se = X.getNode();
        Xr(_e, l) && R.set(l.__key, 0, "element"), Xr(Se, l) && X.set(l.__key, 0, "element");
      }
      if (_e = E, Se = !1, vt(_e) && n) {
        E = _e.anchor;
        let Fe = _e.focus;
        E.key === d && (Vi(E, l, m, l.getPreviousSibling(), l.getNextSibling()), Se = !0), Fe.key === d && (Vi(Fe, l, m, l.getPreviousSibling(), l.getNextSibling()), Se = !0);
      } else
        Eo(_e) && n && l.isSelected() && l.selectPrevious();
      vt(_e) && n && !Se ? (d = l.getIndexWithinParent(), Et(l), qi(_e, m, d, -1)) : Et(l), s || Br(m) || m.canBeEmpty() || !m.isEmpty() || Ps(m, n), n && Yn(m) && m.isEmpty() && m.selectEnd();
    }
  }
  class Wr {
    static getType() {
      Y(64, this.name);
    }
    static clone() {
      Y(65, this.name);
    }
    constructor(n) {
      this.__type = this.constructor.getType(), this.__next = this.__prev = this.__parent = null, wt(this, n);
    }
    getType() {
      return this.__type;
    }
    isAttached() {
      for (var n = this.__key; n !== null; ) {
        if (n === "root")
          return !0;
        if (n = bt(n), n === null)
          break;
        n = n.__parent;
      }
      return !1;
    }
    isSelected(n) {
      if (n = n || Wt(), n == null)
        return !1;
      let s = n.getNodes().some((d) => d.__key === this.__key);
      return ut(this) ? s : vt(n) && n.anchor.type === "element" && n.focus.type === "element" && n.anchor.key === n.focus.key && n.anchor.offset === n.focus.offset ? !1 : s;
    }
    getKey() {
      return this.__key;
    }
    getIndexWithinParent() {
      var n = this.getParent();
      if (n === null)
        return -1;
      n = n.getFirstChild();
      let s = 0;
      for (; n !== null; ) {
        if (this.is(n))
          return s;
        s++, n = n.getNextSibling();
      }
      return -1;
    }
    getParent() {
      let n = this.getLatest().__parent;
      return n === null ? null : bt(n);
    }
    getParentOrThrow() {
      let n = this.getParent();
      return n === null && Y(66, this.__key), n;
    }
    getTopLevelElement() {
      let n = this;
      for (; n !== null; ) {
        let s = n.getParent();
        if (Br(s))
          return n;
        n = s;
      }
      return null;
    }
    getTopLevelElementOrThrow() {
      let n = this.getTopLevelElement();
      return n === null && Y(67, this.__key), n;
    }
    getParents() {
      let n = [], s = this.getParent();
      for (; s !== null; )
        n.push(s), s = s.getParent();
      return n;
    }
    getParentKeys() {
      let n = [], s = this.getParent();
      for (; s !== null; )
        n.push(s.__key), s = s.getParent();
      return n;
    }
    getPreviousSibling() {
      let n = this.getLatest().__prev;
      return n === null ? null : bt(n);
    }
    getPreviousSiblings() {
      let n = [];
      var s = this.getParent();
      if (s === null)
        return n;
      for (s = s.getFirstChild(); s !== null && !s.is(this); )
        n.push(s), s = s.getNextSibling();
      return n;
    }
    getNextSibling() {
      let n = this.getLatest().__next;
      return n === null ? null : bt(n);
    }
    getNextSiblings() {
      let n = [], s = this.getNextSibling();
      for (; s !== null; )
        n.push(s), s = s.getNextSibling();
      return n;
    }
    getCommonAncestor(n) {
      let s = this.getParents();
      var d = n.getParents();
      Je(this) && s.unshift(this), Je(n) && d.unshift(n), n = s.length;
      var m = d.length;
      if (n === 0 || m === 0 || s[n - 1] !== d[m - 1])
        return null;
      for (d = new Set(d), m = 0; m < n; m++) {
        let E = s[m];
        if (d.has(E))
          return E;
      }
      return null;
    }
    is(n) {
      return n == null ? !1 : this.__key === n.__key;
    }
    isBefore(n) {
      if (this === n)
        return !1;
      if (n.isParentOf(this))
        return !0;
      if (this.isParentOf(n))
        return !1;
      var s = this.getCommonAncestor(n);
      let d = this;
      for (; ; ) {
        var m = d.getParentOrThrow();
        if (m === s) {
          m = d.getIndexWithinParent();
          break;
        }
        d = m;
      }
      for (d = n; ; ) {
        if (n = d.getParentOrThrow(), n === s) {
          s = d.getIndexWithinParent();
          break;
        }
        d = n;
      }
      return m < s;
    }
    isParentOf(n) {
      let s = this.__key;
      if (s === n.__key)
        return !1;
      for (; n !== null; ) {
        if (n.__key === s)
          return !0;
        n = n.getParent();
      }
      return !1;
    }
    getNodesBetween(n) {
      let s = this.isBefore(n), d = [], m = /* @__PURE__ */ new Set();
      for (var E = this; ; ) {
        var R = E.__key;
        if (m.has(R) || (m.add(R), d.push(E)), E === n)
          break;
        if (R = Je(E) ? s ? E.getFirstChild() : E.getLastChild() : null, R !== null)
          E = R;
        else if (R = s ? E.getNextSibling() : E.getPreviousSibling(), R !== null)
          E = R;
        else {
          if (E = E.getParentOrThrow(), m.has(E.__key) || d.push(E), E === n)
            break;
          R = E;
          do
            R === null && Y(68), E = s ? R.getNextSibling() : R.getPreviousSibling(), R = R.getParent(), R !== null && (E !== null || m.has(R.__key) || d.push(R));
          while (E === null);
        }
      }
      return s || d.reverse(), d;
    }
    isDirty() {
      let n = Xt()._dirtyLeaves;
      return n !== null && n.has(this.__key);
    }
    getLatest() {
      let n = bt(this.__key);
      return n === null && Y(113), n;
    }
    getWritable() {
      Un();
      var n = lr(), s = Xt();
      n = n._nodeMap;
      let d = this.__key, m = this.getLatest(), E = m.__parent;
      s = s._cloneNotNeeded;
      var R = Wt();
      return Bs(R) && R.setCachedNodes(null), s.has(d) ? (Yt(m), m) : (R = m.constructor.clone(m), R.__parent = E, R.__next = m.__next, R.__prev = m.__prev, Je(m) && Je(R) ? (R.__first = m.__first, R.__last = m.__last, R.__size = m.__size, R.__indent = m.__indent, R.__format = m.__format, R.__dir = m.__dir) : ut(m) && ut(R) && (R.__format = m.__format, R.__style = m.__style, R.__mode = m.__mode, R.__detail = m.__detail), s.add(d), R.__key = d, Yt(R), n.set(d, R), R);
    }
    getTextContent() {
      return "";
    }
    getTextContentSize() {
      return this.getTextContent().length;
    }
    createDOM() {
      Y(70);
    }
    updateDOM() {
      Y(71);
    }
    exportDOM(n) {
      return { element: this.createDOM(n._config, n) };
    }
    exportJSON() {
      Y(72);
    }
    static importJSON() {
      Y(18, this.name);
    }
    static transform() {
      return null;
    }
    remove(n) {
      Ps(this, !0, n);
    }
    replace(n, s) {
      Un();
      var d = Wt();
      d !== null && (d = d.clone()), zo(this, n);
      let m = this.getLatest(), E = this.__key, R = n.__key, X = n.getWritable();
      n = this.getParentOrThrow().getWritable();
      let _e = n.__size;
      Et(X);
      let Se = m.getPreviousSibling(), Fe = m.getNextSibling(), Ue = m.__prev, Pe = m.__next, De = m.__parent;
      return Ps(m, !1, !0), Se === null ? n.__first = R : Se.getWritable().__next = R, X.__prev = Ue, Fe === null ? n.__last = R : Fe.getWritable().__prev = R, X.__next = Pe, X.__parent = De, n.__size = _e, s && this.getChildren().forEach((Xe) => {
        X.append(Xe);
      }), vt(d) && (rr(d), s = d.anchor, d = d.focus, s.key === E && $s(s, X), d.key === E && $s(d, X)), Kt() === E && Dt(R), X;
    }
    insertAfter(n, s = !0) {
      Un(), zo(this, n);
      var d = this.getWritable();
      let m = n.getWritable();
      var E = m.getParent();
      let R = Wt();
      var X = !1, _e = !1;
      if (E !== null) {
        var Se = n.getIndexWithinParent();
        Et(m), vt(R) && (_e = E.__key, X = R.anchor, E = R.focus, X = X.type === "element" && X.key === _e && X.offset === Se + 1, _e = E.type === "element" && E.key === _e && E.offset === Se + 1);
      }
      E = this.getNextSibling(), Se = this.getParentOrThrow().getWritable();
      let Fe = m.__key, Ue = d.__next;
      return E === null ? Se.__last = Fe : E.getWritable().__prev = Fe, Se.__size++, d.__next = Fe, m.__next = Ue, m.__prev = d.__key, m.__parent = d.__parent, s && vt(R) && (s = this.getIndexWithinParent(), qi(R, Se, s + 1), d = Se.__key, X && R.anchor.set(d, s + 2, "element"), _e && R.focus.set(d, s + 2, "element")), n;
    }
    insertBefore(n, s = !0) {
      Un(), zo(this, n);
      var d = this.getWritable();
      let m = n.getWritable(), E = m.__key;
      Et(m);
      let R = this.getPreviousSibling(), X = this.getParentOrThrow().getWritable(), _e = d.__prev, Se = this.getIndexWithinParent();
      return R === null ? X.__first = E : R.getWritable().__next = E, X.__size++, d.__prev = E, m.__prev = _e, m.__next = d.__key, m.__parent = d.__parent, d = Wt(), s && vt(d) && (s = this.getParentOrThrow(), qi(d, s, Se)), n;
    }
    isParentRequired() {
      return !1;
    }
    createParentElementNode() {
      return Zn();
    }
    selectStart() {
      return this.selectPrevious();
    }
    selectEnd() {
      return this.selectNext(
        0,
        0
      );
    }
    selectPrevious(n, s) {
      Un();
      let d = this.getPreviousSibling(), m = this.getParentOrThrow();
      return d === null ? m.select(0, 0) : Je(d) ? d.select() : ut(d) ? d.select(n, s) : (n = d.getIndexWithinParent() + 1, m.select(n, n));
    }
    selectNext(n, s) {
      Un();
      let d = this.getNextSibling(), m = this.getParentOrThrow();
      return d === null ? m.select() : Je(d) ? d.select(0, 0) : ut(d) ? d.select(n, s) : (n = d.getIndexWithinParent(), m.select(n, n));
    }
    markDirty() {
      this.getWritable();
    }
  }
  function xl(l, n, s) {
    s = s || n.getParentOrThrow().getLastChild();
    let d = n;
    for (n = [n]; d !== s; ) {
      if (!d.getNextSibling())
        throw Error("insertRangeAfter: lastToInsert must be a later sibling of firstToInsert");
      d = d.getNextSibling(), n.push(d);
    }
    for (let m of n)
      l = l.insertAfter(m);
  }
  class Sr extends Wr {
    static getType() {
      return "linebreak";
    }
    static clone(n) {
      return new Sr(n.__key);
    }
    constructor(n) {
      super(n);
    }
    getTextContent() {
      return `
`;
    }
    createDOM() {
      return document.createElement("br");
    }
    updateDOM() {
      return !1;
    }
    static importDOM() {
      return { br: (n) => {
        let s = n.parentElement, d, m;
        return s !== null && ((d = s.firstChild) === n || d.nextSibling === n && d.nodeType === 3 && (d.textContent || "").match(/^( |\t|\r?\n)+$/) !== null) && ((m = s.lastChild) === n || m.previousSibling === n && m.nodeType === 3 && (m.textContent || "").match(/^( |\t|\r?\n)+$/) !== null) ? null : { conversion: ya, priority: 0 };
      } };
    }
    static importJSON() {
      return wr();
    }
    exportJSON() {
      return { type: "linebreak", version: 1 };
    }
  }
  function ya() {
    return { node: wr() };
  }
  function wr() {
    return Ni(new Sr());
  }
  function ri(l) {
    return l instanceof Sr;
  }
  function Is(l, n) {
    return n & 16 ? "code" : n & 128 ? "mark" : n & 32 ? "sub" : n & 64 ? "sup" : null;
  }
  function Ei(l, n) {
    return n & 1 ? "strong" : n & 2 ? "em" : "span";
  }
  function mo(l, n, s, d, m) {
    l = d.classList, d = Ft(m, "base"), d !== void 0 && l.add(...d), d = Ft(m, "underlineStrikethrough");
    let E = !1, R = n & 8 && n & 4;
    var X = s & 8 && s & 4;
    d !== void 0 && (X ? (E = !0, R || l.add(...d)) : R && l.remove(...d));
    for (let _e in ie)
      X = ie[_e], d = Ft(m, _e), d !== void 0 && (s & X ? !E || _e !== "underline" && _e !== "strikethrough" ? (!(n & X) || R && _e === "underline" || _e === "strikethrough") && l.add(...d) : n & X && l.remove(...d) : n & X && l.remove(...d));
  }
  function ks(l, n, s) {
    let d = n.firstChild;
    if (s = s.isComposing(), l += s ? Te : "", d == null)
      n.textContent = l;
    else if (n = d.nodeValue, n !== l)
      if (s || g) {
        s = n.length;
        let m = l.length, E = 0, R = 0;
        for (; E < s && E < m && n[E] === l[E]; )
          E++;
        for (; R + E < s && R + E < m && n[s - R - 1] === l[m - R - 1]; )
          R++;
        l = [E, s - E - R, l.slice(E, m - R)];
        let [X, _e, Se] = l;
        _e !== 0 && d.deleteData(X, _e), d.insertData(X, Se);
      } else
        d.nodeValue = l;
  }
  function yo(l, n) {
    return n = document.createElement(n), n.appendChild(l), n;
  }
  class zr extends Wr {
    static getType() {
      return "text";
    }
    static clone(n) {
      return new zr(n.__text, n.__key);
    }
    constructor(n, s) {
      super(s), this.__text = n, this.__format = 0, this.__style = "", this.__detail = this.__mode = 0;
    }
    getFormat() {
      return this.getLatest().__format;
    }
    getDetail() {
      return this.getLatest().__detail;
    }
    getMode() {
      let n = this.getLatest();
      return Ye[n.__mode];
    }
    getStyle() {
      return this.getLatest().__style;
    }
    isToken() {
      return this.getLatest().__mode === 1;
    }
    isComposing() {
      return this.__key === Kt();
    }
    isSegmented() {
      return this.getLatest().__mode === 2;
    }
    isDirectionless() {
      return (this.getLatest().__detail & 1) !== 0;
    }
    isUnmergeable() {
      return (this.getLatest().__detail & 2) !== 0;
    }
    hasFormat(n) {
      return n = ie[n], (this.getFormat() & n) !== 0;
    }
    isSimpleText() {
      return this.__type === "text" && this.__mode === 0;
    }
    getTextContent() {
      return this.getLatest().__text;
    }
    getFormatFlags(n, s) {
      let d = this.getLatest().__format;
      return St(d, n, s);
    }
    createDOM(n) {
      var s = this.__format, d = Is(this, s);
      let m = Ei(this, s), E = document.createElement(d === null ? m : d), R = E;
      return this.hasFormat("code") && E.setAttribute("spellcheck", "false"), d !== null && (R = document.createElement(m), E.appendChild(R)), d = R, ks(this.__text, d, this), n = n.theme.text, n !== void 0 && mo(m, 0, s, d, n), s = this.__style, s !== "" && (E.style.cssText = s), E;
    }
    updateDOM(n, s, d) {
      let m = this.__text;
      var E = n.__format, R = this.__format, X = Is(this, E);
      let _e = Is(this, R);
      var Se = Ei(this, E);
      let Fe = Ei(this, R);
      return (X === null ? Se : X) !== (_e === null ? Fe : _e) ? !0 : X === _e && Se !== Fe ? (E = s.firstChild, E == null && Y(48), n = X = document.createElement(Fe), ks(m, n, this), d = d.theme.text, d !== void 0 && mo(Fe, 0, R, n, d), s.replaceChild(X, E), !1) : (Se = s, _e !== null && X !== null && (Se = s.firstChild, Se == null && Y(49)), ks(m, Se, this), d = d.theme.text, d !== void 0 && E !== R && mo(Fe, E, R, Se, d), R = this.__style, n.__style !== R && (s.style.cssText = R), !1);
    }
    static importDOM() {
      return {
        "#text": () => ({ conversion: Xo, priority: 0 }),
        b: () => ({ conversion: it, priority: 0 }),
        code: () => ({ conversion: ii, priority: 0 }),
        em: () => ({ conversion: ii, priority: 0 }),
        i: () => ({ conversion: ii, priority: 0 }),
        s: () => ({ conversion: ii, priority: 0 }),
        span: () => ({ conversion: vl, priority: 0 }),
        strong: () => ({ conversion: ii, priority: 0 }),
        sub: () => ({ conversion: ii, priority: 0 }),
        sup: () => ({ conversion: ii, priority: 0 }),
        u: () => ({ conversion: ii, priority: 0 })
      };
    }
    static importJSON(n) {
      let s = An(n.text);
      return s.setFormat(n.format), s.setDetail(n.detail), s.setMode(n.mode), s.setStyle(n.style), s;
    }
    exportDOM(n) {
      return { element: n } = super.exportDOM(n), n !== null && Bi(n) || Y(132), n.style.whiteSpace = "pre-wrap", this.hasFormat("bold") && (n = yo(n, "b")), this.hasFormat("italic") && (n = yo(n, "i")), this.hasFormat("strikethrough") && (n = yo(n, "s")), this.hasFormat("underline") && (n = yo(n, "u")), { element: n };
    }
    exportJSON() {
      return {
        detail: this.getDetail(),
        format: this.getFormat(),
        mode: this.getMode(),
        style: this.getStyle(),
        text: this.getTextContent(),
        type: "text",
        version: 1
      };
    }
    selectionTransform() {
    }
    setFormat(n) {
      let s = this.getWritable();
      return s.__format = typeof n == "string" ? ie[n] : n, s;
    }
    setDetail(n) {
      let s = this.getWritable();
      return s.__detail = typeof n == "string" ? ue[n] : n, s;
    }
    setStyle(n) {
      let s = this.getWritable();
      return s.__style = n, s;
    }
    toggleFormat(n) {
      let s = this.getFormat();
      return n = St(s, n, null), this.setFormat(n);
    }
    toggleDirectionless() {
      let n = this.getWritable();
      return n.__detail ^= 1, n;
    }
    toggleUnmergeable() {
      let n = this.getWritable();
      return n.__detail ^= 2, n;
    }
    setMode(n) {
      if (n = Be[n], this.__mode === n)
        return this;
      let s = this.getWritable();
      return s.__mode = n, s;
    }
    setTextContent(n) {
      if (this.__text === n)
        return this;
      let s = this.getWritable();
      return s.__text = n, s;
    }
    select(n, s) {
      Un();
      let d = Wt();
      var m = this.getTextContent();
      let E = this.__key;
      if (typeof m == "string" ? (m = m.length, n === void 0 && (n = m), s === void 0 && (s = m)) : s = n = 0, vt(d))
        m = Kt(), m !== d.anchor.key && m !== d.focus.key || Dt(E), d.setTextNodeRange(this, n, this, s);
      else
        return $n(E, n, E, s, "text", "text");
      return d;
    }
    selectStart() {
      return this.select(0, 0);
    }
    selectEnd() {
      let n = this.getTextContentSize();
      return this.select(n, n);
    }
    spliceText(n, s, d, m) {
      let E = this.getWritable(), R = E.__text, X = d.length, _e = n;
      0 > _e && (_e = X + _e, 0 > _e && (_e = 0));
      let Se = Wt();
      return m && vt(Se) && (n += X, Se.setTextNodeRange(E, n, E, n)), s = R.slice(0, _e) + d + R.slice(_e + s), E.__text = s, E;
    }
    canInsertTextBefore() {
      return !0;
    }
    canInsertTextAfter() {
      return !0;
    }
    splitText(...n) {
      Un();
      var s = this.getLatest(), d = s.getTextContent(), m = s.__key, E = Kt(), R = new Set(n);
      n = [];
      for (var X = d.length, _e = "", Se = 0; Se < X; Se++)
        _e !== "" && R.has(Se) && (n.push(_e), _e = ""), _e += d[Se];
      if (_e !== "" && n.push(_e), R = n.length, R === 0)
        return [];
      if (n[0] === d)
        return [s];
      var Fe = n[0];
      d = s.getParentOrThrow(), Se = s.getFormat();
      let Ue = s.getStyle(), Pe = s.__detail;
      X = !1, s.isSegmented() ? (_e = An(Fe), _e.__format = Se, _e.__style = Ue, _e.__detail = Pe, X = !0) : (_e = s.getWritable(), _e.__text = Fe), s = Wt(), _e = [_e], Fe = Fe.length;
      for (let lt = 1; lt < R; lt++) {
        var De = n[lt], Xe = De.length;
        De = An(De).getWritable(), De.__format = Se, De.__style = Ue, De.__detail = Pe;
        let Nt = De.__key;
        if (Xe = Fe + Xe, vt(s)) {
          let Ot = s.anchor, sn = s.focus;
          Ot.key === m && Ot.type === "text" && Ot.offset > Fe && Ot.offset <= Xe && (Ot.key = Nt, Ot.offset -= Fe, s.dirty = !0), sn.key === m && sn.type === "text" && sn.offset > Fe && sn.offset <= Xe && (sn.key = Nt, sn.offset -= Fe, s.dirty = !0);
        }
        E === m && Dt(Nt), Fe = Xe, _e.push(De);
      }
      return m = this.getPreviousSibling(), E = this.getNextSibling(), m !== null && Yt(m), E !== null && Yt(E), m = d.getWritable(), E = this.getIndexWithinParent(), X ? (m.splice(E, 0, _e), this.remove()) : m.splice(E, 1, _e), vt(s) && qi(s, d, E, R - 1), _e;
    }
    mergeWithSibling(n) {
      var s = n === this.getPreviousSibling();
      s || n === this.getNextSibling() || Y(50);
      var d = this.__key;
      let m = n.__key, E = this.__text, R = E.length;
      Kt() === m && Dt(d);
      let X = Wt();
      if (vt(X)) {
        let _e = X.anchor, Se = X.focus;
        _e !== null && _e.key === m && (rs(_e, s, d, n, R), X.dirty = !0), Se !== null && Se.key === m && (rs(Se, s, d, n, R), X.dirty = !0);
      }
      return d = n.__text, this.setTextContent(s ? d + E : E + d), s = this.getWritable(), n.remove(), s;
    }
    isTextEntity() {
      return !1;
    }
  }
  function vl(l) {
    let n = l.style.fontWeight === "700", s = l.style.textDecoration === "line-through", d = l.style.fontStyle === "italic", m = l.style.textDecoration === "underline", E = l.style.verticalAlign;
    return { forChild: (R) => (ut(R) && (n && R.toggleFormat("bold"), s && R.toggleFormat("strikethrough"), d && R.toggleFormat("italic"), m && R.toggleFormat("underline"), E === "sub" && R.toggleFormat("subscript"), E === "super" && R.toggleFormat("superscript")), R), node: null };
  }
  function it(l) {
    let n = l.style.fontWeight === "normal";
    return { forChild: (s) => (ut(s) && !n && s.toggleFormat("bold"), s), node: null };
  }
  let Co = /* @__PURE__ */ new WeakMap();
  function Xo(l) {
    l.parentElement === null && Y(129);
    for (var n = l.textContent || "", s, d = l.parentNode, m = [l]; d !== null && (s = Co.get(d)) === void 0 && !(d.nodeName === "PRE" || d.nodeType === 1 && d.style !== void 0 && d.style.whiteSpace !== void 0 && d.style.whiteSpace.startsWith("pre")); )
      m.push(d), d = d.parentNode;
    for (s = s === void 0 ? d : s, d = 0; d < m.length; d++)
      Co.set(m[d], s);
    if (s !== null) {
      for (n = n.split(/(\r?\n|\t)/), l = [], m = n.length, s = 0; s < m; s++)
        d = n[s], d === `
` || d === `\r
` ? l.push(wr()) : d === "	" ? l.push(Ti()) : d !== "" && l.push(An(d));
      return { node: l };
    }
    if (n = n.replace(/\r/g, "").replace(/[ \t\n]+/g, " "), n === "")
      return { node: null };
    if (n[0] === " ") {
      for (m = l, s = !0; m !== null && (m = Sl(m, !1)) !== null; )
        if (d = m.textContent || "", 0 < d.length) {
          /[ \t\n]$/.test(d) && (n = n.slice(1)), s = !1;
          break;
        }
      s && (n = n.slice(1));
    }
    if (n[n.length - 1] === " ") {
      for (m = !0; l !== null && (l = Sl(l, !0)) !== null; )
        if (0 < (l.textContent || "").replace(/^( |\t|\r?\n)+/, "").length) {
          m = !1;
          break;
        }
      m && (n = n.slice(0, n.length - 1));
    }
    return n === "" ? { node: null } : { node: An(n) };
  }
  let Qo = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/, "i");
  function Sl(l, n) {
    for (; ; ) {
      for (var s = void 0; (s = n ? l.nextSibling : l.previousSibling) === null; )
        if (l = l.parentElement, l === null)
          return null;
      if (l = s, l.nodeType === 1 && (s = l.style.display, s === "" && l.nodeName.match(Qo) === null || s !== "" && !s.startsWith("inline")))
        return null;
      for (; (s = n ? l.firstChild : l.lastChild) !== null; )
        l = s;
      if (l.nodeType === 3)
        return l;
      if (l.nodeName === "BR")
        return null;
    }
  }
  let Ca = { code: "code", em: "italic", i: "italic", s: "strikethrough", strong: "bold", sub: "subscript", sup: "superscript", u: "underline" };
  function ii(l) {
    let n = Ca[l.nodeName.toLowerCase()];
    return n === void 0 ? { node: null } : { forChild: (s) => (ut(s) && !s.hasFormat(n) && s.toggleFormat(n), s), node: null };
  }
  function An(l = "") {
    return Ni(new zr(l));
  }
  function ut(l) {
    return l instanceof zr;
  }
  class Gi extends zr {
    static getType() {
      return "tab";
    }
    static clone(n) {
      let s = new Gi(n.__key);
      return s.__text = n.__text, s.__format = n.__format, s.__style = n.__style, s;
    }
    constructor(n) {
      super("	", n), this.__detail = 2;
    }
    static importDOM() {
      return null;
    }
    static importJSON(n) {
      let s = Ti();
      return s.setFormat(n.format), s.setStyle(n.style), s;
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "tab", version: 1 };
    }
    setTextContent() {
      Y(126);
    }
    setDetail() {
      Y(127);
    }
    setMode() {
      Y(128);
    }
    canInsertTextBefore() {
      return !1;
    }
    canInsertTextAfter() {
      return !1;
    }
  }
  function Ti() {
    return Ni(new Gi());
  }
  function wl(l) {
    return l instanceof Gi;
  }
  class mr {
    constructor(n, s, d) {
      this._selection = null, this.key = n, this.offset = s, this.type = d;
    }
    is(n) {
      return this.key === n.key && this.offset === n.offset && this.type === n.type;
    }
    isBefore(n) {
      let s = this.getNode(), d = n.getNode(), m = this.offset;
      if (n = n.offset, Je(s)) {
        var E = s.getDescendantByIndex(m);
        s = E ?? s;
      }
      return Je(d) && (E = d.getDescendantByIndex(n), d = E ?? d), s === d ? m < n : s.isBefore(d);
    }
    getNode() {
      let n = bt(this.key);
      return n === null && Y(20), n;
    }
    set(n, s, d) {
      let m = this._selection, E = this.key;
      this.key = n, this.offset = s, this.type = d, Yr() || (Kt() === E && Dt(n), m !== null && (m.setCachedNodes(null), m.dirty = !0));
    }
  }
  function Or(l, n) {
    let s = n.__key, d = l.offset, m = "element";
    if (ut(n))
      m = "text", n = n.getTextContentSize(), d > n && (d = n);
    else if (!Je(n)) {
      var E = n.getNextSibling();
      ut(E) ? (s = E.__key, d = 0, m = "text") : (E = n.getParent()) && (s = E.__key, d = n.getIndexWithinParent() + 1);
    }
    l.set(s, d, m);
  }
  function $s(l, n) {
    if (Je(n)) {
      let s = n.getLastDescendant();
      Je(s) || ut(s) ? Or(l, s) : Or(l, n);
    } else
      Or(l, n);
  }
  function Yi(l, n, s, d) {
    let m = l.getNode(), E = m.getChildAtIndex(l.offset), R = An(), X = Yn(m) ? Zn().append(R) : R;
    R.setFormat(s), R.setStyle(d), E === null ? m.append(X) : E.insertBefore(X), l.is(n) && n.set(R.__key, 0, "text"), l.set(R.__key, 0, "text");
  }
  function Rr(l, n, s, d) {
    l.key = n, l.offset = s, l.type = d;
  }
  class Fs {
    constructor(n, s) {
      this.anchor = n, this.focus = s, n._selection = this, s._selection = this, this._cachedNodes = null, this.dirty = !1;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(n) {
      this._cachedNodes = n;
    }
    is(n) {
      return Bs(n) ? this.anchor.is(n.anchor) && this.focus.is(n.focus) : !1;
    }
    isCollapsed() {
      return !1;
    }
    extract() {
      return this.getNodes();
    }
    isBackward() {
      return this.focus.isBefore(this.anchor);
    }
    getCharacterOffsets() {
      return vi(this);
    }
  }
  class ji {
    constructor(n) {
      this.dirty = !1, this._nodes = n, this._cachedNodes = null;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(n) {
      this._cachedNodes = n;
    }
    is(n) {
      if (!Eo(n))
        return !1;
      let s = this._nodes, d = n._nodes;
      return s.size === d.size && Array.from(s).every((m) => d.has(m));
    }
    add(n) {
      this.dirty = !0, this._nodes.add(n), this._cachedNodes = null;
    }
    delete(n) {
      this.dirty = !0, this._nodes.delete(n), this._cachedNodes = null;
    }
    clear() {
      this.dirty = !0, this._nodes.clear(), this._cachedNodes = null;
    }
    has(n) {
      return this._nodes.has(n);
    }
    clone() {
      return new ji(new Set(this._nodes));
    }
    extract() {
      return this.getNodes();
    }
    insertRawText() {
    }
    insertText() {
    }
    insertNodes(n) {
      let s = this.getNodes(), d = s.length;
      var m = s[d - 1];
      if (ut(m))
        m = m.select();
      else {
        let E = m.getIndexWithinParent() + 1;
        m = m.getParentOrThrow().select(E, E);
      }
      for (m.insertNodes(n), n = 0; n < d; n++)
        s[n].remove();
    }
    getNodes() {
      var n = this._cachedNodes;
      if (n !== null)
        return n;
      var s = this._nodes;
      n = [];
      for (let d of s)
        s = bt(d), s !== null && n.push(s);
      return Yr() || (this._cachedNodes = n), n;
    }
    getTextContent() {
      let n = this.getNodes(), s = "";
      for (let d = 0; d < n.length; d++)
        s += n[d].getTextContent();
      return s;
    }
  }
  function vt(l) {
    return l instanceof xi;
  }
  function Bs(l) {
    return l instanceof Fs;
  }
  function sr(l) {
    let [n, , s] = Gr(l);
    l = s.getChildren();
    let d = l.length;
    var m = l[0].getChildren().length;
    let E = Array(d);
    for (var R = 0; R < d; R++)
      E[R] = Array(m);
    for (m = 0; m < d; m++) {
      R = l[m].getChildren();
      let X = 0;
      for (let _e = 0; _e < R.length; _e++) {
        for (; E[m][X]; )
          X++;
        let Se = R[_e], Fe = Se.__rowSpan || 1, Ue = Se.__colSpan || 1;
        for (let Pe = 0; Pe < Fe; Pe++)
          for (let De = 0; De < Ue; De++)
            E[m + Pe][X + De] = Se;
        if (n === Se)
          return { colSpan: Ue, columnIndex: X, rowIndex: m, rowSpan: Fe };
        X += Ue;
      }
    }
    return null;
  }
  class es extends Fs {
    constructor(n, s, d) {
      super(s, d), this.gridKey = n;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(n) {
      this._cachedNodes = n;
    }
    is(n) {
      return No(n) ? this.gridKey === n.gridKey && this.anchor.is(n.anchor) && this.focus.is(n.focus) : !1;
    }
    set(n, s, d) {
      this.dirty = !0, this.gridKey = n, this.anchor.key = s, this.focus.key = d, this._cachedNodes = null;
    }
    clone() {
      return new es(this.gridKey, this.anchor, this.focus);
    }
    isCollapsed() {
      return !1;
    }
    extract() {
      return this.getNodes();
    }
    insertRawText() {
    }
    insertText() {
    }
    insertNodes(n) {
      let s = this.focus.getNode();
      Qe(s.select(0, s.getChildrenSize())).insertNodes(n);
    }
    getShape() {
      var n = bt(this.anchor.key);
      if (ar(n) || Y(103), n = sr(n), n === null)
        throw Error("getCellRect: expected to find AnchorNode");
      var s = bt(this.focus.key);
      ar(s) || Y(104);
      let d = sr(s);
      if (d === null)
        throw Error("getCellRect: expected to find focusCellNode");
      s = Math.min(n.columnIndex, d.columnIndex);
      let m = Math.max(n.columnIndex, d.columnIndex), E = Math.min(n.rowIndex, d.rowIndex);
      return n = Math.max(n.rowIndex, d.rowIndex), { fromX: Math.min(s, m), fromY: Math.min(
        E,
        n
      ), toX: Math.max(s, m), toY: Math.max(E, n) };
    }
    getNodes() {
      function n(Nt) {
        let { cell: Ot, startColumn: sn, startRow: Xn } = Nt;
        Se = Math.min(Se, sn), Fe = Math.min(Fe, Xn), Ue = Math.max(Ue, sn + Ot.__colSpan - 1), Pe = Math.max(Pe, Xn + Ot.__rowSpan - 1);
      }
      var s = this._cachedNodes;
      if (s !== null)
        return s;
      var d = this.anchor.getNode();
      s = this.focus.getNode();
      var m = Go(d, ar);
      d = Go(s, ar), ar(m) || Y(103), ar(d) || Y(104), s = m.getParent(), Oo(s) || Y(105), s = s.getParent(), ls(s) || Y(106);
      var E = d.getParents()[1];
      if (E !== s) {
        if (s.isParentOf(d)) {
          if (s = E.getParent(), s == null)
            throw Error("Expected focusCellParent to have a parent");
          this.set(this.gridKey, d.getKey(), s.getKey());
        } else {
          if (s = s.getParent(), s == null)
            throw Error("Expected gridParent to have a parent");
          this.set(this.gridKey, s.getKey(), d.getKey());
        }
        return this.getNodes();
      }
      let [R, X, _e] = si(s, m, d), Se = Math.min(X.startColumn, _e.startColumn), Fe = Math.min(X.startRow, _e.startRow), Ue = Math.max(X.startColumn + X.cell.__colSpan - 1, _e.startColumn + _e.cell.__colSpan - 1), Pe = Math.max(X.startRow + X.cell.__rowSpan - 1, _e.startRow + _e.cell.__rowSpan - 1);
      d = Se, m = Fe, E = Se;
      for (var De = Fe; Se < d || Fe < m || Ue > E || Pe > De; ) {
        if (Se < d) {
          var Xe = De - m;
          --d;
          for (var lt = 0; lt <= Xe; lt++)
            n(R[m + lt][d]);
        }
        if (Fe < m)
          for (Xe = E - d, --m, lt = 0; lt <= Xe; lt++)
            n(R[m][d + lt]);
        if (Ue > E)
          for (Xe = De - m, E += 1, lt = 0; lt <= Xe; lt++)
            n(R[m + lt][E]);
        if (Pe > De)
          for (Xe = E - d, De += 1, lt = 0; lt <= Xe; lt++)
            n(R[De][d + lt]);
      }
      for (s = [s], d = null, m = Fe; m <= Pe; m++)
        for (E = Se; E <= Ue; E++)
          ({ cell: De } = R[m][E]), Xe = De.getParent(), Oo(Xe) || Y(107), Xe !== d && s.push(Xe), s.push(De, ...ua(De)), d = Xe;
      return Yr() || (this._cachedNodes = s), s;
    }
    getTextContent() {
      let n = this.getNodes(), s = "";
      for (let d = 0; d < n.length; d++)
        s += n[d].getTextContent();
      return s;
    }
  }
  function No(l) {
    return l instanceof es;
  }
  class xi extends Fs {
    constructor(n, s, d, m) {
      super(n, s), this.format = d, this.style = m;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(n) {
      this._cachedNodes = n;
    }
    is(n) {
      return vt(n) ? this.anchor.is(n.anchor) && this.focus.is(n.focus) && this.format === n.format && this.style === n.style : !1;
    }
    isCollapsed() {
      return this.anchor.is(this.focus);
    }
    getNodes() {
      var n = this._cachedNodes;
      if (n !== null)
        return n;
      n = this.anchor;
      var s = this.focus, d = n.isBefore(s), m = d ? n : s;
      d = d ? s : n, n = m.getNode(), s = d.getNode();
      let E = m.offset;
      return m = d.offset, Je(n) && (d = n.getDescendantByIndex(E), n = d ?? n), Je(s) && (d = s.getDescendantByIndex(m), d !== null && d !== n && s.getChildAtIndex(m) === d && (d = d.getPreviousSibling()), s = d ?? s), n = n.is(s) ? Je(n) && 0 < n.getChildrenSize() ? [] : [n] : n.getNodesBetween(s), Yr() || (this._cachedNodes = n), n;
    }
    setTextNodeRange(n, s, d, m) {
      Rr(this.anchor, n.__key, s, "text"), Rr(this.focus, d.__key, m, "text"), this._cachedNodes = null, this.dirty = !0;
    }
    getTextContent() {
      let n = this.getNodes();
      if (n.length === 0)
        return "";
      let s = n[0], d = n[n.length - 1], m = this.anchor, E = this.focus, R = m.isBefore(E), [X, _e] = vi(this), Se = "", Fe = !0;
      for (let Ue = 0; Ue < n.length; Ue++) {
        let Pe = n[Ue];
        if (Je(Pe) && !Pe.isInline())
          Fe || (Se += `
`), Fe = !Pe.isEmpty();
        else if (Fe = !1, ut(Pe)) {
          let De = Pe.getTextContent();
          Pe === s ? Pe === d ? (m.type !== "element" || E.type !== "element" || E.offset === m.offset) && (De = X < _e ? De.slice(X, _e) : De.slice(_e, X)) : De = R ? De.slice(X) : De.slice(_e) : Pe === d && (De = R ? De.slice(0, _e) : De.slice(0, X)), Se += De;
        } else
          !Qt(Pe) && !ri(Pe) || Pe === d && this.isCollapsed() || (Se += Pe.getTextContent());
      }
      return Se;
    }
    applyDOMRange(n) {
      let s = Xt(), d = s.getEditorState()._selection;
      if (n = pn(n.startContainer, n.startOffset, n.endContainer, n.endOffset, s, d), n !== null) {
        var [m, E] = n;
        Rr(this.anchor, m.key, m.offset, m.type), Rr(this.focus, E.key, E.offset, E.type), this._cachedNodes = null;
      }
    }
    clone() {
      let n = this.anchor, s = this.focus;
      return new xi(new mr(n.key, n.offset, n.type), new mr(s.key, s.offset, s.type), this.format, this.style);
    }
    toggleFormat(n) {
      this.format = St(this.format, n, null), this.dirty = !0;
    }
    setStyle(n) {
      this.style = n, this.dirty = !0;
    }
    hasFormat(n) {
      return (this.format & ie[n]) !== 0;
    }
    insertRawText(n) {
      n = n.split(/(\r?\n|\t)/);
      let s = [], d = n.length;
      for (let m = 0; m < d; m++) {
        let E = n[m];
        E === `
` || E === `\r
` ? s.push(wr()) : E === "	" ? s.push(Ti()) : s.push(An(E));
      }
      this.insertNodes(s);
    }
    insertText(n) {
      var s = this.anchor, d = this.focus, m = this.isCollapsed() || s.isBefore(d), E = this.format, R = this.style;
      m && s.type === "element" ? Yi(s, d, E, R) : m || d.type !== "element" || Yi(d, s, E, R);
      var X = this.getNodes(), _e = X.length, Se = m ? d : s;
      d = (m ? s : d).offset;
      var Fe = Se.offset;
      s = X[0], ut(s) || Y(26), m = s.getTextContent().length;
      var Ue = s.getParentOrThrow(), Pe = X[_e - 1];
      if (this.isCollapsed() && d === m && (s.isSegmented() || s.isToken() || !s.canInsertTextAfter() || !Ue.canInsertTextAfter() && s.getNextSibling() === null)) {
        var De = s.getNextSibling();
        if (ut(De) && De.canInsertTextBefore() && !Ct(De) || (De = An(), De.setFormat(E), Ue.canInsertTextAfter() ? s.insertAfter(De) : Ue.insertAfter(De)), De.select(0, 0), s = De, n !== "") {
          this.insertText(n);
          return;
        }
      } else if (this.isCollapsed() && d === 0 && (s.isSegmented() || s.isToken() || !s.canInsertTextBefore() || !Ue.canInsertTextBefore() && s.getPreviousSibling() === null)) {
        if (De = s.getPreviousSibling(), (!ut(De) || Ct(De)) && (De = An(), De.setFormat(E), Ue.canInsertTextBefore() ? s.insertBefore(De) : Ue.insertBefore(De)), De.select(), s = De, n !== "") {
          this.insertText(n);
          return;
        }
      } else if (s.isSegmented() && d !== m)
        Ue = An(s.getTextContent()), Ue.setFormat(E), s.replace(Ue), s = Ue;
      else if (!(this.isCollapsed() || n === "" || (De = Pe.getParent(), Ue.canInsertTextBefore() && Ue.canInsertTextAfter() && (!Je(De) || De.canInsertTextBefore() && De.canInsertTextAfter())))) {
        this.insertText(""), Rl(this.anchor, this.focus, null), this.insertText(n);
        return;
      }
      if (_e === 1)
        if (s.isToken())
          n = An(n), n.select(), s.replace(n);
        else {
          if (X = s.getFormat(), _e = s.getStyle(), d === Fe && (X !== E || _e !== R))
            if (s.getTextContent() === "")
              s.setFormat(E), s.setStyle(R);
            else {
              X = An(n), X.setFormat(E), X.setStyle(R), X.select(), d === 0 ? s.insertBefore(X, !1) : ([_e] = s.splitText(d), _e.insertAfter(X, !1)), X.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= n.length);
              return;
            }
          else if (wl(s)) {
            n = An(n), n.setFormat(E), n.setStyle(R), n.select(), s.replace(n);
            return;
          }
          s = s.spliceText(d, Fe - d, n, !0), s.getTextContent() === "" ? s.remove() : this.anchor.type === "text" && (s.isComposing() ? this.anchor.offset -= n.length : (this.format = X, this.style = _e));
        }
      else {
        if (E = /* @__PURE__ */ new Set([...s.getParentKeys(), ...Pe.getParentKeys()]), De = Je(s) ? s : s.getParentOrThrow(), R = Je(Pe) ? Pe : Pe.getParentOrThrow(), Ue = Pe, !De.is(R) && R.isInline())
          do
            Ue = R, R = R.getParentOrThrow();
          while (R.isInline());
        if (Se.type === "text" && (Fe !== 0 || Pe.getTextContent() === "") || Se.type === "element" && Pe.getIndexWithinParent() < Fe)
          if (ut(Pe) && !Pe.isToken() && Fe !== Pe.getTextContentSize()) {
            if (Pe.isSegmented()) {
              var Xe = An(Pe.getTextContent());
              Pe.replace(Xe), Pe = Xe;
            }
            Yn(Se.getNode()) || Se.type !== "text" || (Pe = Pe.spliceText(0, Fe, "")), E.add(Pe.__key);
          } else
            Se = Pe.getParentOrThrow(), Se.canBeEmpty() || Se.getChildrenSize() !== 1 ? Pe.remove() : Se.remove();
        else
          E.add(Pe.__key);
        for (Se = R.getChildren(), Fe = new Set(X), Pe = De.is(R), De = De.isInline() && s.getNextSibling() === null ? De : s, Xe = Se.length - 1; 0 <= Xe; Xe--) {
          let lt = Se[Xe];
          if (lt.is(s) || Je(lt) && lt.isParentOf(s))
            break;
          lt.isAttached() && (!Fe.has(lt) || lt.is(Ue) ? Pe || De.insertAfter(lt, !1) : lt.remove());
        }
        if (!Pe)
          for (Se = R, R = null; Se !== null; )
            Fe = Se.getChildren(), Pe = Fe.length, (Pe === 0 || Fe[Pe - 1].is(R)) && (E.delete(Se.__key), R = Se), Se = Se.getParent();
        for (s.isToken() ? d === m ? s.select() : (n = An(n), n.select(), s.replace(n)) : (s = s.spliceText(d, m - d, n, !0), s.getTextContent() === "" ? s.remove() : s.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= n.length)), n = 1; n < _e; n++)
          s = X[n], E.has(s.__key) || s.remove();
      }
    }
    removeText() {
      this.insertText("");
    }
    formatText(n) {
      if (this.isCollapsed())
        this.toggleFormat(n), Dt(null);
      else {
        var s = this.getNodes(), d = [];
        for (var m of s)
          ut(m) && d.push(m);
        var E = d.length;
        if (E === 0)
          this.toggleFormat(n), Dt(null);
        else {
          m = this.anchor;
          var R = this.focus, X = this.isBackward();
          s = X ? R : m, m = X ? m : R;
          var _e = 0, Se = d[0];
          if (R = s.type === "element" ? 0 : s.offset, s.type === "text" && R === Se.getTextContentSize() && (_e = 1, Se = d[1], R = 0), Se != null) {
            X = Se.getFormatFlags(n, null);
            var Fe = E - 1, Ue = d[Fe];
            if (E = m.type === "text" ? m.offset : Ue.getTextContentSize(), Se.is(Ue))
              R !== E && (R === 0 && E === Se.getTextContentSize() ? Se.setFormat(X) : (n = Se.splitText(R, E), n = R === 0 ? n[0] : n[1], n.setFormat(X), s.type === "text" && s.set(n.__key, 0, "text"), m.type === "text" && m.set(n.__key, E - R, "text")), this.format = X);
            else {
              R !== 0 && ([, Se] = Se.splitText(R), R = 0), Se.setFormat(X);
              var Pe = Ue.getFormatFlags(n, X);
              for (0 < E && (E !== Ue.getTextContentSize() && ([Ue] = Ue.splitText(E)), Ue.setFormat(Pe)), _e += 1; _e < Fe; _e++) {
                let De = d[_e];
                if (!De.isToken()) {
                  let Xe = De.getFormatFlags(n, Pe);
                  De.setFormat(Xe);
                }
              }
              s.type === "text" && s.set(Se.__key, R, "text"), m.type === "text" && m.set(Ue.__key, E, "text"), this.format = X | Pe;
            }
          }
        }
      }
    }
    insertNodes(n) {
      if (n.length !== 0) {
        if (this.anchor.key === "root") {
          this.insertParagraph();
          var s = Wt();
          if (!vt(s))
            throw Error("Expected RangeSelection after insertParagraph");
          return s.insertNodes(n);
        }
        var d = ao(this.anchor.getNode(), Kr);
        if (s = n[n.length - 1], "__language" in d)
          if ("__language" in n[0])
            this.insertText(n[0].getTextContent());
          else {
            var m = vo(this);
            d.splice(m, 0, n), s.selectEnd();
          }
        else if (n.some((X) => (Je(X) || Qt(X)) && !X.isInline())) {
          s = So(n), n = s.getLastDescendant();
          var E = s.getChildren();
          s = Je(d) && d.isEmpty() ? null : this.insertParagraph(), m = E[E.length - 1];
          var R = E[0];
          ((X) => Je(X) && Kr(X) && !X.isEmpty() && Je(d) && (!d.isEmpty() || "__value" in d && "__checked" in d))(R) && (d.append(...R.getChildren()), R = E[1]), R && xl(d, R), E = ao(n, Kr), s && Je(E) && ("__value" in s && "__checked" in s || Kr(m)) && (E.append(...s.getChildren()), s.remove()), Je(d) && d.isEmpty() && d.remove(), n.selectEnd(), n = Je(d) ? d.getLastChild() : null, ri(n) && E !== d && n.remove();
        } else
          m = vo(this), d.splice(m, 0, n), s.selectEnd();
      }
    }
    insertParagraph() {
      if (this.anchor.key === "root") {
        var n = Zn();
        return on().splice(this.anchor.offset, 0, [n]), n.select(), n;
      }
      var s = vo(this);
      return n = ao(this.anchor.getNode(), Kr), s = (s = n.getChildAtIndex(s)) ? [s, ...s.getNextSiblings()] : [], (n = n.insertNewAfter(this, !1)) ? (n.append(...s), n.selectStart(), n) : null;
    }
    insertLineBreak(n) {
      var s = wr();
      this.insertNodes([s]), n && (n = s.getParentOrThrow(), s = s.getIndexWithinParent(), n.select(s, s));
    }
    extract() {
      var n = this.getNodes(), s = n.length, d = s - 1, m = this.anchor;
      let E = this.focus;
      var R = n[0];
      let X = n[d], [_e, Se] = vi(this);
      return s === 0 ? [] : s === 1 ? ut(R) && !this.isCollapsed() ? (n = _e > Se ? Se : _e, d = R.splitText(n, _e > Se ? _e : Se), n = n === 0 ? d[0] : d[1], n != null ? [n] : []) : [R] : (s = m.isBefore(E), ut(R) && (m = s ? _e : Se, m === R.getTextContentSize() ? n.shift() : m !== 0 && ([, R] = R.splitText(m), n[0] = R)), ut(X) && (R = X.getTextContent().length, s = s ? Se : _e, s === 0 ? n.pop() : s !== R && ([X] = X.splitText(s), n[d] = X)), n);
    }
    modify(n, s, d) {
      var m = this.focus, E = this.anchor, R = n === "move", X = cn(m, s);
      if (Qt(X) && !X.isIsolated())
        R && X.isKeyboardSelectable() ? (s = yr(), s.add(X.__key), rr(s)) : (n = s ? X.getPreviousSibling() : X.getNextSibling(), ut(n) ? (X = n.__key, s = s ? n.getTextContent().length : 0, m.set(X, s, "text"), R && E.set(X, s, "text")) : (d = X.getParentOrThrow(), Je(n) ? (d = n.__key, X = s ? n.getChildrenSize() : 0) : (X = X.getIndexWithinParent(), d = d.__key, s || X++), m.set(d, X, "element"), R && E.set(d, X, "element")));
      else if (E = Xt(), m = xr(E._window)) {
        var _e = E._blockCursorElement, Se = E._rootElement;
        if (Se === null || _e === null || !Je(X) || X.isInline() || X.canBeEmpty() || ws(_e, E, Se), m.modify(n, s ? "backward" : "forward", d), 0 < m.rangeCount && (X = m.getRangeAt(0), E = this.anchor.getNode(), E = Yn(E) ? E : xs(E), this.applyDOMRange(X), this.dirty = !0, !R)) {
          for (R = this.getNodes(), n = [], d = !1, _e = 0; _e < R.length; _e++)
            Se = R[_e], Xr(Se, E) ? n.push(Se) : d = !0;
          d && 0 < n.length && (s ? (s = n[0], Je(s) ? s.selectStart() : s.getParentOrThrow().selectStart()) : (s = n[n.length - 1], Je(s) ? s.selectEnd() : s.getParentOrThrow().selectEnd())), (m.anchorNode !== X.startContainer || m.anchorOffset !== X.startOffset) && (s = this.focus, R = this.anchor, m = R.key, X = R.offset, E = R.type, Rr(R, s.key, s.offset, s.type), Rr(s, m, X, E), this._cachedNodes = null);
        }
      }
    }
    deleteCharacter(n) {
      let s = this.isCollapsed();
      if (this.isCollapsed()) {
        var d = this.anchor, m = this.focus, E = d.getNode();
        if (!n && (d.type === "element" && Je(E) && d.offset === E.getChildrenSize() || d.type === "text" && d.offset === E.getTextContentSize())) {
          var R = E.getParent();
          if (R = E.getNextSibling() || (R === null ? null : R.getNextSibling()), Je(R) && R.isShadowRoot())
            return;
        }
        if (R = cn(m, n), Qt(R) && !R.isIsolated()) {
          R.isKeyboardSelectable() && Je(E) && E.getChildrenSize() === 0 ? (E.remove(), n = yr(), n.add(R.__key), rr(n)) : (R.remove(), Xt().dispatchCommand(e, void 0));
          return;
        }
        if (!n && Je(R) && Je(E) && E.isEmpty()) {
          E.remove(), R.selectStart();
          return;
        }
        if (this.modify("extend", n, "character"), this.isCollapsed()) {
          if (n && d.offset === 0 && (d.type === "element" ? d.getNode() : d.getNode().getParentOrThrow()).collapseAtStart(this))
            return;
        } else {
          if (R = m.type === "text" ? m.getNode() : null, E = d.type === "text" ? d.getNode() : null, R !== null && R.isSegmented()) {
            if (d = m.offset, m = R.getTextContentSize(), R.is(E) || n && d !== m || !n && d !== 0) {
              ts(R, n, d);
              return;
            }
          } else if (E !== null && E.isSegmented() && (d = d.offset, m = E.getTextContentSize(), E.is(R) || n && d !== 0 || !n && d !== m)) {
            ts(E, n, d);
            return;
          }
          if (E = this.anchor, R = this.focus, d = E.getNode(), m = R.getNode(), d === m && E.type === "text" && R.type === "text") {
            var X = E.offset, _e = R.offset;
            let Se = X < _e;
            m = Se ? X : _e, _e = Se ? _e : X, X = _e - 1, m !== X && (d = d.getTextContent().slice(m, _e), Wo(d) || (n ? R.offset = X : E.offset = X));
          }
        }
      }
      this.removeText(), n && !s && this.isCollapsed() && this.anchor.type === "element" && this.anchor.offset === 0 && (n = this.anchor.getNode(), n.isEmpty() && Yn(n.getParent()) && n.getIndexWithinParent() === 0 && n.collapseAtStart(this));
    }
    deleteLine(n) {
      this.isCollapsed() && (this.anchor.type === "text" && this.modify("extend", n, "lineboundary"), (n ? this.focus : this.anchor).offset === 0 && this.modify("extend", n, "character")), this.removeText();
    }
    deleteWord(n) {
      this.isCollapsed() && this.modify("extend", n, "word"), this.removeText();
    }
  }
  function Eo(l) {
    return l instanceof ji;
  }
  function To(l) {
    let n = l.offset;
    return l.type === "text" ? n : (l = l.getNode(), n === l.getChildrenSize() ? l.getTextContent().length : 0);
  }
  function vi(l) {
    let n = l.anchor;
    return l = l.focus, n.type === "element" && l.type === "element" && n.key === l.key && n.offset === l.offset ? [0, 0] : [To(n), To(l)];
  }
  function ts(l, n, s) {
    let d = l.getTextContent().split(/(?=\s)/g), m = d.length, E = 0, R = 0;
    for (let X = 0; X < m; X++) {
      let _e = d[X], Se = X === m - 1;
      if (R = E, E += _e.length, n && E === s || E > s || Se) {
        d.splice(X, 1), Se && (R = void 0);
        break;
      }
    }
    n = d.join("").trim(), n === "" ? l.remove() : (l.setTextContent(n), l.select(R, R));
  }
  function Ol(l, n, s, d) {
    var m = n;
    if (l.nodeType === 1) {
      let X = !1;
      var E = l.childNodes, R = E.length;
      m === R && (X = !0, m = R - 1);
      let _e = E[m];
      if (R = !1, _e === d._blockCursorElement ? (_e = E[m + 1], R = !0) : d._blockCursorElement !== null && m--, d = Fr(_e), ut(d))
        m = X ? d.getTextContentSize() : 0;
      else {
        if (E = Fr(l), E === null)
          return null;
        if (Je(E) ? (l = E.getChildAtIndex(m), (n = Je(l)) && (n = l.getParent(), n = s === null || n === null || !n.canBeEmpty() || n !== s.getNode()), n && (s = X ? l.getLastDescendant() : l.getFirstDescendant(), s === null ? (E = l, m = 0) : (l = s, E = Je(l) ? l : l.getParentOrThrow())), ut(l) ? (d = l, E = null, m = X ? l.getTextContentSize() : 0) : l !== E && X && !R && m++) : (m = E.getIndexWithinParent(), m = n === 0 && Qt(E) && Fr(l) === E ? m : m + 1, E = E.getParentOrThrow()), Je(E))
          return new mr(E.__key, m, "element");
      }
    } else
      d = Fr(l);
    return ut(d) ? new mr(d.__key, m, "text") : null;
  }
  function Ks(l, n, s) {
    var d = l.offset, m = l.getNode();
    d === 0 ? (d = m.getPreviousSibling(), m = m.getParent(), n ? (s || !n) && d === null && Je(m) && m.isInline() && (n = m.getPreviousSibling(), ut(n) && (l.key = n.__key, l.offset = n.getTextContent().length)) : Je(d) && !s && d.isInline() ? (l.key = d.__key, l.offset = d.getChildrenSize(), l.type = "element") : ut(d) && (l.key = d.__key, l.offset = d.getTextContent().length)) : d === m.getTextContent().length && (d = m.getNextSibling(), m = m.getParent(), n && Je(d) && d.isInline() ? (l.key = d.__key, l.offset = 0, l.type = "element") : (s || n) && d === null && Je(m) && m.isInline() && !m.canInsertTextAfter() && (n = m.getNextSibling(), ut(n) && (l.key = n.__key, l.offset = 0)));
  }
  function Rl(l, n, s) {
    if (l.type === "text" && n.type === "text") {
      var d = l.isBefore(n);
      let m = l.is(n);
      Ks(l, d, m), Ks(n, !d, m), m && (n.key = l.key, n.offset = l.offset, n.type = l.type), d = Xt(), d.isComposing() && d._compositionKey !== l.key && vt(s) && (d = s.anchor, s = s.focus, Rr(l, d.key, d.offset, d.type), Rr(n, s.key, s.offset, s.type));
    }
  }
  function pn(l, n, s, d, m, E) {
    return l === null || s === null || !nt(m, l, s) || (n = Ol(l, n, vt(E) ? E.anchor : null, m), n === null) || (d = Ol(s, d, vt(E) ? E.focus : null, m), d === null || n.type === "element" && d.type === "element" && (l = Fr(l), s = Fr(s), Qt(l) && Qt(s))) ? null : (Rl(n, d, E), [n, d]);
  }
  function $n(l, n, s, d, m, E) {
    let R = lr();
    return l = new xi(new mr(l, n, m), new mr(s, d, E), 0, ""), l.dirty = !0, R._selection = l;
  }
  function yr() {
    return new ji(/* @__PURE__ */ new Set());
  }
  function oi(l) {
    let n = l.getEditorState()._selection, s = xr(l._window);
    return vt(n) || n == null ? bn(n, s, l) : n.clone();
  }
  function bn(l, n, s) {
    var d = s._window;
    if (d === null)
      return null;
    var m = d.event, E = m ? m.type : void 0;
    d = E === "selectionchange", m = !st && (d || E === "beforeinput" || E === "compositionstart" || E === "compositionend" || E === "click" && m && m.detail === 3 || E === "drop" || E === void 0);
    let R;
    if (!vt(l) || m) {
      if (n === null)
        return null;
      if (m = n.anchorNode, E = n.focusNode, R = n.anchorOffset, n = n.focusOffset, d && vt(l) && !nt(s, m, E))
        return l.clone();
    } else
      return l.clone();
    if (s = pn(m, R, E, n, s, l), s === null)
      return null;
    let [X, _e] = s;
    return new xi(X, _e, vt(l) ? l.format : 0, vt(l) ? l.style : "");
  }
  function Wt() {
    return lr()._selection;
  }
  function Si() {
    return Xt()._editorState._selection;
  }
  function qi(l, n, s, d = 1) {
    var m = l.anchor, E = l.focus, R = m.getNode(), X = E.getNode();
    if (n.is(R) || n.is(X)) {
      if (R = n.__key, l.isCollapsed())
        n = m.offset, (s <= n && 0 < d || s < n && 0 > d) && (s = Math.max(0, n + d), m.set(R, s, "element"), E.set(R, s, "element"), xo(l));
      else {
        let Se = l.isBackward();
        X = Se ? E : m;
        var _e = X.getNode();
        m = Se ? m : E, E = m.getNode(), n.is(_e) && (_e = X.offset, (s <= _e && 0 < d || s < _e && 0 > d) && X.set(R, Math.max(0, _e + d), "element")), n.is(E) && (n = m.offset, (s <= n && 0 < d || s < n && 0 > d) && m.set(R, Math.max(0, n + d), "element"));
      }
      xo(l);
    }
  }
  function xo(l) {
    var n = l.anchor, s = n.offset;
    let d = l.focus;
    var m = d.offset, E = n.getNode(), R = d.getNode();
    if (l.isCollapsed())
      Je(E) && (R = E.getChildrenSize(), R = (m = s >= R) ? E.getChildAtIndex(R - 1) : E.getChildAtIndex(s), ut(R) && (s = 0, m && (s = R.getTextContentSize()), n.set(R.__key, s, "text"), d.set(R.__key, s, "text")));
    else {
      if (Je(E)) {
        let X = E.getChildrenSize();
        s = (l = s >= X) ? E.getChildAtIndex(X - 1) : E.getChildAtIndex(s), ut(s) && (E = 0, l && (E = s.getTextContentSize()), n.set(s.__key, E, "text"));
      }
      Je(R) && (s = R.getChildrenSize(), m = (n = m >= s) ? R.getChildAtIndex(s - 1) : R.getChildAtIndex(m), ut(m) && (R = 0, n && (R = m.getTextContentSize()), d.set(m.__key, R, "text")));
    }
  }
  function ns(l, n) {
    if (n = n.getEditorState()._selection, l = l._selection, vt(l)) {
      var s = l.anchor;
      let d = l.focus, m;
      s.type === "text" && (m = s.getNode(), m.selectionTransform(n, l)), d.type === "text" && (s = d.getNode(), m !== s && s.selectionTransform(n, l));
    }
  }
  function Vi(l, n, s, d, m) {
    let E = null, R = 0, X = null;
    d !== null ? (E = d.__key, ut(d) ? (R = d.getTextContentSize(), X = "text") : Je(d) && (R = d.getChildrenSize(), X = "element")) : m !== null && (E = m.__key, ut(m) ? X = "text" : Je(m) && (X = "element")), E !== null && X !== null ? l.set(E, R, X) : (R = n.getIndexWithinParent(), R === -1 && (R = s.getChildrenSize()), l.set(s.__key, R, "element"));
  }
  function rs(l, n, s, d, m) {
    l.type === "text" ? (l.key = s, n || (l.offset += m)) : l.offset > d.getIndexWithinParent() && --l.offset;
  }
  function si(l, n, s) {
    let d = [], m = null, E = null;
    l = l.getChildren();
    for (let Fe = 0; Fe < l.length; Fe++) {
      var R = l[Fe];
      Oo(R) || Y(108);
      var X = R.getChildren();
      R = 0;
      for (let Ue of X) {
        for (ar(Ue) || Y(109); d[Fe] !== void 0 && d[Fe][R] !== void 0; )
          R++;
        X = Fe;
        var _e = R, Se = Ue;
        let Pe = { cell: Se, startColumn: _e, startRow: X }, De = Se.__rowSpan, Xe = Se.__colSpan;
        for (let lt = 0; lt < De; lt++) {
          d[X + lt] === void 0 && (d[X + lt] = []);
          for (let Nt = 0; Nt < Xe; Nt++)
            d[X + lt][_e + Nt] = Pe;
        }
        n.is(Se) && (m = Pe), s.is(Se) && (E = Pe), R += Ue.__colSpan;
      }
    }
    return m === null && Y(110), E === null && Y(111), [d, m, E];
  }
  function Gr(l) {
    l instanceof ss || (l instanceof Wr ? (l = Go(l, ar), ar(l) || Y(114)) : (l = Go(l.getNode(), ar), ar(l) || Y(114)));
    let n = l.getParent();
    Oo(n) || Y(115);
    let s = n.getParent();
    return ls(s) || Y(116), [l, n, s];
  }
  function vo(l) {
    l.isCollapsed() || l.removeText();
    var n = l.anchor, s = n.getNode();
    if (!ut(s))
      return n.offset;
    let d = s.getParent();
    return d ? (s = s.splitText(n.offset), s.length === 0 ? 0 : (n = n.offset === 0 ? 0 : 1, s = s[0].getIndexWithinParent() + n, !d.isInline() || s === 0 ? s : ((s = d.getChildAtIndex(s)) && d.insertNewAfter(l).append(s, ...s.getNextSiblings()), d.getIndexWithinParent() + n))) : (l = Zn(), on().append(l), l.select(), 0);
  }
  function So(l) {
    let n = Zn(), s = null;
    for (let d = 0; d < l.length; d++) {
      let m = l[d], E = ri(m);
      if (E || Qt(m) && m.isInline() || Je(m) && m.isInline() || ut(m) || m.isParentRequired()) {
        if (s === null && (s = m.createParentElementNode(), n.append(s), E))
          continue;
        s !== null && s.append(m);
      } else
        n.append(m), s = null;
    }
    return n;
  }
  let dn = null, _n = null, mn = !1, Hs = !1, Ji = 0, Us = { characterData: !0, childList: !0, subtree: !0 };
  function Yr() {
    return mn || dn !== null && dn._readOnly;
  }
  function Un() {
    mn && Y(13);
  }
  function lr() {
    return dn === null && Y(15), dn;
  }
  function Xt() {
    return _n === null && Y(16), _n;
  }
  function Ws(l, n, s) {
    var d = n.__type;
    let m = l._nodes.get(d);
    for (m === void 0 && Y(30, d), l = s.get(d), l === void 0 && (l = Array.from(m.transforms), s.set(d, l)), s = l.length, d = 0; d < s && (l[d](n), n.isAttached()); d++)
      ;
  }
  function Dl(l, n) {
    n = n._dirtyLeaves, l = l._nodeMap;
    for (let s of n)
      n = l.get(s), ut(n) && n.isAttached() && n.isSimpleText() && !n.isUnmergeable() && Ve(n);
  }
  function Na(l, n) {
    let s = n._dirtyLeaves, d = n._dirtyElements;
    l = l._nodeMap;
    let m = Kt(), E = /* @__PURE__ */ new Map();
    var R = s;
    let X = R.size;
    for (var _e = d, Se = _e.size; 0 < X || 0 < Se; ) {
      if (0 < X) {
        n._dirtyLeaves = /* @__PURE__ */ new Set();
        for (let Fe of R)
          R = l.get(Fe), ut(R) && R.isAttached() && R.isSimpleText() && !R.isUnmergeable() && Ve(R), R !== void 0 && R !== void 0 && R.__key !== m && R.isAttached() && Ws(n, R, E), s.add(Fe);
        if (R = n._dirtyLeaves, X = R.size, 0 < X) {
          Ji++;
          continue;
        }
      }
      n._dirtyLeaves = /* @__PURE__ */ new Set(), n._dirtyElements = /* @__PURE__ */ new Map();
      for (let Fe of _e)
        _e = Fe[0], Se = Fe[1], (_e === "root" || Se) && (R = l.get(_e), R !== void 0 && R !== void 0 && R.__key !== m && R.isAttached() && Ws(n, R, E), d.set(_e, Se));
      R = n._dirtyLeaves, X = R.size, _e = n._dirtyElements, Se = _e.size, Ji++;
    }
    n._dirtyLeaves = s, n._dirtyElements = d;
  }
  function Zi(l, n) {
    var s = l.type, d = n.get(s);
    if (d === void 0 && Y(17, s), s = d.klass, l.type !== s.getType() && Y(18, s.name), s = s.importJSON(l), l = l.children, Je(s) && Array.isArray(l))
      for (d = 0; d < l.length; d++) {
        let m = Zi(l[d], n);
        s.append(m);
      }
    return s;
  }
  function Al(l, n) {
    let s = dn, d = mn, m = _n;
    dn = l, mn = !0, _n = null;
    try {
      return n();
    } finally {
      dn = s, mn = d, _n = m;
    }
  }
  function Cr(l, n) {
    let s = l._pendingEditorState, d = l._rootElement, m = l._headless || d === null;
    if (s !== null) {
      var E = l._editorState, R = E._selection, X = s._selection, _e = l._dirtyType !== 0, Se = dn, Fe = mn, Ue = _n, Pe = l._updating, De = l._observer, Xe = null;
      if (l._pendingEditorState = null, l._editorState = s, !m && _e && De !== null) {
        _n = l, dn = s, mn = !1, l._updating = !0;
        try {
          let qt = l._dirtyType, wn = l._dirtyElements, ft = l._dirtyLeaves;
          De.disconnect();
          var lt = qt, Nt = wn, Ot = ft;
          Sn = pr = Cn = "", ei = lt === 2, un = null, Dn = l, Qr = l._config, co = l._nodes, Yo = Dn._listeners.mutation, vr = Nt, gn = Ot, ti = E._nodeMap, or = s._nodeMap, Ki = s._readOnly, jo = new Map(l._keyToDOMMap);
          let cr = /* @__PURE__ */ new Map();
          Hi = cr, Ui("root", null), Hi = jo = Qr = or = ti = gn = vr = co = Dn = void 0, Xe = cr;
        } catch (qt) {
          if (qt instanceof Error && l._onError(qt), Hs)
            throw qt;
          zs(l, null, d, s), be(l), l._dirtyType = 2, Hs = !0, Cr(l, E), Hs = !1;
          return;
        } finally {
          De.observe(d, Us), l._updating = Pe, dn = Se, mn = Fe, _n = Ue;
        }
      }
      s._readOnly || (s._readOnly = !0);
      var sn = l._dirtyLeaves, Xn = l._dirtyElements, Ar = l._normalizedNodes, jr = l._updateTags, ci = l._deferred;
      _e && (l._dirtyType = 0, l._cloneNotNeeded.clear(), l._dirtyLeaves = /* @__PURE__ */ new Set(), l._dirtyElements = /* @__PURE__ */ new Map(), l._normalizedNodes = /* @__PURE__ */ new Set(), l._updateTags = /* @__PURE__ */ new Set());
      var ui = l._decorators, to = l._pendingDecorators || ui, Gs = s._nodeMap, as;
      for (as in to)
        Gs.has(as) || (to === ui && (to = Ci(l)), delete to[as]);
      var br = m ? null : xr(l._window);
      if (l._editable && br !== null && (_e || X === null || X.dirty)) {
        _n = l, dn = s;
        try {
          if (De !== null && De.disconnect(), _e || X === null || X.dirty) {
            let qt = l._blockCursorElement;
            qt !== null && ws(qt, l, d);
            e: {
              let wn = br.anchorNode, ft = br.focusNode, cr = br.anchorOffset, Ri = br.focusOffset, zn = document.activeElement;
              if (!(jr.has("collaboration") && zn !== d || zn !== null && qe(zn)))
                if (vt(X)) {
                  var no = X.anchor, cs = X.focus, Ro = no.key, wi = cs.key, Fl = Rn(l, Ro), Bl = Rn(l, wi), Do = no.offset, Kl = cs.offset, Ys = X.format, js = X.style, Hl = X.isCollapsed(), ro = Fl, us = Bl, Mr = !1;
                  if (no.type === "text") {
                    ro = xt(Fl);
                    let Qn = no.getNode();
                    Mr = Qn.getFormat() !== Ys || Qn.getStyle() !== js;
                  } else
                    vt(R) && R.anchor.type === "text" && (Mr = !0);
                  if (cs.type === "text" && (us = xt(Bl)), ro !== null && us !== null) {
                    if (Hl && (R === null || Mr || vt(R) && (R.format !== Ys || R.style !== js))) {
                      var Mn = performance.now();
                      gl = [Ys, js, Do, Ro, Mn];
                    }
                    if (cr === Do && Ri === Kl && wn === ro && ft === us && (br.type !== "Range" || !Hl) && (zn !== null && d.contains(zn) || d.focus({ preventScroll: !0 }), no.type !== "element"))
                      break e;
                    try {
                      br.setBaseAndExtent(ro, Do, us, Kl);
                    } catch {
                    }
                    if (!jr.has("skip-scroll-into-view") && X.isCollapsed() && d !== null && d === document.activeElement) {
                      let Qn = X instanceof xi && X.anchor.type === "element" ? ro.childNodes[Do] || null : 0 < br.rangeCount ? br.getRangeAt(0) : null;
                      if (Qn !== null) {
                        let On;
                        if (Qn instanceof Text) {
                          let Gn = document.createRange();
                          Gn.selectNode(Qn), On = Gn.getBoundingClientRect();
                        } else
                          On = Qn.getBoundingClientRect();
                        let ur = d.ownerDocument, hi = ur.defaultView;
                        if (hi !== null)
                          for (var { top: dt, bottom: di } = On, Oi, Ao, fi = d; fi !== null; ) {
                            let Gn = fi === ur.body;
                            if (Gn)
                              Oi = 0, Ao = Kn(l).innerHeight;
                            else {
                              let ds = fi.getBoundingClientRect();
                              Oi = ds.top, Ao = ds.bottom;
                            }
                            let Di = 0;
                            if (dt < Oi ? Di = -(Oi - dt) : di > Ao && (Di = di - Ao), Di !== 0)
                              if (Gn)
                                hi.scrollBy(0, Di);
                              else {
                                let ds = fi.scrollTop;
                                fi.scrollTop += Di;
                                let Wl = fi.scrollTop - ds;
                                dt -= Wl, di -= Wl;
                              }
                            if (Gn)
                              break;
                            fi = ir(fi);
                          }
                      }
                    }
                    bs = !0;
                  }
                } else
                  R !== null && nt(l, wn, ft) && br.removeAllRanges();
            }
          }
          e: {
            let qt = l._blockCursorElement;
            if (vt(X) && X.isCollapsed() && X.anchor.type === "element" && d.contains(document.activeElement)) {
              let wn = X.anchor, ft = wn.getNode(), cr = wn.offset, Ri = ft.getChildrenSize(), zn = !1, Qn = null;
              if (cr === Ri) {
                let On = ft.getChildAtIndex(cr - 1);
                Ss(On) && (zn = !0);
              } else {
                let On = ft.getChildAtIndex(cr);
                if (Ss(On)) {
                  let ur = On.getPreviousSibling();
                  (ur === null || Ss(ur)) && (zn = !0, Qn = l.getElementByKey(On.__key));
                }
              }
              if (zn) {
                let On = l.getElementByKey(ft.__key);
                if (qt === null) {
                  let ur = l._config.theme, hi = document.createElement("div");
                  hi.contentEditable = "false", hi.setAttribute("data-lexical-cursor", "true");
                  let Gn = ur.blockCursor;
                  if (Gn !== void 0) {
                    if (typeof Gn == "string") {
                      let Di = Gn.split(" ");
                      Gn = ur.blockCursor = Di;
                    }
                    Gn !== void 0 && hi.classList.add(...Gn);
                  }
                  l._blockCursorElement = qt = hi;
                }
                d.style.caretColor = "transparent", Qn === null ? On.appendChild(qt) : On.insertBefore(qt, Qn);
                break e;
              }
            }
            qt !== null && ws(qt, l, d);
          }
          De !== null && De.observe(d, Us);
        } finally {
          _n = Ue, dn = Se;
        }
      }
      if (Xe !== null) {
        var Lr = Xe;
        let qt = Array.from(l._listeners.mutation), wn = qt.length;
        for (let ft = 0; ft < wn; ft++) {
          let [cr, Ri] = qt[ft], zn = Lr.get(Ri);
          zn !== void 0 && cr(zn, { dirtyLeaves: sn, prevEditorState: E, updateTags: jr });
        }
      }
      vt(X) || X === null || R !== null && R.is(X) || l.dispatchCommand(e, void 0);
      var bo = l._pendingDecorators;
      bo !== null && (l._decorators = bo, l._pendingDecorators = null, Xi("decorator", l, !0, bo));
      var Ul = Ho(n || E), qs = Ho(s);
      if (Ul !== qs && Xi("textcontent", l, !0, qs), Xi("update", l, !0, { dirtyElements: Xn, dirtyLeaves: sn, editorState: s, normalizedNodes: Ar, prevEditorState: n || E, tags: jr }), l._deferred = [], ci.length !== 0) {
        let qt = l._updating;
        l._updating = !0;
        try {
          for (let wn = 0; wn < ci.length; wn++)
            ci[wn]();
        } finally {
          l._updating = qt;
        }
      }
      var qr = l._updates;
      if (qr.length !== 0) {
        let qt = qr.shift();
        if (qt) {
          let [wn, ft] = qt;
          bl(l, wn, ft);
        }
      }
    }
  }
  function Xi(l, n, s, ...d) {
    let m = n._updating;
    n._updating = s;
    try {
      let E = Array.from(n._listeners[l]);
      for (l = 0; l < E.length; l++)
        E[l].apply(null, d);
    } finally {
      n._updating = m;
    }
  }
  function rt(l, n, s) {
    if (l._updating === !1 || _n !== l) {
      let E = !1;
      return l.update(() => {
        E = rt(l, n, s);
      }), E;
    }
    let d = ye(l);
    for (let E = 4; 0 <= E; E--)
      for (let R = 0; R < d.length; R++) {
        var m = d[R]._commands.get(n);
        if (m !== void 0 && (m = m[E], m !== void 0)) {
          m = Array.from(m);
          let X = m.length;
          for (let _e = 0; _e < X; _e++)
            if (m[_e](s, l) === !0)
              return !0;
        }
      }
    return !1;
  }
  function is(l, n) {
    let s = l._updates;
    for (n = n || !1; s.length !== 0; ) {
      var d = s.shift();
      if (d) {
        let [m, E] = d, R;
        E !== void 0 && (d = E.onUpdate, R = E.tag, E.skipTransforms && (n = !0), d && l._deferred.push(d), R && l._updateTags.add(R)), m();
      }
    }
    return n;
  }
  function bl(l, n, s) {
    let d = l._updateTags;
    var m, E = m = !1;
    if (s !== void 0) {
      var R = s.onUpdate;
      m = s.tag, m != null && d.add(m), m = s.skipTransforms || !1, E = s.discrete || !1;
    }
    R && l._deferred.push(R), s = l._editorState, R = l._pendingEditorState;
    let X = !1;
    (R === null || R._readOnly) && (R = l._pendingEditorState = new eo(new Map((R || s)._nodeMap)), X = !0), R._flushSync = E, E = dn;
    let _e = mn, Se = _n, Fe = l._updating;
    dn = R, mn = !1, l._updating = !0, _n = l;
    try {
      X && (l._headless ? s._selection != null && (R._selection = s._selection.clone()) : R._selection = oi(l));
      let Ue = l._compositionKey;
      n(), m = is(l, m), ns(R, l), l._dirtyType !== 0 && (m ? Dl(R, l) : Na(R, l), is(l), Os(s, R, l._dirtyLeaves, l._dirtyElements)), Ue !== l._compositionKey && (R._flushSync = !0);
      let Pe = R._selection;
      if (vt(Pe)) {
        let De = R._nodeMap, Xe = Pe.focus.key;
        De.get(Pe.anchor.key) !== void 0 && De.get(Xe) !== void 0 || Y(19);
      } else
        Eo(Pe) && Pe._nodes.size === 0 && (R._selection = null);
    } catch (Ue) {
      Ue instanceof Error && l._onError(Ue), l._pendingEditorState = s, l._dirtyType = 2, l._cloneNotNeeded.clear(), l._dirtyLeaves = /* @__PURE__ */ new Set(), l._dirtyElements.clear(), Cr(l);
      return;
    } finally {
      dn = E, mn = _e, _n = Se, l._updating = Fe, Ji = 0;
    }
    l._dirtyType !== 0 || Ll(R, l) ? R._flushSync ? (R._flushSync = !1, Cr(l)) : X && je(() => {
      Cr(l);
    }) : (R._flushSync = !1, X && (d.clear(), l._deferred = [], l._pendingEditorState = null));
  }
  function Jn(l, n, s) {
    l._updating ? l._updates.push([n, s]) : bl(l, n, s);
  }
  class Ml extends Wr {
    constructor(n) {
      super(n);
    }
    decorate() {
      Y(47);
    }
    isIsolated() {
      return !1;
    }
    isInline() {
      return !0;
    }
    isKeyboardSelectable() {
      return !0;
    }
  }
  function Qt(l) {
    return l instanceof Ml;
  }
  class Wn extends Wr {
    constructor(n) {
      super(n), this.__last = this.__first = null, this.__indent = this.__format = this.__size = 0, this.__dir = null;
    }
    getFormat() {
      return this.getLatest().__format;
    }
    getFormatType() {
      let n = this.getFormat();
      return Le[n] || "";
    }
    getIndent() {
      return this.getLatest().__indent;
    }
    getChildren() {
      let n = [], s = this.getFirstChild();
      for (; s !== null; )
        n.push(s), s = s.getNextSibling();
      return n;
    }
    getChildrenKeys() {
      let n = [], s = this.getFirstChild();
      for (; s !== null; )
        n.push(s.__key), s = s.getNextSibling();
      return n;
    }
    getChildrenSize() {
      return this.getLatest().__size;
    }
    isEmpty() {
      return this.getChildrenSize() === 0;
    }
    isDirty() {
      let n = Xt()._dirtyElements;
      return n !== null && n.has(this.__key);
    }
    isLastChild() {
      let n = this.getLatest(), s = this.getParentOrThrow().getLastChild();
      return s !== null && s.is(n);
    }
    getAllTextNodes() {
      let n = [], s = this.getFirstChild();
      for (; s !== null; ) {
        if (ut(s) && n.push(s), Je(s)) {
          let d = s.getAllTextNodes();
          n.push(...d);
        }
        s = s.getNextSibling();
      }
      return n;
    }
    getFirstDescendant() {
      let n = this.getFirstChild();
      for (; n !== null; ) {
        if (Je(n)) {
          let s = n.getFirstChild();
          if (s !== null) {
            n = s;
            continue;
          }
        }
        break;
      }
      return n;
    }
    getLastDescendant() {
      let n = this.getLastChild();
      for (; n !== null; ) {
        if (Je(n)) {
          let s = n.getLastChild();
          if (s !== null) {
            n = s;
            continue;
          }
        }
        break;
      }
      return n;
    }
    getDescendantByIndex(n) {
      let s = this.getChildren(), d = s.length;
      return n >= d ? (n = s[d - 1], Je(n) && n.getLastDescendant() || n || null) : (n = s[n], Je(n) && n.getFirstDescendant() || n || null);
    }
    getFirstChild() {
      let n = this.getLatest().__first;
      return n === null ? null : bt(n);
    }
    getFirstChildOrThrow() {
      let n = this.getFirstChild();
      return n === null && Y(45, this.__key), n;
    }
    getLastChild() {
      let n = this.getLatest().__last;
      return n === null ? null : bt(n);
    }
    getLastChildOrThrow() {
      let n = this.getLastChild();
      return n === null && Y(96, this.__key), n;
    }
    getChildAtIndex(n) {
      var s = this.getChildrenSize();
      let d;
      if (n < s / 2) {
        for (d = this.getFirstChild(), s = 0; d !== null && s <= n; ) {
          if (s === n)
            return d;
          d = d.getNextSibling(), s++;
        }
        return null;
      }
      for (d = this.getLastChild(), --s; d !== null && s >= n; ) {
        if (s === n)
          return d;
        d = d.getPreviousSibling(), s--;
      }
      return null;
    }
    getTextContent() {
      let n = "", s = this.getChildren(), d = s.length;
      for (let m = 0; m < d; m++) {
        let E = s[m];
        n += E.getTextContent(), Je(E) && m !== d - 1 && !E.isInline() && (n += `

`);
      }
      return n;
    }
    getTextContentSize() {
      let n = 0, s = this.getChildren(), d = s.length;
      for (let m = 0; m < d; m++) {
        let E = s[m];
        n += E.getTextContentSize(), Je(E) && m !== d - 1 && !E.isInline() && (n += 2);
      }
      return n;
    }
    getDirection() {
      return this.getLatest().__dir;
    }
    hasFormat(n) {
      return n !== "" ? (n = we[n], (this.getFormat() & n) !== 0) : !1;
    }
    select(n, s) {
      Un();
      let d = Wt(), m = n, E = s;
      var R = this.getChildrenSize();
      if (!this.canBeEmpty()) {
        if (n === 0 && s === 0) {
          if (n = this.getFirstChild(), ut(n) || Je(n))
            return n.select(0, 0);
        } else if (!(n !== void 0 && n !== R || s !== void 0 && s !== R) && (n = this.getLastChild(), ut(n) || Je(n)))
          return n.select();
      }
      if (m === void 0 && (m = R), E === void 0 && (E = R), R = this.__key, vt(d))
        d.anchor.set(R, m, "element"), d.focus.set(R, E, "element"), d.dirty = !0;
      else
        return $n(R, m, R, E, "element", "element");
      return d;
    }
    selectStart() {
      let n = this.getFirstDescendant();
      return n ? n.selectStart() : this.select();
    }
    selectEnd() {
      let n = this.getLastDescendant();
      return n ? n.selectEnd() : this.select();
    }
    clear() {
      let n = this.getWritable();
      return this.getChildren().forEach((s) => s.remove()), n;
    }
    append(...n) {
      return this.splice(
        this.getChildrenSize(),
        0,
        n
      );
    }
    setDirection(n) {
      let s = this.getWritable();
      return s.__dir = n, s;
    }
    setFormat(n) {
      return this.getWritable().__format = n !== "" ? we[n] : 0, this;
    }
    setIndent(n) {
      return this.getWritable().__indent = n, this;
    }
    splice(n, s, d) {
      let m = d.length, E = this.getChildrenSize(), R = this.getWritable(), X = R.__key;
      var _e = [], Se = [];
      let Fe = this.getChildAtIndex(n + s), Ue = null, Pe = E - s + m;
      if (n !== 0)
        if (n === E)
          Ue = this.getLastChild();
        else {
          var De = this.getChildAtIndex(n);
          De !== null && (Ue = De.getPreviousSibling());
        }
      if (0 < s) {
        var Xe = Ue === null ? this.getFirstChild() : Ue.getNextSibling();
        for (De = 0; De < s; De++) {
          Xe === null && Y(100);
          var lt = Xe.getNextSibling(), Nt = Xe.__key;
          Xe = Xe.getWritable(), Et(Xe), Se.push(Nt), Xe = lt;
        }
      }
      for (De = Ue, lt = 0; lt < m; lt++) {
        Nt = d[lt], De !== null && Nt.is(De) && (Ue = De = De.getPreviousSibling()), Xe = Nt.getWritable(), Xe.__parent === X && Pe--, Et(Xe);
        let Ot = Nt.__key;
        De === null ? (R.__first = Ot, Xe.__prev = null) : (De = De.getWritable(), De.__next = Ot, Xe.__prev = De.__key), Nt.__key === X && Y(76), Xe.__parent = X, _e.push(Ot), De = Nt;
      }
      if (n + s === E ? De !== null && (De.getWritable().__next = null, R.__last = De.__key) : Fe !== null && (n = Fe.getWritable(), De !== null ? (s = De.getWritable(), n.__prev = De.__key, s.__next = Fe.__key) : n.__prev = null), R.__size = Pe, Se.length && (n = Wt(), vt(n))) {
        Se = new Set(Se), _e = new Set(_e);
        let { anchor: Ot, focus: sn } = n;
        os(Ot, Se, _e) && Vi(Ot, Ot.getNode(), this, Ue, Fe), os(sn, Se, _e) && Vi(sn, sn.getNode(), this, Ue, Fe), Pe !== 0 || this.canBeEmpty() || Br(this) || this.remove();
      }
      return R;
    }
    exportJSON() {
      return { children: [], direction: this.getDirection(), format: this.getFormatType(), indent: this.getIndent(), type: "element", version: 1 };
    }
    insertNewAfter() {
      return null;
    }
    canIndent() {
      return !0;
    }
    collapseAtStart() {
      return !1;
    }
    excludeFromCopy() {
      return !1;
    }
    canExtractContents() {
      return !0;
    }
    canReplaceWith() {
      return !0;
    }
    canInsertAfter() {
      return !0;
    }
    canBeEmpty() {
      return !0;
    }
    canInsertTextBefore() {
      return !0;
    }
    canInsertTextAfter() {
      return !0;
    }
    isInline() {
      return !1;
    }
    isShadowRoot() {
      return !1;
    }
    canMergeWith() {
      return !1;
    }
    extractWithChild() {
      return !1;
    }
  }
  function Je(l) {
    return l instanceof Wn;
  }
  function os(l, n, s) {
    for (l = l.getNode(); l; ) {
      let d = l.__key;
      if (n.has(d) && !s.has(d))
        return !0;
      l = l.getParent();
    }
    return !1;
  }
  class Dr extends Wn {
    static getType() {
      return "root";
    }
    static clone() {
      return new Dr();
    }
    constructor() {
      super("root"), this.__cachedText = null;
    }
    getTopLevelElementOrThrow() {
      Y(51);
    }
    getTextContent() {
      let n = this.__cachedText;
      return !Yr() && Xt()._dirtyType !== 0 || n === null ? super.getTextContent() : n;
    }
    remove() {
      Y(52);
    }
    replace() {
      Y(53);
    }
    insertBefore() {
      Y(54);
    }
    insertAfter() {
      Y(55);
    }
    updateDOM() {
      return !1;
    }
    append(...n) {
      for (let s = 0; s < n.length; s++) {
        let d = n[s];
        Je(d) || Qt(d) || Y(56);
      }
      return super.append(...n);
    }
    static importJSON(n) {
      let s = on();
      return s.setFormat(n.format), s.setIndent(n.indent), s.setDirection(n.direction), s;
    }
    exportJSON() {
      return { children: [], direction: this.getDirection(), format: this.getFormatType(), indent: this.getIndent(), type: "root", version: 1 };
    }
    collapseAtStart() {
      return !0;
    }
  }
  function Yn(l) {
    return l instanceof Dr;
  }
  function Ll(l, n) {
    if (n = n.getEditorState()._selection, l = l._selection, l !== null) {
      if (l.dirty || !l.is(n))
        return !0;
    } else if (n !== null)
      return !0;
    return !1;
  }
  function li() {
    return new eo(/* @__PURE__ */ new Map([["root", new Dr()]]));
  }
  function Qi(l) {
    let n = l.exportJSON();
    var s = l.constructor;
    n.type !== s.getType() && Y(130, s.name);
    let d = n.children;
    if (Je(l))
      for (Array.isArray(d) || Y(59, s.name), l = l.getChildren(), s = 0; s < l.length; s++) {
        let m = Qi(l[s]);
        d.push(m);
      }
    return n;
  }
  class eo {
    constructor(n, s) {
      this._nodeMap = n, this._selection = s || null, this._readOnly = this._flushSync = !1;
    }
    isEmpty() {
      return this._nodeMap.size === 1 && this._selection === null;
    }
    read(n) {
      return Al(this, n);
    }
    clone(n) {
      return n = new eo(this._nodeMap, n === void 0 ? this._selection : n), n._readOnly = !0, n;
    }
    toJSON() {
      return Al(this, () => ({ root: Qi(on()) }));
    }
  }
  class ai extends Wn {
    static getType() {
      return "paragraph";
    }
    static clone(n) {
      return new ai(n.__key);
    }
    createDOM(n) {
      let s = document.createElement("p");
      return n = Ft(n.theme, "paragraph"), n !== void 0 && s.classList.add(...n), s;
    }
    updateDOM() {
      return !1;
    }
    static importDOM() {
      return { p: () => ({ conversion: wo, priority: 0 }) };
    }
    exportDOM(n) {
      if ({ element: n } = super.exportDOM(n), n && Bi(n)) {
        this.isEmpty() && n.append(document.createElement("br"));
        var s = this.getFormatType();
        n.style.textAlign = s, (s = this.getDirection()) && (n.dir = s), s = this.getIndent(), 0 < s && (n.style.textIndent = `${20 * s}px`);
      }
      return { element: n };
    }
    static importJSON(n) {
      let s = Zn();
      return s.setFormat(n.format), s.setIndent(n.indent), s.setDirection(n.direction), s;
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "paragraph", version: 1 };
    }
    insertNewAfter(n, s) {
      n = Zn();
      let d = this.getDirection();
      return n.setDirection(d), this.insertAfter(n, s), n;
    }
    collapseAtStart() {
      let n = this.getChildren();
      if (n.length === 0 || ut(n[0]) && n[0].getTextContent().trim() === "") {
        if (this.getNextSibling() !== null)
          return this.selectNext(), this.remove(), !0;
        if (this.getPreviousSibling() !== null)
          return this.selectPrevious(), this.remove(), !0;
      }
      return !1;
    }
  }
  function wo(l) {
    let n = Zn();
    return l.style && (n.setFormat(l.style.textAlign), l = parseInt(l.style.textIndent, 10) / 20, 0 < l && n.setIndent(l)), { node: n };
  }
  function Zn() {
    return Ni(new ai());
  }
  function zs(l, n, s, d) {
    let m = l._keyToDOMMap;
    m.clear(), l._editorState = li(), l._pendingEditorState = d, l._compositionKey = null, l._dirtyType = 0, l._cloneNotNeeded.clear(), l._dirtyLeaves = /* @__PURE__ */ new Set(), l._dirtyElements.clear(), l._normalizedNodes = /* @__PURE__ */ new Set(), l._updateTags = /* @__PURE__ */ new Set(), l._updates = [], l._blockCursorElement = null, d = l._observer, d !== null && (d.disconnect(), l._observer = null), n !== null && (n.textContent = ""), s !== null && (s.textContent = "", m.set("root", s));
  }
  function Pl(l, n) {
    let s = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ new Set(), m = (E) => {
      Object.keys(E).forEach((R) => {
        let X = s.get(R);
        X === void 0 && (X = [], s.set(R, X)), X.push(E[R]);
      });
    };
    return l.forEach((E) => {
      E = E.klass.importDOM != null ? E.klass.importDOM.bind(E.klass) : null, E == null || d.has(E) || (d.add(E), E = E(), E !== null && m(E));
    }), n && m(n), s;
  }
  class Il {
    constructor(n, s, d, m, E, R, X) {
      this._parentEditor = s, this._rootElement = null, this._editorState = n, this._compositionKey = this._pendingEditorState = null, this._deferred = [], this._keyToDOMMap = /* @__PURE__ */ new Map(), this._updates = [], this._updating = !1, this._listeners = { decorator: /* @__PURE__ */ new Set(), editable: /* @__PURE__ */ new Set(), mutation: /* @__PURE__ */ new Map(), root: /* @__PURE__ */ new Set(), textcontent: /* @__PURE__ */ new Set(), update: /* @__PURE__ */ new Set() }, this._commands = /* @__PURE__ */ new Map(), this._config = m, this._nodes = d, this._decorators = {}, this._pendingDecorators = null, this._dirtyType = 0, this._cloneNotNeeded = /* @__PURE__ */ new Set(), this._dirtyLeaves = /* @__PURE__ */ new Set(), this._dirtyElements = /* @__PURE__ */ new Map(), this._normalizedNodes = /* @__PURE__ */ new Set(), this._updateTags = /* @__PURE__ */ new Set(), this._observer = null, this._key = Ge(), this._onError = E, this._htmlConversions = R, this._editable = X, this._headless = s !== null && s._headless, this._blockCursorElement = this._window = null;
    }
    isComposing() {
      return this._compositionKey != null;
    }
    registerUpdateListener(n) {
      let s = this._listeners.update;
      return s.add(n), () => {
        s.delete(n);
      };
    }
    registerEditableListener(n) {
      let s = this._listeners.editable;
      return s.add(n), () => {
        s.delete(n);
      };
    }
    registerDecoratorListener(n) {
      let s = this._listeners.decorator;
      return s.add(n), () => {
        s.delete(n);
      };
    }
    registerTextContentListener(n) {
      let s = this._listeners.textcontent;
      return s.add(n), () => {
        s.delete(n);
      };
    }
    registerRootListener(n) {
      let s = this._listeners.root;
      return n(this._rootElement, null), s.add(n), () => {
        n(null, this._rootElement), s.delete(n);
      };
    }
    registerCommand(n, s, d) {
      d === void 0 && Y(35);
      let m = this._commands;
      m.has(n) || m.set(n, [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()]);
      let E = m.get(n);
      E === void 0 && Y(36, String(n));
      let R = E[d];
      return R.add(s), () => {
        R.delete(s), E.every((X) => X.size === 0) && m.delete(n);
      };
    }
    registerMutationListener(n, s) {
      this._nodes.get(n.getType()) === void 0 && Y(37, n.name);
      let d = this._listeners.mutation;
      return d.set(s, n), () => {
        d.delete(s);
      };
    }
    registerNodeTransformToKlass(n, s) {
      var d = n.getType();
      return d = this._nodes.get(d), d === void 0 && Y(37, n.name), d.transforms.add(s), d;
    }
    registerNodeTransform(n, s) {
      var d = this.registerNodeTransformToKlass(n, s);
      let m = [d];
      return d = d.replaceWithKlass, d != null && (d = this.registerNodeTransformToKlass(d, s), m.push(d)), Uo(this, n.getType()), () => {
        m.forEach((E) => E.transforms.delete(s));
      };
    }
    hasNode(n) {
      return this._nodes.has(n.getType());
    }
    hasNodes(n) {
      return n.every(this.hasNode.bind(this));
    }
    dispatchCommand(n, s) {
      return rt(this, n, s);
    }
    getDecorators() {
      return this._decorators;
    }
    getRootElement() {
      return this._rootElement;
    }
    getKey() {
      return this._key;
    }
    setRootElement(n) {
      let s = this._rootElement;
      if (n !== s) {
        let R = Ft(this._config.theme, "root");
        var d = this._pendingEditorState || this._editorState;
        if (this._rootElement = n, zs(this, s, n, d), s !== null) {
          if (!this._config.disableEvents) {
            go !== 0 && (go--, go === 0 && s.ownerDocument.removeEventListener("selectionchange", Tl));
            var m = s.__lexicalEditor;
            if (m != null) {
              if (m._parentEditor !== null) {
                var E = ye(m);
                E = E[E.length - 1]._key, zi.get(E) === m && zi.delete(E);
              } else
                zi.delete(m._key);
              s.__lexicalEditor = null;
            }
            for (m = El(s), E = 0; E < m.length; E++)
              m[E]();
            s.__lexicalEventHandles = [];
          }
          R != null && s.classList.remove(...R);
        }
        n !== null ? (d = (d = n.ownerDocument) && d.defaultView || null, m = n.style, m.userSelect = "text", m.whiteSpace = "pre-wrap", m.wordBreak = "break-word", n.setAttribute(
          "data-lexical-editor",
          "true"
        ), this._window = d, this._dirtyType = 2, be(this), this._updateTags.add("history-merge"), Cr(this), this._config.disableEvents || ma(n, this), R != null && n.classList.add(...R)) : (this._editorState = d, this._window = this._pendingEditorState = null), Xi("root", this, !1, n, s);
      }
    }
    getElementByKey(n) {
      return this._keyToDOMMap.get(n) || null;
    }
    getEditorState() {
      return this._editorState;
    }
    setEditorState(n, s) {
      n.isEmpty() && Y(38), Oe(this);
      let d = this._pendingEditorState, m = this._updateTags;
      s = s !== void 0 ? s.tag : null, d === null || d.isEmpty() || (s != null && m.add(s), Cr(this)), this._pendingEditorState = n, this._dirtyType = 2, this._dirtyElements.set("root", !1), this._compositionKey = null, s != null && m.add(s), Cr(this);
    }
    parseEditorState(n, s) {
      n = typeof n == "string" ? JSON.parse(n) : n;
      let d = li(), m = dn, E = mn, R = _n, X = this._dirtyElements, _e = this._dirtyLeaves, Se = this._cloneNotNeeded, Fe = this._dirtyType;
      this._dirtyElements = /* @__PURE__ */ new Map(), this._dirtyLeaves = /* @__PURE__ */ new Set(), this._cloneNotNeeded = /* @__PURE__ */ new Set(), this._dirtyType = 0, dn = d, mn = !1, _n = this;
      try {
        Zi(n.root, this._nodes), s && s(), d._readOnly = !0;
      } catch (Ue) {
        Ue instanceof Error && this._onError(Ue);
      } finally {
        this._dirtyElements = X, this._dirtyLeaves = _e, this._cloneNotNeeded = Se, this._dirtyType = Fe, dn = m, mn = E, _n = R;
      }
      return d;
    }
    update(n, s) {
      Jn(this, n, s);
    }
    focus(n, s = {}) {
      let d = this._rootElement;
      d !== null && (d.setAttribute("autocapitalize", "off"), Jn(this, () => {
        let m = Wt(), E = on();
        m !== null ? m.dirty = !0 : E.getChildrenSize() !== 0 && (s.defaultSelection === "rootStart" ? E.selectStart() : E.selectEnd());
      }, { onUpdate: () => {
        d.removeAttribute("autocapitalize"), n && n();
      }, tag: "focus" }), this._pendingEditorState === null && d.removeAttribute("autocapitalize"));
    }
    blur() {
      var n = this._rootElement;
      n !== null && n.blur(), n = xr(this._window), n !== null && n.removeAllRanges();
    }
    isEditable() {
      return this._editable;
    }
    setEditable(n) {
      this._editable !== n && (this._editable = n, Xi("editable", this, !0, n));
    }
    toJSON() {
      return { editorState: this._editorState.toJSON() };
    }
  }
  class ss extends Wn {
    constructor(n, s) {
      super(s), this.__colSpan = n, this.__rowSpan = 1;
    }
    exportJSON() {
      return { ...super.exportJSON(), colSpan: this.__colSpan, rowSpan: this.__rowSpan };
    }
    getColSpan() {
      return this.__colSpan;
    }
    setColSpan(n) {
      return this.getWritable().__colSpan = n, this;
    }
    getRowSpan() {
      return this.__rowSpan;
    }
    setRowSpan(n) {
      return this.getWritable().__rowSpan = n, this;
    }
  }
  function ar(l) {
    return l instanceof ss;
  }
  class kl extends Wn {
  }
  function ls(l) {
    return l instanceof kl;
  }
  class $l extends Wn {
  }
  function Oo(l) {
    return l instanceof $l;
  }
  return ke.$INTERNAL_isPointSelection = Bs, ke.$addUpdateTag = function(l) {
    Un(), Xt()._updateTags.add(l);
  }, ke.$applyNodeReplacement = Ni, ke.$copyNode = vs, ke.$createLineBreakNode = wr, ke.$createNodeSelection = yr, ke.$createParagraphNode = Zn, ke.$createRangeSelection = function() {
    let l = new mr("root", 0, "element"), n = new mr("root", 0, "element");
    return new xi(l, n, 0, "");
  }, ke.$createTabNode = Ti, ke.$createTextNode = An, ke.$getAdjacentNode = cn, ke.$getNearestNodeFromDOMNode = gr, ke.$getNearestRootOrShadowRoot = xs, ke.$getNodeByKey = bt, ke.$getPreviousSelection = Si, ke.$getRoot = on, ke.$getSelection = Wt, ke.$getTextContent = function() {
    let l = Wt();
    return l === null ? "" : l.getTextContent();
  }, ke.$hasAncestor = Xr, ke.$hasUpdateTag = function(l) {
    return Xt()._updateTags.has(l);
  }, ke.$insertNodes = function(l) {
    let n = Wt() || Si();
    n === null && (n = on().selectEnd()), n.insertNodes(l);
  }, ke.$isBlockElementNode = function(l) {
    return Je(l) && !l.isInline();
  }, ke.$isDecoratorNode = Qt, ke.$isElementNode = Je, ke.$isInlineElementOrDecoratorNode = function(l) {
    return Je(l) && l.isInline() || Qt(l) && l.isInline();
  }, ke.$isLeafNode = function(l) {
    return ut(l) || ri(l) || Qt(l);
  }, ke.$isLineBreakNode = ri, ke.$isNodeSelection = Eo, ke.$isParagraphNode = function(l) {
    return l instanceof ai;
  }, ke.$isRangeSelection = vt, ke.$isRootNode = Yn, ke.$isRootOrShadowRoot = Br, ke.$isTabNode = wl, ke.$isTextNode = ut, ke.$nodesOfType = function(l) {
    var n = lr();
    let s = n._readOnly, d = l.getType();
    n = n._nodeMap;
    let m = [];
    for (let [, E] of n)
      E instanceof l && E.__type === d && (s || E.isAttached()) && m.push(E);
    return m;
  }, ke.$normalizeSelection__EXPERIMENTAL = Qe, ke.$parseSerializedNode = function(l) {
    return Zi(l, Xt()._nodes);
  }, ke.$selectAll = function() {
    var l = on();
    l = l.select(0, l.getChildrenSize()), rr(Qe(l));
  }, ke.$setCompositionKey = Dt, ke.$setSelection = rr, ke.$splitNode = function(l, n) {
    let s = l.getChildAtIndex(n);
    s == null && (s = l), Br(l) && Y(102);
    let d = (R) => {
      const X = R.getParentOrThrow(), _e = Br(X), Se = R !== s || _e ? vs(R) : R;
      if (_e)
        return R.insertAfter(Se), [R, Se, Se];
      const [Fe, Ue, Pe] = d(X);
      return R = R.getNextSiblings(), Pe.append(Se, ...R), [Fe, Ue, Se];
    }, [m, E] = d(s);
    return [m, E];
  }, ke.BLUR_COMMAND = j, ke.CAN_REDO_COMMAND = {}, ke.CAN_UNDO_COMMAND = {}, ke.CLEAR_EDITOR_COMMAND = {}, ke.CLEAR_HISTORY_COMMAND = {}, ke.CLICK_COMMAND = t, ke.COMMAND_PRIORITY_CRITICAL = 4, ke.COMMAND_PRIORITY_EDITOR = 0, ke.COMMAND_PRIORITY_HIGH = 3, ke.COMMAND_PRIORITY_LOW = 1, ke.COMMAND_PRIORITY_NORMAL = 2, ke.CONTROLLED_TEXT_INSERTION_COMMAND = h, ke.COPY_COMMAND = Z, ke.CUT_COMMAND = ee, ke.DELETE_CHARACTER_COMMAND = r, ke.DELETE_LINE_COMMAND = S, ke.DELETE_WORD_COMMAND = O, ke.DEPRECATED_$computeGridMap = si, ke.DEPRECATED_$createGridSelection = function() {
    let l = new mr("root", 0, "element"), n = new mr("root", 0, "element");
    return new es("root", l, n);
  }, ke.DEPRECATED_$getGridCellNodeRect = sr, ke.DEPRECATED_$getNodeTriplet = Gr, ke.DEPRECATED_$isGridCellNode = ar, ke.DEPRECATED_$isGridNode = ls, ke.DEPRECATED_$isGridRowNode = Oo, ke.DEPRECATED_$isGridSelection = No, ke.DEPRECATED_GridCellNode = ss, ke.DEPRECATED_GridNode = kl, ke.DEPRECATED_GridRowNode = $l, ke.DRAGEND_COMMAND = pe, ke.DRAGOVER_COMMAND = me, ke.DRAGSTART_COMMAND = q, ke.DROP_COMMAND = G, ke.DecoratorNode = Ml, ke.ElementNode = Wn, ke.FOCUS_COMMAND = w, ke.FORMAT_ELEMENT_COMMAND = {}, ke.FORMAT_TEXT_COMMAND = x, ke.INDENT_CONTENT_COMMAND = {}, ke.INSERT_LINE_BREAK_COMMAND = o, ke.INSERT_PARAGRAPH_COMMAND = f, ke.INSERT_TAB_COMMAND = {}, ke.KEY_ARROW_DOWN_COMMAND = K, ke.KEY_ARROW_LEFT_COMMAND = F, ke.KEY_ARROW_RIGHT_COMMAND = N, ke.KEY_ARROW_UP_COMMAND = I, ke.KEY_BACKSPACE_COMMAND = te, ke.KEY_DELETE_COMMAND = de, ke.KEY_DOWN_COMMAND = H, ke.KEY_ENTER_COMMAND = B, ke.KEY_ESCAPE_COMMAND = re, ke.KEY_MODIFIER_COMMAND = ne, ke.KEY_SPACE_COMMAND = z, ke.KEY_TAB_COMMAND = V, ke.LineBreakNode = Sr, ke.MOVE_TO_END = v, ke.MOVE_TO_START = U, ke.OUTDENT_CONTENT_COMMAND = {}, ke.PASTE_COMMAND = C, ke.ParagraphNode = ai, ke.REDO_COMMAND = k, ke.REMOVE_TEXT_COMMAND = T, ke.RootNode = Dr, ke.SELECTION_CHANGE_COMMAND = e, ke.SELECT_ALL_COMMAND = P, ke.TabNode = Gi, ke.TextNode = zr, ke.UNDO_COMMAND = D, ke.createCommand = function() {
    return {};
  }, ke.createEditor = function(l) {
    var n = l || {}, s = _n, d = n.theme || {};
    let m = l === void 0 ? s : n.parentEditor || null, E = n.disableEvents || !1, R = li(), X = n.namespace || (m !== null ? m._config.namespace : Ge()), _e = n.editorState, Se = [Dr, zr, Sr, Gi, ai, ...n.nodes || []], { onError: Fe, html: Ue } = n;
    if (n = n.editable !== void 0 ? n.editable : !0, l === void 0 && s !== null)
      l = s._nodes;
    else
      for (l = /* @__PURE__ */ new Map(), s = 0; s < Se.length; s++) {
        let De = Se[s], Xe = null;
        var Pe = null;
        typeof De != "function" && (Pe = De, De = Pe.replace, Xe = Pe.with, Pe = Pe.withKlass || null);
        let lt = De.getType(), Nt = De.transform(), Ot = /* @__PURE__ */ new Set();
        Nt !== null && Ot.add(Nt), l.set(lt, { exportDOM: Ue && Ue.export ? Ue.export.get(De) : void 0, klass: De, replace: Xe, replaceWithKlass: Pe, transforms: Ot });
      }
    return d = new Il(R, m, l, { disableEvents: E, namespace: X, theme: d }, Fe || console.error, Pl(l, Ue ? Ue.import : void 0), n), _e !== void 0 && (d._pendingEditorState = _e, d._dirtyType = 2), d;
  }, ke.getNearestEditorFromDOMNode = gt, ke.isHTMLAnchorElement = function(l) {
    return Bi(l) && l.tagName === "A";
  }, ke.isHTMLElement = Bi, ke.isSelectionCapturedInDecoratorInput = qe, ke.isSelectionWithinEditor = nt, ke;
}
var $e = {}, Bu;
function Wp() {
  if (Bu)
    return $e;
  Bu = 1;
  function e(c) {
    return {
      type: c
    };
  }
  const t = e("SELECTION_CHANGE_COMMAND"), r = e("CLICK_COMMAND"), o = e("DELETE_CHARACTER_COMMAND"), f = e("INSERT_LINE_BREAK_COMMAND"), h = e("INSERT_PARAGRAPH_COMMAND"), C = e("CONTROLLED_TEXT_INSERTION_COMMAND"), T = e("PASTE_COMMAND"), O = e("REMOVE_TEXT_COMMAND"), S = e("DELETE_WORD_COMMAND"), x = e("DELETE_LINE_COMMAND"), D = e("FORMAT_TEXT_COMMAND"), k = e("UNDO_COMMAND"), H = e("REDO_COMMAND"), N = e("KEYDOWN_COMMAND"), v = e("KEY_ARROW_RIGHT_COMMAND"), F = e("MOVE_TO_END"), U = e("KEY_ARROW_LEFT_COMMAND"), I = e("MOVE_TO_START"), K = e("KEY_ARROW_UP_COMMAND"), B = e("KEY_ARROW_DOWN_COMMAND"), z = e("KEY_ENTER_COMMAND"), te = e("KEY_SPACE_COMMAND"), re = e("KEY_BACKSPACE_COMMAND"), de = e("KEY_ESCAPE_COMMAND"), V = e("KEY_DELETE_COMMAND"), G = e("KEY_TAB_COMMAND"), q = e("INSERT_TAB_COMMAND"), me = e("INDENT_CONTENT_COMMAND"), pe = e("OUTDENT_CONTENT_COMMAND"), Z = e("DROP_COMMAND"), ee = e("FORMAT_ELEMENT_COMMAND"), P = e("DRAGSTART_COMMAND"), w = e("DRAGOVER_COMMAND"), j = e("DRAGEND_COMMAND"), ne = e("COPY_COMMAND"), Y = e("CUT_COMMAND"), W = e("SELECT_ALL_COMMAND"), Q = e("CLEAR_EDITOR_COMMAND"), b = e("CLEAR_HISTORY_COMMAND"), g = e("CAN_REDO_COMMAND"), _ = e("CAN_UNDO_COMMAND"), A = e("FOCUS_COMMAND"), J = e("BLUR_COMMAND"), ce = e("KEY_MODIFIER_COMMAND"), ge = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", ae = ge && "documentMode" in document ? document.documentMode : null, Te = ge && /Mac|iPod|iPhone|iPad/.test(navigator.platform), Me = ge && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), ze = ge && "InputEvent" in window && !ae ? "getTargetRanges" in new window.InputEvent("input") : !1, oe = ge && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), ie = ge && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, ue = ge && /Android/.test(navigator.userAgent), we = ge && /^(?=.*Chrome).*/i.test(navigator.userAgent), Le = ge && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !we, Be = 1, Ye = 3, st = 0, pt = 1, at = 2, ve = 0, se = 1, he = 2, Oe = 1, be = 2, Re = 4, He = 8, Ve = 16, Qe = 32, ct = 64, At = 128, je = Oe | be | Re | He | Ve | Qe | ct | At, qe = 1, nt = 2, gt = 1, Ct = 2, xt = 3, St = 4, wt = 5, Et = 6, Yt = " ", Kt = oe || ie || Le ? Yt : "​", bt = `

`, nr = Me ? Yt : Kt, gr = "֑-߿יִ-﷽ﹰ-ﻼ", Ci = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿", Ho = new RegExp("^[^" + Ci + "]*[" + gr + "]"), Uo = new RegExp("^[^" + gr + "]*[" + Ci + "]"), on = {
    bold: Oe,
    code: Ve,
    highlight: At,
    italic: be,
    strikethrough: Re,
    subscript: Qe,
    superscript: ct,
    underline: He
  }, rr = {
    directionless: qe,
    unmergeable: nt
  }, Fr = {
    center: Ct,
    end: Et,
    justify: St,
    left: gt,
    right: xt,
    start: wt
  }, Wo = {
    [Ct]: "center",
    [Et]: "end",
    [St]: "justify",
    [gt]: "left",
    [xt]: "right",
    [wt]: "start"
  }, ye = {
    normal: ve,
    segmented: he,
    token: se
  }, Ge = {
    [ve]: "normal",
    [he]: "segmented",
    [se]: "token"
  }, et = 100;
  let _t = !1, It = 0;
  function Ft() {
    return _t;
  }
  function Lt(c) {
    It = c.timeStamp;
  }
  function Mt(c) {
    It === 0 && Ti(c).addEventListener("textInput", Lt, !0);
  }
  function cn(c, i, a) {
    return (
      // @ts-expect-error: internal field
      i.__lexicalLineBreak === c || // @ts-ignore We intentionally add this to the Node.
      c[`__lexicalKey_${a._key}`] !== void 0
    );
  }
  function Zt(c) {
    return c.getEditorState().read(() => {
      const i = en();
      return i !== null ? i.clone() : null;
    });
  }
  function jt(c, i, a) {
    const u = sr(a._window);
    let p = null, y = null;
    u !== null && u.anchorNode === c && (p = u.anchorOffset, y = u.focusOffset);
    const M = c.nodeValue;
    M !== null && fo(i, M, p, y, !1);
  }
  function Rn(c, i, a) {
    if (ft(c)) {
      const u = c.anchor.getNode();
      if (u.is(a) && c.format !== u.getFormat())
        return !1;
    }
    return i.nodeType === Ye && a.isAttached();
  }
  function ir(c, i, a) {
    _t = !0;
    const u = performance.now() - It > et;
    try {
      Nr(c, () => {
        const p = en() || Zt(c), y = /* @__PURE__ */ new Map(), M = c.getRootElement(), $ = c._editorState, le = c._blockCursorElement;
        let fe = !1, Ce = "";
        for (let xe = 0; xe < i.length; xe++) {
          const Ne = i[xe], Ke = Ne.type, Ie = Ne.target;
          let Ae = or(Ie, $);
          if (!(Ae === null && Ie !== M || yn(Ae))) {
            if (Ke === "characterData")
              u && dt(Ae) && Rn(p, Ie, Ae) && jt(
                // nodeType === DOM_TEXT_TYPE is a Text DOM node
                Ie,
                Ae,
                c
              );
            else if (Ke === "childList") {
              fe = !0;
              const ht = Ne.addedNodes;
              for (let Pt = 0; Pt < ht.length; Pt++) {
                const Rt = ht[Pt], mt = ti(Rt), Tt = Rt.parentNode;
                if (Tt != null && Rt !== le && mt === null && (Rt.nodeName !== "BR" || !cn(Rt, Tt, c))) {
                  if (Me) {
                    const $t = Rt.innerText || Rt.nodeValue;
                    $t && (Ce += $t);
                  }
                  Tt.removeChild(Rt);
                }
              }
              const We = Ne.removedNodes, tt = We.length;
              if (tt > 0) {
                let Pt = 0;
                for (let Rt = 0; Rt < tt; Rt++) {
                  const mt = We[Rt];
                  (mt.nodeName === "BR" && cn(mt, Ie, c) || le === mt) && (Ie.appendChild(mt), Pt++);
                }
                tt !== Pt && (Ie === M && (Ae = ni($)), y.set(Ie, Ae));
              }
            }
          }
        }
        if (y.size > 0)
          for (const [xe, Ne] of y)
            if (Ze(Ne)) {
              const Ke = Ne.getChildrenKeys();
              let Ie = xe.firstChild;
              for (let Ae = 0; Ae < Ke.length; Ae++) {
                const ht = Ke[Ae], We = c.getElementByKey(ht);
                We !== null && (Ie == null ? (xe.appendChild(We), Ie = We) : Ie !== We && xe.replaceChild(We, Ie), Ie = Ie.nextSibling);
              }
            } else
              dt(Ne) && Ne.markDirty();
        const Ee = a.takeRecords();
        if (Ee.length > 0) {
          for (let xe = 0; xe < Ee.length; xe++) {
            const Ne = Ee[xe], Ke = Ne.addedNodes, Ie = Ne.target;
            for (let Ae = 0; Ae < Ke.length; Ae++) {
              const ht = Ke[Ae], We = ht.parentNode;
              We != null && ht.nodeName === "BR" && !cn(ht, Ie, c) && We.removeChild(ht);
            }
          }
          a.takeRecords();
        }
        p !== null && (fe && (p.dirty = !0, _r(p)), Me && vl(c) && p.insertRawText(Ce));
      });
    } finally {
      _t = !1;
    }
  }
  function Xr(c) {
    const i = c._observer;
    if (i !== null) {
      const a = i.takeRecords();
      ir(c, a, i);
    }
  }
  function Kn(c) {
    Mt(c), c._observer = new MutationObserver((i, a) => {
      ir(c, i, a);
    });
  }
  function xs(c, i) {
    const a = c.__mode, u = c.__format, p = c.__style, y = i.__mode, M = i.__format, $ = i.__style;
    return (a === null || a === y) && (u === null || u === M) && (p === null || p === $);
  }
  function Br(c, i) {
    const a = c.mergeWithSibling(i), u = ln()._normalizedNodes;
    return u.add(c.__key), u.add(i.__key), a;
  }
  function vs(c) {
    let i = c;
    if (i.__text === "" && i.isSimpleText() && !i.isUnmergeable()) {
      i.remove();
      return;
    }
    let a;
    for (; (a = i.getPreviousSibling()) !== null && dt(a) && a.isSimpleText() && !a.isUnmergeable(); )
      if (a.__text === "")
        a.remove();
      else if (xs(a, i)) {
        i = Br(a, i);
        break;
      } else
        break;
    let u;
    for (; (u = i.getNextSibling()) !== null && dt(u) && u.isSimpleText() && !u.isUnmergeable(); )
      if (u.__text === "")
        u.remove();
      else if (xs(i, u)) {
        i = Br(i, u);
        break;
      } else
        break;
  }
  function Ni(c) {
    return zo(c.anchor), zo(c.focus), c;
  }
  function zo(c) {
    for (; c.type === "element"; ) {
      const i = c.getNode(), a = c.offset;
      let u, p;
      if (a === i.getChildrenSize() ? (u = i.getChildAtIndex(a - 1), p = !0) : (u = i.getChildAtIndex(a), p = !1), dt(u)) {
        c.set(u.__key, p ? u.getTextContentSize() : 0, "text");
        break;
      } else if (!Ze(u))
        break;
      c.set(u.__key, p ? u.getChildrenSize() : 0, "element");
    }
  }
  let Ss = 1;
  function ws() {
    return "" + Ss++;
  }
  function xr(c, i) {
    const a = c._nodes.get(i);
    if (a === void 0)
      throw Error(`registeredNode: Type ${i} not found`);
    return a;
  }
  const Go = typeof queueMicrotask == "function" ? queueMicrotask : (c) => {
    Promise.resolve().then(c);
  };
  function ua(c) {
    return yn(or(c));
  }
  function Bi(c) {
    const i = document.activeElement;
    if (i === null)
      return !1;
    const a = i.nodeName;
    return yn(or(c)) && (a === "INPUT" || a === "TEXTAREA" || i.contentEditable === "true" && // @ts-ignore iternal field
    i.__lexicalEditor == null);
  }
  function Kr(c, i, a) {
    const u = c.getRootElement();
    try {
      return u !== null && u.contains(i) && u.contains(a) && // Ignore if selection is within nested editor
      i !== null && !Bi(i) && ao(i) === c;
    } catch {
      return !1;
    }
  }
  function ao(c) {
    let i = c;
    for (; i != null; ) {
      const a = i.__lexicalEditor;
      if (a != null)
        return a;
      i = Qo(i);
    }
    return null;
  }
  function cl(c) {
    return Ho.test(c) ? "rtl" : Uo.test(c) ? "ltr" : null;
  }
  function Os(c) {
    return c.isToken() || c.isSegmented();
  }
  function Cn(c) {
    return c.nodeType === Ye;
  }
  function Sn(c) {
    let i = c;
    for (; i != null; ) {
      if (Cn(i))
        return i;
      i = i.firstChild;
    }
    return null;
  }
  function pr(c, i, a) {
    const u = on[i];
    if (a !== null && (c & u) === (a & u))
      return c;
    let p = c ^ u;
    return i === "subscript" ? p &= ~on.superscript : i === "superscript" && (p &= ~on.subscript), p;
  }
  function Qr(c) {
    return dt(c) || ui(c) || yn(c);
  }
  function Dn(c, i) {
    if (i != null) {
      c.__key = i;
      return;
    }
    jn(), lu();
    const a = ln(), u = gi(), p = ws();
    u._nodeMap.set(p, c), Ze(c) ? a._dirtyElements.set(p, !0) : a._dirtyLeaves.add(p), a._cloneNotNeeded.add(p), a._dirtyType = pt, c.__key = p;
  }
  function co(c, i, a) {
    let u = c;
    for (; u !== null; ) {
      if (a.has(u))
        return;
      const p = i.get(u);
      if (p === void 0)
        break;
      a.set(u, !1), u = p.__parent;
    }
  }
  function ei(c) {
    const i = c.getParent();
    if (i !== null) {
      const a = c.getWritable(), u = i.getWritable(), p = c.getPreviousSibling(), y = c.getNextSibling();
      if (p === null)
        if (y !== null) {
          const M = y.getWritable();
          u.__first = y.__key, M.__prev = null;
        } else
          u.__first = null;
      else {
        const M = p.getWritable();
        if (y !== null) {
          const $ = y.getWritable();
          $.__prev = M.__key, M.__next = $.__key;
        } else
          M.__next = null;
        a.__prev = null;
      }
      if (y === null)
        if (p !== null) {
          const M = p.getWritable();
          u.__last = p.__key, M.__next = null;
        } else
          u.__last = null;
      else {
        const M = y.getWritable();
        if (p !== null) {
          const $ = p.getWritable();
          $.__next = M.__key, M.__prev = $.__key;
        } else
          M.__prev = null;
        a.__next = null;
      }
      u.__size--, a.__parent = null;
    }
  }
  function Ki(c) {
    lu();
    const i = c.getLatest(), a = i.__parent, u = gi(), p = ln(), y = u._nodeMap, M = p._dirtyElements;
    a !== null && co(a, y, M);
    const $ = i.__key;
    p._dirtyType = pt, Ze(c) ? M.set($, !0) : p._dirtyLeaves.add($);
  }
  function Yo(c) {
    const i = c.getPreviousSibling(), a = c.getNextSibling();
    i !== null && Ki(i), a !== null && Ki(a);
  }
  function un(c) {
    jn();
    const i = ln(), a = i._compositionKey;
    if (c !== a) {
      if (i._compositionKey = c, a !== null) {
        const u = gn(a);
        u !== null && u.getWritable();
      }
      if (c !== null) {
        const u = gn(c);
        u !== null && u.getWritable();
      }
    }
  }
  function vr() {
    return hs() ? null : ln()._compositionKey;
  }
  function gn(c, i) {
    const u = (i || gi())._nodeMap.get(c);
    return u === void 0 ? null : u;
  }
  function ti(c, i) {
    const a = ln(), u = c[`__lexicalKey_${a._key}`];
    return u !== void 0 ? gn(u, i) : null;
  }
  function or(c, i) {
    let a = c;
    for (; a != null; ) {
      const u = ti(a, i);
      if (u !== null)
        return u;
      a = Qo(a);
    }
    return null;
  }
  function jo(c) {
    const i = c._decorators, a = Object.assign({}, i);
    return c._pendingDecorators = a, a;
  }
  function Hi(c) {
    return c.read(() => Hn().getTextContent());
  }
  function qo(c, i) {
    Nr(c, () => {
      const a = gi();
      if (a.isEmpty())
        return;
      if (i === "root") {
        Hn().markDirty();
        return;
      }
      const u = a._nodeMap;
      for (const [, p] of u)
        p.markDirty();
    }, c._pendingEditorState === null ? {
      tag: "history-merge"
    } : void 0);
  }
  function Hn() {
    return ni(gi());
  }
  function ni(c) {
    return c._nodeMap.get("root");
  }
  function _r(c) {
    jn();
    const i = gi();
    if (c !== null) {
      if (Object.isFrozen(c))
        throw Error("$setSelection called on frozen selection object. Ensure selection is cloned before passing in.");
      c.dirty = !0, c.setCachedNodes(null);
    }
    i._selection = c;
  }
  function ul() {
    jn();
    const c = ln();
    Xr(c);
  }
  function Hr(c) {
    const i = ln(), a = dl(c, i);
    if (a === null) {
      const u = i.getRootElement();
      return c === u ? gn("root") : null;
    }
    return gn(a);
  }
  function Vo(c, i) {
    return i ? c.getTextContentSize() : 0;
  }
  function dl(c, i) {
    let a = c;
    for (; a != null; ) {
      const u = a[`__lexicalKey_${i._key}`];
      if (u !== void 0)
        return u;
      a = Qo(a);
    }
    return null;
  }
  function Rs(c) {
    return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(c);
  }
  function Jo(c) {
    const i = [];
    let a = c;
    for (; a !== null; )
      i.push(a), a = a._parentEditor;
    return i;
  }
  function uo() {
    return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 5);
  }
  function Ui(c) {
    return c.nodeType === Ye ? c.nodeValue : null;
  }
  function Zo(c, i, a) {
    const u = sr(i._window);
    if (u === null)
      return;
    const p = u.anchorNode;
    let {
      anchorOffset: y,
      focusOffset: M
    } = u;
    if (p !== null) {
      let $ = Ui(p);
      const le = or(p);
      if ($ !== null && dt(le)) {
        if ($ === Kt && a) {
          const fe = a.length;
          $ = a, y = fe, M = fe;
        }
        $ !== null && fo(le, $, y, M, c);
      }
    }
  }
  function fo(c, i, a, u, p) {
    let y = c;
    if (y.isAttached() && (p || !y.isDirty())) {
      const M = y.isComposing();
      let $ = i;
      (M || p) && i[i.length - 1] === Kt && ($ = i.slice(0, -1));
      const le = y.getTextContent();
      if (p || $ !== le) {
        if ($ === "") {
          if (un(null), !oe && !ie && !Le) {
            const Ie = ln();
            setTimeout(() => {
              Ie.update(() => {
                y.isAttached() && y.remove();
              });
            }, 20);
          } else
            y.remove();
          return;
        }
        const fe = y.getParent(), Ce = fs(), Ee = y.getTextContentSize(), xe = vr(), Ne = y.getKey();
        if (y.isToken() || xe !== null && Ne === xe && !M || // Check if character was added at the start or boundaries when not insertable, and we need
        // to clear this input from occurring as that action wasn't permitted.
        ft(Ce) && (fe !== null && !fe.canInsertTextBefore() && Ce.anchor.offset === 0 || Ce.anchor.key === c.__key && Ce.anchor.offset === 0 && !y.canInsertTextBefore() || Ce.focus.key === c.__key && Ce.focus.offset === Ee && !y.canInsertTextAfter())) {
          y.markDirty();
          return;
        }
        const Ke = en();
        if (!ft(Ke) || a === null || u === null) {
          y.setTextContent($);
          return;
        }
        if (Ke.setTextNodeRange(y, a, y, u), y.isSegmented()) {
          const Ie = y.getTextContent(), Ae = Mn(Ie);
          y.replace(Ae), y = Ae;
        }
        y.setTextContent($);
      }
    }
  }
  function Ds(c) {
    const i = c.getPreviousSibling();
    return (dt(i) || Ze(i) && i.isInline()) && !i.canInsertTextAfter();
  }
  function Ur(c, i) {
    if (i.isSegmented())
      return !0;
    if (!c.isCollapsed())
      return !1;
    const a = c.anchor.offset, u = i.getParentOrThrow(), p = i.isToken();
    return a === 0 ? !i.canInsertTextBefore() || !u.canInsertTextBefore() || p || Ds(i) : a === i.getTextContentSize() ? !i.canInsertTextAfter() || !u.canInsertTextAfter() || p : !1;
  }
  function As(c, i, a, u) {
    return c === 9 && !i && !a && !u;
  }
  function ho(c, i, a, u) {
    return c === 66 && !i && Wr(a, u);
  }
  function fl(c, i, a, u) {
    return c === 73 && !i && Wr(a, u);
  }
  function hl(c, i, a, u) {
    return c === 85 && !i && Wr(a, u);
  }
  function Wi(c, i) {
    return xl(c) && !i;
  }
  function go(c, i) {
    return xl(c) && i;
  }
  function bs(c, i) {
    return Te && i && c === 79;
  }
  function Ms(c, i, a) {
    return Sr(c) && (Te ? i : a);
  }
  function po(c, i, a) {
    return wr(c) && (Te ? i : a);
  }
  function _o(c, i) {
    return Te && i && Sr(c);
  }
  function gl(c, i) {
    return Te && i && wr(c);
  }
  function pl(c, i, a, u) {
    return Te ? i || a ? !1 : Sr(c) || c === 72 && u : u || i || a ? !1 : Sr(c);
  }
  function _l(c, i, a, u, p) {
    return Te ? a || u || p ? !1 : wr(c) || c === 68 && i : i || u || p ? !1 : wr(c);
  }
  function ml(c, i, a, u) {
    return c === 90 && !i && Wr(a, u);
  }
  function da(c, i, a, u) {
    return Te ? c === 90 && a && i : c === 89 && u || c === 90 && u && i;
  }
  function fa(c, i, a, u) {
    return i ? !1 : c === 67 ? Te ? a : u : !1;
  }
  function yl(c, i, a, u) {
    return i ? !1 : c === 88 ? Te ? a : u : !1;
  }
  function Cl(c) {
    return c === 37;
  }
  function Nl(c) {
    return c === 39;
  }
  function ha(c) {
    return c === 38;
  }
  function ga(c) {
    return c === 40;
  }
  function Ls(c, i, a, u) {
    return Cl(c) && !i && !u && !a;
  }
  function pa(c, i, a, u, p) {
    return Cl(c) && !u && !a && (i || p);
  }
  function _a(c, i, a, u) {
    return Nl(c) && !i && !u && !a;
  }
  function El(c, i, a, u, p) {
    return Nl(c) && !u && !a && (i || p);
  }
  function zi(c, i, a) {
    return ha(c) && !i && !a;
  }
  function Tl(c, i, a) {
    return ga(c) && !i && !a;
  }
  function ma(c, i, a, u) {
    return c || i || a || u;
  }
  function Ps(c) {
    return c === 32;
  }
  function Wr(c, i) {
    return Te ? c : i;
  }
  function xl(c) {
    return c === 13;
  }
  function Sr(c) {
    return c === 8;
  }
  function ya(c) {
    return c === 27;
  }
  function wr(c) {
    return c === 46;
  }
  function ri(c, i, a) {
    return c === 65 && Wr(i, a);
  }
  function Is() {
    const c = Hn(), i = c.select(0, c.getChildrenSize());
    _r(Ni(i));
  }
  function Ei(c, i) {
    c.__lexicalClassNameCache === void 0 && (c.__lexicalClassNameCache = {});
    const a = c.__lexicalClassNameCache, u = a[i];
    if (u !== void 0)
      return u;
    const p = c[i];
    if (typeof p == "string") {
      const y = p.split(" ");
      return a[i] = y, y;
    }
    return p;
  }
  function mo(c, i, a, u, p) {
    if (a.size === 0)
      return;
    const y = u.__type, M = u.__key, $ = i.get(y);
    if ($ === void 0)
      throw Error(`Type ${y} not in registeredNodes`);
    const le = $.klass;
    let fe = c.get(le);
    fe === void 0 && (fe = /* @__PURE__ */ new Map(), c.set(le, fe));
    const Ce = fe.get(M), Ee = Ce === "destroyed" && p === "created";
    (Ce === void 0 || Ee) && fe.set(M, Ee ? "updated" : p);
  }
  function ks(c) {
    const i = gi(), a = i._readOnly, u = c.getType(), p = i._nodeMap, y = [];
    for (const [, M] of p)
      M instanceof c && M.__type === u && (a || M.isAttached()) && y.push(M);
    return y;
  }
  function yo(c, i, a) {
    const u = c.getParent();
    let p = a, y = c;
    return u !== null && (i && a === 0 ? (p = y.getIndexWithinParent(), y = u) : !i && a === y.getChildrenSize() && (p = y.getIndexWithinParent() + 1, y = u)), y.getChildAtIndex(i ? p - 1 : p);
  }
  function zr(c, i) {
    const a = c.offset;
    if (c.type === "element") {
      const u = c.getNode();
      return yo(u, i, a);
    } else {
      const u = c.getNode();
      if (i && a === 0 || !i && a === u.getTextContentSize()) {
        const p = i ? u.getPreviousSibling() : u.getNextSibling();
        return p === null ? yo(u.getParentOrThrow(), i, u.getIndexWithinParent() + (i ? 0 : 1)) : p;
      }
    }
    return null;
  }
  function vl(c) {
    const i = Ti(c).event, a = i && i.inputType;
    return a === "insertFromPaste" || a === "insertFromPasteAsQuotation";
  }
  function it(c, i, a) {
    return fu(c, i, a);
  }
  function Co(c) {
    return !Er(c) && !c.isLastChild() && !c.isInline();
  }
  function Xo(c, i) {
    const a = c._keyToDOMMap.get(i);
    if (a === void 0)
      throw Error(`Reconciliation: could not find DOM element for node key ${i}`);
    return a;
  }
  function Qo(c) {
    const i = c.assignedSlot || c.parentElement;
    return i !== null && i.nodeType === 11 ? i.host : i;
  }
  function Sl(c, i, a) {
    const u = a.ownerDocument, p = u.defaultView;
    if (p === null)
      return;
    let {
      top: y,
      bottom: M
    } = i, $ = 0, le = 0, fe = a;
    for (; fe !== null; ) {
      const Ce = fe === u.body;
      if (Ce)
        $ = 0, le = Ti(c).innerHeight;
      else {
        const xe = fe.getBoundingClientRect();
        $ = xe.top, le = xe.bottom;
      }
      let Ee = 0;
      if (y < $ ? Ee = -($ - y) : M > le && (Ee = M - le), Ee !== 0)
        if (Ce)
          p.scrollBy(0, Ee);
        else {
          const xe = fe.scrollTop;
          fe.scrollTop += Ee;
          const Ne = fe.scrollTop - xe;
          y -= Ne, M -= Ne;
        }
      if (Ce)
        break;
      fe = Qo(fe);
    }
  }
  function Ca(c) {
    return ln()._updateTags.has(c);
  }
  function ii(c) {
    jn(), ln()._updateTags.add(c);
  }
  function An(c) {
    const i = en();
    if (!ft(i) || !Ze(c))
      return i;
    const {
      anchor: a,
      focus: u
    } = i, p = a.getNode(), y = u.getNode();
    return ut(p, c) && a.set(c.__key, 0, "element"), ut(y, c) && u.set(c.__key, 0, "element"), i;
  }
  function ut(c, i) {
    let a = c.getParent();
    for (; a !== null; ) {
      if (a.is(i))
        return !0;
      a = a.getParent();
    }
    return !1;
  }
  function Gi(c) {
    const i = c.ownerDocument;
    return i && i.defaultView || null;
  }
  function Ti(c) {
    const i = c._window;
    if (i === null)
      throw Error("window object not found");
    return i;
  }
  function wl(c) {
    return Ze(c) && c.isInline() || yn(c) && c.isInline();
  }
  function mr(c) {
    let i = c.getParentOrThrow();
    for (; i !== null; ) {
      if (Or(i))
        return i;
      i = i.getParentOrThrow();
    }
    return i;
  }
  function Or(c) {
    return Er(c) || Ze(c) && c.isShadowRoot();
  }
  function $s(c) {
    const i = c.constructor.clone(c);
    return Dn(i, null), i;
  }
  function Yi(c) {
    const i = ln(), a = c.constructor.getType(), u = i._nodes.get(a);
    if (u === void 0)
      throw Error('$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the "nodes" array in the editor config.');
    const p = u.replace;
    if (p !== null) {
      const y = p(c);
      if (!(y instanceof c.constructor))
        throw Error("$initializeNode failed. Ensure replacement node is a subclass of the original node.");
      return y;
    }
    return c;
  }
  function Rr(c, i) {
    const a = c.getParent();
    if (Er(a) && !Ze(i) && !yn(i))
      throw Error("Only element or decorator nodes can be inserted in to the root node");
  }
  function Fs(c) {
    const i = c.theme, a = document.createElement("div");
    a.contentEditable = "false", a.setAttribute("data-lexical-cursor", "true");
    let u = i.blockCursor;
    if (u !== void 0) {
      if (typeof u == "string") {
        const p = u.split(" ");
        u = i.blockCursor = p;
      }
      u !== void 0 && a.classList.add(...u);
    }
    return a;
  }
  function ji(c) {
    return (yn(c) || Ze(c) && !c.canBeEmpty()) && !c.isInline();
  }
  function vt(c, i, a) {
    a.style.removeProperty("caret-color"), i._blockCursorElement = null;
    const u = c.parentElement;
    u !== null && u.removeChild(c);
  }
  function Bs(c, i, a) {
    let u = c._blockCursorElement;
    if (ft(a) && a.isCollapsed() && a.anchor.type === "element" && i.contains(document.activeElement)) {
      const p = a.anchor, y = p.getNode(), M = p.offset, $ = y.getChildrenSize();
      let le = !1, fe = null;
      if (M === $) {
        const Ce = y.getChildAtIndex(M - 1);
        ji(Ce) && (le = !0);
      } else {
        const Ce = y.getChildAtIndex(M);
        if (ji(Ce)) {
          const Ee = Ce.getPreviousSibling();
          (Ee === null || ji(Ee)) && (le = !0, fe = c.getElementByKey(Ce.__key));
        }
      }
      if (le) {
        const Ce = c.getElementByKey(y.__key);
        u === null && (c._blockCursorElement = u = Fs(c._config)), i.style.caretColor = "transparent", fe === null ? Ce.appendChild(u) : Ce.insertBefore(u, fe);
        return;
      }
    }
    u !== null && vt(u, c, i);
  }
  function sr(c) {
    return ge ? (c || window).getSelection() : null;
  }
  function es(c, i) {
    let a = c.getChildAtIndex(i);
    if (a == null && (a = c), Or(c))
      throw Error("Can not call $splitNode() on root element");
    const u = (M) => {
      const $ = M.getParentOrThrow(), le = Or($), fe = M === a && !le ? M : $s(M);
      if (le)
        return M.insertAfter(fe), [M, fe, fe];
      {
        const [Ce, Ee, xe] = u($), Ne = M.getNextSiblings();
        return xe.append(fe, ...Ne), [Ce, Ee, fe];
      }
    }, [p, y] = u(a);
    return [p, y];
  }
  function No(c, i) {
    let a = c;
    for (; a !== Hn() && a != null; ) {
      if (i(a))
        return a;
      a = a.getParent();
    }
    return null;
  }
  function xi(c) {
    const i = [], a = [c];
    for (; a.length > 0; ) {
      const u = a.pop();
      if (u === void 0)
        throw Error("Stack.length > 0; can't be undefined");
      Ze(u) && a.unshift(...u.getChildren()), u !== c && i.push(u);
    }
    return i;
  }
  function Eo(c) {
    return To(c) && c.tagName === "A";
  }
  function To(c) {
    return c.nodeType === 1;
  }
  function vi(c) {
    if (yn(c) && !c.isInline())
      return !0;
    if (!Ze(c) || Or(c))
      return !1;
    const i = c.getFirstChild(), a = i === null || ui(i) || dt(i) || i.isInline();
    return !c.isInline() && c.canBeEmpty() !== !1 && a;
  }
  function ts(c, i) {
    let a = c;
    for (; a !== null && a.getParent() !== null && !i(a); )
      a = a.getParentOrThrow();
    return i(a) ? a : null;
  }
  function Ol(c, i) {
    const a = c._decorators;
    let p = c._pendingDecorators || a;
    const y = i._nodeMap;
    let M;
    for (M in p)
      y.has(M) || (p === a && (p = jo(c)), delete p[M]);
  }
  function Ks(c, i, a, u, p, y) {
    let M = c.getFirstChild();
    for (; M !== null; ) {
      const $ = M.__key;
      M.__parent === i && (Ze(M) && Ks(M, $, a, u, p, y), a.has($) || y.delete($), p.push($)), M = M.getNextSibling();
    }
  }
  function Rl(c, i, a, u) {
    const p = c._nodeMap, y = i._nodeMap, M = [];
    for (const [$] of u) {
      const le = y.get($);
      le !== void 0 && (le.isAttached() || (Ze(le) && Ks(le, $, p, y, M, u), p.has($) || u.delete($), M.push($)));
    }
    for (const $ of M)
      y.delete($);
    for (const $ of a) {
      const le = y.get($);
      le !== void 0 && !le.isAttached() && (p.has($) || a.delete($), y.delete($));
    }
  }
  let pn = "", $n = "", yr = "", oi, bn, Wt, Si = !1, qi = !1, xo, ns = null, Vi, rs, si, Gr, vo, So;
  function dn(c, i) {
    const a = si.get(c);
    if (i !== null) {
      const u = Qt(c);
      u.parentNode === i && i.removeChild(u);
    }
    if (Gr.has(c) || bn._keyToDOMMap.delete(c), Ze(a)) {
      const u = Zi(a, si);
      _n(u, 0, u.length - 1, null);
    }
    a !== void 0 && mo(So, Wt, xo, a, "destroyed");
  }
  function _n(c, i, a, u) {
    let p = i;
    for (; p <= a; ++p) {
      const y = c[p];
      y !== void 0 && dn(y, u);
    }
  }
  function mn(c, i) {
    c.setProperty("text-align", i);
  }
  const Hs = "40px";
  function Ji(c, i) {
    const a = oi.theme.indent;
    if (typeof a == "string") {
      const p = c.classList.contains(a);
      i > 0 && !p ? c.classList.add(a) : i < 1 && p && c.classList.remove(a);
    }
    const u = getComputedStyle(c).getPropertyValue("--lexical-indent-base-value") || Hs;
    c.style.setProperty("padding-inline-start", i === 0 ? "" : `calc(${i} * ${u})`);
  }
  function Us(c, i) {
    const a = c.style;
    i === 0 ? mn(a, "") : i === gt ? mn(a, "left") : i === Ct ? mn(a, "center") : i === xt ? mn(a, "right") : i === St ? mn(a, "justify") : i === wt ? mn(a, "start") : i === Et && mn(a, "end");
  }
  function Yr(c, i, a) {
    const u = Gr.get(c);
    if (u === void 0)
      throw Error("createNode: node does not exist in nodeMap");
    const p = u.createDOM(oi, bn);
    if (Ml(c, p, bn), dt(u) ? p.setAttribute("data-lexical-text", "true") : yn(u) && p.setAttribute("data-lexical-decorator", "true"), Ze(u)) {
      const y = u.__indent, M = u.__size;
      if (y !== 0 && Ji(p, y), M !== 0) {
        const le = M - 1, fe = Zi(u, Gr);
        Un(fe, le, u, p);
      }
      const $ = u.__format;
      $ !== 0 && Us(p, $), u.isInline() || Ws(null, u, p), Co(u) && (pn += bt, yr += bt);
    } else {
      const y = u.getTextContent();
      if (yn(u)) {
        const M = u.decorate(bn, oi);
        M !== null && Xi(c, M), p.contentEditable = "false";
      } else
        dt(u) && (u.isDirectionless() || ($n += y));
      pn += y, yr += y;
    }
    if (i !== null)
      if (a != null)
        i.insertBefore(p, a);
      else {
        const y = i.__lexicalLineBreak;
        y != null ? i.insertBefore(p, y) : i.appendChild(p);
      }
    return Object.freeze(u), mo(So, Wt, xo, u, "created"), p;
  }
  function Un(c, i, a, u) {
    const p = $n;
    $n = "", lr(c, a, 0, i, u, null), Dl(a, u), $n = p;
  }
  function lr(c, i, a, u, p, y) {
    const M = pn;
    pn = "";
    let $ = a;
    for (; $ <= u; ++$)
      Yr(c[$], p, y);
    Co(i) && (pn += bt), p.__lexicalTextContent = pn, pn = M + pn;
  }
  function Xt(c, i) {
    const a = i.get(c);
    return ui(a) || yn(a) && a.isInline();
  }
  function Ws(c, i, a) {
    const u = c !== null && (c.__size === 0 || Xt(c.__last, si)), p = i.__size === 0 || Xt(i.__last, Gr);
    if (u) {
      if (!p) {
        const y = a.__lexicalLineBreak;
        y != null && a.removeChild(y), a.__lexicalLineBreak = null;
      }
    } else if (p) {
      const y = document.createElement("br");
      a.__lexicalLineBreak = y, a.appendChild(y);
    }
  }
  function Dl(c, i) {
    const a = (
      // @ts-expect-error: internal field
      i.__lexicalDirTextContent
    ), u = i.__lexicalDir;
    if (a !== $n || u !== ns) {
      const p = $n === "", y = p ? ns : cl($n);
      if (y !== u) {
        const M = i.classList, $ = oi.theme;
        let le = u !== null ? $[u] : void 0, fe = y !== null ? $[y] : void 0;
        if (le !== void 0) {
          if (typeof le == "string") {
            const Ce = le.split(" ");
            le = $[u] = Ce;
          }
          M.remove(...le);
        }
        if (y === null || p && y === "ltr")
          i.removeAttribute("dir");
        else {
          if (fe !== void 0) {
            if (typeof fe == "string") {
              const Ce = fe.split(" ");
              fe = $[y] = Ce;
            }
            fe !== void 0 && M.add(...fe);
          }
          i.dir = y;
        }
        if (!qi) {
          const Ce = c.getWritable();
          Ce.__dir = y;
        }
      }
      ns = y, i.__lexicalDirTextContent = $n, i.__lexicalDir = y;
    }
  }
  function Na(c, i, a) {
    const u = $n;
    $n = "", Al(c, i, a), Dl(i, a), $n = u;
  }
  function Zi(c, i) {
    const a = [];
    let u = c.__first;
    for (; u !== null; ) {
      const p = i.get(u);
      if (p === void 0)
        throw Error("createChildrenArray: node does not exist in nodeMap");
      a.push(u), u = p.__next;
    }
    return a;
  }
  function Al(c, i, a) {
    const u = pn, p = c.__size, y = i.__size;
    if (pn = "", p === 1 && y === 1) {
      const M = c.__first, $ = i.__first;
      if (M === $)
        Cr(M, a);
      else {
        const le = Qt(M), fe = Yr($, null, null);
        a.replaceChild(fe, le), dn(M, null);
      }
    } else {
      const M = Zi(c, si), $ = Zi(i, Gr);
      if (p === 0)
        y !== 0 && lr($, i, 0, y - 1, a, null);
      else if (y === 0) {
        if (p !== 0) {
          const fe = a.__lexicalLineBreak == null;
          _n(M, 0, p - 1, fe ? null : a), fe && (a.textContent = "");
        }
      } else
        bl(i, M, $, p, y, a);
    }
    Co(i) && (pn += bt), a.__lexicalTextContent = pn, pn = u + pn;
  }
  function Cr(c, i) {
    const a = si.get(c);
    let u = Gr.get(c);
    if (a === void 0 || u === void 0)
      throw Error("reconcileNode: prevNode or nextNode does not exist in nodeMap");
    const p = Si || rs.has(c) || Vi.has(c), y = Xo(bn, c);
    if (a === u && !p) {
      if (Ze(a)) {
        const M = y.__lexicalTextContent;
        M !== void 0 && (pn += M, yr += M);
        const $ = y.__lexicalDirTextContent;
        $ !== void 0 && ($n += $);
      } else {
        const M = a.getTextContent();
        dt(a) && !a.isDirectionless() && ($n += M), yr += M, pn += M;
      }
      return y;
    }
    if (a !== u && p && mo(So, Wt, xo, u, "updated"), u.updateDOM(a, y, oi)) {
      const M = Yr(c, null, null);
      if (i === null)
        throw Error("reconcileNode: parentDOM is null");
      return i.replaceChild(M, y), dn(c, null), M;
    }
    if (Ze(a) && Ze(u)) {
      const M = u.__indent;
      M !== a.__indent && Ji(y, M);
      const $ = u.__format;
      $ !== a.__format && Us(y, $), p && (Na(a, u, y), !Er(u) && !u.isInline() && Ws(a, u, y)), Co(u) && (pn += bt, yr += bt);
    } else {
      const M = u.getTextContent();
      if (yn(u)) {
        const $ = u.decorate(bn, oi);
        $ !== null && Xi(c, $);
      } else
        dt(u) && !u.isDirectionless() && ($n += M);
      pn += M, yr += M;
    }
    return !qi && Er(u) && u.__cachedText !== yr && (u = u.getWritable(), u.__cachedText = yr), Object.freeze(u), y;
  }
  function Xi(c, i) {
    let a = bn._pendingDecorators;
    const u = bn._decorators;
    if (a === null) {
      if (u[c] === i)
        return;
      a = jo(bn);
    }
    a[c] = i;
  }
  function rt(c) {
    return c.firstChild;
  }
  function is(c) {
    let i = c.nextSibling;
    return i !== null && i === bn._blockCursorElement && (i = i.nextSibling), i;
  }
  function bl(c, i, a, u, p, y) {
    const M = u - 1, $ = p - 1;
    let le, fe, Ce = rt(y), Ee = 0, xe = 0;
    for (; Ee <= M && xe <= $; ) {
      const Ie = i[Ee], Ae = a[xe];
      if (Ie === Ae)
        Ce = is(Cr(Ae, y)), Ee++, xe++;
      else {
        le === void 0 && (le = new Set(i)), fe === void 0 && (fe = new Set(a));
        const ht = fe.has(Ie), We = le.has(Ae);
        if (!ht)
          Ce = is(Qt(Ie)), dn(Ie, y), Ee++;
        else if (!We)
          Yr(Ae, y, Ce), xe++;
        else {
          const tt = Xo(bn, Ae);
          tt === Ce ? Ce = is(Cr(Ae, y)) : (Ce != null ? y.insertBefore(tt, Ce) : y.appendChild(tt), Cr(Ae, y)), Ee++, xe++;
        }
      }
    }
    const Ne = Ee > M, Ke = xe > $;
    if (Ne && !Ke) {
      const Ie = a[$ + 1], Ae = Ie === void 0 ? null : bn.getElementByKey(Ie);
      lr(a, c, xe, $, y, Ae);
    } else
      Ke && !Ne && _n(i, Ee, M, y);
  }
  function Jn(c, i, a, u, p, y) {
    pn = "", yr = "", $n = "", Si = u === at, ns = null, bn = a, oi = a._config, Wt = a._nodes, xo = bn._listeners.mutation, Vi = p, rs = y, si = c._nodeMap, Gr = i._nodeMap, qi = i._readOnly, vo = new Map(a._keyToDOMMap);
    const M = /* @__PURE__ */ new Map();
    return So = M, Cr("root", null), bn = void 0, Wt = void 0, Vi = void 0, rs = void 0, si = void 0, Gr = void 0, oi = void 0, vo = void 0, So = void 0, M;
  }
  function Ml(c, i, a) {
    const u = a._keyToDOMMap;
    i["__lexicalKey_" + a._key] = c, u.set(c, i);
  }
  function Qt(c) {
    const i = vo.get(c);
    if (i === void 0)
      throw Error(`Reconciliation: could not find DOM element for node key ${c}`);
    return i;
  }
  const Wn = Object.freeze({}), Je = 30, os = [["keydown", E], ["pointerdown", kl], ["compositionstart", s], ["compositionend", m], ["input", n], ["click", ar], ["cut", Wn], ["copy", Wn], ["dragstart", Wn], ["dragover", Wn], ["dragend", Wn], ["paste", Wn], ["focus", Wn], ["blur", Wn], ["drop", Wn]];
  ze && os.push(["beforeinput", (c, i) => l(c, i)]);
  let Dr = 0, Yn = 0, Ll = 0, li = null, Qi = 0, eo = !1, ai = !1, wo = !1, Zn = !1, zs = [0, "", 0, "root", 0];
  function Pl(c, i, a, u, p) {
    const y = c.anchor, M = c.focus, $ = y.getNode(), le = ln(), fe = sr(le._window), Ce = fe !== null ? fe.anchorNode : null, Ee = y.key, xe = le.getElementByKey(Ee), Ne = a.length;
    return Ee !== M.key || // If we're working with a non-text node.
    !dt($) || // If we are replacing a range with a single character or grapheme, and not composing.
    (!p && (!ze || // We check to see if there has been
    // a recent beforeinput event for "textInput". If there has been one in the last
    // 50ms then we proceed as normal. However, if there is not, then this is likely
    // a dangling `input` event caused by execCommand('insertText').
    Ll < u + 50) || $.isDirty() && Ne < 2 || Rs(a)) && y.offset !== M.offset && !$.isComposing() || // Any non standard text node.
    Os($) || // If the text length is more than a single character and we're either
    // dealing with this in "beforeinput" or where the node has already recently
    // been changed (thus is dirty).
    $.isDirty() && Ne > 1 || // If the DOM selection element is not the same as the backing node during beforeinput.
    (p || !ze) && xe !== null && !$.isComposing() && Ce !== Sn(xe) || // If TargetRange is not the same as the DOM selection; browser trying to edit random parts
    // of the editor.
    fe !== null && i !== null && (!i.collapsed || i.startContainer !== fe.anchorNode || i.startOffset !== fe.anchorOffset) || // Check if we're changing from bold to italics, or some other format.
    $.getFormat() !== c.format || $.getStyle() !== c.style || // One last set of heuristics to check against.
    Ur(c, $);
  }
  function Il(c, i) {
    return c !== null && c.nodeValue !== null && c.nodeType === Ye && i !== 0 && i !== c.nodeValue.length;
  }
  function ss(c, i, a) {
    const {
      anchorNode: u,
      anchorOffset: p,
      focusNode: y,
      focusOffset: M
    } = c;
    eo && (eo = !1, Il(u, p) && Il(y, M)) || Nr(i, () => {
      if (!a) {
        _r(null);
        return;
      }
      if (!Kr(i, u, y))
        return;
      const $ = en();
      if (ft($)) {
        const le = $.anchor, fe = le.getNode();
        if ($.isCollapsed()) {
          c.type === "Range" && c.anchorNode === c.focusNode && ($.dirty = !0);
          const Ce = Ti(i).event, Ee = Ce ? Ce.timeStamp : performance.now(), [xe, Ne, Ke, Ie, Ae] = zs, ht = Hn(), We = i.isComposing() === !1 && ht.getTextContent() === "";
          Ee < Ae + 200 && le.offset === Ke && le.key === Ie ? ($.format = xe, $.style = Ne) : le.type === "text" ? ($.format = fe.getFormat(), $.style = fe.getStyle()) : le.type === "element" && !We && ($.format = 0, $.style = "");
        } else {
          let Ce = je, Ee = !1;
          const xe = $.getNodes(), Ne = xe.length;
          for (let Ke = 0; Ke < Ne; Ke++) {
            const Ie = xe[Ke];
            if (dt(Ie) && (Ee = !0, Ce &= Ie.getFormat(), Ce === 0))
              break;
          }
          $.format = Ee ? Ce : 0;
        }
      }
      it(i, t, void 0);
    });
  }
  function ar(c, i) {
    Nr(i, () => {
      const a = en(), u = sr(i._window), p = fs();
      if (u) {
        if (ft(a)) {
          const y = a.anchor, M = y.getNode();
          if (y.type === "element" && y.offset === 0 && a.isCollapsed() && !Er(M) && Hn().getChildrenSize() === 1 && M.getTopLevelElementOrThrow().isEmpty() && p !== null && a.is(p))
            u.removeAllRanges(), a.dirty = !0;
          else if (c.detail === 3 && !a.isCollapsed()) {
            const le = a.focus.getNode();
            M !== le && (Ze(M) ? M.select(0) : M.getParentOrThrow().select(0));
          }
        } else if (c.pointerType === "touch") {
          const y = u.anchorNode;
          if (y !== null) {
            const M = y.nodeType;
            if (M === Be || M === Ye) {
              const $ = Ta(p, u, i);
              _r($);
            }
          }
        }
      }
      it(i, r, c);
    });
  }
  function kl(c, i) {
    const a = c.target, u = c.pointerType;
    a instanceof Node && u !== "touch" && Nr(i, () => {
      ua(a) || (ai = !0);
    });
  }
  function ls(c) {
    if (!c.getTargetRanges)
      return null;
    const i = c.getTargetRanges();
    return i.length === 0 ? null : i[0];
  }
  function $l(c, i) {
    return c !== i || Ze(c) || Ze(i) || !c.isToken() || !i.isToken();
  }
  function Oo(c) {
    return Yn === 229 && c < Dr + Je;
  }
  function l(c, i) {
    const a = c.inputType, u = ls(c);
    a === "deleteCompositionText" || // If we're pasting in FF, we shouldn't get this event
    // as the `paste` event should have triggered, unless the
    // user has dom.event.clipboardevents.enabled disabled in
    // about:config. In that case, we need to process the
    // pasted content in the DOM mutation phase.
    Me && vl(i) || a !== "insertCompositionText" && Nr(i, () => {
      const p = en();
      if (a === "deleteContentBackward") {
        if (p === null) {
          const Ce = fs();
          if (!ft(Ce))
            return;
          _r(Ce.clone());
        }
        if (ft(p)) {
          if (ue && un(p.anchor.key), Oo(c.timeStamp) && i.isComposing() && p.anchor.key === p.focus.key) {
            if (un(null), Dr = 0, setTimeout(() => {
              Nr(i, () => {
                un(null);
              });
            }, Je), ft(p)) {
              const Ee = p.anchor.getNode();
              Ee.markDirty(), p.format = Ee.getFormat(), p.style = Ee.getStyle();
            }
            p.anchor.getNode().getTextContent().length <= 1 && (c.preventDefault(), it(i, o, !0));
          } else
            c.preventDefault(), it(i, o, !0);
          return;
        }
      }
      if (!ft(p))
        return;
      const y = c.data;
      li !== null && Zo(!1, i, li), (!p.dirty || li !== null) && p.isCollapsed() && !Er(p.anchor.getNode()) && u !== null && p.applyDOMRange(u), li = null;
      const M = p.anchor, $ = p.focus, le = M.getNode(), fe = $.getNode();
      if (a === "insertText" || a === "insertTranspose") {
        if (y === `
`)
          c.preventDefault(), it(i, f, !1);
        else if (y === bt)
          c.preventDefault(), it(i, h, void 0);
        else if (y == null && c.dataTransfer) {
          const Ce = c.dataTransfer.getData("text/plain");
          c.preventDefault(), p.insertRawText(Ce);
        } else
          y != null && Pl(p, u, y, c.timeStamp, !0) ? (c.preventDefault(), it(i, C, y)) : li = y;
        Ll = c.timeStamp;
        return;
      }
      switch (c.preventDefault(), a) {
        case "insertFromYank":
        case "insertFromDrop":
        case "insertReplacementText": {
          it(i, C, c);
          break;
        }
        case "insertFromComposition": {
          un(null), it(i, C, c);
          break;
        }
        case "insertLineBreak": {
          un(null), it(i, f, !1);
          break;
        }
        case "insertParagraph": {
          un(null), wo && !ie ? (wo = !1, it(i, f, !1)) : it(i, h, void 0);
          break;
        }
        case "insertFromPaste":
        case "insertFromPasteAsQuotation": {
          it(i, T, c);
          break;
        }
        case "deleteByComposition": {
          $l(le, fe) && it(i, O, c);
          break;
        }
        case "deleteByDrag":
        case "deleteByCut": {
          it(i, O, c);
          break;
        }
        case "deleteContent": {
          it(i, o, !1);
          break;
        }
        case "deleteWordBackward": {
          it(i, S, !0);
          break;
        }
        case "deleteWordForward": {
          it(i, S, !1);
          break;
        }
        case "deleteHardLineBackward":
        case "deleteSoftLineBackward": {
          it(i, x, !0);
          break;
        }
        case "deleteContentForward":
        case "deleteHardLineForward":
        case "deleteSoftLineForward": {
          it(i, x, !1);
          break;
        }
        case "formatStrikeThrough": {
          it(i, D, "strikethrough");
          break;
        }
        case "formatBold": {
          it(i, D, "bold");
          break;
        }
        case "formatItalic": {
          it(i, D, "italic");
          break;
        }
        case "formatUnderline": {
          it(i, D, "underline");
          break;
        }
        case "historyUndo": {
          it(i, k, void 0);
          break;
        }
        case "historyRedo": {
          it(i, H, void 0);
          break;
        }
      }
    });
  }
  function n(c, i) {
    c.stopPropagation(), Nr(i, () => {
      const a = en(), u = c.data, p = ls(c);
      if (u != null && ft(a) && Pl(a, p, u, c.timeStamp, !1)) {
        Zn && (d(i, u), Zn = !1);
        const y = a.anchor, M = y.getNode(), $ = sr(i._window);
        if ($ === null)
          return;
        const le = y.offset;
        (!ze || a.isCollapsed() || !dt(M) || $.anchorNode === null || M.getTextContent().slice(0, le) + u + M.getTextContent().slice(le + a.focus.offset) !== Ui($.anchorNode)) && it(i, C, u);
        const fe = u.length;
        Me && fe > 1 && c.inputType === "insertCompositionText" && !i.isComposing() && (a.anchor.offset -= fe), !oe && !ie && !Le && i.isComposing() && (Dr = 0, un(null));
      } else
        Zo(!1, i, u !== null ? u : void 0), Zn && (d(i, u || void 0), Zn = !1);
      ul();
    }), li = null;
  }
  function s(c, i) {
    Nr(i, () => {
      const a = en();
      if (ft(a) && !i.isComposing()) {
        const u = a.anchor, p = a.anchor.getNode();
        un(u.key), // If it has been 30ms since the last keydown, then we should
        // apply the empty space heuristic. We can't do this for Safari,
        // as the keydown fires after composition start.
        (c.timeStamp < Dr + Je || // FF has issues around composing multibyte characters, so we also
        // need to invoke the empty space heuristic below.
        u.type === "element" || !a.isCollapsed() || p.getFormat() !== a.format || p.getStyle() !== a.style) && it(i, C, nr);
      }
    });
  }
  function d(c, i) {
    const a = c._compositionKey;
    if (un(null), a !== null && i != null) {
      if (i === "") {
        const u = gn(a), p = Sn(c.getElementByKey(a));
        p !== null && p.nodeValue !== null && dt(u) && fo(u, p.nodeValue, null, null, !0);
        return;
      }
      if (i[i.length - 1] === `
`) {
        const u = en();
        if (ft(u)) {
          const p = u.focus;
          u.anchor.set(p.key, p.offset, p.type), it(c, z, null);
          return;
        }
      }
    }
    Zo(!0, c, i);
  }
  function m(c, i) {
    Me ? Zn = !0 : Nr(i, () => {
      d(i, c.data);
    });
  }
  function E(c, i) {
    if (Dr = c.timeStamp, Yn = c.keyCode, i.isComposing())
      return;
    const {
      keyCode: a,
      shiftKey: u,
      ctrlKey: p,
      metaKey: y,
      altKey: M
    } = c;
    if (!it(i, N, c)) {
      if (_a(a, p, M, y))
        it(i, v, c);
      else if (El(a, p, u, M, y))
        it(i, F, c);
      else if (Ls(a, p, M, y))
        it(i, U, c);
      else if (pa(a, p, u, M, y))
        it(i, I, c);
      else if (zi(a, p, y))
        it(i, K, c);
      else if (Tl(a, p, y))
        it(i, B, c);
      else if (go(a, u))
        wo = !0, it(i, z, c);
      else if (Ps(a))
        it(i, te, c);
      else if (bs(a, p))
        c.preventDefault(), wo = !0, it(i, f, !0);
      else if (Wi(a, u))
        wo = !1, it(i, z, c);
      else if (pl(a, M, y, p))
        Sr(a) ? it(i, re, c) : (c.preventDefault(), it(i, o, !0));
      else if (ya(a))
        it(i, de, c);
      else if (_l(a, p, u, M, y))
        wr(a) ? it(i, V, c) : (c.preventDefault(), it(i, o, !1));
      else if (Ms(a, M, p))
        c.preventDefault(), it(i, S, !0);
      else if (po(a, M, p))
        c.preventDefault(), it(i, S, !1);
      else if (_o(a, y))
        c.preventDefault(), it(i, x, !0);
      else if (gl(a, y))
        c.preventDefault(), it(i, x, !1);
      else if (ho(a, M, y, p))
        c.preventDefault(), it(i, D, "bold");
      else if (hl(a, M, y, p))
        c.preventDefault(), it(i, D, "underline");
      else if (fl(a, M, y, p))
        c.preventDefault(), it(i, D, "italic");
      else if (As(a, M, p, y))
        it(i, G, c);
      else if (ml(a, u, y, p))
        c.preventDefault(), it(i, k, void 0);
      else if (da(a, u, y, p))
        c.preventDefault(), it(i, H, void 0);
      else {
        const $ = i._editorState._selection;
        ur($) ? fa(a, u, y, p) ? (c.preventDefault(), it(i, ne, c)) : yl(a, u, y, p) ? (c.preventDefault(), it(i, Y, c)) : ri(a, y, p) && (c.preventDefault(), it(i, W, c)) : !Me && ri(a, y, p) && (c.preventDefault(), it(i, W, c));
      }
      ma(p, u, M, y) && it(i, ce, c);
    }
  }
  function R(c) {
    let i = c.__lexicalEventHandles;
    return i === void 0 && (i = [], c.__lexicalEventHandles = i), i;
  }
  const X = /* @__PURE__ */ new Map();
  function _e(c) {
    const i = c.target, a = i == null ? null : i.nodeType === 9 ? i.defaultView : i.ownerDocument.defaultView, u = sr(a);
    if (u === null)
      return;
    const p = ao(u.anchorNode);
    if (p === null)
      return;
    ai && (ai = !1, Nr(p, () => {
      const Ce = fs(), Ee = u.anchorNode;
      if (Ee === null)
        return;
      const xe = Ee.nodeType;
      if (xe !== Be && xe !== Ye)
        return;
      const Ne = Ta(Ce, u, p);
      _r(Ne);
    }));
    const y = Jo(p), M = y[y.length - 1], $ = M._key, le = X.get($), fe = le || M;
    fe !== p && ss(u, fe, !1), ss(u, p, !0), p !== M ? X.set($, p) : le && X.delete($);
  }
  function Se(c) {
    c._lexicalHandled = !0;
  }
  function Fe(c) {
    return c._lexicalHandled === !0;
  }
  function Ue(c, i) {
    Qi === 0 && c.ownerDocument.addEventListener("selectionchange", _e), Qi++, c.__lexicalEditor = i;
    const a = R(c);
    for (let u = 0; u < os.length; u++) {
      const [p, y] = os[u], M = typeof y == "function" ? ($) => {
        Fe($) || (Se($), i.isEditable() && y($, i));
      } : ($) => {
        if (!Fe($) && (Se($), i.isEditable()))
          switch (p) {
            case "cut":
              return it(i, Y, $);
            case "copy":
              return it(i, ne, $);
            case "paste":
              return it(i, T, $);
            case "dragstart":
              return it(i, P, $);
            case "dragover":
              return it(i, w, $);
            case "dragend":
              return it(i, j, $);
            case "focus":
              return it(i, A, $);
            case "blur":
              return it(i, J, $);
            case "drop":
              return it(i, Z, $);
          }
      };
      c.addEventListener(p, M), a.push(() => {
        c.removeEventListener(p, M);
      });
    }
  }
  function Pe(c) {
    Qi !== 0 && (Qi--, Qi === 0 && c.ownerDocument.removeEventListener("selectionchange", _e));
    const i = c.__lexicalEditor;
    i != null && (De(i), c.__lexicalEditor = null);
    const a = R(c);
    for (let u = 0; u < a.length; u++)
      a[u]();
    c.__lexicalEventHandles = [];
  }
  function De(c) {
    if (c._parentEditor !== null) {
      const i = Jo(c), u = i[i.length - 1]._key;
      X.get(u) === c && X.delete(u);
    } else
      X.delete(c._key);
  }
  function Xe() {
    eo = !0;
  }
  function lt(c, i, a, u, p) {
    zs = [c, i, a, u, p];
  }
  function Nt(c, i, a) {
    jn();
    const u = c.__key, p = c.getParent();
    if (p === null)
      return;
    const y = An(c);
    let M = !1;
    if (ft(y) && i) {
      const $ = y.anchor, le = y.focus;
      $.key === u && (Gl($, c, p, c.getPreviousSibling(), c.getNextSibling()), M = !0), le.key === u && (Gl(le, c, p, c.getPreviousSibling(), c.getNextSibling()), M = !0);
    } else
      ur(y) && i && c.isSelected() && c.selectPrevious();
    if (ft(y) && i && !M) {
      const $ = c.getIndexWithinParent();
      ei(c), zl(y, p, $, -1);
    } else
      ei(c);
    !a && !Or(p) && !p.canBeEmpty() && p.isEmpty() && Nt(p, i), i && Er(p) && p.isEmpty() && p.selectEnd();
  }
  class Ot {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    /** @internal */
    /** @internal */
    //@ts-ignore We set the key in the constructor.
    /** @internal */
    /** @internal */
    /** @internal */
    // Flow doesn't support abstract classes unfortunately, so we can't _force_
    // subclasses of Node to implement statics. All subclasses of Node should have
    // a static getType and clone method though. We define getType and clone here so we can call it
    // on any  Node, and we throw this error by default since the subclass should provide
    // their own implementation.
    /**
     * Returns the string type of this node. Every node must
     * implement this and it MUST BE UNIQUE amongst nodes registered
     * on the editor.
     *
     */
    static getType() {
      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);
    }
    /**
     * Clones this node, creating a new node with a different key
     * and adding it to the EditorState (but not attaching it anywhere!). All nodes must
     * implement this method.
     *
     */
    static clone(i) {
      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);
    }
    constructor(i) {
      this.__type = this.constructor.getType(), this.__parent = null, this.__prev = null, this.__next = null, Dn(this, i), this.__type !== "root" && (jn(), sn(
        this.__type,
        // @ts-expect-error
        this.constructor
      ));
    }
    // Getters and Traversers
    /**
     * Returns the string type of this node.
     */
    getType() {
      return this.__type;
    }
    /**
     * Returns true if there is a path between this node and the RootNode, false otherwise.
     * This is a way of determining if the node is "attached" EditorState. Unattached nodes
     * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.
     */
    isAttached() {
      let i = this.__key;
      for (; i !== null; ) {
        if (i === "root")
          return !0;
        const a = gn(i);
        if (a === null)
          break;
        i = a.__parent;
      }
      return !1;
    }
    /**
     * Returns true if this node is contained within the provided Selection., false otherwise.
     * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine
     * what's included.
     *
     * @param selection - The selection that we want to determine if the node is in.
     */
    isSelected(i) {
      const a = i || en();
      if (a == null)
        return !1;
      const u = a.getNodes().some((p) => p.__key === this.__key);
      return dt(this) ? u : ft(a) && a.anchor.type === "element" && a.focus.type === "element" && a.anchor.key === a.focus.key && a.anchor.offset === a.focus.offset ? !1 : u;
    }
    /**
     * Returns this nodes key.
     */
    getKey() {
      return this.__key;
    }
    /**
     * Returns the zero-based index of this node within the parent.
     */
    getIndexWithinParent() {
      const i = this.getParent();
      if (i === null)
        return -1;
      let a = i.getFirstChild(), u = 0;
      for (; a !== null; ) {
        if (this.is(a))
          return u;
        u++, a = a.getNextSibling();
      }
      return -1;
    }
    /**
     * Returns the parent of this node, or null if none is found.
     */
    getParent() {
      const i = this.getLatest().__parent;
      return i === null ? null : gn(i);
    }
    /**
     * Returns the parent of this node, or throws if none is found.
     */
    getParentOrThrow() {
      const i = this.getParent();
      if (i === null)
        throw Error(`Expected node ${this.__key} to have a parent.`);
      return i;
    }
    /**
     * Returns the highest (in the EditorState tree)
     * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}
     * for more information on which Elements comprise "roots".
     */
    getTopLevelElement() {
      let i = this;
      for (; i !== null; ) {
        const a = i.getParent();
        if (Or(a))
          return i;
        i = a;
      }
      return null;
    }
    /**
     * Returns the highest (in the EditorState tree)
     * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}
     * for more information on which Elements comprise "roots".
     */
    getTopLevelElementOrThrow() {
      const i = this.getTopLevelElement();
      if (i === null)
        throw Error(`Expected node ${this.__key} to have a top parent element.`);
      return i;
    }
    /**
     * Returns a list of the every ancestor of this node,
     * all the way up to the RootNode.
     *
     */
    getParents() {
      const i = [];
      let a = this.getParent();
      for (; a !== null; )
        i.push(a), a = a.getParent();
      return i;
    }
    /**
     * Returns a list of the keys of every ancestor of this node,
     * all the way up to the RootNode.
     *
     */
    getParentKeys() {
      const i = [];
      let a = this.getParent();
      for (; a !== null; )
        i.push(a.__key), a = a.getParent();
      return i;
    }
    /**
     * Returns the "previous" siblings - that is, the node that comes
     * before this one in the same parent.
     *
     */
    getPreviousSibling() {
      const a = this.getLatest().__prev;
      return a === null ? null : gn(a);
    }
    /**
     * Returns the "previous" siblings - that is, the nodes that come between
     * this one and the first child of it's parent, inclusive.
     *
     */
    getPreviousSiblings() {
      const i = [], a = this.getParent();
      if (a === null)
        return i;
      let u = a.getFirstChild();
      for (; u !== null && !u.is(this); )
        i.push(u), u = u.getNextSibling();
      return i;
    }
    /**
     * Returns the "next" siblings - that is, the node that comes
     * after this one in the same parent
     *
     */
    getNextSibling() {
      const a = this.getLatest().__next;
      return a === null ? null : gn(a);
    }
    /**
     * Returns all "next" siblings - that is, the nodes that come between this
     * one and the last child of it's parent, inclusive.
     *
     */
    getNextSiblings() {
      const i = [];
      let a = this.getNextSibling();
      for (; a !== null; )
        i.push(a), a = a.getNextSibling();
      return i;
    }
    /**
     * Returns the closest common ancestor of this node and the provided one or null
     * if one cannot be found.
     *
     * @param node - the other node to find the common ancestor of.
     */
    getCommonAncestor(i) {
      const a = this.getParents(), u = i.getParents();
      Ze(this) && a.unshift(this), Ze(i) && u.unshift(i);
      const p = a.length, y = u.length;
      if (p === 0 || y === 0 || a[p - 1] !== u[y - 1])
        return null;
      const M = new Set(u);
      for (let $ = 0; $ < p; $++) {
        const le = a[$];
        if (M.has(le))
          return le;
      }
      return null;
    }
    /**
     * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.
     * Always use this instead of referential equality.
     *
     * @param object - the node to perform the equality comparison on.
     */
    is(i) {
      return i == null ? !1 : this.__key === i.__key;
    }
    /**
     * Returns true if this node logical precedes the target node in the editor state.
     *
     * @param targetNode - the node we're testing to see if it's after this one.
     */
    isBefore(i) {
      if (this === i)
        return !1;
      if (i.isParentOf(this))
        return !0;
      if (this.isParentOf(i))
        return !1;
      const a = this.getCommonAncestor(i);
      let u = 0, p = 0, y = this;
      for (; ; ) {
        const M = y.getParentOrThrow();
        if (M === a) {
          u = y.getIndexWithinParent();
          break;
        }
        y = M;
      }
      for (y = i; ; ) {
        const M = y.getParentOrThrow();
        if (M === a) {
          p = y.getIndexWithinParent();
          break;
        }
        y = M;
      }
      return u < p;
    }
    /**
     * Returns true if this node is the parent of the target node, false otherwise.
     *
     * @param targetNode - the would-be child node.
     */
    isParentOf(i) {
      const a = this.__key;
      if (a === i.__key)
        return !1;
      let u = i;
      for (; u !== null; ) {
        if (u.__key === a)
          return !0;
        u = u.getParent();
      }
      return !1;
    }
    // TO-DO: this function can be simplified a lot
    /**
     * Returns a list of nodes that are between this node and
     * the target node in the EditorState.
     *
     * @param targetNode - the node that marks the other end of the range of nodes to be returned.
     */
    getNodesBetween(i) {
      const a = this.isBefore(i), u = [], p = /* @__PURE__ */ new Set();
      let y = this;
      for (; ; ) {
        const M = y.__key;
        if (p.has(M) || (p.add(M), u.push(y)), y === i)
          break;
        const $ = Ze(y) ? a ? y.getFirstChild() : y.getLastChild() : null;
        if ($ !== null) {
          y = $;
          continue;
        }
        const le = a ? y.getNextSibling() : y.getPreviousSibling();
        if (le !== null) {
          y = le;
          continue;
        }
        const fe = y.getParentOrThrow();
        if (p.has(fe.__key) || u.push(fe), fe === i)
          break;
        let Ce = null, Ee = fe;
        do {
          if (Ee === null)
            throw Error("getNodesBetween: ancestor is null");
          Ce = a ? Ee.getNextSibling() : Ee.getPreviousSibling(), Ee = Ee.getParent(), Ee !== null && Ce === null && !p.has(Ee.__key) && u.push(Ee);
        } while (Ce === null);
        y = Ce;
      }
      return a || u.reverse(), u;
    }
    /**
     * Returns true if this node has been marked dirty during this update cycle.
     *
     */
    isDirty() {
      const a = ln()._dirtyLeaves;
      return a !== null && a.has(this.__key);
    }
    /**
     * Returns the latest version of the node from the active EditorState.
     * This is used to avoid getting values from stale node references.
     *
     */
    getLatest() {
      const i = gn(this.__key);
      if (i === null)
        throw Error("Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.");
      return i;
    }
    /**
     * Returns a mutable version of the node. Will throw an error if
     * called outside of a Lexical Editor {@link LexicalEditor.update} callback.
     *
     */
    getWritable() {
      jn();
      const i = gi(), a = ln(), u = i._nodeMap, p = this.__key, y = this.getLatest(), M = y.__parent, $ = a._cloneNotNeeded, le = en();
      if (cr(le) && le.setCachedNodes(null), $.has(p))
        return Ki(y), y;
      const Ce = y.constructor.clone(y);
      return Ce.__parent = M, Ce.__next = y.__next, Ce.__prev = y.__prev, Ze(y) && Ze(Ce) ? (Ce.__first = y.__first, Ce.__last = y.__last, Ce.__size = y.__size, Ce.__indent = y.__indent, Ce.__format = y.__format, Ce.__dir = y.__dir) : dt(y) && dt(Ce) && (Ce.__format = y.__format, Ce.__style = y.__style, Ce.__mode = y.__mode, Ce.__detail = y.__detail), $.add(p), Ce.__key = p, Ki(Ce), u.set(p, Ce), Ce;
    }
    /**
     * Returns the text content of the node. Override this for
     * custom nodes that should have a representation in plain text
     * format (for copy + paste, for example)
     *
     */
    getTextContent() {
      return "";
    }
    /**
     * Returns the length of the string produced by calling getTextContent on this node.
     *
     */
    getTextContentSize() {
      return this.getTextContent().length;
    }
    // View
    /**
     * Called during the reconciliation process to determine which nodes
     * to insert into the DOM for this Lexical Node.
     *
     * This method must return exactly one HTMLElement. Nested elements are not supported.
     *
     * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.
     *
     * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.
     * @param _editor - allows access to the editor for context during reconciliation.
     *
     * */
    createDOM(i, a) {
      throw Error("createDOM: base method not extended");
    }
    /**
     * Called when a node changes and should update the DOM
     * in whatever way is necessary to make it align with any changes that might
     * have happened during the update.
     *
     * Returning "true" here will cause lexical to unmount and recreate the DOM node
     * (by calling createDOM). You would need to do this if the element tag changes,
     * for instance.
     *
     * */
    updateDOM(i, a, u) {
      throw Error("updateDOM: base method not extended");
    }
    /**
     * Controls how the this node is serialized to HTML. This is important for
     * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,
     * in which case the primary transfer format is HTML. It's also important if you're serializing
     * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could
     * also use this method to build your own HTML renderer.
     *
     * */
    exportDOM(i) {
      return {
        element: this.createDOM(i._config, i)
      };
    }
    /**
     * Controls how the this node is serialized to JSON. This is important for
     * copy and paste between Lexical editors sharing the same namespace. It's also important
     * if you're serializing to JSON for persistent storage somewhere.
     * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).
     *
     * */
    exportJSON() {
      throw Error("exportJSON: base method not extended");
    }
    /**
     * Controls how the this node is deserialized from JSON. This is usually boilerplate,
     * but provides an abstraction between the node implementation and serialized interface that can
     * be important if you ever make breaking changes to a node schema (by adding or removing properties).
     * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).
     *
     * */
    static importJSON(i) {
      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);
    }
    /**
     * @experimental
     *
     * Registers the returned function as a transform on the node during
     * Editor initialization. Most such use cases should be addressed via
     * the {@link LexicalEditor.registerNodeTransform} API.
     *
     * Experimental - use at your own risk.
     */
    static transform() {
      return null;
    }
    // Setters and mutators
    /**
     * Removes this LexicalNode from the EditorState. If the node isn't re-inserted
     * somewhere, the Lexical garbage collector will eventually clean it up.
     *
     * @param preserveEmptyParent - If falsy, the node's parent will be removed if
     * it's empty after the removal operation. This is the default behavior, subject to
     * other node heuristics such as {@link ElementNode#canBeEmpty}
     * */
    remove(i) {
      Nt(this, !0, i);
    }
    /**
     * Replaces this LexicalNode with the provided node, optionally transferring the children
     * of the replaced node to the replacing node.
     *
     * @param replaceWith - The node to replace this one with.
     * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.
     * */
    replace(i, a) {
      jn();
      let u = en();
      u !== null && (u = u.clone()), Rr(this, i);
      const p = this.getLatest(), y = this.__key, M = i.__key, $ = i.getWritable(), le = this.getParentOrThrow().getWritable(), fe = le.__size;
      ei($);
      const Ce = p.getPreviousSibling(), Ee = p.getNextSibling(), xe = p.__prev, Ne = p.__next, Ke = p.__parent;
      if (Nt(p, !1, !0), Ce === null)
        le.__first = M;
      else {
        const Ie = Ce.getWritable();
        Ie.__next = M;
      }
      if ($.__prev = xe, Ee === null)
        le.__last = M;
      else {
        const Ie = Ee.getWritable();
        Ie.__prev = M;
      }
      if ($.__next = Ne, $.__parent = Ke, le.__size = fe, a && this.getChildren().forEach((Ie) => {
        $.append(Ie);
      }), ft(u)) {
        _r(u);
        const Ie = u.anchor, Ae = u.focus;
        Ie.key === y && Ul(Ie, $), Ae.key === y && Ul(Ae, $);
      }
      return vr() === y && un(M), $;
    }
    /**
     * Inserts a node after this LexicalNode (as the next sibling).
     *
     * @param nodeToInsert - The node to insert after this one.
     * @param restoreSelection - Whether or not to attempt to resolve the
     * selection to the appropriate place after the operation is complete.
     * */
    insertAfter(i, a = !0) {
      jn(), Rr(this, i);
      const u = this.getWritable(), p = i.getWritable(), y = p.getParent(), M = en();
      let $ = !1, le = !1;
      if (y !== null) {
        const Ne = i.getIndexWithinParent();
        if (ei(p), ft(M)) {
          const Ke = y.__key, Ie = M.anchor, Ae = M.focus;
          $ = Ie.type === "element" && Ie.key === Ke && Ie.offset === Ne + 1, le = Ae.type === "element" && Ae.key === Ke && Ae.offset === Ne + 1;
        }
      }
      const fe = this.getNextSibling(), Ce = this.getParentOrThrow().getWritable(), Ee = p.__key, xe = u.__next;
      if (fe === null)
        Ce.__last = Ee;
      else {
        const Ne = fe.getWritable();
        Ne.__prev = Ee;
      }
      if (Ce.__size++, u.__next = Ee, p.__next = xe, p.__prev = u.__key, p.__parent = u.__parent, a && ft(M)) {
        const Ne = this.getIndexWithinParent();
        zl(M, Ce, Ne + 1);
        const Ke = Ce.__key;
        $ && M.anchor.set(Ke, Ne + 2, "element"), le && M.focus.set(Ke, Ne + 2, "element");
      }
      return i;
    }
    /**
     * Inserts a node before this LexicalNode (as the previous sibling).
     *
     * @param nodeToInsert - The node to insert after this one.
     * @param restoreSelection - Whether or not to attempt to resolve the
     * selection to the appropriate place after the operation is complete.
     * */
    insertBefore(i, a = !0) {
      jn(), Rr(this, i);
      const u = this.getWritable(), p = i.getWritable(), y = p.__key;
      ei(p);
      const M = this.getPreviousSibling(), $ = this.getParentOrThrow().getWritable(), le = u.__prev, fe = this.getIndexWithinParent();
      if (M === null)
        $.__first = y;
      else {
        const Ee = M.getWritable();
        Ee.__next = y;
      }
      $.__size++, u.__prev = y, p.__prev = le, p.__next = u.__key, p.__parent = u.__parent;
      const Ce = en();
      if (a && ft(Ce)) {
        const Ee = this.getParentOrThrow();
        zl(Ce, Ee, fe);
      }
      return i;
    }
    /**
     * Whether or not this node has a required parent. Used during copy + paste operations
     * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without
     * a ListNode parent or TextNodes with a ParagraphNode parent.
     *
     * */
    isParentRequired() {
      return !1;
    }
    /**
     * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.
     *
     * */
    createParentElementNode() {
      return Ai();
    }
    selectStart() {
      return this.selectPrevious();
    }
    selectEnd() {
      return this.selectNext(0, 0);
    }
    /**
     * Moves selection to the previous sibling of this node, at the specified offsets.
     *
     * @param anchorOffset - The anchor offset for selection.
     * @param focusOffset -  The focus offset for selection
     * */
    selectPrevious(i, a) {
      jn();
      const u = this.getPreviousSibling(), p = this.getParentOrThrow();
      if (u === null)
        return p.select(0, 0);
      if (Ze(u))
        return u.select();
      if (!dt(u)) {
        const y = u.getIndexWithinParent() + 1;
        return p.select(y, y);
      }
      return u.select(i, a);
    }
    /**
     * Moves selection to the next sibling of this node, at the specified offsets.
     *
     * @param anchorOffset - The anchor offset for selection.
     * @param focusOffset -  The focus offset for selection
     * */
    selectNext(i, a) {
      jn();
      const u = this.getNextSibling(), p = this.getParentOrThrow();
      if (u === null)
        return p.select();
      if (Ze(u))
        return u.select(0, 0);
      if (!dt(u)) {
        const y = u.getIndexWithinParent();
        return p.select(y, y);
      }
      return u.select(i, a);
    }
    /**
     * Marks a node dirty, triggering transforms and
     * forcing it to be reconciled during the update cycle.
     *
     * */
    markDirty() {
      this.getWritable();
    }
  }
  function sn(c, i) {
    const a = ln()._nodes.get(c);
    if (a === void 0)
      throw Error(`Create node: Attempted to create node ${i.name} that was not configured to be used on the editor.`);
    const u = a.klass;
    if (u !== i)
      throw Error(`Create node: Type ${c} in node ${i.name} does not match registered node ${u.name} with the same type`);
  }
  function Xn(c, i, a) {
    const u = a || i.getParentOrThrow().getLastChild();
    let p = i;
    const y = [i];
    for (; p !== u; ) {
      if (!p.getNextSibling())
        throw Error("insertRangeAfter: lastToInsert must be a later sibling of firstToInsert");
      p = p.getNextSibling(), y.push(p);
    }
    let M = c;
    for (const $ of y)
      M = M.insertAfter($);
  }
  class Ar extends Ot {
    static getType() {
      return "linebreak";
    }
    static clone(i) {
      return new Ar(i.__key);
    }
    constructor(i) {
      super(i);
    }
    getTextContent() {
      return `
`;
    }
    createDOM() {
      return document.createElement("br");
    }
    updateDOM() {
      return !1;
    }
    static importDOM() {
      return {
        br: (i) => {
          const a = i.parentElement;
          let u, p;
          return a !== null && ((u = a.firstChild) === i || u.nextSibling === i && u.nodeType === Ye && (u.textContent || "").match(/^( |\t|\r?\n)+$/) !== null) && ((p = a.lastChild) === i || p.previousSibling === i && p.nodeType === Ye && (p.textContent || "").match(/^( |\t|\r?\n)+$/) !== null) ? null : {
            conversion: jr,
            priority: 0
          };
        }
      };
    }
    static importJSON(i) {
      return ci();
    }
    exportJSON() {
      return {
        type: "linebreak",
        version: 1
      };
    }
  }
  function jr(c) {
    return {
      node: ci()
    };
  }
  function ci() {
    return Yi(new Ar());
  }
  function ui(c) {
    return c instanceof Ar;
  }
  function to(c, i) {
    return i & Ve ? "code" : i & At ? "mark" : i & Qe ? "sub" : i & ct ? "sup" : null;
  }
  function Gs(c, i) {
    return i & Oe ? "strong" : i & be ? "em" : "span";
  }
  function as(c, i, a, u, p) {
    const y = u.classList;
    let M = Ei(p, "base");
    M !== void 0 && y.add(...M), M = Ei(p, "underlineStrikethrough");
    let $ = !1;
    const le = i & He && i & Re, fe = a & He && a & Re;
    M !== void 0 && (fe ? ($ = !0, le || y.add(...M)) : le && y.remove(...M));
    for (const Ce in on) {
      const xe = on[Ce];
      if (M = Ei(p, Ce), M !== void 0)
        if (a & xe) {
          if ($ && (Ce === "underline" || Ce === "strikethrough")) {
            i & xe && y.remove(...M);
            continue;
          }
          (!(i & xe) || le && Ce === "underline" || Ce === "strikethrough") && y.add(...M);
        } else
          i & xe && y.remove(...M);
    }
  }
  function br(c, i) {
    const a = c.length, u = i.length;
    let p = 0, y = 0;
    for (; p < a && p < u && c[p] === i[p]; )
      p++;
    for (; y + p < a && y + p < u && c[a - y - 1] === i[u - y - 1]; )
      y++;
    return [p, a - p - y, i.slice(p, u - y)];
  }
  function no(c, i, a) {
    const u = i.firstChild, p = a.isComposing(), M = c + (p ? Kt : "");
    if (u == null)
      i.textContent = M;
    else {
      const $ = u.nodeValue;
      if ($ !== M)
        if (p || Me) {
          const [le, fe, Ce] = br($, M);
          fe !== 0 && u.deleteData(le, fe), u.insertData(le, Ce);
        } else
          u.nodeValue = M;
    }
  }
  function cs(c, i, a, u, p, y) {
    no(p, c, i);
    const $ = y.theme.text;
    $ !== void 0 && as(a, 0, u, c, $);
  }
  function Ro(c, i) {
    const a = document.createElement(i);
    return a.appendChild(c), a;
  }
  class wi extends Ot {
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    static getType() {
      return "text";
    }
    static clone(i) {
      return new wi(i.__text, i.__key);
    }
    constructor(i, a) {
      super(a), this.__text = i, this.__format = 0, this.__style = "", this.__mode = 0, this.__detail = 0;
    }
    /**
     * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the
     * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.
     *
     * @returns a number representing the format of the text node.
     */
    getFormat() {
      return this.getLatest().__format;
    }
    /**
     * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the
     * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless
     * or TextNode.isUnmergeable instead.
     *
     * @returns a number representing the detail of the text node.
     */
    getDetail() {
      return this.getLatest().__detail;
    }
    /**
     * Returns the mode (TextModeType) of the TextNode, which may be "normal", "token", or "segmented"
     *
     * @returns TextModeType.
     */
    getMode() {
      const i = this.getLatest();
      return Ge[i.__mode];
    }
    /**
     * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.
     *
     * @returns CSSText-like string of styles applied to the underlying DOM node.
     */
    getStyle() {
      return this.getLatest().__style;
    }
    /**
     * Returns whether or not the node is in "token" mode. TextNodes in token mode can be navigated through character-by-character
     * with a RangeSelection, but are deleted as a single entity (not invdividually by character).
     *
     * @returns true if the node is in token mode, false otherwise.
     */
    isToken() {
      return this.getLatest().__mode === se;
    }
    /**
     *
     * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to
     * mutate the TextNode, false otherwise.
     */
    isComposing() {
      return this.__key === vr();
    }
    /**
     * Returns whether or not the node is in "segemented" mode. TextNodes in segemented mode can be navigated through character-by-character
     * with a RangeSelection, but are deleted in space-delimited "segments".
     *
     * @returns true if the node is in segmented mode, false otherwise.
     */
    isSegmented() {
      return this.getLatest().__mode === he;
    }
    /**
     * Returns whether or not the node is "directionless". Directionless nodes don't respect changes between RTL and LTR modes.
     *
     * @returns true if the node is directionless, false otherwise.
     */
    isDirectionless() {
      return (this.getLatest().__detail & qe) !== 0;
    }
    /**
     * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge
     * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.
     *
     * @returns true if the node is unmergeable, false otherwise.
     */
    isUnmergeable() {
      return (this.getLatest().__detail & nt) !== 0;
    }
    /**
     * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType
     * string values to get the format of a TextNode.
     *
     * @param type - the TextFormatType to check for.
     *
     * @returns true if the node has the provided format, false otherwise.
     */
    hasFormat(i) {
      const a = on[i];
      return (this.getFormat() & a) !== 0;
    }
    /**
     * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type "text"
     * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).
     *
     * @returns true if the node is simple text, false otherwise.
     */
    isSimpleText() {
      return this.__type === "text" && this.__mode === 0;
    }
    /**
     * Returns the text content of the node as a string.
     *
     * @returns a string representing the text content of the node.
     */
    getTextContent() {
      return this.getLatest().__text;
    }
    /**
     * Returns the format flags applied to the node as a 32-bit integer.
     *
     * @returns a number representing the TextFormatTypes applied to the node.
     */
    getFormatFlags(i, a) {
      const p = this.getLatest().__format;
      return pr(p, i, a);
    }
    // View
    createDOM(i) {
      const a = this.__format, u = to(this, a), p = Gs(this, a), y = u === null ? p : u, M = document.createElement(y);
      let $ = M;
      this.hasFormat("code") && M.setAttribute("spellcheck", "false"), u !== null && ($ = document.createElement(p), M.appendChild($));
      const le = this.__text;
      cs($, this, p, a, le, i);
      const fe = this.__style;
      return fe !== "" && (M.style.cssText = fe), M;
    }
    updateDOM(i, a, u) {
      const p = this.__text, y = i.__format, M = this.__format, $ = to(this, y), le = to(this, M), fe = Gs(this, y), Ce = Gs(this, M);
      if (($ === null ? fe : $) !== (le === null ? Ce : le))
        return !0;
      if ($ === le && fe !== Ce) {
        const We = a.firstChild;
        if (We == null)
          throw Error("updateDOM: prevInnerDOM is null or undefined");
        const tt = document.createElement(Ce);
        return cs(tt, this, Ce, M, p, u), a.replaceChild(tt, We), !1;
      }
      let Ne = a;
      if (le !== null && $ !== null && (Ne = a.firstChild, Ne == null))
        throw Error("updateDOM: innerDOM is null or undefined");
      no(p, Ne, this);
      const Ie = u.theme.text;
      Ie !== void 0 && y !== M && as(Ce, y, M, Ne, Ie);
      const Ae = i.__style, ht = this.__style;
      return Ae !== ht && (a.style.cssText = ht), !1;
    }
    static importDOM() {
      return {
        "#text": () => ({
          conversion: js,
          priority: 0
        }),
        b: () => ({
          conversion: Bl,
          priority: 0
        }),
        code: () => ({
          conversion: Mr,
          priority: 0
        }),
        em: () => ({
          conversion: Mr,
          priority: 0
        }),
        i: () => ({
          conversion: Mr,
          priority: 0
        }),
        s: () => ({
          conversion: Mr,
          priority: 0
        }),
        span: () => ({
          conversion: Fl,
          priority: 0
        }),
        strong: () => ({
          conversion: Mr,
          priority: 0
        }),
        sub: () => ({
          conversion: Mr,
          priority: 0
        }),
        sup: () => ({
          conversion: Mr,
          priority: 0
        }),
        u: () => ({
          conversion: Mr,
          priority: 0
        })
      };
    }
    static importJSON(i) {
      const a = Mn(i.text);
      return a.setFormat(i.format), a.setDetail(i.detail), a.setMode(i.mode), a.setStyle(i.style), a;
    }
    // This improves Lexical's basic text output in copy+paste plus
    // for headless mode where people might use Lexical to generate
    // HTML content and not have the ability to use CSS classes.
    exportDOM(i) {
      let {
        element: a
      } = super.exportDOM(i);
      if (!(a !== null && To(a)))
        throw Error("Expected TextNode createDOM to always return a HTMLElement");
      return a.style.whiteSpace = "pre-wrap", this.hasFormat("bold") && (a = Ro(a, "b")), this.hasFormat("italic") && (a = Ro(a, "i")), this.hasFormat("strikethrough") && (a = Ro(a, "s")), this.hasFormat("underline") && (a = Ro(a, "u")), {
        element: a
      };
    }
    exportJSON() {
      return {
        detail: this.getDetail(),
        format: this.getFormat(),
        mode: this.getMode(),
        style: this.getStyle(),
        text: this.getTextContent(),
        type: "text",
        version: 1
      };
    }
    // Mutators
    selectionTransform(i, a) {
    }
    /**
     * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType
     * version of the argument can only specify one format and doing so will remove all other formats that
     * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}
     *
     * @param format - TextFormatType or 32-bit integer representing the node format.
     *
     * @returns this TextNode.
     * // TODO 0.12 This should just be a `string`.
     */
    setFormat(i) {
      const a = this.getWritable();
      return a.__format = typeof i == "string" ? on[i] : i, a;
    }
    /**
     * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType
     * version of the argument can only specify one detail value and doing so will remove all other detail values that
     * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}
     * or {@link TextNode.togglerUnmergeable}
     *
     * @param detail - TextDetailType or 32-bit integer representing the node detail.
     *
     * @returns this TextNode.
     * // TODO 0.12 This should just be a `string`.
     */
    setDetail(i) {
      const a = this.getWritable();
      return a.__detail = typeof i == "string" ? rr[i] : i, a;
    }
    /**
     * Sets the node style to the provided CSSText-like string. Set this property as you
     * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.
     *
     * @param style - CSSText to be applied to the underlying HTMLElement.
     *
     * @returns this TextNode.
     */
    setStyle(i) {
      const a = this.getWritable();
      return a.__style = i, a;
    }
    /**
     * Applies the provided format to this TextNode if it's not present. Removes it if it's present.
     * The subscript and superscript formats are mutually exclusive.
     * Prefer using this method to turn specific formats on and off.
     *
     * @param type - TextFormatType to toggle.
     *
     * @returns this TextNode.
     */
    toggleFormat(i) {
      const a = this.getFormat(), u = pr(a, i, null);
      return this.setFormat(u);
    }
    /**
     * Toggles the directionless detail value of the node. Prefer using this method over setDetail.
     *
     * @returns this TextNode.
     */
    toggleDirectionless() {
      const i = this.getWritable();
      return i.__detail ^= qe, i;
    }
    /**
     * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.
     *
     * @returns this TextNode.
     */
    toggleUnmergeable() {
      const i = this.getWritable();
      return i.__detail ^= nt, i;
    }
    /**
     * Sets the mode of the node.
     *
     * @returns this TextNode.
     */
    setMode(i) {
      const a = ye[i];
      if (this.__mode === a)
        return this;
      const u = this.getWritable();
      return u.__mode = a, u;
    }
    /**
     * Sets the text content of the node.
     *
     * @param text - the string to set as the text value of the node.
     *
     * @returns this TextNode.
     */
    setTextContent(i) {
      if (this.__text === i)
        return this;
      const a = this.getWritable();
      return a.__text = i, a;
    }
    /**
     * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.
     *
     * @param _anchorOffset - the offset at which the Selection anchor will be placed.
     * @param _focusOffset - the offset at which the Selection focus will be placed.
     *
     * @returns the new RangeSelection.
     */
    select(i, a) {
      jn();
      let u = i, p = a;
      const y = en(), M = this.getTextContent(), $ = this.__key;
      if (typeof M == "string") {
        const le = M.length;
        u === void 0 && (u = le), p === void 0 && (p = le);
      } else
        u = 0, p = 0;
      if (ft(y)) {
        const le = vr();
        (le === y.anchor.key || le === y.focus.key) && un($), y.setTextNodeRange(this, u, this, p);
      } else
        return tu($, u, $, p, "text", "text");
      return y;
    }
    selectStart() {
      return this.select(0, 0);
    }
    selectEnd() {
      const i = this.getTextContentSize();
      return this.select(i, i);
    }
    /**
     * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters
     * specified. Can optionally calculate a new selection after the operation is complete.
     *
     * @param offset - the offset at which the splice operation should begin.
     * @param delCount - the number of characters to delete, starting from the offset.
     * @param newText - the text to insert into the TextNode at the offset.
     * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.
     *
     * @returns this TextNode.
     */
    spliceText(i, a, u, p) {
      const y = this.getWritable(), M = y.__text, $ = u.length;
      let le = i;
      le < 0 && (le = $ + le, le < 0 && (le = 0));
      const fe = en();
      if (p && ft(fe)) {
        const Ee = i + $;
        fe.setTextNodeRange(y, Ee, y, Ee);
      }
      const Ce = M.slice(0, le) + u + M.slice(le + a);
      return y.__text = Ce, y;
    }
    /**
     * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
     * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt
     * to insert text into this node. If false, it will insert the text in a new sibling node.
     *
     * @returns true if text can be inserted before the node, false otherwise.
     */
    canInsertTextBefore() {
      return !0;
    }
    /**
     * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
     * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt
     * to insert text into this node. If false, it will insert the text in a new sibling node.
     *
     * @returns true if text can be inserted after the node, false otherwise.
     */
    canInsertTextAfter() {
      return !0;
    }
    /**
     * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings
     * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.
     *
     * @param splitOffsets - rest param of the text content character offsets at which this node should be split.
     *
     * @returns an Array containing the newly-created TextNodes.
     */
    splitText(...i) {
      jn();
      const a = this.getLatest(), u = a.getTextContent(), p = a.__key, y = vr(), M = new Set(i), $ = [], le = u.length;
      let fe = "";
      for (let Tt = 0; Tt < le; Tt++)
        fe !== "" && M.has(Tt) && ($.push(fe), fe = ""), fe += u[Tt];
      fe !== "" && $.push(fe);
      const Ce = $.length;
      if (Ce === 0)
        return [];
      if ($[0] === u)
        return [a];
      const Ee = $[0], xe = a.getParentOrThrow();
      let Ne;
      const Ke = a.getFormat(), Ie = a.getStyle(), Ae = a.__detail;
      let ht = !1;
      a.isSegmented() ? (Ne = Mn(Ee), Ne.__format = Ke, Ne.__style = Ie, Ne.__detail = Ae, ht = !0) : (Ne = a.getWritable(), Ne.__text = Ee);
      const We = en(), tt = [Ne];
      let Pt = Ee.length;
      for (let Tt = 1; Tt < Ce; Tt++) {
        const $t = $[Tt], Gt = $t.length, an = Mn($t).getWritable();
        an.__format = Ke, an.__style = Ie, an.__detail = Ae;
        const zt = an.__key, Nn = Pt + Gt;
        if (ft(We)) {
          const Vr = We.anchor, bi = We.focus;
          Vr.key === p && Vr.type === "text" && Vr.offset > Pt && Vr.offset <= Nn && (Vr.key = zt, Vr.offset -= Pt, We.dirty = !0), bi.key === p && bi.type === "text" && bi.offset > Pt && bi.offset <= Nn && (bi.key = zt, bi.offset -= Pt, We.dirty = !0);
        }
        y === p && un(zt), Pt = Nn, tt.push(an);
      }
      Yo(this);
      const Rt = xe.getWritable(), mt = this.getIndexWithinParent();
      return ht ? (Rt.splice(mt, 0, tt), this.remove()) : Rt.splice(mt, 1, tt), ft(We) && zl(We, xe, mt, Ce - 1), tt;
    }
    /**
     * Merges the target TextNode into this TextNode, removing the target node.
     *
     * @param target - the TextNode to merge into this one.
     *
     * @returns this TextNode.
     */
    mergeWithSibling(i) {
      const a = i === this.getPreviousSibling();
      if (!a && i !== this.getNextSibling())
        throw Error("mergeWithSibling: sibling must be a previous or next sibling");
      const u = this.__key, p = i.__key, y = this.__text, M = y.length;
      vr() === p && un(u);
      const le = en();
      if (ft(le)) {
        const xe = le.anchor, Ne = le.focus;
        xe !== null && xe.key === p && (ru(xe, a, u, i, M), le.dirty = !0), Ne !== null && Ne.key === p && (ru(Ne, a, u, i, M), le.dirty = !0);
      }
      const fe = i.__text, Ce = a ? fe + y : y + fe;
      this.setTextContent(Ce);
      const Ee = this.getWritable();
      return i.remove(), Ee;
    }
    /**
     * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
     * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the
     * node class that you create and replace matched text with should return true from this method.
     *
     * @returns true if the node is to be treated as a "text entity", false otherwise.
     */
    isTextEntity() {
      return !1;
    }
  }
  function Fl(c) {
    const i = c, a = i.style.fontWeight === "700", u = i.style.textDecoration === "line-through", p = i.style.fontStyle === "italic", y = i.style.textDecoration === "underline", M = i.style.verticalAlign;
    return {
      forChild: ($) => (dt($) && (a && $.toggleFormat("bold"), u && $.toggleFormat("strikethrough"), p && $.toggleFormat("italic"), y && $.toggleFormat("underline"), M === "sub" && $.toggleFormat("subscript"), M === "super" && $.toggleFormat("superscript")), $),
      node: null
    };
  }
  function Bl(c) {
    const a = c.style.fontWeight === "normal";
    return {
      forChild: (u) => (dt(u) && !a && u.toggleFormat("bold"), u),
      node: null
    };
  }
  const Do = /* @__PURE__ */ new WeakMap();
  function Kl(c) {
    return c.nodeName === "PRE" || c.nodeType === Be && c.style !== void 0 && c.style.whiteSpace !== void 0 && c.style.whiteSpace.startsWith("pre");
  }
  function Ys(c) {
    let i, a = c.parentNode;
    const u = [c];
    for (; a !== null && (i = Do.get(a)) === void 0 && !Kl(a); )
      u.push(a), a = a.parentNode;
    const p = i === void 0 ? a : i;
    for (let y = 0; y < u.length; y++)
      Do.set(u[y], p);
    return p;
  }
  function js(c) {
    const i = c;
    if (c.parentElement === null)
      throw Error("Expected parentElement of Text not to be null");
    let u = i.textContent || "";
    if (Ys(i) !== null) {
      const p = u.split(/(\r?\n|\t)/), y = [], M = p.length;
      for (let $ = 0; $ < M; $++) {
        const le = p[$];
        le === `
` || le === `\r
` ? y.push(ci()) : le === "	" ? y.push(Oi()) : le !== "" && y.push(Mn(le));
      }
      return {
        node: y
      };
    }
    if (u = u.replace(/\r/g, "").replace(/[ \t\n]+/g, " "), u === "")
      return {
        node: null
      };
    if (u[0] === " ") {
      let p = i, y = !0;
      for (; p !== null && (p = ro(p, !1)) !== null; ) {
        const M = p.textContent || "";
        if (M.length > 0) {
          /[ \t\n]$/.test(M) && (u = u.slice(1)), y = !1;
          break;
        }
      }
      y && (u = u.slice(1));
    }
    if (u[u.length - 1] === " ") {
      let p = i, y = !0;
      for (; p !== null && (p = ro(p, !0)) !== null; )
        if ((p.textContent || "").replace(/^( |\t|\r?\n)+/, "").length > 0) {
          y = !1;
          break;
        }
      y && (u = u.slice(0, u.length - 1));
    }
    return u === "" ? {
      node: null
    } : {
      node: Mn(u)
    };
  }
  const Hl = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/, "i");
  function ro(c, i) {
    let a = c;
    for (; ; ) {
      let u;
      for (; (u = i ? a.nextSibling : a.previousSibling) === null; ) {
        const y = a.parentElement;
        if (y === null)
          return null;
        a = y;
      }
      if (a = u, a.nodeType === Be) {
        const y = a.style.display;
        if (y === "" && a.nodeName.match(Hl) === null || y !== "" && !y.startsWith("inline"))
          return null;
      }
      let p = a;
      for (; (p = i ? a.firstChild : a.lastChild) !== null; )
        a = p;
      if (a.nodeType === Ye)
        return a;
      if (a.nodeName === "BR")
        return null;
    }
  }
  const us = {
    code: "code",
    em: "italic",
    i: "italic",
    s: "strikethrough",
    strong: "bold",
    sub: "subscript",
    sup: "superscript",
    u: "underline"
  };
  function Mr(c) {
    const i = us[c.nodeName.toLowerCase()];
    return i === void 0 ? {
      node: null
    } : {
      forChild: (a) => (dt(a) && !a.hasFormat(i) && a.toggleFormat(i), a),
      node: null
    };
  }
  function Mn(c = "") {
    return Yi(new wi(c));
  }
  function dt(c) {
    return c instanceof wi;
  }
  class di extends wi {
    static getType() {
      return "tab";
    }
    static clone(i) {
      const a = new di(i.__key);
      return a.__text = i.__text, a.__format = i.__format, a.__style = i.__style, a;
    }
    constructor(i) {
      super("	", i), this.__detail = nt;
    }
    static importDOM() {
      return null;
    }
    static importJSON(i) {
      const a = Oi();
      return a.setFormat(i.format), a.setStyle(i.style), a;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "tab",
        version: 1
      };
    }
    setTextContent(i) {
      throw Error("TabNode does not support setTextContent");
    }
    setDetail(i) {
      throw Error("TabNode does not support setDetail");
    }
    setMode(i) {
      throw Error("TabNode does not support setMode");
    }
    canInsertTextBefore() {
      return !1;
    }
    canInsertTextAfter() {
      return !1;
    }
  }
  function Oi() {
    return Yi(new di());
  }
  function Ao(c) {
    return c instanceof di;
  }
  class fi {
    constructor(i, a, u) {
      this._selection = null, this.key = i, this.offset = a, this.type = u;
    }
    is(i) {
      return this.key === i.key && this.offset === i.offset && this.type === i.type;
    }
    isBefore(i) {
      let a = this.getNode(), u = i.getNode();
      const p = this.offset, y = i.offset;
      if (Ze(a)) {
        const M = a.getDescendantByIndex(p);
        a = M ?? a;
      }
      if (Ze(u)) {
        const M = u.getDescendantByIndex(y);
        u = M ?? u;
      }
      return a === u ? p < y : a.isBefore(u);
    }
    getNode() {
      const i = this.key, a = gn(i);
      if (a === null)
        throw Error("Point.getNode: node not found");
      return a;
    }
    set(i, a, u) {
      const p = this._selection, y = this.key;
      this.key = i, this.offset = a, this.type = u, hs() || (vr() === y && un(i), p !== null && (p.setCachedNodes(null), p.dirty = !0));
    }
  }
  function Lr(c, i, a) {
    return new fi(c, i, a);
  }
  function bo(c, i) {
    let a = i.__key, u = c.offset, p = "element";
    if (dt(i)) {
      p = "text";
      const y = i.getTextContentSize();
      u > y && (u = y);
    } else if (!Ze(i)) {
      const y = i.getNextSibling();
      if (dt(y))
        a = y.__key, u = 0, p = "text";
      else {
        const M = i.getParent();
        M && (a = M.__key, u = i.getIndexWithinParent() + 1);
      }
    }
    c.set(a, u, p);
  }
  function Ul(c, i) {
    if (Ze(i)) {
      const a = i.getLastDescendant();
      Ze(a) || dt(a) ? bo(c, a) : bo(c, i);
    } else
      bo(c, i);
  }
  function qs(c, i, a, u) {
    const p = c.getNode(), y = p.getChildAtIndex(c.offset), M = Mn(), $ = Er(p) ? Ai().append(M) : M;
    M.setFormat(a), M.setStyle(u), y === null ? p.append($) : y.insertBefore($), c.is(i) && i.set(M.__key, 0, "text"), c.set(M.__key, 0, "text");
  }
  function qr(c, i, a, u) {
    c.key = i, c.offset = a, c.type = u;
  }
  class qt {
    constructor(i, a) {
      this.anchor = i, this.focus = a, i._selection = this, a._selection = this, this._cachedNodes = null, this.dirty = !1;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(i) {
      this._cachedNodes = i;
    }
    is(i) {
      return cr(i) ? this.anchor.is(i.anchor) && this.focus.is(i.focus) : !1;
    }
    isCollapsed() {
      return !1;
    }
    extract() {
      return this.getNodes();
    }
    /**
     * Returns whether the Selection is "backwards", meaning the focus
     * logically precedes the anchor in the EditorState.
     * @returns true if the Selection is backwards, false otherwise.
     */
    isBackward() {
      return this.focus.isBefore(this.anchor);
    }
    /**
     * Returns the character-based offsets of the Selection, accounting for non-text Points
     * by using the children size or text content.
     *
     * @returns the character offsets for the Selection
     */
    getCharacterOffsets() {
      return Gn(this);
    }
  }
  class wn {
    constructor(i) {
      this.dirty = !1, this._nodes = i, this._cachedNodes = null;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(i) {
      this._cachedNodes = i;
    }
    is(i) {
      if (!ur(i))
        return !1;
      const a = this._nodes, u = i._nodes;
      return a.size === u.size && Array.from(a).every((p) => u.has(p));
    }
    add(i) {
      this.dirty = !0, this._nodes.add(i), this._cachedNodes = null;
    }
    delete(i) {
      this.dirty = !0, this._nodes.delete(i), this._cachedNodes = null;
    }
    clear() {
      this.dirty = !0, this._nodes.clear(), this._cachedNodes = null;
    }
    has(i) {
      return this._nodes.has(i);
    }
    clone() {
      return new wn(new Set(this._nodes));
    }
    extract() {
      return this.getNodes();
    }
    insertRawText(i) {
    }
    insertText() {
    }
    insertNodes(i) {
      const a = this.getNodes(), u = a.length, p = a[u - 1];
      let y;
      if (dt(p))
        y = p.select();
      else {
        const M = p.getIndexWithinParent() + 1;
        y = p.getParentOrThrow().select(M, M);
      }
      y.insertNodes(i);
      for (let M = 0; M < u; M++)
        a[M].remove();
    }
    getNodes() {
      const i = this._cachedNodes;
      if (i !== null)
        return i;
      const a = this._nodes, u = [];
      for (const p of a) {
        const y = gn(p);
        y !== null && u.push(y);
      }
      return hs() || (this._cachedNodes = u), u;
    }
    getTextContent() {
      const i = this.getNodes();
      let a = "";
      for (let u = 0; u < i.length; u++)
        a += i[u].getTextContent();
      return a;
    }
  }
  function ft(c) {
    return c instanceof On;
  }
  function cr(c) {
    return c instanceof qt;
  }
  function Ri(c) {
    const [i, , a] = ou(c), u = a.getChildren(), p = u.length, y = u[0].getChildren().length, M = new Array(p);
    for (let $ = 0; $ < p; $++)
      M[$] = new Array(y);
    for (let $ = 0; $ < p; $++) {
      const fe = u[$].getChildren();
      let Ce = 0;
      for (let Ee = 0; Ee < fe.length; Ee++) {
        for (; M[$][Ce]; )
          Ce++;
        const xe = fe[Ee], Ne = xe.__rowSpan || 1, Ke = xe.__colSpan || 1;
        for (let Ie = 0; Ie < Ne; Ie++)
          for (let Ae = 0; Ae < Ke; Ae++)
            M[$ + Ie][Ce + Ae] = xe;
        if (i === xe)
          return {
            colSpan: Ke,
            columnIndex: Ce,
            rowIndex: $,
            rowSpan: Ne
          };
        Ce += Ke;
      }
    }
    return null;
  }
  class zn extends qt {
    constructor(i, a, u) {
      super(a, u), this.gridKey = i;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(i) {
      this._cachedNodes = i;
    }
    is(i) {
      return Qn(i) ? this.gridKey === i.gridKey && this.anchor.is(i.anchor) && this.focus.is(i.focus) : !1;
    }
    set(i, a, u) {
      this.dirty = !0, this.gridKey = i, this.anchor.key = a, this.focus.key = u, this._cachedNodes = null;
    }
    clone() {
      return new zn(this.gridKey, this.anchor, this.focus);
    }
    isCollapsed() {
      return !1;
    }
    extract() {
      return this.getNodes();
    }
    insertRawText(i) {
    }
    insertText() {
    }
    insertNodes(i) {
      const a = this.focus.getNode();
      Ni(a.select(0, a.getChildrenSize())).insertNodes(i);
    }
    // TODO Deprecate this method. It's confusing when used with colspan|rowspan
    getShape() {
      const i = gn(this.anchor.key);
      if (!Pr(i))
        throw Error("Expected GridSelection anchor to be (or a child of) GridCellNode");
      const a = Ri(i);
      if (a === null)
        throw Error("getCellRect: expected to find AnchorNode");
      const u = gn(this.focus.key);
      if (!Pr(u))
        throw Error("Expected GridSelection focus to be (or a child of) GridCellNode");
      const p = Ri(u);
      if (p === null)
        throw Error("getCellRect: expected to find focusCellNode");
      const y = Math.min(a.columnIndex, p.columnIndex), M = Math.max(a.columnIndex, p.columnIndex), $ = Math.min(a.rowIndex, p.rowIndex), le = Math.max(a.rowIndex, p.rowIndex);
      return {
        fromX: Math.min(y, M),
        fromY: Math.min($, le),
        toX: Math.max(y, M),
        toY: Math.max($, le)
      };
    }
    getNodes() {
      const i = this._cachedNodes;
      if (i !== null)
        return i;
      const a = this.anchor.getNode(), u = this.focus.getNode(), p = No(a, Pr), y = No(u, Pr);
      if (!Pr(p))
        throw Error("Expected GridSelection anchor to be (or a child of) GridCellNode");
      if (!Pr(y))
        throw Error("Expected GridSelection focus to be (or a child of) GridCellNode");
      const M = p.getParent();
      if (!Js(M))
        throw Error("Expected anchorCell to have a parent GridRowNode");
      const $ = M.getParent();
      if (!Da($))
        throw Error("Expected tableNode to have a parent GridNode");
      const le = y.getParents()[1];
      if (le !== $) {
        if ($.isParentOf(y)) {
          const Tt = le.getParent();
          if (Tt == null)
            throw Error("Expected focusCellParent to have a parent");
          this.set(this.gridKey, y.getKey(), Tt.getKey());
        } else {
          const Tt = $.getParent();
          if (Tt == null)
            throw Error("Expected gridParent to have a parent");
          this.set(this.gridKey, Tt.getKey(), y.getKey());
        }
        return this.getNodes();
      }
      const [fe, Ce, Ee] = iu($, p, y);
      let xe = Math.min(Ce.startColumn, Ee.startColumn), Ne = Math.min(Ce.startRow, Ee.startRow), Ke = Math.max(Ce.startColumn + Ce.cell.__colSpan - 1, Ee.startColumn + Ee.cell.__colSpan - 1), Ie = Math.max(Ce.startRow + Ce.cell.__rowSpan - 1, Ee.startRow + Ee.cell.__rowSpan - 1), Ae = xe, ht = Ne, We = xe, tt = Ne;
      function Pt(Tt) {
        const {
          cell: $t,
          startColumn: Gt,
          startRow: an
        } = Tt;
        xe = Math.min(xe, Gt), Ne = Math.min(Ne, an), Ke = Math.max(Ke, Gt + $t.__colSpan - 1), Ie = Math.max(Ie, an + $t.__rowSpan - 1);
      }
      for (; xe < Ae || Ne < ht || Ke > We || Ie > tt; ) {
        if (xe < Ae) {
          const Tt = tt - ht, $t = Ae - 1;
          for (let Gt = 0; Gt <= Tt; Gt++)
            Pt(fe[ht + Gt][$t]);
          Ae = $t;
        }
        if (Ne < ht) {
          const Tt = We - Ae, $t = ht - 1;
          for (let Gt = 0; Gt <= Tt; Gt++)
            Pt(fe[$t][Ae + Gt]);
          ht = $t;
        }
        if (Ke > We) {
          const Tt = tt - ht, $t = We + 1;
          for (let Gt = 0; Gt <= Tt; Gt++)
            Pt(fe[ht + Gt][$t]);
          We = $t;
        }
        if (Ie > tt) {
          const Tt = We - Ae, $t = tt + 1;
          for (let Gt = 0; Gt <= Tt; Gt++)
            Pt(fe[$t][Ae + Gt]);
          tt = $t;
        }
      }
      const Rt = [$];
      let mt = null;
      for (let Tt = Ne; Tt <= Ie; Tt++)
        for (let $t = xe; $t <= Ke; $t++) {
          const {
            cell: Gt
          } = fe[Tt][$t], an = Gt.getParent();
          if (!Js(an))
            throw Error("Expected GridCellNode parent to be a GridRowNode");
          an !== mt && Rt.push(an), Rt.push(Gt, ...xi(Gt)), mt = an;
        }
      return hs() || (this._cachedNodes = Rt), Rt;
    }
    getTextContent() {
      const i = this.getNodes();
      let a = "";
      for (let u = 0; u < i.length; u++)
        a += i[u].getTextContent();
      return a;
    }
  }
  function Qn(c) {
    return c instanceof zn;
  }
  class On extends qt {
    constructor(i, a, u, p) {
      super(i, a), this.format = u, this.style = p;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(i) {
      this._cachedNodes = i;
    }
    /**
     * Used to check if the provided selections is equal to this one by value,
     * inluding anchor, focus, format, and style properties.
     * @param selection - the Selection to compare this one to.
     * @returns true if the Selections are equal, false otherwise.
     */
    is(i) {
      return ft(i) ? this.anchor.is(i.anchor) && this.focus.is(i.focus) && this.format === i.format && this.style === i.style : !1;
    }
    /**
     * Returns whether the Selection is "collapsed", meaning the anchor and focus are
     * the same node and have the same offset.
     *
     * @returns true if the Selection is collapsed, false otherwise.
     */
    isCollapsed() {
      return this.anchor.is(this.focus);
    }
    /**
     * Gets all the nodes in the Selection. Uses caching to make it generally suitable
     * for use in hot paths.
     *
     * @returns an Array containing all the nodes in the Selection
     */
    getNodes() {
      const i = this._cachedNodes;
      if (i !== null)
        return i;
      const a = this.anchor, u = this.focus, p = a.isBefore(u), y = p ? a : u, M = p ? u : a;
      let $ = y.getNode(), le = M.getNode();
      const fe = y.offset, Ce = M.offset;
      if (Ze($)) {
        const xe = $.getDescendantByIndex(fe);
        $ = xe ?? $;
      }
      if (Ze(le)) {
        let xe = le.getDescendantByIndex(Ce);
        xe !== null && xe !== $ && le.getChildAtIndex(Ce) === xe && (xe = xe.getPreviousSibling()), le = xe ?? le;
      }
      let Ee;
      return $.is(le) ? Ze($) && $.getChildrenSize() > 0 ? Ee = [] : Ee = [$] : Ee = $.getNodesBetween(le), hs() || (this._cachedNodes = Ee), Ee;
    }
    /**
     * Sets this Selection to be of type "text" at the provided anchor and focus values.
     *
     * @param anchorNode - the anchor node to set on the Selection
     * @param anchorOffset - the offset to set on the Selection
     * @param focusNode - the focus node to set on the Selection
     * @param focusOffset - the focus offset to set on the Selection
     */
    setTextNodeRange(i, a, u, p) {
      qr(this.anchor, i.__key, a, "text"), qr(this.focus, u.__key, p, "text"), this._cachedNodes = null, this.dirty = !0;
    }
    /**
     * Gets the (plain) text content of all the nodes in the selection.
     *
     * @returns a string representing the text content of all the nodes in the Selection
     */
    getTextContent() {
      const i = this.getNodes();
      if (i.length === 0)
        return "";
      const a = i[0], u = i[i.length - 1], p = this.anchor, y = this.focus, M = p.isBefore(y), [$, le] = Gn(this);
      let fe = "", Ce = !0;
      for (let Ee = 0; Ee < i.length; Ee++) {
        const xe = i[Ee];
        if (Ze(xe) && !xe.isInline())
          Ce || (fe += `
`), xe.isEmpty() ? Ce = !1 : Ce = !0;
        else if (Ce = !1, dt(xe)) {
          let Ne = xe.getTextContent();
          xe === a ? xe === u ? (p.type !== "element" || y.type !== "element" || y.offset === p.offset) && (Ne = $ < le ? Ne.slice($, le) : Ne.slice(le, $)) : Ne = M ? Ne.slice($) : Ne.slice(le) : xe === u && (Ne = M ? Ne.slice(0, le) : Ne.slice(0, $)), fe += Ne;
        } else
          (yn(xe) || ui(xe)) && (xe !== u || !this.isCollapsed()) && (fe += xe.getTextContent());
      }
      return fe;
    }
    /**
     * Attempts to map a DOM selection range onto this Lexical Selection,
     * setting the anchor, focus, and type accordingly
     *
     * @param range a DOM Selection range conforming to the StaticRange interface.
     */
    applyDOMRange(i) {
      const a = ln(), p = a.getEditorState()._selection, y = eu(i.startContainer, i.startOffset, i.endContainer, i.endOffset, a, p);
      if (y === null)
        return;
      const [M, $] = y;
      qr(this.anchor, M.key, M.offset, M.type), qr(this.focus, $.key, $.offset, $.type), this._cachedNodes = null;
    }
    /**
     * Creates a new RangeSelection, copying over all the property values from this one.
     *
     * @returns a new RangeSelection with the same property values as this one.
     */
    clone() {
      const i = this.anchor, a = this.focus;
      return new On(Lr(i.key, i.offset, i.type), Lr(a.key, a.offset, a.type), this.format, this.style);
    }
    /**
     * Toggles the provided format on all the TextNodes in the Selection.
     *
     * @param format a string TextFormatType to toggle on the TextNodes in the selection
     */
    toggleFormat(i) {
      this.format = pr(this.format, i, null), this.dirty = !0;
    }
    /**
     * Sets the value of the style property on the Selection
     *
     * @param style - the style to set at the value of the style property.
     */
    setStyle(i) {
      this.style = i, this.dirty = !0;
    }
    /**
     * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection
     * has the specified format.
     *
     * @param type the TextFormatType to check for.
     * @returns true if the provided format is currently toggled on on the Selection, false otherwise.
     */
    hasFormat(i) {
      const a = on[i];
      return (this.format & a) !== 0;
    }
    /**
     * Attempts to insert the provided text into the EditorState at the current Selection.
     * converts tabs, newlines, and carriage returns into LexicalNodes.
     *
     * @param text the text to insert into the Selection
     */
    insertRawText(i) {
      const a = i.split(/(\r?\n|\t)/), u = [], p = a.length;
      for (let y = 0; y < p; y++) {
        const M = a[y];
        M === `
` || M === `\r
` ? u.push(ci()) : M === "	" ? u.push(Oi()) : u.push(Mn(M));
      }
      this.insertNodes(u);
    }
    /**
     * Attempts to insert the provided text into the EditorState at the current Selection as a new
     * Lexical TextNode, according to a series of insertion heuristics based on the selection type and position.
     *
     * @param text the text to insert into the Selection
     */
    insertText(i) {
      const a = this.anchor, u = this.focus, p = this.isCollapsed() || a.isBefore(u), y = this.format, M = this.style;
      p && a.type === "element" ? qs(a, u, y, M) : !p && u.type === "element" && qs(u, a, y, M);
      const $ = this.getNodes(), le = $.length, fe = p ? a : u, Ce = p ? u : a, Ee = fe.offset, xe = Ce.offset;
      let Ne = $[0];
      if (!dt(Ne))
        throw Error("insertText: first node is not a text node");
      const Ie = Ne.getTextContent().length, Ae = Ne.getParentOrThrow(), ht = le - 1;
      let We = $[ht];
      if (this.isCollapsed() && Ee === Ie && (Ne.isSegmented() || Ne.isToken() || !Ne.canInsertTextAfter() || !Ae.canInsertTextAfter() && Ne.getNextSibling() === null)) {
        let tt = Ne.getNextSibling();
        if ((!dt(tt) || !tt.canInsertTextBefore() || Os(tt)) && (tt = Mn(), tt.setFormat(y), Ae.canInsertTextAfter() ? Ne.insertAfter(tt) : Ae.insertAfter(tt)), tt.select(0, 0), Ne = tt, i !== "") {
          this.insertText(i);
          return;
        }
      } else if (this.isCollapsed() && Ee === 0 && (Ne.isSegmented() || Ne.isToken() || !Ne.canInsertTextBefore() || !Ae.canInsertTextBefore() && Ne.getPreviousSibling() === null)) {
        let tt = Ne.getPreviousSibling();
        if ((!dt(tt) || Os(tt)) && (tt = Mn(), tt.setFormat(y), Ae.canInsertTextBefore() ? Ne.insertBefore(tt) : Ae.insertBefore(tt)), tt.select(), Ne = tt, i !== "") {
          this.insertText(i);
          return;
        }
      } else if (Ne.isSegmented() && Ee !== Ie) {
        const tt = Mn(Ne.getTextContent());
        tt.setFormat(y), Ne.replace(tt), Ne = tt;
      } else if (!this.isCollapsed() && i !== "") {
        const tt = We.getParent();
        if (!Ae.canInsertTextBefore() || !Ae.canInsertTextAfter() || Ze(tt) && (!tt.canInsertTextBefore() || !tt.canInsertTextAfter())) {
          this.insertText(""), Qc(this.anchor, this.focus, null), this.insertText(i);
          return;
        }
      }
      if (le === 1) {
        if (Ne.isToken()) {
          const mt = Mn(i);
          mt.select(), Ne.replace(mt);
          return;
        }
        const tt = Ne.getFormat(), Pt = Ne.getStyle();
        if (Ee === xe && (tt !== y || Pt !== M))
          if (Ne.getTextContent() === "")
            Ne.setFormat(y), Ne.setStyle(M);
          else {
            const mt = Mn(i);
            if (mt.setFormat(y), mt.setStyle(M), mt.select(), Ee === 0)
              Ne.insertBefore(mt, !1);
            else {
              const [Tt] = Ne.splitText(Ee);
              Tt.insertAfter(mt, !1);
            }
            mt.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= i.length);
            return;
          }
        else if (Ao(Ne)) {
          const mt = Mn(i);
          mt.setFormat(y), mt.setStyle(M), mt.select(), Ne.replace(mt);
          return;
        }
        const Rt = xe - Ee;
        Ne = Ne.spliceText(Ee, Rt, i, !0), Ne.getTextContent() === "" ? Ne.remove() : this.anchor.type === "text" && (Ne.isComposing() ? this.anchor.offset -= i.length : (this.format = tt, this.style = Pt));
      } else {
        const tt = /* @__PURE__ */ new Set([...Ne.getParentKeys(), ...We.getParentKeys()]), Pt = Ze(Ne) ? Ne : Ne.getParentOrThrow();
        let Rt = Ze(We) ? We : We.getParentOrThrow(), mt = We;
        if (!Pt.is(Rt) && Rt.isInline())
          do
            mt = Rt, Rt = Rt.getParentOrThrow();
          while (Rt.isInline());
        if (Ce.type === "text" && (xe !== 0 || We.getTextContent() === "") || Ce.type === "element" && We.getIndexWithinParent() < xe)
          if (dt(We) && !We.isToken() && xe !== We.getTextContentSize()) {
            if (We.isSegmented()) {
              const zt = Mn(We.getTextContent());
              We.replace(zt), We = zt;
            }
            !Er(Ce.getNode()) && Ce.type === "text" && (We = We.spliceText(0, xe, "")), tt.add(We.__key);
          } else {
            const zt = We.getParentOrThrow();
            !zt.canBeEmpty() && zt.getChildrenSize() === 1 ? zt.remove() : We.remove();
          }
        else
          tt.add(We.__key);
        const Tt = Rt.getChildren(), $t = new Set($), Gt = Pt.is(Rt), an = Pt.isInline() && Ne.getNextSibling() === null ? Pt : Ne;
        for (let zt = Tt.length - 1; zt >= 0; zt--) {
          const Nn = Tt[zt];
          if (Nn.is(Ne) || Ze(Nn) && Nn.isParentOf(Ne))
            break;
          Nn.isAttached() && (!$t.has(Nn) || Nn.is(mt) ? Gt || an.insertAfter(Nn, !1) : Nn.remove());
        }
        if (!Gt) {
          let zt = Rt, Nn = null;
          for (; zt !== null; ) {
            const Vr = zt.getChildren(), bi = Vr.length;
            (bi === 0 || Vr[bi - 1].is(Nn)) && (tt.delete(zt.__key), Nn = zt), zt = zt.getParent();
          }
        }
        if (!Ne.isToken())
          Ne = Ne.spliceText(Ee, Ie - Ee, i, !0), Ne.getTextContent() === "" ? Ne.remove() : Ne.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= i.length);
        else if (Ee === Ie)
          Ne.select();
        else {
          const zt = Mn(i);
          zt.select(), Ne.replace(zt);
        }
        for (let zt = 1; zt < le; zt++) {
          const Nn = $[zt], Vr = Nn.__key;
          tt.has(Vr) || Nn.remove();
        }
      }
    }
    /**
     * Removes the text in the Selection, adjusting the EditorState accordingly.
     */
    removeText() {
      this.insertText("");
    }
    /**
     * Applies the provided format to the TextNodes in the Selection, splitting or
     * merging nodes as necessary.
     *
     * @param formatType the format type to apply to the nodes in the Selection.
     */
    formatText(i) {
      if (this.isCollapsed()) {
        this.toggleFormat(i), un(null);
        return;
      }
      const a = this.getNodes(), u = [];
      for (const We of a)
        dt(We) && u.push(We);
      const p = u.length;
      if (p === 0) {
        this.toggleFormat(i), un(null);
        return;
      }
      const y = this.anchor, M = this.focus, $ = this.isBackward(), le = $ ? M : y, fe = $ ? y : M;
      let Ce = 0, Ee = u[0], xe = le.type === "element" ? 0 : le.offset;
      if (le.type === "text" && xe === Ee.getTextContentSize() && (Ce = 1, Ee = u[1], xe = 0), Ee == null)
        return;
      const Ne = Ee.getFormatFlags(i, null), Ke = p - 1;
      let Ie = u[Ke];
      const Ae = fe.type === "text" ? fe.offset : Ie.getTextContentSize();
      if (Ee.is(Ie)) {
        if (xe === Ae)
          return;
        if (xe === 0 && Ae === Ee.getTextContentSize())
          Ee.setFormat(Ne);
        else {
          const We = Ee.splitText(xe, Ae), tt = xe === 0 ? We[0] : We[1];
          tt.setFormat(Ne), le.type === "text" && le.set(tt.__key, 0, "text"), fe.type === "text" && fe.set(tt.__key, Ae - xe, "text");
        }
        this.format = Ne;
        return;
      }
      xe !== 0 && ([, Ee] = Ee.splitText(xe), xe = 0), Ee.setFormat(Ne);
      const ht = Ie.getFormatFlags(i, Ne);
      Ae > 0 && (Ae !== Ie.getTextContentSize() && ([Ie] = Ie.splitText(Ae)), Ie.setFormat(ht));
      for (let We = Ce + 1; We < Ke; We++) {
        const tt = u[We];
        if (!tt.isToken()) {
          const Pt = tt.getFormatFlags(i, ht);
          tt.setFormat(Pt);
        }
      }
      le.type === "text" && le.set(Ee.__key, xe, "text"), fe.type === "text" && fe.set(Ie.__key, Ae, "text"), this.format = Ne | ht;
    }
    /**
     * Attempts to "intelligently" insert an arbitrary list of Lexical nodes into the EditorState at the
     * current Selection according to a set of heuristics that determine how surrounding nodes
     * should be changed, replaced, or moved to accomodate the incoming ones.
     *
     * @param nodes - the nodes to insert
     */
    insertNodes(i) {
      if (i.length === 0)
        return;
      if (this.anchor.key === "root") {
        this.insertParagraph();
        const Ae = en();
        if (!ft(Ae))
          throw Error("Expected RangeSelection after insertParagraph");
        return Ae.insertNodes(i);
      }
      const a = ts(this.anchor.getNode(), vi), u = i[i.length - 1];
      if ("__language" in a) {
        if ("__language" in i[0])
          this.insertText(i[0].getTextContent());
        else {
          const Ae = xa(this);
          a.splice(Ae, 0, i), u.selectEnd();
        }
        return;
      }
      const p = (Ae) => (Ze(Ae) || yn(Ae)) && !Ae.isInline();
      if (!i.some(p)) {
        const Ae = xa(this);
        a.splice(Ae, 0, i), u.selectEnd();
        return;
      }
      const y = ng(i), M = y.getLastDescendant(), $ = y.getChildren(), le = (Ae) => "__value" in Ae && "__checked" in Ae, fe = (Ae) => Ze(Ae) && vi(Ae) && !Ae.isEmpty() && Ze(a) && (!a.isEmpty() || le(a)), Ee = !Ze(a) || !a.isEmpty() ? this.insertParagraph() : null, xe = $[$.length - 1];
      let Ne = $[0];
      fe(Ne) && (a.append(...Ne.getChildren()), Ne = $[1]), Ne && Xn(a, Ne);
      const Ke = ts(M, vi);
      Ee && Ze(Ke) && (le(Ee) || vi(xe)) && (Ke.append(...Ee.getChildren()), Ee.remove()), Ze(a) && a.isEmpty() && a.remove(), M.selectEnd();
      const Ie = Ze(a) ? a.getLastChild() : null;
      ui(Ie) && Ke !== a && Ie.remove();
    }
    /**
     * Inserts a new ParagraphNode into the EditorState at the current Selection
     *
     * @returns the newly inserted node.
     */
    insertParagraph() {
      if (this.anchor.key === "root") {
        const M = Ai();
        return Hn().splice(this.anchor.offset, 0, [M]), M.select(), M;
      }
      const i = xa(this), a = ts(this.anchor.getNode(), vi), u = a.getChildAtIndex(i), p = u ? [u, ...u.getNextSiblings()] : [], y = a.insertNewAfter(this, !1);
      return y ? (y.append(...p), y.selectStart(), y) : null;
    }
    /**
     * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the
     * current Selection.
     */
    insertLineBreak(i) {
      const a = ci();
      if (this.insertNodes([a]), i) {
        const u = a.getParentOrThrow(), p = a.getIndexWithinParent();
        u.select(p, p);
      }
    }
    /**
     * Extracts the nodes in the Selection, splitting nodes where necessary
     * to get offset-level precision.
     *
     * @returns The nodes in the Selection
     */
    extract() {
      const i = this.getNodes(), a = i.length, u = a - 1, p = this.anchor, y = this.focus;
      let M = i[0], $ = i[u];
      const [le, fe] = Gn(this);
      if (a === 0)
        return [];
      if (a === 1) {
        if (dt(M) && !this.isCollapsed()) {
          const Ee = le > fe ? fe : le, xe = le > fe ? le : fe, Ne = M.splitText(Ee, xe), Ke = Ee === 0 ? Ne[0] : Ne[1];
          return Ke != null ? [Ke] : [];
        }
        return [M];
      }
      const Ce = p.isBefore(y);
      if (dt(M)) {
        const Ee = Ce ? le : fe;
        Ee === M.getTextContentSize() ? i.shift() : Ee !== 0 && ([, M] = M.splitText(Ee), i[0] = M);
      }
      if (dt($)) {
        const xe = $.getTextContent().length, Ne = Ce ? fe : le;
        Ne === 0 ? i.pop() : Ne !== xe && ([$] = $.splitText(Ne), i[u] = $);
      }
      return i;
    }
    /**
     * Modifies the Selection according to the parameters and a set of heuristics that account for
     * various node types. Can be used to safely move or extend selection by one logical "unit" without
     * dealing explicitly with all the possible node types.
     *
     * @param alter the type of modification to perform
     * @param isBackward whether or not selection is backwards
     * @param granularity the granularity at which to apply the modification
     */
    modify(i, a, u) {
      const p = this.focus, y = this.anchor, M = i === "move", $ = zr(p, a);
      if (yn($) && !$.isIsolated()) {
        if (M && $.isKeyboardSelectable()) {
          const Ne = Ea();
          Ne.add($.__key), _r(Ne);
          return;
        }
        const xe = a ? $.getPreviousSibling() : $.getNextSibling();
        if (dt(xe)) {
          const Ne = xe.__key, Ke = a ? xe.getTextContent().length : 0;
          p.set(Ne, Ke, "text"), M && y.set(Ne, Ke, "text");
          return;
        } else {
          const Ne = $.getParentOrThrow();
          let Ke, Ie;
          Ze(xe) ? (Ie = xe.__key, Ke = a ? xe.getChildrenSize() : 0) : (Ke = $.getIndexWithinParent(), Ie = Ne.__key, a || Ke++), p.set(Ie, Ke, "element"), M && y.set(Ie, Ke, "element");
          return;
        }
      }
      const le = ln(), fe = sr(le._window);
      if (!fe)
        return;
      const Ce = le._blockCursorElement, Ee = le._rootElement;
      if (Ee !== null && Ce !== null && Ze($) && !$.isInline() && !$.canBeEmpty() && vt(Ce, le, Ee), ds(fe, i, a ? "backward" : "forward", u), fe.rangeCount > 0) {
        const xe = fe.getRangeAt(0), Ne = this.anchor.getNode(), Ke = Er(Ne) ? Ne : mr(Ne);
        if (this.applyDOMRange(xe), this.dirty = !0, !M) {
          const Ie = this.getNodes(), Ae = [];
          let ht = !1;
          for (let We = 0; We < Ie.length; We++) {
            const tt = Ie[We];
            ut(tt, Ke) ? Ae.push(tt) : ht = !0;
          }
          if (ht && Ae.length > 0)
            if (a) {
              const We = Ae[0];
              Ze(We) ? We.selectStart() : We.getParentOrThrow().selectStart();
            } else {
              const We = Ae[Ae.length - 1];
              Ze(We) ? We.selectEnd() : We.getParentOrThrow().selectEnd();
            }
          (fe.anchorNode !== xe.startContainer || fe.anchorOffset !== xe.startOffset) && Di(this);
        }
      }
    }
    /**
     * Performs one logical character deletion operation on the EditorState based on the current Selection.
     * Handles different node types.
     *
     * @param isBackward whether or not the selection is backwards.
     */
    deleteCharacter(i) {
      const a = this.isCollapsed();
      if (this.isCollapsed()) {
        const u = this.anchor, p = this.focus;
        let y = u.getNode();
        if (!i && // Delete forward handle case
        (u.type === "element" && Ze(y) && u.offset === y.getChildrenSize() || u.type === "text" && u.offset === y.getTextContentSize())) {
          const $ = y.getParent(), le = y.getNextSibling() || ($ === null ? null : $.getNextSibling());
          if (Ze(le) && le.isShadowRoot())
            return;
        }
        const M = zr(p, i);
        if (yn(M) && !M.isIsolated()) {
          if (M.isKeyboardSelectable() && Ze(y) && y.getChildrenSize() === 0) {
            y.remove();
            const $ = Ea();
            $.add(M.__key), _r($);
          } else
            M.remove(), ln().dispatchCommand(t, void 0);
          return;
        } else if (!i && Ze(M) && Ze(y) && y.isEmpty()) {
          y.remove(), M.selectStart();
          return;
        }
        if (this.modify("extend", i, "character"), this.isCollapsed()) {
          if (i && u.offset === 0 && (u.type === "element" ? u.getNode() : u.getNode().getParentOrThrow()).collapseAtStart(this))
            return;
        } else {
          const $ = p.type === "text" ? p.getNode() : null;
          if (y = u.type === "text" ? u.getNode() : null, $ !== null && $.isSegmented()) {
            const le = p.offset, fe = $.getTextContentSize();
            if ($.is(y) || i && le !== fe || !i && le !== 0) {
              Jc($, i, le);
              return;
            }
          } else if (y !== null && y.isSegmented()) {
            const le = u.offset, fe = y.getTextContentSize();
            if (y.is($) || i && le !== 0 || !i && le !== fe) {
              Jc(y, i, le);
              return;
            }
          }
          Wl(this, i);
        }
      }
      if (this.removeText(), i && !a && this.isCollapsed() && this.anchor.type === "element" && this.anchor.offset === 0) {
        const u = this.anchor.getNode();
        u.isEmpty() && Er(u.getParent()) && u.getIndexWithinParent() === 0 && u.collapseAtStart(this);
      }
    }
    /**
     * Performs one logical line deletion operation on the EditorState based on the current Selection.
     * Handles different node types.
     *
     * @param isBackward whether or not the selection is backwards.
     */
    deleteLine(i) {
      this.isCollapsed() && (this.anchor.type === "text" && this.modify("extend", i, "lineboundary"), (i ? this.focus : this.anchor).offset === 0 && this.modify("extend", i, "character")), this.removeText();
    }
    /**
     * Performs one logical word deletion operation on the EditorState based on the current Selection.
     * Handles different node types.
     *
     * @param isBackward whether or not the selection is backwards.
     */
    deleteWord(i) {
      this.isCollapsed() && this.modify("extend", i, "word"), this.removeText();
    }
  }
  function ur(c) {
    return c instanceof wn;
  }
  function hi(c) {
    const i = c.offset;
    if (c.type === "text")
      return i;
    const a = c.getNode();
    return i === a.getChildrenSize() ? a.getTextContent().length : 0;
  }
  function Gn(c) {
    const i = c.anchor, a = c.focus;
    return i.type === "element" && a.type === "element" && i.key === a.key && i.offset === a.offset ? [0, 0] : [hi(i), hi(a)];
  }
  function Di(c) {
    const i = c.focus, a = c.anchor, u = a.key, p = a.offset, y = a.type;
    qr(a, i.key, i.offset, i.type), qr(i, u, p, y), c._cachedNodes = null;
  }
  function ds(c, i, a, u) {
    c.modify(i, a, u);
  }
  function Wl(c, i) {
    const a = c.anchor, u = c.focus, p = a.getNode(), y = u.getNode();
    if (p === y && a.type === "text" && u.type === "text") {
      const M = a.offset, $ = u.offset, le = M < $, fe = le ? M : $, Ce = le ? $ : M, Ee = Ce - 1;
      if (fe !== Ee) {
        const xe = p.getTextContent().slice(fe, Ce);
        Rs(xe) || (i ? u.offset = Ee : a.offset = Ee);
      }
    }
  }
  function Jc(c, i, a) {
    const u = c, y = u.getTextContent().split(/(?=\s)/g), M = y.length;
    let $ = 0, le = 0;
    for (let Ce = 0; Ce < M; Ce++) {
      const Ee = y[Ce], xe = Ce === M - 1;
      if (le = $, $ += Ee.length, i && $ === a || $ > a || xe) {
        y.splice(Ce, 1), xe && (le = void 0);
        break;
      }
    }
    const fe = y.join("").trim();
    fe === "" ? u.remove() : (u.setTextContent(fe), u.select(le, le));
  }
  function jh(c, i, a) {
    const u = c.getParent();
    return a === null || u === null || !u.canBeEmpty() || u !== a.getNode();
  }
  function Zc(c, i, a, u) {
    let p = i, y;
    if (c.nodeType === Be) {
      let M = !1;
      const $ = c.childNodes, le = $.length;
      p === le && (M = !0, p = le - 1);
      let fe = $[p], Ce = !1;
      if (fe === u._blockCursorElement ? (fe = $[p + 1], Ce = !0) : u._blockCursorElement !== null && p--, y = Hr(fe), dt(y))
        p = Vo(y, M);
      else {
        let Ee = Hr(c);
        if (Ee === null)
          return null;
        if (Ze(Ee)) {
          let xe = Ee.getChildAtIndex(p);
          if (Ze(xe) && jh(xe, p, a)) {
            const Ne = M ? xe.getLastDescendant() : xe.getFirstDescendant();
            Ne === null ? (Ee = xe, p = 0) : (xe = Ne, Ee = Ze(xe) ? xe : xe.getParentOrThrow());
          }
          dt(xe) ? (y = xe, Ee = null, p = Vo(xe, M)) : xe !== Ee && M && !Ce && p++;
        } else {
          const xe = Ee.getIndexWithinParent();
          i === 0 && yn(Ee) && Hr(c) === Ee ? p = xe : p = xe + 1, Ee = Ee.getParentOrThrow();
        }
        if (Ze(Ee))
          return Lr(Ee.__key, p, "element");
      }
    } else
      y = Hr(c);
    return dt(y) ? Lr(y.__key, p, "text") : null;
  }
  function Xc(c, i, a) {
    const u = c.offset, p = c.getNode();
    if (u === 0) {
      const y = p.getPreviousSibling(), M = p.getParent();
      if (!i)
        Ze(y) && !a && y.isInline() ? (c.key = y.__key, c.offset = y.getChildrenSize(), c.type = "element") : dt(y) && (c.key = y.__key, c.offset = y.getTextContent().length);
      else if ((a || !i) && y === null && Ze(M) && M.isInline()) {
        const $ = M.getPreviousSibling();
        dt($) && (c.key = $.__key, c.offset = $.getTextContent().length);
      }
    } else if (u === p.getTextContent().length) {
      const y = p.getNextSibling(), M = p.getParent();
      if (i && Ze(y) && y.isInline())
        c.key = y.__key, c.offset = 0, c.type = "element";
      else if ((a || i) && y === null && Ze(M) && M.isInline() && !M.canInsertTextAfter()) {
        const $ = M.getNextSibling();
        dt($) && (c.key = $.__key, c.offset = 0);
      }
    }
  }
  function Qc(c, i, a) {
    if (c.type === "text" && i.type === "text") {
      const u = c.isBefore(i), p = c.is(i);
      Xc(c, u, p), Xc(i, !u, p), p && (i.key = c.key, i.offset = c.offset, i.type = c.type);
      const y = ln();
      if (y.isComposing() && y._compositionKey !== c.key && ft(a)) {
        const M = a.anchor, $ = a.focus;
        qr(c, M.key, M.offset, M.type), qr(i, $.key, $.offset, $.type);
      }
    }
  }
  function eu(c, i, a, u, p, y) {
    if (c === null || a === null || !Kr(p, c, a))
      return null;
    const M = Zc(c, i, ft(y) ? y.anchor : null, p);
    if (M === null)
      return null;
    const $ = Zc(a, u, ft(y) ? y.focus : null, p);
    if ($ === null)
      return null;
    if (M.type === "element" && $.type === "element") {
      const le = Hr(c), fe = Hr(a);
      if (yn(le) && yn(fe))
        return null;
    }
    return Qc(M, $, y), [M, $];
  }
  function qh(c) {
    return Ze(c) && !c.isInline();
  }
  function tu(c, i, a, u, p, y) {
    const M = gi(), $ = new On(Lr(c, i, p), Lr(a, u, y), 0, "");
    return $.dirty = !0, M._selection = $, $;
  }
  function Vh() {
    const c = Lr("root", 0, "element"), i = Lr("root", 0, "element");
    return new On(c, i, 0, "");
  }
  function Ea() {
    return new wn(/* @__PURE__ */ new Set());
  }
  function Jh() {
    const c = Lr("root", 0, "element"), i = Lr("root", 0, "element");
    return new zn("root", c, i);
  }
  function Zh(c) {
    const a = c.getEditorState()._selection, u = sr(c._window);
    return ft(a) || a == null ? Ta(a, u, c) : a.clone();
  }
  function Ta(c, i, a) {
    const u = a._window;
    if (u === null)
      return null;
    const p = u.event, y = p ? p.type : void 0, M = y === "selectionchange", $ = !Ft() && (M || y === "beforeinput" || y === "compositionstart" || y === "compositionend" || y === "click" && p && p.detail === 3 || y === "drop" || y === void 0);
    let le, fe, Ce, Ee;
    if (!ft(c) || $) {
      if (i === null)
        return null;
      if (le = i.anchorNode, fe = i.focusNode, Ce = i.anchorOffset, Ee = i.focusOffset, M && ft(c) && !Kr(a, le, fe))
        return c.clone();
    } else
      return c.clone();
    const xe = eu(le, Ce, fe, Ee, a, c);
    if (xe === null)
      return null;
    const [Ne, Ke] = xe;
    return new On(Ne, Ke, ft(c) ? c.format : 0, ft(c) ? c.style : "");
  }
  function en() {
    return gi()._selection;
  }
  function fs() {
    return ln()._editorState._selection;
  }
  function zl(c, i, a, u = 1) {
    const p = c.anchor, y = c.focus, M = p.getNode(), $ = y.getNode();
    if (!i.is(M) && !i.is($))
      return;
    const le = i.__key;
    if (c.isCollapsed()) {
      const fe = p.offset;
      if (a <= fe && u > 0 || a < fe && u < 0) {
        const Ce = Math.max(0, fe + u);
        p.set(le, Ce, "element"), y.set(le, Ce, "element"), nu(c);
      }
    } else {
      const fe = c.isBackward(), Ce = fe ? y : p, Ee = Ce.getNode(), xe = fe ? p : y, Ne = xe.getNode();
      if (i.is(Ee)) {
        const Ke = Ce.offset;
        (a <= Ke && u > 0 || a < Ke && u < 0) && Ce.set(le, Math.max(0, Ke + u), "element");
      }
      if (i.is(Ne)) {
        const Ke = xe.offset;
        (a <= Ke && u > 0 || a < Ke && u < 0) && xe.set(le, Math.max(0, Ke + u), "element");
      }
    }
    nu(c);
  }
  function nu(c) {
    const i = c.anchor, a = i.offset, u = c.focus, p = u.offset, y = i.getNode(), M = u.getNode();
    if (c.isCollapsed()) {
      if (!Ze(y))
        return;
      const $ = y.getChildrenSize(), le = a >= $, fe = le ? y.getChildAtIndex($ - 1) : y.getChildAtIndex(a);
      if (dt(fe)) {
        let Ce = 0;
        le && (Ce = fe.getTextContentSize()), i.set(fe.__key, Ce, "text"), u.set(fe.__key, Ce, "text");
      }
      return;
    }
    if (Ze(y)) {
      const $ = y.getChildrenSize(), le = a >= $, fe = le ? y.getChildAtIndex($ - 1) : y.getChildAtIndex(a);
      if (dt(fe)) {
        let Ce = 0;
        le && (Ce = fe.getTextContentSize()), i.set(fe.__key, Ce, "text");
      }
    }
    if (Ze(M)) {
      const $ = M.getChildrenSize(), le = p >= $, fe = le ? M.getChildAtIndex($ - 1) : M.getChildAtIndex(p);
      if (dt(fe)) {
        let Ce = 0;
        le && (Ce = fe.getTextContentSize()), u.set(fe.__key, Ce, "text");
      }
    }
  }
  function Xh(c, i) {
    const u = i.getEditorState()._selection, p = c._selection;
    if (ft(p)) {
      const y = p.anchor, M = p.focus;
      let $;
      if (y.type === "text" && ($ = y.getNode(), $.selectionTransform(u, p)), M.type === "text") {
        const le = M.getNode();
        $ !== le && le.selectionTransform(u, p);
      }
    }
  }
  function Gl(c, i, a, u, p) {
    let y = null, M = 0, $ = null;
    u !== null ? (y = u.__key, dt(u) ? (M = u.getTextContentSize(), $ = "text") : Ze(u) && (M = u.getChildrenSize(), $ = "element")) : p !== null && (y = p.__key, dt(p) ? $ = "text" : Ze(p) && ($ = "element")), y !== null && $ !== null ? c.set(y, M, $) : (M = i.getIndexWithinParent(), M === -1 && (M = a.getChildrenSize()), c.set(a.__key, M, "element"));
  }
  function ru(c, i, a, u, p) {
    c.type === "text" ? (c.key = a, i || (c.offset += p)) : c.offset > u.getIndexWithinParent() && (c.offset -= 1);
  }
  function Qh(c, i, a, u, p, y, M) {
    const $ = u.anchorNode, le = u.focusNode, fe = u.anchorOffset, Ce = u.focusOffset, Ee = document.activeElement;
    if (p.has("collaboration") && Ee !== y || Ee !== null && Bi(Ee))
      return;
    if (!ft(i)) {
      c !== null && Kr(a, $, le) && u.removeAllRanges();
      return;
    }
    const xe = i.anchor, Ne = i.focus, Ke = xe.key, Ie = Ne.key, Ae = Xo(a, Ke), ht = Xo(a, Ie), We = xe.offset, tt = Ne.offset, Pt = i.format, Rt = i.style, mt = i.isCollapsed();
    let Tt = Ae, $t = ht, Gt = !1;
    if (xe.type === "text") {
      Tt = Sn(Ae);
      const an = xe.getNode();
      Gt = an.getFormat() !== Pt || an.getStyle() !== Rt;
    } else
      ft(c) && c.anchor.type === "text" && (Gt = !0);
    if (Ne.type === "text" && ($t = Sn(ht)), !(Tt === null || $t === null) && (mt && (c === null || Gt || ft(c) && (c.format !== Pt || c.style !== Rt)) && lt(Pt, Rt, We, Ke, performance.now()), !(fe === We && Ce === tt && $ === Tt && le === $t && // Badly interpreted range selection when collapsed - #1482
    !(u.type === "Range" && mt) && ((Ee === null || !y.contains(Ee)) && y.focus({
      preventScroll: !0
    }), xe.type !== "element")))) {
      try {
        u.setBaseAndExtent(Tt, We, $t, tt);
      } catch {
      }
      if (!p.has("skip-scroll-into-view") && i.isCollapsed() && y !== null && y === document.activeElement) {
        const an = i instanceof On && i.anchor.type === "element" ? Tt.childNodes[We] || null : u.rangeCount > 0 ? u.getRangeAt(0) : null;
        if (an !== null) {
          let zt;
          if (an instanceof Text) {
            const Nn = document.createRange();
            Nn.selectNode(an), zt = Nn.getBoundingClientRect();
          } else
            zt = an.getBoundingClientRect();
          Sl(a, zt, y);
        }
      }
      Xe();
    }
  }
  function eg(c) {
    let i = en() || fs();
    i === null && (i = Hn().selectEnd()), i.insertNodes(c);
  }
  function tg() {
    const c = en();
    return c === null ? "" : c.getTextContent();
  }
  function iu(c, i, a) {
    const u = [];
    let p = null, y = null;
    function M(fe, Ce, Ee) {
      const xe = {
        cell: Ee,
        startColumn: Ce,
        startRow: fe
      }, Ne = Ee.__rowSpan, Ke = Ee.__colSpan;
      for (let Ie = 0; Ie < Ne; Ie++) {
        u[fe + Ie] === void 0 && (u[fe + Ie] = []);
        for (let Ae = 0; Ae < Ke; Ae++)
          u[fe + Ie][Ce + Ae] = xe;
      }
      i.is(Ee) && (p = xe), a.is(Ee) && (y = xe);
    }
    function $(fe, Ce) {
      return u[fe] === void 0 || u[fe][Ce] === void 0;
    }
    const le = c.getChildren();
    for (let fe = 0; fe < le.length; fe++) {
      const Ce = le[fe];
      if (!Js(Ce))
        throw Error("Expected GridNode children to be GridRowNode");
      const Ee = Ce.getChildren();
      let xe = 0;
      for (const Ne of Ee) {
        if (!Pr(Ne))
          throw Error("Expected GridRowNode children to be GridCellNode");
        for (; !$(fe, xe); )
          xe++;
        M(fe, xe, Ne), xe += Ne.__colSpan;
      }
    }
    if (p === null)
      throw Error("Anchor not found in Grid");
    if (y === null)
      throw Error("Focus not found in Grid");
    return [u, p, y];
  }
  function ou(c) {
    let i;
    if (c instanceof Ra)
      i = c;
    else if (c instanceof Ot) {
      const p = No(c, Pr);
      if (!Pr(p))
        throw Error("Expected to find a parent GridCellNode");
      i = p;
    } else {
      const p = No(c.getNode(), Pr);
      if (!Pr(p))
        throw Error("Expected to find a parent GridCellNode");
      i = p;
    }
    const a = i.getParent();
    if (!Js(a))
      throw Error("Expected GridCellNode to have a parent GridRowNode");
    const u = a.getParent();
    if (!Da(u))
      throw Error("Expected GridRowNode to have a parent GridNode");
    return [i, a, u];
  }
  function xa(c) {
    c.isCollapsed() || c.removeText();
    const i = c.anchor, a = i.getNode();
    if (!dt(a))
      return i.offset;
    const u = a.getParent();
    if (!u) {
      const le = Ai();
      return Hn().append(le), le.select(), 0;
    }
    const p = a.splitText(i.offset);
    if (p.length === 0)
      return 0;
    const y = i.offset === 0 ? 0 : 1, M = p[0].getIndexWithinParent() + y;
    if (!u.isInline() || M === 0)
      return M;
    const $ = u.getChildAtIndex(M);
    return $ && u.insertNewAfter(c).append($, ...$.getNextSiblings()), u.getIndexWithinParent() + y;
  }
  function ng(c) {
    const i = Ai();
    let a = null;
    for (let u = 0; u < c.length; u++) {
      const p = c[u], y = ui(p);
      if (y || yn(p) && p.isInline() || Ze(p) && p.isInline() || dt(p) || p.isParentRequired()) {
        if (a === null && (a = p.createParentElementNode(), i.append(a), y))
          continue;
        a !== null && a.append(p);
      } else
        i.append(p), a = null;
    }
    return i;
  }
  let Fn = null, Bn = null, dr = !1, va = !1, Yl = 0;
  const su = {
    characterData: !0,
    childList: !0,
    subtree: !0
  };
  function hs() {
    return dr || Fn !== null && Fn._readOnly;
  }
  function jn() {
    if (dr)
      throw Error("Cannot use method in read-only mode.");
  }
  function lu() {
    if (Yl > 99)
      throw Error("One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.");
  }
  function gi() {
    if (Fn === null)
      throw Error("Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().");
    return Fn;
  }
  function ln() {
    if (Bn === null)
      throw Error("Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().");
    return Bn;
  }
  function rg() {
    return Bn;
  }
  function au(c, i, a) {
    const u = i.__type, p = xr(c, u);
    let y = a.get(u);
    y === void 0 && (y = Array.from(p.transforms), a.set(u, y));
    const M = y.length;
    for (let $ = 0; $ < M && (y[$](i), !!i.isAttached()); $++)
      ;
  }
  function cu(c, i) {
    return c !== void 0 && // We don't want to transform nodes being composed
    c.__key !== i && c.isAttached();
  }
  function ig(c, i) {
    const a = i._dirtyLeaves, u = c._nodeMap;
    for (const p of a) {
      const y = u.get(p);
      dt(y) && y.isAttached() && y.isSimpleText() && !y.isUnmergeable() && vs(y);
    }
  }
  function og(c, i) {
    const a = i._dirtyLeaves, u = i._dirtyElements, p = c._nodeMap, y = vr(), M = /* @__PURE__ */ new Map();
    let $ = a, le = $.size, fe = u, Ce = fe.size;
    for (; le > 0 || Ce > 0; ) {
      if (le > 0) {
        i._dirtyLeaves = /* @__PURE__ */ new Set();
        for (const Ee of $) {
          const xe = p.get(Ee);
          dt(xe) && xe.isAttached() && xe.isSimpleText() && !xe.isUnmergeable() && vs(xe), xe !== void 0 && cu(xe, y) && au(i, xe, M), a.add(Ee);
        }
        if ($ = i._dirtyLeaves, le = $.size, le > 0) {
          Yl++;
          continue;
        }
      }
      i._dirtyLeaves = /* @__PURE__ */ new Set(), i._dirtyElements = /* @__PURE__ */ new Map();
      for (const Ee of fe) {
        const xe = Ee[0], Ne = Ee[1];
        if (xe !== "root" && !Ne)
          continue;
        const Ke = p.get(xe);
        Ke !== void 0 && cu(Ke, y) && au(i, Ke, M), u.set(xe, Ne);
      }
      $ = i._dirtyLeaves, le = $.size, fe = i._dirtyElements, Ce = fe.size, Yl++;
    }
    i._dirtyLeaves = a, i._dirtyElements = u;
  }
  function sg(c) {
    return Sa(c, ln()._nodes);
  }
  function Sa(c, i) {
    const a = c.type, u = i.get(a);
    if (u === void 0)
      throw Error(`parseEditorState: type "${a}" + not found`);
    const p = u.klass;
    if (c.type !== p.getType())
      throw Error(`LexicalNode: Node ${p.name} does not implement .importJSON().`);
    const y = p.importJSON(c), M = c.children;
    if (Ze(y) && Array.isArray(M))
      for (let $ = 0; $ < M.length; $++) {
        const le = M[$], fe = Sa(le, i);
        y.append(fe);
      }
    return y;
  }
  function lg(c, i, a) {
    const u = Oa(), p = Fn, y = dr, M = Bn, $ = i._dirtyElements, le = i._dirtyLeaves, fe = i._cloneNotNeeded, Ce = i._dirtyType;
    i._dirtyElements = /* @__PURE__ */ new Map(), i._dirtyLeaves = /* @__PURE__ */ new Set(), i._cloneNotNeeded = /* @__PURE__ */ new Set(), i._dirtyType = 0, Fn = u, dr = !1, Bn = i;
    try {
      const Ee = i._nodes, xe = c.root;
      Sa(xe, Ee), a && a(), u._readOnly = !0, du(u);
    } catch (Ee) {
      Ee instanceof Error && i._onError(Ee);
    } finally {
      i._dirtyElements = $, i._dirtyLeaves = le, i._cloneNotNeeded = fe, i._dirtyType = Ce, Fn = p, dr = y, Bn = M;
    }
    return u;
  }
  function uu(c, i) {
    const a = Fn, u = dr, p = Bn;
    Fn = c, dr = !0, Bn = null;
    try {
      return i();
    } finally {
      Fn = a, dr = u, Bn = p;
    }
  }
  function du(c) {
    const i = c._nodeMap;
    i.set = () => {
      throw new Error("Cannot call set() on a frozen Lexical node map");
    }, i.clear = () => {
      throw new Error("Cannot call clear() on a frozen Lexical node map");
    }, i.delete = () => {
      throw new Error("Cannot call delete() on a frozen Lexical node map");
    };
  }
  function Mo(c, i) {
    const a = c._pendingEditorState, u = c._rootElement, p = c._headless || u === null;
    if (a === null)
      return;
    const y = c._editorState, M = y._selection, $ = a._selection, le = c._dirtyType !== st, fe = Fn, Ce = dr, Ee = Bn, xe = c._updating, Ne = c._observer;
    let Ke = null;
    if (c._pendingEditorState = null, c._editorState = a, !p && le && Ne !== null) {
      Bn = c, Fn = a, dr = !1, c._updating = !0;
      try {
        const mt = c._dirtyType, Tt = c._dirtyElements, $t = c._dirtyLeaves;
        Ne.disconnect(), Ke = Jn(y, a, c, mt, Tt, $t);
      } catch (mt) {
        if (mt instanceof Error && c._onError(mt), !va)
          mu(c, null, u, a), Kn(c), c._dirtyType = at, va = !0, Mo(c, y), va = !1;
        else
          throw mt;
        return;
      } finally {
        Ne.observe(u, su), c._updating = xe, Fn = fe, dr = Ce, Bn = Ee;
      }
    }
    a._readOnly || (a._readOnly = !0, du(a), ft($) && (Object.freeze($.anchor), Object.freeze($.focus)), Object.freeze($));
    const Ie = c._dirtyLeaves, Ae = c._dirtyElements, ht = c._normalizedNodes, We = c._updateTags, tt = c._deferred;
    le && (c._dirtyType = st, c._cloneNotNeeded.clear(), c._dirtyLeaves = /* @__PURE__ */ new Set(), c._dirtyElements = /* @__PURE__ */ new Map(), c._normalizedNodes = /* @__PURE__ */ new Set(), c._updateTags = /* @__PURE__ */ new Set()), Ol(c, a);
    const Pt = p ? null : sr(c._window);
    if (c._editable && // domSelection will be null in headless
    Pt !== null && (le || $ === null || $.dirty)) {
      Bn = c, Fn = a;
      try {
        if (Ne !== null && Ne.disconnect(), le || $ === null || $.dirty) {
          const mt = c._blockCursorElement;
          mt !== null && vt(mt, c, u), Qh(M, $, c, Pt, We, u);
        }
        Bs(c, u, $), Ne !== null && Ne.observe(u, su);
      } finally {
        Bn = Ee, Fn = fe;
      }
    }
    Ke !== null && cg(c, Ke, We, Ie, y), !ft($) && $ !== null && (M === null || !M.is($)) && c.dispatchCommand(t, void 0);
    const Rt = c._pendingDecorators;
    Rt !== null && (c._decorators = Rt, c._pendingDecorators = null, Vs("decorator", c, !0, Rt)), ag(c, i || y, a), Vs("update", c, !0, {
      dirtyElements: Ae,
      dirtyLeaves: Ie,
      editorState: a,
      normalizedNodes: ht,
      prevEditorState: i || y,
      tags: We
    }), dg(c, tt), ug(c);
  }
  function ag(c, i, a) {
    const u = Hi(i), p = Hi(a);
    u !== p && Vs("textcontent", c, !0, p);
  }
  function cg(c, i, a, u, p) {
    const y = Array.from(c._listeners.mutation), M = y.length;
    for (let $ = 0; $ < M; $++) {
      const [le, fe] = y[$], Ce = i.get(fe);
      Ce !== void 0 && le(Ce, {
        dirtyLeaves: u,
        prevEditorState: p,
        updateTags: a
      });
    }
  }
  function Vs(c, i, a, ...u) {
    const p = i._updating;
    i._updating = a;
    try {
      const y = Array.from(i._listeners[c]);
      for (let M = 0; M < y.length; M++)
        y[M].apply(null, u);
    } finally {
      i._updating = p;
    }
  }
  function fu(c, i, a) {
    if (c._updating === !1 || Bn !== c) {
      let p = !1;
      return c.update(() => {
        p = fu(c, i, a);
      }), p;
    }
    const u = Jo(c);
    for (let p = 4; p >= 0; p--)
      for (let y = 0; y < u.length; y++) {
        const le = u[y]._commands.get(i);
        if (le !== void 0) {
          const fe = le[p];
          if (fe !== void 0) {
            const Ce = Array.from(fe), Ee = Ce.length;
            for (let xe = 0; xe < Ee; xe++)
              if (Ce[xe](a, c) === !0)
                return !0;
          }
        }
      }
    return !1;
  }
  function ug(c) {
    const i = c._updates;
    if (i.length !== 0) {
      const a = i.shift();
      if (a) {
        const [u, p] = a;
        gu(c, u, p);
      }
    }
  }
  function dg(c, i) {
    if (c._deferred = [], i.length !== 0) {
      const a = c._updating;
      c._updating = !0;
      try {
        for (let u = 0; u < i.length; u++)
          i[u]();
      } finally {
        c._updating = a;
      }
    }
  }
  function hu(c, i) {
    const a = c._updates;
    let u = i || !1;
    for (; a.length !== 0; ) {
      const p = a.shift();
      if (p) {
        const [y, M] = p;
        let $, le;
        M !== void 0 && ($ = M.onUpdate, le = M.tag, M.skipTransforms && (u = !0), $ && c._deferred.push($), le && c._updateTags.add(le)), y();
      }
    }
    return u;
  }
  function gu(c, i, a) {
    const u = c._updateTags;
    let p, y, M = !1, $ = !1;
    a !== void 0 && (p = a.onUpdate, y = a.tag, y != null && u.add(y), M = a.skipTransforms || !1, $ = a.discrete || !1), p && c._deferred.push(p);
    const le = c._editorState;
    let fe = c._pendingEditorState, Ce = !1;
    (fe === null || fe._readOnly) && (fe = c._pendingEditorState = gg(fe || le), Ce = !0), fe._flushSync = $;
    const Ee = Fn, xe = dr, Ne = Bn, Ke = c._updating;
    Fn = fe, dr = !1, c._updating = !0, Bn = c;
    try {
      Ce && (c._headless ? le._selection != null && (fe._selection = le._selection.clone()) : fe._selection = Zh(c));
      const Ae = c._compositionKey;
      i(), M = hu(c, M), Xh(fe, c), c._dirtyType !== st && (M ? ig(fe, c) : og(fe, c), hu(c), Rl(le, fe, c._dirtyLeaves, c._dirtyElements));
      const ht = c._compositionKey;
      Ae !== ht && (fe._flushSync = !0);
      const We = fe._selection;
      if (ft(We)) {
        const tt = fe._nodeMap, Pt = We.anchor.key, Rt = We.focus.key;
        if (tt.get(Pt) === void 0 || tt.get(Rt) === void 0)
          throw Error("updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.");
      } else
        ur(We) && We._nodes.size === 0 && (fe._selection = null);
    } catch (Ae) {
      Ae instanceof Error && c._onError(Ae), c._pendingEditorState = le, c._dirtyType = at, c._cloneNotNeeded.clear(), c._dirtyLeaves = /* @__PURE__ */ new Set(), c._dirtyElements.clear(), Mo(c);
      return;
    } finally {
      Fn = Ee, dr = xe, Bn = Ne, c._updating = Ke, Yl = 0;
    }
    c._dirtyType !== st || hg(fe, c) ? fe._flushSync ? (fe._flushSync = !1, Mo(c)) : Ce && Go(() => {
      Mo(c);
    }) : (fe._flushSync = !1, Ce && (u.clear(), c._deferred = [], c._pendingEditorState = null));
  }
  function Nr(c, i, a) {
    c._updating ? c._updates.push([i, a]) : gu(c, i, a);
  }
  class wa extends Ot {
    constructor(i) {
      super(i);
    }
    /**
     * The returned value is added to the LexicalEditor._decorators
     */
    decorate(i, a) {
      throw Error("decorate: base method not extended");
    }
    isIsolated() {
      return !1;
    }
    isInline() {
      return !0;
    }
    isKeyboardSelectable() {
      return !0;
    }
  }
  function yn(c) {
    return c instanceof wa;
  }
  class Lo extends Ot {
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    constructor(i) {
      super(i), this.__first = null, this.__last = null, this.__size = 0, this.__format = 0, this.__indent = 0, this.__dir = null;
    }
    getFormat() {
      return this.getLatest().__format;
    }
    getFormatType() {
      const i = this.getFormat();
      return Wo[i] || "";
    }
    getIndent() {
      return this.getLatest().__indent;
    }
    getChildren() {
      const i = [];
      let a = this.getFirstChild();
      for (; a !== null; )
        i.push(a), a = a.getNextSibling();
      return i;
    }
    getChildrenKeys() {
      const i = [];
      let a = this.getFirstChild();
      for (; a !== null; )
        i.push(a.__key), a = a.getNextSibling();
      return i;
    }
    getChildrenSize() {
      return this.getLatest().__size;
    }
    isEmpty() {
      return this.getChildrenSize() === 0;
    }
    isDirty() {
      const a = ln()._dirtyElements;
      return a !== null && a.has(this.__key);
    }
    isLastChild() {
      const i = this.getLatest(), a = this.getParentOrThrow().getLastChild();
      return a !== null && a.is(i);
    }
    getAllTextNodes() {
      const i = [];
      let a = this.getFirstChild();
      for (; a !== null; ) {
        if (dt(a) && i.push(a), Ze(a)) {
          const u = a.getAllTextNodes();
          i.push(...u);
        }
        a = a.getNextSibling();
      }
      return i;
    }
    getFirstDescendant() {
      let i = this.getFirstChild();
      for (; i !== null; ) {
        if (Ze(i)) {
          const a = i.getFirstChild();
          if (a !== null) {
            i = a;
            continue;
          }
        }
        break;
      }
      return i;
    }
    getLastDescendant() {
      let i = this.getLastChild();
      for (; i !== null; ) {
        if (Ze(i)) {
          const a = i.getLastChild();
          if (a !== null) {
            i = a;
            continue;
          }
        }
        break;
      }
      return i;
    }
    getDescendantByIndex(i) {
      const a = this.getChildren(), u = a.length;
      if (i >= u) {
        const y = a[u - 1];
        return Ze(y) && y.getLastDescendant() || y || null;
      }
      const p = a[i];
      return Ze(p) && p.getFirstDescendant() || p || null;
    }
    getFirstChild() {
      const a = this.getLatest().__first;
      return a === null ? null : gn(a);
    }
    getFirstChildOrThrow() {
      const i = this.getFirstChild();
      if (i === null)
        throw Error(`Expected node ${this.__key} to have a first child.`);
      return i;
    }
    getLastChild() {
      const a = this.getLatest().__last;
      return a === null ? null : gn(a);
    }
    getLastChildOrThrow() {
      const i = this.getLastChild();
      if (i === null)
        throw Error(`Expected node ${this.__key} to have a last child.`);
      return i;
    }
    getChildAtIndex(i) {
      const a = this.getChildrenSize();
      let u, p;
      if (i < a / 2) {
        for (u = this.getFirstChild(), p = 0; u !== null && p <= i; ) {
          if (p === i)
            return u;
          u = u.getNextSibling(), p++;
        }
        return null;
      }
      for (u = this.getLastChild(), p = a - 1; u !== null && p >= i; ) {
        if (p === i)
          return u;
        u = u.getPreviousSibling(), p--;
      }
      return null;
    }
    getTextContent() {
      let i = "";
      const a = this.getChildren(), u = a.length;
      for (let p = 0; p < u; p++) {
        const y = a[p];
        i += y.getTextContent(), Ze(y) && p !== u - 1 && !y.isInline() && (i += bt);
      }
      return i;
    }
    getTextContentSize() {
      let i = 0;
      const a = this.getChildren(), u = a.length;
      for (let p = 0; p < u; p++) {
        const y = a[p];
        i += y.getTextContentSize(), Ze(y) && p !== u - 1 && !y.isInline() && (i += bt.length);
      }
      return i;
    }
    getDirection() {
      return this.getLatest().__dir;
    }
    hasFormat(i) {
      if (i !== "") {
        const a = Fr[i];
        return (this.getFormat() & a) !== 0;
      }
      return !1;
    }
    // Mutators
    select(i, a) {
      jn();
      const u = en();
      let p = i, y = a;
      const M = this.getChildrenSize();
      if (!this.canBeEmpty()) {
        if (i === 0 && a === 0) {
          const le = this.getFirstChild();
          if (dt(le) || Ze(le))
            return le.select(0, 0);
        } else if ((i === void 0 || i === M) && (a === void 0 || a === M)) {
          const le = this.getLastChild();
          if (dt(le) || Ze(le))
            return le.select();
        }
      }
      p === void 0 && (p = M), y === void 0 && (y = M);
      const $ = this.__key;
      if (ft(u))
        u.anchor.set($, p, "element"), u.focus.set($, y, "element"), u.dirty = !0;
      else
        return tu($, p, $, y, "element", "element");
      return u;
    }
    selectStart() {
      const i = this.getFirstDescendant();
      return i ? i.selectStart() : this.select();
    }
    selectEnd() {
      const i = this.getLastDescendant();
      return i ? i.selectEnd() : this.select();
    }
    clear() {
      const i = this.getWritable();
      return this.getChildren().forEach((u) => u.remove()), i;
    }
    append(...i) {
      return this.splice(this.getChildrenSize(), 0, i);
    }
    setDirection(i) {
      const a = this.getWritable();
      return a.__dir = i, a;
    }
    setFormat(i) {
      const a = this.getWritable();
      return a.__format = i !== "" ? Fr[i] : 0, this;
    }
    setIndent(i) {
      const a = this.getWritable();
      return a.__indent = i, this;
    }
    splice(i, a, u) {
      const p = u.length, y = this.getChildrenSize(), M = this.getWritable(), $ = M.__key, le = [], fe = [], Ce = this.getChildAtIndex(i + a);
      let Ee = null, xe = y - a + p;
      if (i !== 0)
        if (i === y)
          Ee = this.getLastChild();
        else {
          const Ke = this.getChildAtIndex(i);
          Ke !== null && (Ee = Ke.getPreviousSibling());
        }
      if (a > 0) {
        let Ke = Ee === null ? this.getFirstChild() : Ee.getNextSibling();
        for (let Ie = 0; Ie < a; Ie++) {
          if (Ke === null)
            throw Error("splice: sibling not found");
          const Ae = Ke.getNextSibling(), ht = Ke.__key, We = Ke.getWritable();
          ei(We), fe.push(ht), Ke = Ae;
        }
      }
      let Ne = Ee;
      for (let Ke = 0; Ke < p; Ke++) {
        const Ie = u[Ke];
        Ne !== null && Ie.is(Ne) && (Ee = Ne = Ne.getPreviousSibling());
        const Ae = Ie.getWritable();
        Ae.__parent === $ && xe--, ei(Ae);
        const ht = Ie.__key;
        if (Ne === null)
          M.__first = ht, Ae.__prev = null;
        else {
          const We = Ne.getWritable();
          We.__next = ht, Ae.__prev = We.__key;
        }
        if (Ie.__key === $)
          throw Error("append: attempting to append self");
        Ae.__parent = $, le.push(ht), Ne = Ie;
      }
      if (i + a === y) {
        if (Ne !== null) {
          const Ke = Ne.getWritable();
          Ke.__next = null, M.__last = Ne.__key;
        }
      } else if (Ce !== null) {
        const Ke = Ce.getWritable();
        if (Ne !== null) {
          const Ie = Ne.getWritable();
          Ke.__prev = Ne.__key, Ie.__next = Ce.__key;
        } else
          Ke.__prev = null;
      }
      if (M.__size = xe, fe.length) {
        const Ke = en();
        if (ft(Ke)) {
          const Ie = new Set(fe), Ae = new Set(le), {
            anchor: ht,
            focus: We
          } = Ke;
          pu(ht, Ie, Ae) && Gl(ht, ht.getNode(), this, Ee, Ce), pu(We, Ie, Ae) && Gl(We, We.getNode(), this, Ee, Ce), xe === 0 && !this.canBeEmpty() && !Or(this) && this.remove();
        }
      }
      return M;
    }
    // JSON serialization
    exportJSON() {
      return {
        children: [],
        direction: this.getDirection(),
        format: this.getFormatType(),
        indent: this.getIndent(),
        type: "element",
        version: 1
      };
    }
    // These are intended to be extends for specific element heuristics.
    insertNewAfter(i, a) {
      return null;
    }
    canIndent() {
      return !0;
    }
    /*
     * This method controls the behavior of a the node during backwards
     * deletion (i.e., backspace) when selection is at the beginning of
     * the node (offset 0)
     */
    collapseAtStart(i) {
      return !1;
    }
    excludeFromCopy(i) {
      return !1;
    }
    // TODO 0.10 deprecate
    canExtractContents() {
      return !0;
    }
    canReplaceWith(i) {
      return !0;
    }
    canInsertAfter(i) {
      return !0;
    }
    canBeEmpty() {
      return !0;
    }
    canInsertTextBefore() {
      return !0;
    }
    canInsertTextAfter() {
      return !0;
    }
    isInline() {
      return !1;
    }
    // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the
    // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)
    // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode
    // will return the immediate first child underneath TableCellNode instead of RootNode.
    isShadowRoot() {
      return !1;
    }
    canMergeWith(i) {
      return !1;
    }
    extractWithChild(i, a, u) {
      return !1;
    }
  }
  function Ze(c) {
    return c instanceof Lo;
  }
  function pu(c, i, a) {
    let u = c.getNode();
    for (; u; ) {
      const p = u.__key;
      if (i.has(p) && !a.has(p))
        return !0;
      u = u.getParent();
    }
    return !1;
  }
  class gs extends Lo {
    /** @internal */
    static getType() {
      return "root";
    }
    static clone() {
      return new gs();
    }
    constructor() {
      super("root"), this.__cachedText = null;
    }
    getTopLevelElementOrThrow() {
      throw Error("getTopLevelElementOrThrow: root nodes are not top level elements");
    }
    getTextContent() {
      const i = this.__cachedText;
      return (hs() || ln()._dirtyType === st) && i !== null ? i : super.getTextContent();
    }
    remove() {
      throw Error("remove: cannot be called on root nodes");
    }
    replace(i) {
      throw Error("replace: cannot be called on root nodes");
    }
    insertBefore(i) {
      throw Error("insertBefore: cannot be called on root nodes");
    }
    insertAfter(i) {
      throw Error("insertAfter: cannot be called on root nodes");
    }
    // View
    updateDOM(i, a) {
      return !1;
    }
    // Mutate
    append(...i) {
      for (let a = 0; a < i.length; a++) {
        const u = i[a];
        if (!Ze(u) && !yn(u))
          throw Error("rootNode.append: Only element or decorator nodes can be appended to the root node");
      }
      return super.append(...i);
    }
    static importJSON(i) {
      const a = Hn();
      return a.setFormat(i.format), a.setIndent(i.indent), a.setDirection(i.direction), a;
    }
    exportJSON() {
      return {
        children: [],
        direction: this.getDirection(),
        format: this.getFormatType(),
        indent: this.getIndent(),
        type: "root",
        version: 1
      };
    }
    collapseAtStart() {
      return !0;
    }
  }
  function fg() {
    return new gs();
  }
  function Er(c) {
    return c instanceof gs;
  }
  function hg(c, i) {
    const a = i.getEditorState()._selection, u = c._selection;
    if (u !== null) {
      if (u.dirty || !u.is(a))
        return !0;
    } else if (a !== null)
      return !0;
    return !1;
  }
  function gg(c) {
    return new jl(new Map(c._nodeMap));
  }
  function Oa() {
    return new jl(/* @__PURE__ */ new Map([["root", fg()]]));
  }
  function _u(c) {
    const i = c.exportJSON(), a = c.constructor;
    if (i.type !== a.getType())
      throw Error(`LexicalNode: Node ${a.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);
    const u = i.children;
    if (Ze(c)) {
      if (!Array.isArray(u))
        throw Error(`LexicalNode: Node ${a.name} is an element but .exportJSON() does not have a children array.`);
      const p = c.getChildren();
      for (let y = 0; y < p.length; y++) {
        const M = p[y], $ = _u(M);
        u.push($);
      }
    }
    return i;
  }
  class jl {
    constructor(i, a) {
      this._nodeMap = i, this._selection = a || null, this._flushSync = !1, this._readOnly = !1;
    }
    isEmpty() {
      return this._nodeMap.size === 1 && this._selection === null;
    }
    read(i) {
      return uu(this, i);
    }
    clone(i) {
      const a = new jl(this._nodeMap, i === void 0 ? this._selection : i);
      return a._readOnly = !0, a;
    }
    toJSON() {
      return uu(this, () => ({
        root: _u(Hn())
      }));
    }
  }
  class ps extends Lo {
    static getType() {
      return "paragraph";
    }
    static clone(i) {
      return new ps(i.__key);
    }
    // View
    createDOM(i) {
      const a = document.createElement("p"), u = Ei(i.theme, "paragraph");
      return u !== void 0 && a.classList.add(...u), a;
    }
    updateDOM(i, a, u) {
      return !1;
    }
    static importDOM() {
      return {
        p: (i) => ({
          conversion: pg,
          priority: 0
        })
      };
    }
    exportDOM(i) {
      const {
        element: a
      } = super.exportDOM(i);
      if (a && To(a)) {
        this.isEmpty() && a.append(document.createElement("br"));
        const u = this.getFormatType();
        a.style.textAlign = u;
        const p = this.getDirection();
        p && (a.dir = p);
        const y = this.getIndent();
        y > 0 && (a.style.textIndent = `${y * 20}px`);
      }
      return {
        element: a
      };
    }
    static importJSON(i) {
      const a = Ai();
      return a.setFormat(i.format), a.setIndent(i.indent), a.setDirection(i.direction), a;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "paragraph",
        version: 1
      };
    }
    // Mutation
    insertNewAfter(i, a) {
      const u = Ai(), p = this.getDirection();
      return u.setDirection(p), this.insertAfter(u, a), u;
    }
    collapseAtStart() {
      const i = this.getChildren();
      if (i.length === 0 || dt(i[0]) && i[0].getTextContent().trim() === "") {
        if (this.getNextSibling() !== null)
          return this.selectNext(), this.remove(), !0;
        if (this.getPreviousSibling() !== null)
          return this.selectPrevious(), this.remove(), !0;
      }
      return !1;
    }
  }
  function pg(c) {
    const i = Ai();
    if (c.style) {
      i.setFormat(c.style.textAlign);
      const a = parseInt(c.style.textIndent, 10) / 20;
      a > 0 && i.setIndent(a);
    }
    return {
      node: i
    };
  }
  function Ai() {
    return Yi(new ps());
  }
  function _g(c) {
    return c instanceof ps;
  }
  const mg = 0, yg = 1, Cg = 2, Ng = 3, Eg = 4;
  function mu(c, i, a, u) {
    const p = c._keyToDOMMap;
    p.clear(), c._editorState = Oa(), c._pendingEditorState = u, c._compositionKey = null, c._dirtyType = st, c._cloneNotNeeded.clear(), c._dirtyLeaves = /* @__PURE__ */ new Set(), c._dirtyElements.clear(), c._normalizedNodes = /* @__PURE__ */ new Set(), c._updateTags = /* @__PURE__ */ new Set(), c._updates = [], c._blockCursorElement = null;
    const y = c._observer;
    y !== null && (y.disconnect(), c._observer = null), i !== null && (i.textContent = ""), a !== null && (a.textContent = "", p.set("root", a));
  }
  function Tg(c, i) {
    const a = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Set(), p = (y) => {
      Object.keys(y).forEach((M) => {
        let $ = a.get(M);
        $ === void 0 && ($ = [], a.set(M, $)), $.push(y[M]);
      });
    };
    return c.forEach((y) => {
      const M = y.klass.importDOM != null ? y.klass.importDOM.bind(y.klass) : null;
      if (M == null || u.has(M))
        return;
      u.add(M);
      const $ = M();
      $ !== null && p($);
    }), i && p(i), a;
  }
  function xg(c) {
    const i = c || {}, a = rg(), u = i.theme || {}, p = c === void 0 ? a : i.parentEditor || null, y = i.disableEvents || !1, M = Oa(), $ = i.namespace || (p !== null ? p._config.namespace : uo()), le = i.editorState, fe = [gs, wi, Ar, di, ps, ...i.nodes || []], {
      onError: Ce,
      html: Ee
    } = i, xe = i.editable !== void 0 ? i.editable : !0;
    let Ne;
    if (c === void 0 && a !== null)
      Ne = a._nodes;
    else {
      Ne = /* @__PURE__ */ new Map();
      for (let Ie = 0; Ie < fe.length; Ie++) {
        let Ae = fe[Ie], ht = null, We = null;
        if (typeof Ae != "function") {
          const mt = Ae;
          Ae = mt.replace, ht = mt.with, We = mt.withKlass || null;
        }
        {
          const mt = Ae.name;
          if (mt !== "RootNode") {
            const Tt = Ae.prototype;
            ["getType", "clone"].forEach(($t) => {
              Ae.hasOwnProperty($t) || console.warn(`${mt} must implement static "${$t}" method`);
            }), // eslint-disable-next-line no-prototype-builtins
            !Ae.hasOwnProperty("importDOM") && // eslint-disable-next-line no-prototype-builtins
            Ae.hasOwnProperty("exportDOM") && console.warn(`${mt} should implement "importDOM" if using a custom "exportDOM" method to ensure HTML serialization (important for copy & paste) works as expected`), Tt instanceof wa && (Tt.hasOwnProperty("decorate") || console.warn(`${Tt.constructor.name} must implement "decorate" method`)), Ae.hasOwnProperty("importJSON") || console.warn(`${mt} should implement "importJSON" method to ensure JSON and default HTML serialization works as expected`), Tt.hasOwnProperty("exportJSON") || console.warn(`${mt} should implement "exportJSON" method to ensure JSON and default HTML serialization works as expected`);
          }
        }
        const tt = Ae.getType(), Pt = Ae.transform(), Rt = /* @__PURE__ */ new Set();
        Pt !== null && Rt.add(Pt), Ne.set(tt, {
          exportDOM: Ee && Ee.export ? Ee.export.get(Ae) : void 0,
          klass: Ae,
          replace: ht,
          replaceWithKlass: We,
          transforms: Rt
        });
      }
    }
    const Ke = new vg(M, p, Ne, {
      disableEvents: y,
      namespace: $,
      theme: u
    }, Ce || console.error, Tg(Ne, Ee ? Ee.import : void 0), xe);
    return le !== void 0 && (Ke._pendingEditorState = le, Ke._dirtyType = at), Ke;
  }
  class vg {
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    constructor(i, a, u, p, y, M, $) {
      this._parentEditor = a, this._rootElement = null, this._editorState = i, this._pendingEditorState = null, this._compositionKey = null, this._deferred = [], this._keyToDOMMap = /* @__PURE__ */ new Map(), this._updates = [], this._updating = !1, this._listeners = {
        decorator: /* @__PURE__ */ new Set(),
        editable: /* @__PURE__ */ new Set(),
        mutation: /* @__PURE__ */ new Map(),
        root: /* @__PURE__ */ new Set(),
        textcontent: /* @__PURE__ */ new Set(),
        update: /* @__PURE__ */ new Set()
      }, this._commands = /* @__PURE__ */ new Map(), this._config = p, this._nodes = u, this._decorators = {}, this._pendingDecorators = null, this._dirtyType = st, this._cloneNotNeeded = /* @__PURE__ */ new Set(), this._dirtyLeaves = /* @__PURE__ */ new Set(), this._dirtyElements = /* @__PURE__ */ new Map(), this._normalizedNodes = /* @__PURE__ */ new Set(), this._updateTags = /* @__PURE__ */ new Set(), this._observer = null, this._key = uo(), this._onError = y, this._htmlConversions = M, this._editable = $, this._headless = a !== null && a._headless, this._window = null, this._blockCursorElement = null;
    }
    /**
     *
     * @returns true if the editor is currently in "composition" mode due to receiving input
     * through an IME, or 3P extension, for example. Returns false otherwise.
     */
    isComposing() {
      return this._compositionKey != null;
    }
    /**
     * Registers a listener for Editor update event. Will trigger the provided callback
     * each time the editor goes through an update (via {@link LexicalEditor.update}) until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerUpdateListener(i) {
      const a = this._listeners.update;
      return a.add(i), () => {
        a.delete(i);
      };
    }
    /**
     * Registers a listener for for when the editor changes between editable and non-editable states.
     * Will trigger the provided callback each time the editor transitions between these states until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerEditableListener(i) {
      const a = this._listeners.editable;
      return a.add(i), () => {
        a.delete(i);
      };
    }
    /**
     * Registers a listener for when the editor's decorator object changes. The decorator object contains
     * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.
     *
     * Will trigger the provided callback each time the editor transitions between these states until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerDecoratorListener(i) {
      const a = this._listeners.decorator;
      return a.add(i), () => {
        a.delete(i);
      };
    }
    /**
     * Registers a listener for when Lexical commits an update to the DOM and the text content of
     * the editor changes from the previous state of the editor. If the text content is the
     * same between updates, no notifications to the listeners will happen.
     *
     * Will trigger the provided callback each time the editor transitions between these states until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerTextContentListener(i) {
      const a = this._listeners.textcontent;
      return a.add(i), () => {
        a.delete(i);
      };
    }
    /**
     * Registers a listener for when the editor's root DOM element (the content editable
     * Lexical attaches to) changes. This is primarily used to attach event listeners to the root
     *  element. The root listener function is executed directly upon registration and then on
     * any subsequent update.
     *
     * Will trigger the provided callback each time the editor transitions between these states until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerRootListener(i) {
      const a = this._listeners.root;
      return i(this._rootElement, null), a.add(i), () => {
        i(null, this._rootElement), a.delete(i);
      };
    }
    /**
     * Registers a listener that will trigger anytime the provided command
     * is dispatched, subject to priority. Listeners that run at a higher priority can "intercept"
     * commands and prevent them from propagating to other handlers by returning true.
     *
     * Listeners registered at the same priority level will run deterministically in the order of registration.
     *
     * @param command - the command that will trigger the callback.
     * @param listener - the function that will execute when the command is dispatched.
     * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerCommand(i, a, u) {
      if (u === void 0)
        throw Error('Listener for type "command" requires a "priority".');
      const p = this._commands;
      p.has(i) || p.set(i, [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()]);
      const y = p.get(i);
      if (y === void 0)
        throw Error(`registerCommand: Command ${String(i)} not found in command map`);
      const M = y[u];
      return M.add(a), () => {
        M.delete(a), y.every(($) => $.size === 0) && p.delete(i);
      };
    }
    /**
     * Registers a listener that will run when a Lexical node of the provided class is
     * mutated. The listener will receive a list of nodes along with the type of mutation
     * that was performed on each: created, destroyed, or updated.
     *
     * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.
     * {@link LexicalEditor.getElementByKey} can be used for this.
     *
     * @param klass - The class of the node that you want to listen to mutations on.
     * @param listener - The logic you want to run when the node is mutated.
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerMutationListener(i, a) {
      if (this._nodes.get(i.getType()) === void 0)
        throw Error(`Node ${i.name} has not been registered. Ensure node has been passed to createEditor.`);
      const p = this._listeners.mutation;
      return p.set(a, i), () => {
        p.delete(a);
      };
    }
    /** @internal */
    registerNodeTransformToKlass(i, a) {
      const u = i.getType(), p = this._nodes.get(u);
      if (p === void 0)
        throw Error(`Node ${i.name} has not been registered. Ensure node has been passed to createEditor.`);
      return p.transforms.add(a), p;
    }
    /**
     * Registers a listener that will run when a Lexical node of the provided class is
     * marked dirty during an update. The listener will continue to run as long as the node
     * is marked dirty. There are no guarantees around the order of transform execution!
     *
     * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)
     * @param klass - The class of the node that you want to run transforms on.
     * @param listener - The logic you want to run when the node is updated.
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerNodeTransform(i, a) {
      const u = this.registerNodeTransformToKlass(i, a), p = [u], y = u.replaceWithKlass;
      if (y != null) {
        const M = this.registerNodeTransformToKlass(y, a);
        p.push(M);
      }
      return qo(this, i.getType()), () => {
        p.forEach((M) => M.transforms.delete(a));
      };
    }
    /**
     * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they
     * depend on have been registered.
     * @returns True if the editor has registered the provided node type, false otherwise.
     */
    hasNode(i) {
      return this._nodes.has(i.getType());
    }
    /**
     * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they
     * depend on have been registered.
     * @returns True if the editor has registered all of the provided node types, false otherwise.
     */
    hasNodes(i) {
      return i.every(this.hasNode.bind(this));
    }
    /**
     * Dispatches a command of the specified type with the specified payload.
     * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})
     * for this type, passing them the provided payload.
     * @param type - the type of command listeners to trigger.
     * @param payload - the data to pass as an argument to the command listeners.
     */
    dispatchCommand(i, a) {
      return it(this, i, a);
    }
    /**
     * Gets a map of all decorators in the editor.
     * @returns A mapping of call decorator keys to their decorated content
     */
    getDecorators() {
      return this._decorators;
    }
    /**
     *
     * @returns the current root element of the editor. If you want to register
     * an event listener, do it via {@link LexicalEditor.registerRootListener}, since
     * this reference may not be stable.
     */
    getRootElement() {
      return this._rootElement;
    }
    /**
     * Gets the key of the editor
     * @returns The editor key
     */
    getKey() {
      return this._key;
    }
    /**
     * Imperatively set the root contenteditable element that Lexical listens
     * for events on.
     */
    setRootElement(i) {
      const a = this._rootElement;
      if (i !== a) {
        const u = Ei(this._config.theme, "root"), p = this._pendingEditorState || this._editorState;
        if (this._rootElement = i, mu(this, a, i, p), a !== null && (this._config.disableEvents || Pe(a), u != null && a.classList.remove(...u)), i !== null) {
          const y = Gi(i), M = i.style;
          M.userSelect = "text", M.whiteSpace = "pre-wrap", M.wordBreak = "break-word", i.setAttribute("data-lexical-editor", "true"), this._window = y, this._dirtyType = at, Kn(this), this._updateTags.add("history-merge"), Mo(this), this._config.disableEvents || Ue(i, this), u != null && i.classList.add(...u);
        } else
          this._editorState = p, this._pendingEditorState = null, this._window = null;
        Vs("root", this, !1, i, a);
      }
    }
    /**
     * Gets the underlying HTMLElement associated with the LexicalNode for the given key.
     * @returns the HTMLElement rendered by the LexicalNode associated with the key.
     * @param key - the key of the LexicalNode.
     */
    getElementByKey(i) {
      return this._keyToDOMMap.get(i) || null;
    }
    /**
     * Gets the active editor state.
     * @returns The editor state
     */
    getEditorState() {
      return this._editorState;
    }
    /**
     * Imperatively set the EditorState. Triggers reconciliation like an update.
     * @param editorState - the state to set the editor
     * @param options - options for the update.
     */
    setEditorState(i, a) {
      if (i.isEmpty())
        throw Error("setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.");
      Xr(this);
      const u = this._pendingEditorState, p = this._updateTags, y = a !== void 0 ? a.tag : null;
      u !== null && !u.isEmpty() && (y != null && p.add(y), Mo(this)), this._pendingEditorState = i, this._dirtyType = at, this._dirtyElements.set("root", !1), this._compositionKey = null, y != null && p.add(y), Mo(this);
    }
    /**
     * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns
     * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,
     * deserliazation from JSON stored in a database uses this method.
     * @param maybeStringifiedEditorState
     * @param updateFn
     * @returns
     */
    parseEditorState(i, a) {
      const u = typeof i == "string" ? JSON.parse(i) : i;
      return lg(u, this, a);
    }
    /**
     * Executes an update to the editor state. The updateFn callback is the ONLY place
     * where Lexical editor state can be safely mutated.
     * @param updateFn - A function that has access to writable editor state.
     * @param options - A bag of options to control the behavior of the update.
     * @param options.onUpdate - A function to run once the update is complete.
     * Useful for synchronizing updates in some cases.
     * @param options.skipTransforms - Setting this to true will suppress all node
     * transforms for this update cycle.
     * @param options.tag - A tag to identify this update, in an update listener, for instance.
     * Some tags are reserved by the core and control update behavior in different ways.
     * @param options.discrete - If true, prevents this update from being batched, forcing it to
     * run synchronously.
     */
    update(i, a) {
      Nr(this, i, a);
    }
    /**
     * Focuses the editor
     * @param callbackFn - A function to run after the editor is focused.
     * @param options - A bag of options
     * @param options.defaultSelection - Where to move selection when the editor is
     * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.
     */
    focus(i, a = {}) {
      const u = this._rootElement;
      u !== null && (u.setAttribute("autocapitalize", "off"), Nr(this, () => {
        const p = en(), y = Hn();
        p !== null ? p.dirty = !0 : y.getChildrenSize() !== 0 && (a.defaultSelection === "rootStart" ? y.selectStart() : y.selectEnd());
      }, {
        onUpdate: () => {
          u.removeAttribute("autocapitalize"), i && i();
        },
        tag: "focus"
      }), this._pendingEditorState === null && u.removeAttribute("autocapitalize"));
    }
    /**
     * Removes focus from the editor.
     */
    blur() {
      const i = this._rootElement;
      i !== null && i.blur();
      const a = sr(this._window);
      a !== null && a.removeAllRanges();
    }
    /**
     * Returns true if the editor is editable, false otherwise.
     * @returns True if the editor is editable, false otherwise.
     */
    isEditable() {
      return this._editable;
    }
    /**
     * Sets the editable property of the editor. When false, the
     * editor will not listen for user events on the underling contenteditable.
     * @param editable - the value to set the editable mode to.
     */
    setEditable(i) {
      this._editable !== i && (this._editable = i, Vs("editable", this, !0, i));
    }
    /**
     * Returns a JSON-serializable javascript object NOT a JSON string.
     * You still must call JSON.stringify (or something else) to turn the
     * state into a string you can transfer over the wire and store in a database.
     *
     * See {@link LexicalNode.exportJSON}
     *
     * @returns A JSON-serializable javascript object
     */
    toJSON() {
      return {
        editorState: this._editorState.toJSON()
      };
    }
  }
  class Ra extends Lo {
    /** @internal */
    constructor(i, a) {
      super(a), this.__colSpan = i, this.__rowSpan = 1;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        colSpan: this.__colSpan,
        rowSpan: this.__rowSpan
      };
    }
    getColSpan() {
      return this.__colSpan;
    }
    setColSpan(i) {
      return this.getWritable().__colSpan = i, this;
    }
    getRowSpan() {
      return this.__rowSpan;
    }
    setRowSpan(i) {
      return this.getWritable().__rowSpan = i, this;
    }
  }
  function Pr(c) {
    return c instanceof Ra;
  }
  class yu extends Lo {
  }
  function Da(c) {
    return c instanceof yu;
  }
  class Cu extends Lo {
  }
  function Js(c) {
    return c instanceof Cu;
  }
  return $e.$INTERNAL_isPointSelection = cr, $e.$addUpdateTag = ii, $e.$applyNodeReplacement = Yi, $e.$copyNode = $s, $e.$createLineBreakNode = ci, $e.$createNodeSelection = Ea, $e.$createParagraphNode = Ai, $e.$createRangeSelection = Vh, $e.$createTabNode = Oi, $e.$createTextNode = Mn, $e.$getAdjacentNode = zr, $e.$getNearestNodeFromDOMNode = or, $e.$getNearestRootOrShadowRoot = mr, $e.$getNodeByKey = gn, $e.$getPreviousSelection = fs, $e.$getRoot = Hn, $e.$getSelection = en, $e.$getTextContent = tg, $e.$hasAncestor = ut, $e.$hasUpdateTag = Ca, $e.$insertNodes = eg, $e.$isBlockElementNode = qh, $e.$isDecoratorNode = yn, $e.$isElementNode = Ze, $e.$isInlineElementOrDecoratorNode = wl, $e.$isLeafNode = Qr, $e.$isLineBreakNode = ui, $e.$isNodeSelection = ur, $e.$isParagraphNode = _g, $e.$isRangeSelection = ft, $e.$isRootNode = Er, $e.$isRootOrShadowRoot = Or, $e.$isTabNode = Ao, $e.$isTextNode = dt, $e.$nodesOfType = ks, $e.$normalizeSelection__EXPERIMENTAL = Ni, $e.$parseSerializedNode = sg, $e.$selectAll = Is, $e.$setCompositionKey = un, $e.$setSelection = _r, $e.$splitNode = es, $e.BLUR_COMMAND = J, $e.CAN_REDO_COMMAND = g, $e.CAN_UNDO_COMMAND = _, $e.CLEAR_EDITOR_COMMAND = Q, $e.CLEAR_HISTORY_COMMAND = b, $e.CLICK_COMMAND = r, $e.COMMAND_PRIORITY_CRITICAL = Eg, $e.COMMAND_PRIORITY_EDITOR = mg, $e.COMMAND_PRIORITY_HIGH = Ng, $e.COMMAND_PRIORITY_LOW = yg, $e.COMMAND_PRIORITY_NORMAL = Cg, $e.CONTROLLED_TEXT_INSERTION_COMMAND = C, $e.COPY_COMMAND = ne, $e.CUT_COMMAND = Y, $e.DELETE_CHARACTER_COMMAND = o, $e.DELETE_LINE_COMMAND = x, $e.DELETE_WORD_COMMAND = S, $e.DEPRECATED_$computeGridMap = iu, $e.DEPRECATED_$createGridSelection = Jh, $e.DEPRECATED_$getGridCellNodeRect = Ri, $e.DEPRECATED_$getNodeTriplet = ou, $e.DEPRECATED_$isGridCellNode = Pr, $e.DEPRECATED_$isGridNode = Da, $e.DEPRECATED_$isGridRowNode = Js, $e.DEPRECATED_$isGridSelection = Qn, $e.DEPRECATED_GridCellNode = Ra, $e.DEPRECATED_GridNode = yu, $e.DEPRECATED_GridRowNode = Cu, $e.DRAGEND_COMMAND = j, $e.DRAGOVER_COMMAND = w, $e.DRAGSTART_COMMAND = P, $e.DROP_COMMAND = Z, $e.DecoratorNode = wa, $e.ElementNode = Lo, $e.FOCUS_COMMAND = A, $e.FORMAT_ELEMENT_COMMAND = ee, $e.FORMAT_TEXT_COMMAND = D, $e.INDENT_CONTENT_COMMAND = me, $e.INSERT_LINE_BREAK_COMMAND = f, $e.INSERT_PARAGRAPH_COMMAND = h, $e.INSERT_TAB_COMMAND = q, $e.KEY_ARROW_DOWN_COMMAND = B, $e.KEY_ARROW_LEFT_COMMAND = U, $e.KEY_ARROW_RIGHT_COMMAND = v, $e.KEY_ARROW_UP_COMMAND = K, $e.KEY_BACKSPACE_COMMAND = re, $e.KEY_DELETE_COMMAND = V, $e.KEY_DOWN_COMMAND = N, $e.KEY_ENTER_COMMAND = z, $e.KEY_ESCAPE_COMMAND = de, $e.KEY_MODIFIER_COMMAND = ce, $e.KEY_SPACE_COMMAND = te, $e.KEY_TAB_COMMAND = G, $e.LineBreakNode = Ar, $e.MOVE_TO_END = F, $e.MOVE_TO_START = I, $e.OUTDENT_CONTENT_COMMAND = pe, $e.PASTE_COMMAND = T, $e.ParagraphNode = ps, $e.REDO_COMMAND = H, $e.REMOVE_TEXT_COMMAND = O, $e.RootNode = gs, $e.SELECTION_CHANGE_COMMAND = t, $e.SELECT_ALL_COMMAND = W, $e.TabNode = di, $e.TextNode = wi, $e.UNDO_COMMAND = k, $e.createCommand = e, $e.createEditor = xg, $e.getNearestEditorFromDOMNode = ao, $e.isHTMLAnchorElement = Eo, $e.isHTMLElement = To, $e.isSelectionCapturedInDecoratorInput = Bi, $e.isSelectionWithinEditor = Kr, $e;
}
var $a, Ku;
function kt() {
  return Ku || (Ku = 1, $a = process.env.NODE_ENV === "development" ? Wp() : Up()), $a;
}
var Hu;
function zp() {
  if (Hu)
    return Ia;
  Hu = 1;
  var e = kn(), t = kt(), r = rn;
  let o = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
  var f = o ? r.useLayoutEffect : r.useEffect;
  let h = { tag: "history-merge" };
  function C(T, O) {
    if (O !== null) {
      if (O === void 0)
        T.update(() => {
          var S = t.$getRoot();
          if (S.isEmpty()) {
            let x = t.$createParagraphNode();
            S.append(x), S = o ? document.activeElement : null, (t.$getSelection() !== null || S !== null && S === T.getRootElement()) && x.select();
          }
        }, h);
      else if (O !== null)
        switch (typeof O) {
          case "string":
            let S = T.parseEditorState(O);
            T.setEditorState(S, h);
            break;
          case "object":
            T.setEditorState(O, h);
            break;
          case "function":
            T.update(() => {
              t.$getRoot().isEmpty() && O(T);
            }, h);
        }
    }
  }
  return Ia.LexicalComposer = function({ initialConfig: T, children: O }) {
    let S = r.useMemo(() => {
      const { theme: x, namespace: D, editor__DEPRECATED: k, nodes: H, onError: N, editorState: v, html: F } = T, U = e.createLexicalComposerContext(null, x);
      let I = k || null;
      if (I === null) {
        const K = t.createEditor({ editable: T.editable, html: F, namespace: D, nodes: H, onError: (B) => N(B, K), theme: x });
        C(K, v), I = K;
      }
      return [I, U];
    }, []);
    return f(() => {
      let x = T.editable, [D] = S;
      D.setEditable(x !== void 0 ? x : !0);
    }, []), r.createElement(
      e.LexicalComposerContext.Provider,
      { value: S },
      O
    );
  }, Ia;
}
var Fa = {}, Uu;
function Gp() {
  if (Uu)
    return Fa;
  Uu = 1;
  var e = kn(), t = kt(), r = rn;
  const o = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
  var h = o ? r.useLayoutEffect : r.useEffect;
  const C = {
    tag: "history-merge"
  };
  function T({
    initialConfig: S,
    children: x
  }) {
    const D = r.useMemo(
      () => {
        const {
          theme: k,
          namespace: H,
          editor__DEPRECATED: N,
          nodes: v,
          onError: F,
          editorState: U,
          html: I
        } = S, K = e.createLexicalComposerContext(null, k);
        let B = N || null;
        if (B === null) {
          const z = t.createEditor({
            editable: S.editable,
            html: I,
            namespace: H,
            nodes: v,
            onError: (te) => F(te, z),
            theme: k
          });
          O(z, U), B = z;
        }
        return [B, K];
      },
      // We only do this for init
      // eslint-disable-next-line react-hooks/exhaustive-deps
      []
    );
    return h(() => {
      const k = S.editable, [H] = D;
      H.setEditable(k !== void 0 ? k : !0);
    }, []), /* @__PURE__ */ r.createElement(e.LexicalComposerContext.Provider, {
      value: D
    }, x);
  }
  function O(S, x) {
    if (x !== null) {
      if (x === void 0)
        S.update(() => {
          const D = t.$getRoot();
          if (D.isEmpty()) {
            const k = t.$createParagraphNode();
            D.append(k);
            const H = o ? document.activeElement : null;
            (t.$getSelection() !== null || H !== null && H === S.getRootElement()) && k.select();
          }
        }, C);
      else if (x !== null)
        switch (typeof x) {
          case "string": {
            const D = S.parseEditorState(x);
            S.setEditorState(D, C);
            break;
          }
          case "object": {
            S.setEditorState(x, C);
            break;
          }
          case "function": {
            S.update(() => {
              t.$getRoot().isEmpty() && x(S);
            }, C);
            break;
          }
        }
    }
  }
  return Fa.LexicalComposer = T, Fa;
}
const Yp = process.env.NODE_ENV === "development" ? Gp() : zp();
var jp = Yp, Ba = {}, Ka, Wu;
function qp() {
  if (Wu)
    return Ka;
  Wu = 1;
  var e = kn(), t = rn, r = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? t.useLayoutEffect : t.useEffect;
  function o(h) {
    let [C] = e.useLexicalComposerContext(), T = t.useMemo(() => h(C), [C, h]), O = t.useRef(T.initialValueFn()), [S, x] = t.useState(O.current);
    return r(() => {
      let { initialValueFn: D, subscribe: k } = T, H = D();
      return O.current !== H && (O.current = H, x(H)), k((N) => {
        O.current = N, x(N);
      });
    }, [T, h]), S;
  }
  function f(h) {
    return { initialValueFn: () => h.isEditable(), subscribe: (C) => h.registerEditableListener(C) };
  }
  return Ka = function() {
    return o(f);
  }, Ka;
}
var Ha, zu;
function Vp() {
  if (zu)
    return Ha;
  zu = 1;
  var e = kn(), t = rn, f = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? t.useLayoutEffect : t.useEffect;
  function h(O) {
    const [S] = e.useLexicalComposerContext(), x = t.useMemo(() => O(S), [S, O]), D = t.useRef(x.initialValueFn()), [k, H] = t.useState(D.current);
    return f(() => {
      const {
        initialValueFn: N,
        subscribe: v
      } = x, F = N();
      return D.current !== F && (D.current = F, H(F)), v((U) => {
        D.current = U, H(U);
      });
    }, [x, O]), k;
  }
  function C(O) {
    return {
      initialValueFn: () => O.isEditable(),
      subscribe: (S) => O.registerEditableListener(S)
    };
  }
  function T() {
    return h(C);
  }
  return Ha = T, Ha;
}
var Ua, Gu;
function oh() {
  return Gu || (Gu = 1, Ua = process.env.NODE_ENV === "development" ? Vp() : qp()), Ua;
}
var Li = {}, Yu;
function Jp() {
  if (Yu)
    return Li;
  Yu = 1;
  var e = kt();
  function t(f, h = !0) {
    return f ? !1 : (f = r(), h && (f = f.trim()), f === "");
  }
  function r() {
    return e.$getRoot().getTextContent();
  }
  function o(f) {
    if (!t(f, !1))
      return !1;
    f = e.$getRoot().getChildren();
    let h = f.length;
    if (1 < h)
      return !1;
    for (let T = 0; T < h; T++) {
      var C = f[T];
      if (e.$isDecoratorNode(C))
        return !1;
      if (e.$isElementNode(C)) {
        if (!e.$isParagraphNode(C) || C.__indent !== 0)
          return !1;
        C = C.getChildren();
        let O = C.length;
        for (let S = 0; S < O; S++)
          if (!e.$isTextNode(C[T]))
            return !1;
      }
    }
    return !0;
  }
  return Li.$canShowPlaceholder = o, Li.$canShowPlaceholderCurry = function(f) {
    return () => o(f);
  }, Li.$findTextIntersectionFromCharacters = function(f, h) {
    var C = f.getFirstChild();
    f = 0;
    e:
      for (; C !== null; ) {
        if (e.$isElementNode(C)) {
          var T = C.getFirstChild();
          if (T !== null) {
            C = T;
            continue;
          }
        } else if (e.$isTextNode(C)) {
          if (T = C.getTextContentSize(), f + T > h)
            return { node: C, offset: h - f };
          f += T;
        }
        if (T = C.getNextSibling(), T !== null)
          C = T;
        else {
          for (C = C.getParent(); C !== null; ) {
            if (T = C.getNextSibling(), T !== null) {
              C = T;
              continue e;
            }
            C = C.getParent();
          }
          break;
        }
      }
    return null;
  }, Li.$isRootTextContentEmpty = t, Li.$isRootTextContentEmptyCurry = function(f, h) {
    return () => t(f, h);
  }, Li.$rootTextContent = r, Li.registerLexicalTextEntity = function(f, h, C, T) {
    let O = (x) => {
      const D = e.$createTextNode(x.getTextContent());
      D.setFormat(x.getFormat()), x.replace(D);
    }, S = f.registerNodeTransform(e.TextNode, (x) => {
      if (x.isSimpleText()) {
        var D = x.getPreviousSibling(), k = x.getTextContent(), H = x;
        if (e.$isTextNode(D)) {
          var N = D.getTextContent(), v = h(N + k);
          if (D instanceof C) {
            if (v === null || D.getLatest().__mode !== 0) {
              O(D);
              return;
            }
            if (v = v.end - N.length, 0 < v) {
              H = k.slice(0, v), H = N + H, D.select(), D.setTextContent(H), v === k.length ? x.remove() : (D = k.slice(v), x.setTextContent(D));
              return;
            }
          } else if (v === null || v.start < N.length)
            return;
        }
        for (; ; ) {
          if (x = h(k), k = v = x === null ? "" : k.slice(x.end), v === "") {
            if (N = H.getNextSibling(), e.$isTextNode(N)) {
              if (v = H.getTextContent() + N.getTextContent(), v = h(v), v === null) {
                N instanceof C ? O(N) : N.markDirty();
                break;
              } else if (v.start !== 0)
                break;
            }
          } else if (N = h(v), N !== null && N.start === 0)
            break;
          if (x === null)
            break;
          if (x.start === 0 && e.$isTextNode(D) && D.isTextEntity())
            continue;
          let F;
          if (x.start === 0 ? [F, H] = H.splitText(x.end) : [, F, H] = H.splitText(x.start, x.end), x = T(F), x.setFormat(F.getFormat()), F.replace(x), H == null)
            break;
        }
      }
    });
    return f = f.registerNodeTransform(C, (x) => {
      var D = x.getTextContent();
      const k = h(D);
      k === null || k.start !== 0 ? O(x) : D.length > k.end ? x.splitText(k.end) : (D = x.getPreviousSibling(), e.$isTextNode(D) && D.isTextEntity() && (O(D), O(x)), D = x.getNextSibling(), e.$isTextNode(D) && D.isTextEntity() && (O(D), x instanceof C && O(x)));
    }), [S, f];
  }, Li;
}
var Pi = {}, ju;
function Zp() {
  if (ju)
    return Pi;
  ju = 1;
  var e = kt();
  function t(O, S) {
    let x = O.getFirstChild(), D = 0;
    e:
      for (; x !== null; ) {
        if (e.$isElementNode(x)) {
          const N = x.getFirstChild();
          if (N !== null) {
            x = N;
            continue;
          }
        } else if (e.$isTextNode(x)) {
          const N = x.getTextContentSize();
          if (D + N > S)
            return {
              node: x,
              offset: S - D
            };
          D += N;
        }
        const k = x.getNextSibling();
        if (k !== null) {
          x = k;
          continue;
        }
        let H = x.getParent();
        for (; H !== null; ) {
          const N = H.getNextSibling();
          if (N !== null) {
            x = N;
            continue e;
          }
          H = H.getParent();
        }
        break;
      }
    return null;
  }
  function r(O, S = !0) {
    if (O)
      return !1;
    let x = f();
    return S && (x = x.trim()), x === "";
  }
  function o(O, S) {
    return () => r(O, S);
  }
  function f() {
    return e.$getRoot().getTextContent();
  }
  function h(O) {
    if (!r(O, !1))
      return !1;
    const x = e.$getRoot().getChildren(), D = x.length;
    if (D > 1)
      return !1;
    for (let k = 0; k < D; k++) {
      const H = x[k];
      if (e.$isDecoratorNode(H))
        return !1;
      if (e.$isElementNode(H)) {
        if (!e.$isParagraphNode(H) || H.__indent !== 0)
          return !1;
        const N = H.getChildren(), v = N.length;
        for (let F = 0; F < v; F++) {
          const U = N[k];
          if (!e.$isTextNode(U))
            return !1;
        }
      }
    }
    return !0;
  }
  function C(O) {
    return () => h(O);
  }
  function T(O, S, x, D) {
    const k = (K) => K instanceof x, H = (K) => {
      const B = e.$createTextNode(K.getTextContent());
      B.setFormat(K.getFormat()), K.replace(B);
    }, N = (K) => K.getLatest().__mode, v = (K) => {
      if (!K.isSimpleText())
        return;
      const B = K.getPreviousSibling();
      let z = K.getTextContent(), te = K, re;
      if (e.$isTextNode(B)) {
        const de = B.getTextContent(), V = de + z, G = S(V);
        if (k(B))
          if (G === null || N(B) !== 0) {
            H(B);
            return;
          } else {
            const q = G.end - de.length;
            if (q > 0) {
              const me = z.slice(0, q), pe = de + me;
              if (B.select(), B.setTextContent(pe), q === z.length)
                K.remove();
              else {
                const Z = z.slice(q);
                K.setTextContent(Z);
              }
              return;
            }
          }
        else if (G === null || G.start < de.length)
          return;
      }
      for (; ; ) {
        re = S(z);
        let de = re === null ? "" : z.slice(re.end);
        if (z = de, de === "") {
          const q = te.getNextSibling();
          if (e.$isTextNode(q)) {
            de = te.getTextContent() + q.getTextContent();
            const me = S(de);
            if (me === null) {
              k(q) ? H(q) : q.markDirty();
              return;
            } else if (me.start !== 0)
              return;
          }
        } else {
          const q = S(de);
          if (q !== null && q.start === 0)
            return;
        }
        if (re === null)
          return;
        if (re.start === 0 && e.$isTextNode(B) && B.isTextEntity())
          continue;
        let V;
        re.start === 0 ? [V, te] = te.splitText(re.end) : [, V, te] = te.splitText(re.start, re.end);
        const G = D(V);
        if (G.setFormat(V.getFormat()), V.replace(G), te == null)
          return;
      }
    }, F = (K) => {
      const B = K.getTextContent(), z = S(B);
      if (z === null || z.start !== 0) {
        H(K);
        return;
      }
      if (B.length > z.end) {
        K.splitText(z.end);
        return;
      }
      const te = K.getPreviousSibling();
      e.$isTextNode(te) && te.isTextEntity() && (H(te), H(K));
      const re = K.getNextSibling();
      e.$isTextNode(re) && re.isTextEntity() && (H(re), k(K) && H(K));
    }, U = O.registerNodeTransform(e.TextNode, v), I = O.registerNodeTransform(x, F);
    return [U, I];
  }
  return Pi.$canShowPlaceholder = h, Pi.$canShowPlaceholderCurry = C, Pi.$findTextIntersectionFromCharacters = t, Pi.$isRootTextContentEmpty = r, Pi.$isRootTextContentEmptyCurry = o, Pi.$rootTextContent = f, Pi.registerLexicalTextEntity = T, Pi;
}
var Wa, qu;
function sh() {
  return qu || (qu = 1, Wa = process.env.NODE_ENV === "development" ? Zp() : Jp()), Wa;
}
var fn = {}, Pn = {}, Vu;
function Xp() {
  if (Vu)
    return Pn;
  Vu = 1;
  var e = kt();
  let t = /* @__PURE__ */ new Map();
  function r(N) {
    for (; N != null; ) {
      if (N.nodeType === Node.TEXT_NODE)
        return N;
      N = N.firstChild;
    }
    return null;
  }
  function o(N) {
    let v = N.parentNode;
    if (v == null)
      throw Error("Should never happen");
    return [v, Array.from(v.childNodes).indexOf(N)];
  }
  function f(N) {
    let v = {};
    N = N.split(";");
    for (let F of N)
      if (F !== "") {
        let [U, I] = F.split(/:([^]+)/);
        U && I && (v[U.trim()] = I.trim());
      }
    return v;
  }
  function h(N) {
    let v = t.get(N);
    return v === void 0 && (v = f(N), t.set(N, v)), v;
  }
  function C(N) {
    let v = "";
    for (let F in N)
      F && (v += `${F}: ${N[F]};`);
    return v;
  }
  function T(N, v) {
    var F = h("getStyle" in N ? N.getStyle() : N.style);
    v = Object.entries(v).reduce((U, [I, K]) => (K === null ? delete U[I] : U[I] = K, U), { ...F }), F = C(v), N.setStyle(F), t.set(F, v);
  }
  function O(N, v) {
    var F = N.getNodes(), U = F.length;
    if (e.DEPRECATED_$isGridSelection(N)) {
      for (var I = e.$createRangeSelection(), K = I.anchor, B = I.focus, z = 0; z < U; z++) {
        var te = F[z];
        e.DEPRECATED_$isGridCellNode(te) && (K.set(te.getKey(), 0, "element"), B.set(te.getKey(), te.getChildrenSize(), "element"), O(e.$normalizeSelection__EXPERIMENTAL(I), v));
      }
      e.$setSelection(N);
    } else if (--U, I = F[0], K = F[U], N.isCollapsed() && e.$isRangeSelection(N))
      T(N, v);
    else {
      z = N.anchor;
      var re = N.focus;
      te = I.getTextContent().length;
      var de = re.offset, V = z.offset, G = z.isBefore(re);
      B = G ? V : de, N = G ? de : V;
      var q = G ? z.type : re.type, me = G ? re.type : z.type;
      if (re = G ? re.key : z.key, e.$isTextNode(I) && B === te && (G = I.getNextSibling(), e.$isTextNode(G) && (B = V = 0, I = G)), F.length === 1)
        e.$isTextNode(I) && (B = q === "element" ? 0 : V > de ? de : V, N = me === "element" ? te : V > de ? V : de, B !== N && (B === 0 && N === te ? (T(I, v), I.select(B, N)) : (F = I.splitText(B, N), F = B === 0 ? F[0] : F[1], T(F, v), F.select(0, N - B))));
      else
        for (e.$isTextNode(I) && B < I.getTextContentSize() && (B !== 0 && (I = I.splitText(B)[1], B = 0, z.set(I.getKey(), B, "text")), T(I, v)), e.$isTextNode(K) && (B = K.getTextContent().length, K.__key !== re && N !== 0 && (N = B), N !== B && ([K] = K.splitText(N)), N !== 0 && T(K, v)), N = 1; N < U; N++)
          B = F[N], z = B.getKey(), e.$isTextNode(B) && z !== I.getKey() && z !== K.getKey() && !B.isToken() && T(B, v);
    }
  }
  function S(N) {
    for (; N !== null && !e.$isRootOrShadowRoot(N); ) {
      let v = N.getLatest(), F = N.getParent();
      v.getChildrenSize() === 0 && N.remove(!0), N = F;
    }
  }
  function x(N, v, F, U, I = null) {
    if (v.length !== 0) {
      var K = v[0], B = /* @__PURE__ */ new Map(), z = [];
      K = e.$isElementNode(K) ? K : K.getParentOrThrow(), K.isInline() && (K = K.getParentOrThrow());
      for (var te = !1; K !== null; ) {
        var re = K.getPreviousSibling();
        if (re !== null) {
          K = re, te = !0;
          break;
        }
        if (K = K.getParentOrThrow(), e.$isRootOrShadowRoot(K))
          break;
      }
      re = /* @__PURE__ */ new Set();
      for (var de = 0; de < F; de++) {
        var V = v[de];
        e.$isElementNode(V) && V.getChildrenSize() === 0 && re.add(V.getKey());
      }
      var G = /* @__PURE__ */ new Set();
      for (de = 0; de < F; de++) {
        V = v[de];
        var q = V.getParent();
        if (q !== null && q.isInline() && (q = q.getParent()), q !== null && e.$isLeafNode(V) && !G.has(V.getKey())) {
          if (V = q.getKey(), B.get(V) === void 0) {
            let me = U();
            me.setFormat(q.getFormatType()), me.setIndent(q.getIndent()), z.push(me), B.set(V, me), q.getChildren().forEach((pe) => {
              me.append(pe), G.add(pe.getKey()), e.$isElementNode(pe) && pe.getChildrenKeys().forEach((Z) => G.add(Z));
            }), S(q);
          }
        } else
          re.has(V.getKey()) && (q = U(), q.setFormat(V.getFormatType()), q.setIndent(V.getIndent()), z.push(q), V.remove(!0));
      }
      if (I !== null)
        for (v = 0; v < z.length; v++)
          I.append(z[v]);
      if (v = null, e.$isRootOrShadowRoot(K))
        if (te)
          if (I !== null)
            K.insertAfter(I);
          else
            for (I = z.length - 1; 0 <= I; I--)
              K.insertAfter(z[I]);
        else if (te = K.getFirstChild(), e.$isElementNode(te) && (K = te), te === null)
          if (I)
            K.append(I);
          else
            for (I = 0; I < z.length; I++)
              te = z[I], K.append(te), v = te;
        else if (I !== null)
          te.insertBefore(I);
        else
          for (K = 0; K < z.length; K++)
            I = z[K], te.insertBefore(I), v = I;
      else if (I)
        K.insertAfter(I);
      else
        for (I = z.length - 1; 0 <= I; I--)
          te = z[I], K.insertAfter(te), v = te;
      z = e.$getPreviousSelection(), e.$isRangeSelection(z) && z.anchor.getNode().isAttached() && z.focus.getNode().isAttached() ? e.$setSelection(z.clone()) : v !== null ? v.selectEnd() : N.dirty = !0;
    }
  }
  function D(N, v, F, U) {
    N.modify(v ? "extend" : "move", F, U);
  }
  function k(N) {
    return N = N.anchor.getNode(), (e.$isRootNode(N) ? N : N.getParentOrThrow()).getDirection() === "rtl";
  }
  function H(N) {
    if (e.$isDecoratorNode(N) && !N.isInline())
      return !0;
    if (!e.$isElementNode(N) || e.$isRootOrShadowRoot(N))
      return !1;
    var v = N.getFirstChild();
    return v = v === null || e.$isLineBreakNode(v) || e.$isTextNode(v) || v.isInline(), !N.isInline() && N.canBeEmpty() !== !1 && v;
  }
  return Pn.$addNodeStyle = function(N) {
    N = N.getStyle();
    let v = f(N);
    t.set(N, v);
  }, Pn.$cloneWithProperties = function(N) {
    let v = N.constructor.clone(N);
    return v.__parent = N.__parent, v.__next = N.__next, v.__prev = N.__prev, e.$isElementNode(N) && e.$isElementNode(v) ? (v.__first = N.__first, v.__last = N.__last, v.__size = N.__size, v.__format = N.__format, v.__indent = N.__indent, v.__dir = N.__dir, v) : (e.$isTextNode(N) && e.$isTextNode(v) && (v.__format = N.__format, v.__style = N.__style, v.__mode = N.__mode, v.__detail = N.__detail), v);
  }, Pn.$getSelectionStyleValueForProperty = function(N, v, F = "") {
    let U = null, I = N.getNodes();
    var K = N.anchor, B = N.focus, z = N.isBackward();
    let te = z ? B.offset : K.offset;
    if (K = z ? B.getNode() : K.getNode(), N.isCollapsed() && N.style !== "" && (N = h(N.style), N !== null && v in N))
      return N[v];
    for (N = 0; N < I.length; N++) {
      var re = I[N];
      if ((N === 0 || te !== 0 || !re.is(K)) && e.$isTextNode(re)) {
        if (B = v, z = F, re = re.getStyle(), re = h(re), B = re !== null && re[B] || z, U === null)
          U = B;
        else if (U !== B) {
          U = "";
          break;
        }
      }
    }
    return U === null ? F : U;
  }, Pn.$isAtNodeEnd = function(N) {
    return N.type === "text" ? N.offset === N.getNode().getTextContentSize() : N.offset === N.getNode().getChildrenSize();
  }, Pn.$isParentElementRTL = k, Pn.$moveCaretSelection = D, Pn.$moveCharacter = function(N, v, F) {
    let U = k(N);
    D(N, v, F ? !U : U, "character");
  }, Pn.$patchStyleText = O, Pn.$selectAll = function(N) {
    let v = N.anchor;
    N = N.focus;
    var F = v.getNode().getTopLevelElementOrThrow().getParentOrThrow();
    let U = F.getFirstDescendant();
    F = F.getLastDescendant();
    let I = "element", K = "element", B = 0;
    e.$isTextNode(U) ? I = "text" : e.$isElementNode(U) || U === null || (U = U.getParentOrThrow()), e.$isTextNode(F) ? (K = "text", B = F.getTextContentSize()) : e.$isElementNode(F) || F === null || (F = F.getParentOrThrow()), U && F && (v.set(U.getKey(), 0, I), N.set(F.getKey(), B, K));
  }, Pn.$setBlocksType = function(N, v) {
    if (N.anchor.key === "root") {
      v = v();
      var F = e.$getRoot();
      (N = F.getFirstChild()) ? N.replace(v, !0) : F.append(v);
    } else {
      for (F = N.getNodes(), N = N.anchor.getNode(); N !== null && N.getParent() !== null && !H(N); )
        N = N.getParentOrThrow();
      for ((N = H(N) ? N : null) && F.indexOf(N) === -1 && F.push(N), N = 0; N < F.length; N++) {
        let U = F[N];
        if (!H(U))
          continue;
        let I = v();
        I.setFormat(U.getFormatType()), I.setIndent(U.getIndent()), U.replace(I, !0);
      }
    }
  }, Pn.$shouldOverrideDefaultCharacterSelection = function(N, v) {
    return N = e.$getAdjacentNode(N.focus, v), e.$isDecoratorNode(N) && !N.isIsolated() || e.$isElementNode(N) && !N.isInline() && !N.canBeEmpty();
  }, Pn.$sliceSelectedTextNodeContent = function(N, v) {
    if (v.isSelected() && !v.isSegmented() && !v.isToken() && e.$INTERNAL_isPointSelection(N)) {
      var F = N.anchor.getNode(), U = N.focus.getNode(), I = v.is(F), K = v.is(U);
      if (I || K) {
        I = N.isBackward();
        let [B, z] = N.getCharacterOffsets();
        N = F.is(U), K = v.is(I ? U : F), U = v.is(I ? F : U), F = 0;
        let te;
        N ? (F = B > z ? z : B, te = B > z ? B : z) : K ? (F = I ? z : B, te = void 0) : U && (I = I ? B : z, F = 0, te = I), v.__text = v.__text.slice(F, te);
      }
    }
    return v;
  }, Pn.$wrapNodes = function(N, v, F = null) {
    var U = N.getNodes();
    let I = U.length;
    var K = N.anchor;
    if (I === 0 || I === 1 && K.type === "element" && K.getNode().getChildrenSize() === 0) {
      N = K.type === "text" ? K.getNode().getParentOrThrow() : K.getNode(), U = N.getChildren();
      let z = v();
      z.setFormat(N.getFormatType()), z.setIndent(N.getIndent()), U.forEach((te) => z.append(te)), F && (z = F.append(z)), N.replace(z);
    } else {
      K = null;
      var B = [];
      for (let z = 0; z < I; z++) {
        let te = U[z];
        e.$isRootOrShadowRoot(te) ? (x(N, B, B.length, v, F), B = [], K = te) : K === null || K !== null && e.$hasAncestor(
          te,
          K
        ) ? B.push(te) : (x(N, B, B.length, v, F), B = [te]);
      }
      x(N, B, B.length, v, F);
    }
  }, Pn.createDOMRange = function(N, v, F, U, I) {
    let K = v.getKey(), B = U.getKey(), z = document.createRange(), te = N.getElementByKey(K);
    if (N = N.getElementByKey(B), e.$isTextNode(v) && (te = r(te)), e.$isTextNode(U) && (N = r(N)), v === void 0 || U === void 0 || te === null || N === null)
      return null;
    te.nodeName === "BR" && ([te, F] = o(te)), N.nodeName === "BR" && ([N, I] = o(N)), v = te.firstChild, te === N && v != null && v.nodeName === "BR" && F === 0 && I === 0 && (I = 1);
    try {
      z.setStart(te, F), z.setEnd(N, I);
    } catch {
      return null;
    }
    return !z.collapsed || F === I && K === B || (z.setStart(N, I), z.setEnd(
      te,
      F
    )), z;
  }, Pn.createRectsFromDOMRange = function(N, v) {
    var F = N.getRootElement();
    if (F === null)
      return [];
    N = F.getBoundingClientRect(), F = getComputedStyle(F), F = parseFloat(F.paddingLeft) + parseFloat(F.paddingRight), v = Array.from(v.getClientRects());
    let U = v.length;
    v.sort((K, B) => {
      let z = K.top - B.top;
      return 3 >= Math.abs(z) ? K.left - B.left : z;
    });
    let I;
    for (let K = 0; K < U; K++) {
      let B = v[K], z = B.width + F === N.width;
      I && I.top <= B.top && I.top + I.height > B.top && I.left + I.width > B.left || z ? (v.splice(K--, 1), U--) : I = B;
    }
    return v;
  }, Pn.getStyleObjectFromCSS = h, Pn.trimTextContentFromAnchor = function(N, v, F) {
    let U = v.getNode();
    if (e.$isElementNode(U)) {
      var I = U.getDescendantByIndex(v.offset);
      I !== null && (U = I);
    }
    for (; 0 < F && U !== null; ) {
      e.$isElementNode(U) && (I = U.getLastDescendant(), I !== null && (U = I));
      var K = U.getPreviousSibling(), B = 0;
      if (K === null) {
        I = U.getParentOrThrow();
        for (var z = I.getPreviousSibling(); z === null; ) {
          if (I = I.getParent(), I === null) {
            K = null;
            break;
          }
          z = I.getPreviousSibling();
        }
        I !== null && (B = I.isInline() ? 0 : 2, K = z);
      }
      if (z = U.getTextContent(), z === "" && e.$isElementNode(U) && !U.isInline() && (z = `

`), I = z.length, !e.$isTextNode(U) || F >= I)
        z = U.getParent(), U.remove(), z == null || z.getChildrenSize() !== 0 || e.$isRootNode(z) || z.remove(), F -= I + B, U = K;
      else {
        let te = U.getKey();
        B = N.getEditorState().read(() => {
          const de = e.$getNodeByKey(te);
          return e.$isTextNode(de) && de.isSimpleText() ? de.getTextContent() : null;
        }), K = I - F;
        let re = z.slice(0, K);
        B !== null && B !== z ? (F = e.$getPreviousSelection(), I = U, U.isSimpleText() ? U.setTextContent(B) : (I = e.$createTextNode(B), U.replace(I)), e.$isRangeSelection(F) && F.isCollapsed() && (F = F.anchor.offset, I.select(F, F))) : U.isSimpleText() ? (B = v.key === te, z = v.offset, z < F && (z = I), F = B ? z - F : 0, I = B ? z : K, B && F === 0 ? ([F] = U.splitText(F, I), F.remove()) : ([, F] = U.splitText(F, I), F.remove())) : (F = e.$createTextNode(re), U.replace(F)), F = 0;
      }
    }
  }, Pn;
}
var In = {}, Ju;
function Qp() {
  if (Ju)
    return In;
  Ju = 1;
  var e = kt();
  const t = /* @__PURE__ */ new Map();
  function r(P) {
    let w = P;
    for (; w != null; ) {
      if (w.nodeType === Node.TEXT_NODE)
        return w;
      w = w.firstChild;
    }
    return null;
  }
  function o(P) {
    const w = P.parentNode;
    if (w == null)
      throw new Error("Should never happen");
    return [w, Array.from(w.childNodes).indexOf(P)];
  }
  function f(P, w, j, ne, Y) {
    const W = w.getKey(), Q = ne.getKey(), b = document.createRange();
    let g = P.getElementByKey(W), _ = P.getElementByKey(Q), A = j, J = Y;
    if (e.$isTextNode(w) && (g = r(g)), e.$isTextNode(ne) && (_ = r(_)), w === void 0 || ne === void 0 || g === null || _ === null)
      return null;
    g.nodeName === "BR" && ([g, A] = o(g)), _.nodeName === "BR" && ([_, J] = o(_));
    const ce = g.firstChild;
    g === _ && ce != null && ce.nodeName === "BR" && A === 0 && J === 0 && (J = 1);
    try {
      b.setStart(g, A), b.setEnd(_, J);
    } catch {
      return null;
    }
    return b.collapsed && (A !== J || W !== Q) && (b.setStart(_, J), b.setEnd(g, A)), b;
  }
  function h(P, w) {
    const j = P.getRootElement();
    if (j === null)
      return [];
    const ne = j.getBoundingClientRect(), Y = getComputedStyle(j), W = parseFloat(Y.paddingLeft) + parseFloat(Y.paddingRight), Q = Array.from(w.getClientRects());
    let b = Q.length;
    Q.sort((_, A) => {
      const J = _.top - A.top;
      return Math.abs(J) <= 3 ? _.left - A.left : J;
    });
    let g;
    for (let _ = 0; _ < b; _++) {
      const A = Q[_], J = g && g.top <= A.top && g.top + g.height > A.top && g.left + g.width > A.left, ce = A.width + W === ne.width;
      if (J || ce) {
        Q.splice(_--, 1), b--;
        continue;
      }
      g = A;
    }
    return Q;
  }
  function C(P) {
    const w = {}, j = P.split(";");
    for (const ne of j)
      if (ne !== "") {
        const [Y, W] = ne.split(/:([^]+)/);
        Y && W && (w[Y.trim()] = W.trim());
      }
    return w;
  }
  function T(P) {
    let w = t.get(P);
    return w === void 0 && (w = C(P), t.set(P, w)), Object.freeze(w), w;
  }
  function O(P) {
    let w = "";
    for (const j in P)
      j && (w += `${j}: ${P[j]};`);
    return w;
  }
  function S(P, w) {
    return P.__first = w.__first, P.__last = w.__last, P.__size = w.__size, P.__format = w.__format, P.__indent = w.__indent, P.__dir = w.__dir, P;
  }
  function x(P, w) {
    return P.__format = w.__format, P.__style = w.__style, P.__mode = w.__mode, P.__detail = w.__detail, P;
  }
  function D(P) {
    const j = P.constructor.clone(P);
    return j.__parent = P.__parent, j.__next = P.__next, j.__prev = P.__prev, e.$isElementNode(P) && e.$isElementNode(j) ? S(j, P) : e.$isTextNode(P) && e.$isTextNode(j) ? x(j, P) : j;
  }
  function k(P, w) {
    if (w.isSelected() && !w.isSegmented() && !w.isToken() && e.$INTERNAL_isPointSelection(P)) {
      const j = P.anchor.getNode(), ne = P.focus.getNode(), Y = w.is(j), W = w.is(ne);
      if (Y || W) {
        const Q = P.isBackward(), [b, g] = P.getCharacterOffsets(), _ = j.is(ne), A = w.is(Q ? ne : j), J = w.is(Q ? j : ne);
        let ce = 0, ge;
        if (_)
          ce = b > g ? g : b, ge = b > g ? b : g;
        else if (A)
          ce = Q ? g : b, ge = void 0;
        else if (J) {
          const ae = Q ? b : g;
          ce = 0, ge = ae;
        }
        return w.__text = w.__text.slice(ce, ge), w;
      }
    }
    return w;
  }
  function H(P) {
    return P.type === "text" ? P.offset === P.getNode().getTextContentSize() : P.offset === P.getNode().getChildrenSize();
  }
  function N(P, w, j) {
    let ne = w.getNode(), Y = j;
    if (e.$isElementNode(ne)) {
      const W = ne.getDescendantByIndex(w.offset);
      W !== null && (ne = W);
    }
    for (; Y > 0 && ne !== null; ) {
      if (e.$isElementNode(ne)) {
        const _ = ne.getLastDescendant();
        _ !== null && (ne = _);
      }
      let W = ne.getPreviousSibling(), Q = 0;
      if (W === null) {
        let _ = ne.getParentOrThrow(), A = _.getPreviousSibling();
        for (; A === null; ) {
          if (_ = _.getParent(), _ === null) {
            W = null;
            break;
          }
          A = _.getPreviousSibling();
        }
        _ !== null && (Q = _.isInline() ? 0 : 2, W = A);
      }
      let b = ne.getTextContent();
      b === "" && e.$isElementNode(ne) && !ne.isInline() && (b = `

`);
      const g = b.length;
      if (!e.$isTextNode(ne) || Y >= g) {
        const _ = ne.getParent();
        ne.remove(), _ != null && _.getChildrenSize() === 0 && !e.$isRootNode(_) && _.remove(), Y -= g + Q, ne = W;
      } else {
        const _ = ne.getKey(), A = P.getEditorState().read(() => {
          const ge = e.$getNodeByKey(_);
          return e.$isTextNode(ge) && ge.isSimpleText() ? ge.getTextContent() : null;
        }), J = g - Y, ce = b.slice(0, J);
        if (A !== null && A !== b) {
          const ge = e.$getPreviousSelection();
          let ae = ne;
          if (ne.isSimpleText())
            ne.setTextContent(A);
          else {
            const Te = e.$createTextNode(A);
            ne.replace(Te), ae = Te;
          }
          if (e.$isRangeSelection(ge) && ge.isCollapsed()) {
            const Te = ge.anchor.offset;
            ae.select(Te, Te);
          }
        } else if (ne.isSimpleText()) {
          const ge = w.key === _;
          let ae = w.offset;
          ae < Y && (ae = g);
          const Te = ge ? ae - Y : 0, Me = ge ? ae : J;
          if (ge && Te === 0) {
            const [ze] = ne.splitText(Te, Me);
            ze.remove();
          } else {
            const [, ze] = ne.splitText(Te, Me);
            ze.remove();
          }
        } else {
          const ge = e.$createTextNode(ce);
          ne.replace(ge);
        }
        Y = 0;
      }
    }
  }
  function v(P) {
    const w = P.getStyle(), j = C(w);
    t.set(w, j);
  }
  function F(P, w) {
    const j = T("getStyle" in P ? P.getStyle() : P.style), ne = Object.entries(w).reduce((W, [Q, b]) => (b === null ? delete W[Q] : W[Q] = b, W), {
      ...j
    }), Y = O(ne);
    P.setStyle(Y), t.set(Y, ne);
  }
  function U(P, w) {
    const j = P.getNodes(), ne = j.length;
    if (e.DEPRECATED_$isGridSelection(P)) {
      const ie = e.$createRangeSelection(), ue = ie.anchor, we = ie.focus;
      for (let Le = 0; Le < ne; Le++) {
        const Be = j[Le];
        e.DEPRECATED_$isGridCellNode(Be) && (ue.set(Be.getKey(), 0, "element"), we.set(Be.getKey(), Be.getChildrenSize(), "element"), U(e.$normalizeSelection__EXPERIMENTAL(ie), w));
      }
      e.$setSelection(P);
      return;
    }
    const Y = ne - 1;
    let W = j[0], Q = j[Y];
    if (P.isCollapsed() && e.$isRangeSelection(P)) {
      F(P, w);
      return;
    }
    const b = P.anchor, g = P.focus, A = W.getTextContent().length, J = g.offset;
    let ce = b.offset;
    const ge = b.isBefore(g);
    let ae = ge ? ce : J, Te = ge ? J : ce;
    const Me = ge ? b.type : g.type, ze = ge ? g.type : b.type, oe = ge ? g.key : b.key;
    if (e.$isTextNode(W) && ae === A) {
      const ie = W.getNextSibling();
      e.$isTextNode(ie) && (ce = 0, ae = 0, W = ie);
    }
    if (j.length === 1) {
      if (e.$isTextNode(W)) {
        if (ae = Me === "element" ? 0 : ce > J ? J : ce, Te = ze === "element" ? A : ce > J ? ce : J, ae === Te)
          return;
        if (ae === 0 && Te === A)
          F(W, w), W.select(ae, Te);
        else {
          const ie = W.splitText(ae, Te), ue = ae === 0 ? ie[0] : ie[1];
          F(ue, w), ue.select(0, Te - ae);
        }
      }
    } else {
      if (e.$isTextNode(W) && ae < W.getTextContentSize() && (ae !== 0 && (W = W.splitText(ae)[1], ae = 0, b.set(W.getKey(), ae, "text")), F(W, w)), e.$isTextNode(Q)) {
        const ue = Q.getTextContent().length;
        Q.__key !== oe && Te !== 0 && (Te = ue), Te !== ue && ([Q] = Q.splitText(Te)), Te !== 0 && F(Q, w);
      }
      for (let ie = 1; ie < Y; ie++) {
        const ue = j[ie], we = ue.getKey();
        e.$isTextNode(ue) && we !== W.getKey() && we !== Q.getKey() && !ue.isToken() && F(ue, w);
      }
    }
  }
  function I(P, w) {
    if (P.anchor.key === "root") {
      const Y = w(), W = e.$getRoot(), Q = W.getFirstChild();
      Q ? Q.replace(Y, !0) : W.append(Y);
      return;
    }
    const j = P.getNodes(), ne = ee(P.anchor.getNode(), Z);
    ne && j.indexOf(ne) === -1 && j.push(ne);
    for (let Y = 0; Y < j.length; Y++) {
      const W = j[Y];
      if (!Z(W))
        continue;
      const Q = w();
      Q.setFormat(W.getFormatType()), Q.setIndent(W.getIndent()), W.replace(Q, !0);
    }
  }
  function K(P) {
    return P.getNode().isAttached();
  }
  function B(P) {
    let w = P;
    for (; w !== null && !e.$isRootOrShadowRoot(w); ) {
      const j = w.getLatest(), ne = w.getParent();
      j.getChildrenSize() === 0 && w.remove(!0), w = ne;
    }
  }
  function z(P, w, j = null) {
    const ne = P.getNodes(), Y = ne.length, W = P.anchor;
    if (Y === 0 || Y === 1 && W.type === "element" && W.getNode().getChildrenSize() === 0) {
      const g = W.type === "text" ? W.getNode().getParentOrThrow() : W.getNode(), _ = g.getChildren();
      let A = w();
      A.setFormat(g.getFormatType()), A.setIndent(g.getIndent()), _.forEach((J) => A.append(J)), j && (A = j.append(A)), g.replace(A);
      return;
    }
    let Q = null, b = [];
    for (let g = 0; g < Y; g++) {
      const _ = ne[g];
      e.$isRootOrShadowRoot(_) ? (te(P, b, b.length, w, j), b = [], Q = _) : Q === null || Q !== null && e.$hasAncestor(_, Q) ? b.push(_) : (te(P, b, b.length, w, j), b = [_]);
    }
    te(P, b, b.length, w, j);
  }
  function te(P, w, j, ne, Y = null) {
    if (w.length === 0)
      return;
    const W = w[0], Q = /* @__PURE__ */ new Map(), b = [];
    let g = e.$isElementNode(W) ? W : W.getParentOrThrow();
    g.isInline() && (g = g.getParentOrThrow());
    let _ = !1;
    for (; g !== null; ) {
      const ae = g.getPreviousSibling();
      if (ae !== null) {
        g = ae, _ = !0;
        break;
      }
      if (g = g.getParentOrThrow(), e.$isRootOrShadowRoot(g))
        break;
    }
    const A = /* @__PURE__ */ new Set();
    for (let ae = 0; ae < j; ae++) {
      const Te = w[ae];
      e.$isElementNode(Te) && Te.getChildrenSize() === 0 && A.add(Te.getKey());
    }
    const J = /* @__PURE__ */ new Set();
    for (let ae = 0; ae < j; ae++) {
      const Te = w[ae];
      let Me = Te.getParent();
      if (Me !== null && Me.isInline() && (Me = Me.getParent()), Me !== null && e.$isLeafNode(Te) && !J.has(Te.getKey())) {
        const ze = Me.getKey();
        if (Q.get(ze) === void 0) {
          const oe = ne();
          oe.setFormat(Me.getFormatType()), oe.setIndent(Me.getIndent()), b.push(oe), Q.set(ze, oe), Me.getChildren().forEach((ie) => {
            oe.append(ie), J.add(ie.getKey()), e.$isElementNode(ie) && ie.getChildrenKeys().forEach((ue) => J.add(ue));
          }), B(Me);
        }
      } else if (A.has(Te.getKey())) {
        const ze = ne();
        ze.setFormat(Te.getFormatType()), ze.setIndent(Te.getIndent()), b.push(ze), Te.remove(!0);
      }
    }
    if (Y !== null)
      for (let ae = 0; ae < b.length; ae++) {
        const Te = b[ae];
        Y.append(Te);
      }
    let ce = null;
    if (e.$isRootOrShadowRoot(g))
      if (_)
        if (Y !== null)
          g.insertAfter(Y);
        else
          for (let ae = b.length - 1; ae >= 0; ae--) {
            const Te = b[ae];
            g.insertAfter(Te);
          }
      else {
        const ae = g.getFirstChild();
        if (e.$isElementNode(ae) && (g = ae), ae === null)
          if (Y)
            g.append(Y);
          else
            for (let Te = 0; Te < b.length; Te++) {
              const Me = b[Te];
              g.append(Me), ce = Me;
            }
        else if (Y !== null)
          ae.insertBefore(Y);
        else
          for (let Te = 0; Te < b.length; Te++) {
            const Me = b[Te];
            ae.insertBefore(Me), ce = Me;
          }
      }
    else if (Y)
      g.insertAfter(Y);
    else
      for (let ae = b.length - 1; ae >= 0; ae--) {
        const Te = b[ae];
        g.insertAfter(Te), ce = Te;
      }
    const ge = e.$getPreviousSelection();
    e.$isRangeSelection(ge) && K(ge.anchor) && K(ge.focus) ? e.$setSelection(ge.clone()) : ce !== null ? ce.selectEnd() : P.dirty = !0;
  }
  function re(P, w) {
    const j = e.$getAdjacentNode(P.focus, w);
    return e.$isDecoratorNode(j) && !j.isIsolated() || e.$isElementNode(j) && !j.isInline() && !j.canBeEmpty();
  }
  function de(P, w, j, ne) {
    P.modify(w ? "extend" : "move", j, ne);
  }
  function V(P) {
    const w = P.anchor.getNode();
    return (e.$isRootNode(w) ? w : w.getParentOrThrow()).getDirection() === "rtl";
  }
  function G(P, w, j) {
    const ne = V(P);
    de(P, w, j ? !ne : ne, "character");
  }
  function q(P) {
    const w = P.anchor, j = P.focus, W = w.getNode().getTopLevelElementOrThrow().getParentOrThrow();
    let Q = W.getFirstDescendant(), b = W.getLastDescendant(), g = "element", _ = "element", A = 0;
    e.$isTextNode(Q) ? g = "text" : !e.$isElementNode(Q) && Q !== null && (Q = Q.getParentOrThrow()), e.$isTextNode(b) ? (_ = "text", A = b.getTextContentSize()) : !e.$isElementNode(b) && b !== null && (b = b.getParentOrThrow()), Q && b && (w.set(Q.getKey(), 0, g), j.set(b.getKey(), A, _));
  }
  function me(P, w, j) {
    const ne = P.getStyle(), Y = T(ne);
    return Y !== null && Y[w] || j;
  }
  function pe(P, w, j = "") {
    let ne = null;
    const Y = P.getNodes(), W = P.anchor, Q = P.focus, b = P.isBackward(), g = b ? Q.offset : W.offset, _ = b ? Q.getNode() : W.getNode();
    if (P.isCollapsed() && P.style !== "") {
      const A = P.style, J = T(A);
      if (J !== null && w in J)
        return J[w];
    }
    for (let A = 0; A < Y.length; A++) {
      const J = Y[A];
      if (!(A !== 0 && g === 0 && J.is(_)) && e.$isTextNode(J)) {
        const ce = me(J, w, j);
        if (ne === null)
          ne = ce;
        else if (ne !== ce) {
          ne = "";
          break;
        }
      }
    }
    return ne === null ? j : ne;
  }
  function Z(P) {
    if (e.$isDecoratorNode(P) && !P.isInline())
      return !0;
    if (!e.$isElementNode(P) || e.$isRootOrShadowRoot(P))
      return !1;
    const w = P.getFirstChild(), j = w === null || e.$isLineBreakNode(w) || e.$isTextNode(w) || w.isInline();
    return !P.isInline() && P.canBeEmpty() !== !1 && j;
  }
  function ee(P, w) {
    let j = P;
    for (; j !== null && j.getParent() !== null && !w(j); )
      j = j.getParentOrThrow();
    return w(j) ? j : null;
  }
  return In.$addNodeStyle = v, In.$cloneWithProperties = D, In.$getSelectionStyleValueForProperty = pe, In.$isAtNodeEnd = H, In.$isParentElementRTL = V, In.$moveCaretSelection = de, In.$moveCharacter = G, In.$patchStyleText = U, In.$selectAll = q, In.$setBlocksType = I, In.$shouldOverrideDefaultCharacterSelection = re, In.$sliceSelectedTextNodeContent = k, In.$wrapNodes = z, In.createDOMRange = f, In.createRectsFromDOMRange = h, In.getStyleObjectFromCSS = T, In.trimTextContentFromAnchor = N, In;
}
var za, Zu;
function oo() {
  return Zu || (Zu = 1, za = process.env.NODE_ENV === "development" ? Qp() : Xp()), za;
}
var Xu;
function e_() {
  if (Xu)
    return fn;
  Xu = 1;
  var e = oo(), t = kt();
  function r(O) {
    let S = new URLSearchParams();
    S.append("code", O);
    for (let x = 1; x < arguments.length; x++)
      S.append("v", arguments[x]);
    throw Error(`Minified Lexical error #${O}; visit https://lexical.dev/docs/error?${S} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  function o(...O) {
    return () => {
      O.forEach((S) => S());
    };
  }
  let f = { attributes: !0, characterData: !0, childList: !0, subtree: !0 };
  function h(O, S, x) {
    function D() {
      if (N === null)
        throw Error("Unexpected null rootDOMNode");
      if (v === null)
        throw Error("Unexpected null parentDOMNode");
      let { left: B, top: z } = N.getBoundingClientRect();
      var te = v;
      let re = e.createRectsFromDOMRange(O, S);
      I.isConnected || te.append(I), te = !1;
      for (let G = 0; G < re.length; G++) {
        var de = re[G];
        let q = U[G] || document.createElement("div"), me = q.style;
        me.position !== "absolute" && (me.position = "absolute", te = !0);
        var V = `${de.left - B}px`;
        me.left !== V && (me.left = V, te = !0), V = `${de.top - z}px`, me.top !== V && (q.style.top = V, te = !0), V = `${de.width}px`, me.width !== V && (q.style.width = V, te = !0), de = `${de.height}px`, me.height !== de && (q.style.height = de, te = !0), q.parentNode !== I && (I.append(q), te = !0), U[G] = q;
      }
      for (; U.length > re.length; )
        U.pop();
      te && x(U);
    }
    function k() {
      N = v = null, F !== null && F.disconnect(), F = null, I.remove();
      for (let B of U)
        B.remove();
      U = [];
    }
    function H() {
      let B = O.getRootElement();
      if (B === null)
        return k();
      let z = B.parentElement;
      if (!(z instanceof HTMLElement))
        return k();
      k(), N = B, v = z, F = new MutationObserver((te) => {
        let re = O.getRootElement(), de = re && re.parentElement;
        if (re !== N || de !== v)
          return H();
        for (let V of te)
          if (!I.contains(V.target))
            return D();
      }), F.observe(z, f), D();
    }
    let N = null, v = null, F = null, U = [], I = document.createElement("div"), K = O.registerRootListener(H);
    return () => {
      K(), k();
    };
  }
  function C(O, S) {
    for (let x of S)
      if (O.type.startsWith(x))
        return !0;
    return !1;
  }
  function T(O, S) {
    for (; O !== t.$getRoot() && O != null; ) {
      if (S(O))
        return O;
      O = O.getParent();
    }
    return null;
  }
  return fn.$splitNode = t.$splitNode, fn.isHTMLAnchorElement = t.isHTMLAnchorElement, fn.isHTMLElement = t.isHTMLElement, fn.$dfs = function(O, S) {
    let x = [];
    O = (O || t.$getRoot()).getLatest(), S = S || (t.$isElementNode(O) ? O.getLastDescendant() : O);
    for (var D = O, k = 0; (D = D.getParent()) !== null; )
      k++;
    for (D = k; O !== null && !O.is(S); )
      if (x.push({ depth: D, node: O }), t.$isElementNode(O) && 0 < O.getChildrenSize())
        O = O.getFirstChild(), D++;
      else
        for (k = null; k === null && O !== null; )
          k = O.getNextSibling(), k === null ? (O = O.getParent(), D--) : O = k;
    return O !== null && O.is(S) && x.push({ depth: D, node: O }), x;
  }, fn.$filter = function(O, S) {
    let x = [];
    for (let D = 0; D < O.length; D++) {
      let k = S(O[D]);
      k !== null && x.push(k);
    }
    return x;
  }, fn.$findMatchingParent = T, fn.$getNearestBlockElementAncestorOrThrow = function(O) {
    let S = T(O, (x) => t.$isElementNode(x) && !x.isInline());
    return t.$isElementNode(S) || r(4, O.__key), S;
  }, fn.$getNearestNodeOfType = function(O, S) {
    for (; O != null; ) {
      if (O instanceof S)
        return O;
      O = O.getParent();
    }
    return null;
  }, fn.$insertFirst = function(O, S) {
    let x = O.getFirstChild();
    x !== null ? x.insertBefore(S) : O.append(S);
  }, fn.$insertNodeToNearestRoot = function(O) {
    var S = t.$getSelection() || t.$getPreviousSelection();
    if (t.$isRangeSelection(S)) {
      var { focus: x } = S;
      if (S = x.getNode(), x = x.offset, t.$isRootOrShadowRoot(S))
        x = S.getChildAtIndex(x), x == null ? S.append(O) : x.insertBefore(O), O.selectNext();
      else {
        let D, k;
        t.$isTextNode(S) ? (D = S.getParentOrThrow(), k = S.getIndexWithinParent(), 0 < x && (k += 1, S.splitText(x))) : (D = S, k = x), [, S] = t.$splitNode(D, k), S.insertBefore(O), S.selectStart();
      }
    } else
      S != null ? (S = S.getNodes(), S[S.length - 1].getTopLevelElementOrThrow().insertAfter(O)) : t.$getRoot().append(O), S = t.$createParagraphNode(), O.insertAfter(S), S.select();
    return O.getLatest();
  }, fn.$restoreEditorState = function(O, S) {
    let x = /* @__PURE__ */ new Map(), D = O._pendingEditorState;
    for (let [k, H] of S._nodeMap) {
      let N = e.$cloneWithProperties(H);
      t.$isTextNode(N) && (N.__text = H.__text), x.set(k, N);
    }
    D && (D._nodeMap = x), O._dirtyType = 2, O = S._selection, t.$setSelection(O === null ? null : O.clone());
  }, fn.$wrapNodeInElement = function(O, S) {
    return S = S(), O.replace(S), S.append(O), S;
  }, fn.addClassNamesToElement = function(O, ...S) {
    S.forEach((x) => {
      typeof x == "string" && (x = x.split(" ").filter((D) => D !== ""), O.classList.add(...x));
    });
  }, fn.isMimeType = C, fn.markSelection = function(O, S) {
    function x(F) {
      F.read(() => {
        var U = t.$getSelection();
        if (t.$isRangeSelection(U)) {
          var { anchor: I, focus: K } = U;
          U = I.getNode();
          var B = U.getKey(), z = I.offset, te = K.getNode(), re = te.getKey(), de = K.offset, V = O.getElementByKey(B), G = O.getElementByKey(re);
          if (B = D === null || V === null || z !== k || B !== D.getKey() || U !== D && (!(D instanceof t.TextNode) || U.updateDOM(D, V, O._config)), re = H === null || G === null || de !== N || re !== H.getKey() || te !== H && (!(H instanceof t.TextNode) || te.updateDOM(H, G, O._config)), B || re) {
            V = O.getElementByKey(I.getNode().getKey());
            var q = O.getElementByKey(K.getNode().getKey());
            if (V !== null && q !== null && V.tagName === "SPAN" && q.tagName === "SPAN") {
              if (re = document.createRange(), K.isBefore(I) ? (B = q, G = K.offset, q = V, V = I.offset) : (B = V, G = I.offset, V = K.offset), B = B.firstChild, B === null || (q = q.firstChild, q === null))
                throw Error("Expected text node to be first child of span");
              re.setStart(B, G), re.setEnd(q, V), v(), v = h(O, re, (me) => {
                for (let pe of me) {
                  let Z = pe.style;
                  Z.background !== "Highlight" && (Z.background = "Highlight"), Z.color !== "HighlightText" && (Z.color = "HighlightText"), Z.zIndex !== "-1" && (Z.zIndex = "-1"), Z.pointerEvents !== "none" && (Z.pointerEvents = "none"), Z.marginTop !== "-1.5px" && (Z.marginTop = "-1.5px"), Z.paddingTop !== "4px" && (Z.paddingTop = "4px"), Z.paddingBottom !== "0px" && (Z.paddingBottom = "0px");
                }
                S !== void 0 && S(me);
              });
            }
          }
          D = U, k = z, H = te, N = de;
        } else
          N = H = k = D = null, v(), v = () => {
          };
      });
    }
    let D = null, k = null, H = null, N = null, v = () => {
    };
    return x(O.getEditorState()), o(O.registerUpdateListener(({ editorState: F }) => x(F)), v, () => {
      v();
    });
  }, fn.mediaFileReader = function(O, S) {
    let x = O[Symbol.iterator]();
    return new Promise((D, k) => {
      let H = [], N = () => {
        const { done: v, value: F } = x.next();
        if (v)
          return D(H);
        const U = new FileReader();
        U.addEventListener("error", k), U.addEventListener("load", () => {
          const I = U.result;
          typeof I == "string" && H.push({ file: F, result: I }), N();
        }), C(F, S) ? U.readAsDataURL(F) : N();
      };
      N();
    });
  }, fn.mergeRegister = o, fn.objectKlassEquals = function(O, S) {
    return O !== null ? Object.getPrototypeOf(O).constructor.name === S.name : !1;
  }, fn.positionNodeOnRange = h, fn.registerNestedElementResolver = function(O, S, x, D) {
    return O.registerNodeTransform(S, (k) => {
      e: {
        for (var H = k.getChildren(), N = 0; N < H.length; N++)
          if (H[N] instanceof S) {
            H = null;
            break e;
          }
        for (H = k; H !== null; )
          if (N = H, H = H.getParent(), H instanceof S) {
            H = { child: N, parent: H };
            break e;
          }
        H = null;
      }
      if (H !== null) {
        const { child: v, parent: F } = H;
        if (v.is(k)) {
          if (D(F, k), k = v.getNextSiblings(), H = k.length, F.insertAfter(v), H !== 0) {
            N = x(F), v.insertAfter(N);
            for (let U = 0; U < H; U++)
              N.append(k[U]);
          }
          F.canBeEmpty() || F.getChildrenSize() !== 0 || F.remove();
        }
      }
    });
  }, fn.removeClassNamesFromElement = function(O, ...S) {
    S.forEach((x) => {
      typeof x == "string" && O.classList.remove(...x.split(" "));
    });
  }, fn;
}
var hn = {}, Qu;
function t_() {
  if (Qu)
    return hn;
  Qu = 1;
  var e = oo(), t = kt();
  function r(...re) {
    return () => {
      re.forEach((de) => de());
    };
  }
  function o(re) {
    return `${re}px`;
  }
  const f = {
    attributes: !0,
    characterData: !0,
    childList: !0,
    subtree: !0
  };
  function h(re, de, V) {
    let G = null, q = null, me = null, pe = [];
    const Z = document.createElement("div");
    function ee() {
      if (G === null)
        throw Error("Unexpected null rootDOMNode");
      if (q === null)
        throw Error("Unexpected null parentDOMNode");
      const {
        left: ne,
        top: Y
      } = G.getBoundingClientRect(), W = q, Q = e.createRectsFromDOMRange(re, de);
      Z.isConnected || W.append(Z);
      let b = !1;
      for (let g = 0; g < Q.length; g++) {
        const _ = Q[g], A = pe[g] || document.createElement("div"), J = A.style;
        J.position !== "absolute" && (J.position = "absolute", b = !0);
        const ce = o(_.left - ne);
        J.left !== ce && (J.left = ce, b = !0);
        const ge = o(_.top - Y);
        J.top !== ge && (A.style.top = ge, b = !0);
        const ae = o(_.width);
        J.width !== ae && (A.style.width = ae, b = !0);
        const Te = o(_.height);
        J.height !== Te && (A.style.height = Te, b = !0), A.parentNode !== Z && (Z.append(A), b = !0), pe[g] = A;
      }
      for (; pe.length > Q.length; )
        pe.pop();
      b && V(pe);
    }
    function P() {
      q = null, G = null, me !== null && me.disconnect(), me = null, Z.remove();
      for (const ne of pe)
        ne.remove();
      pe = [];
    }
    function w() {
      const ne = re.getRootElement();
      if (ne === null)
        return P();
      const Y = ne.parentElement;
      if (!(Y instanceof HTMLElement))
        return P();
      P(), G = ne, q = Y, me = new MutationObserver((W) => {
        const Q = re.getRootElement(), b = Q && Q.parentElement;
        if (Q !== G || b !== q)
          return w();
        for (const g of W)
          if (!Z.contains(g.target))
            return ee();
      }), me.observe(Y, f), ee();
    }
    const j = re.registerRootListener(w);
    return () => {
      j(), P();
    };
  }
  function C(re, de) {
    let V = null, G = null, q = null, me = null, pe = () => {
    };
    function Z(ee) {
      ee.read(() => {
        const P = t.$getSelection();
        if (!t.$isRangeSelection(P)) {
          V = null, G = null, q = null, me = null, pe(), pe = () => {
          };
          return;
        }
        const {
          anchor: w,
          focus: j
        } = P, ne = w.getNode(), Y = ne.getKey(), W = w.offset, Q = j.getNode(), b = Q.getKey(), g = j.offset, _ = re.getElementByKey(Y), A = re.getElementByKey(b), J = V === null || _ === null || W !== G || Y !== V.getKey() || ne !== V && (!(V instanceof t.TextNode) || ne.updateDOM(V, _, re._config)), ce = q === null || A === null || g !== me || b !== q.getKey() || Q !== q && (!(q instanceof t.TextNode) || Q.updateDOM(q, A, re._config));
        if (J || ce) {
          const ge = re.getElementByKey(w.getNode().getKey()), ae = re.getElementByKey(j.getNode().getKey());
          if (ge !== null && ae !== null && ge.tagName === "SPAN" && ae.tagName === "SPAN") {
            const Te = document.createRange();
            let Me, ze, oe, ie;
            j.isBefore(w) ? (Me = ae, ze = j.offset, oe = ge, ie = w.offset) : (Me = ge, ze = w.offset, oe = ae, ie = j.offset);
            const ue = Me.firstChild;
            if (ue === null)
              throw Error("Expected text node to be first child of span");
            const we = oe.firstChild;
            if (we === null)
              throw Error("Expected text node to be first child of span");
            Te.setStart(ue, ze), Te.setEnd(we, ie), pe(), pe = h(re, Te, (Le) => {
              for (const Be of Le) {
                const Ye = Be.style;
                Ye.background !== "Highlight" && (Ye.background = "Highlight"), Ye.color !== "HighlightText" && (Ye.color = "HighlightText"), Ye.zIndex !== "-1" && (Ye.zIndex = "-1"), Ye.pointerEvents !== "none" && (Ye.pointerEvents = "none"), Ye.marginTop !== o(-1.5) && (Ye.marginTop = o(-1.5)), Ye.paddingTop !== o(4) && (Ye.paddingTop = o(4)), Ye.paddingBottom !== o(0) && (Ye.paddingBottom = o(0));
              }
              de !== void 0 && de(Le);
            });
          }
        }
        V = ne, G = W, q = Q, me = g;
      });
    }
    return Z(re.getEditorState()), r(re.registerUpdateListener(({
      editorState: ee
    }) => Z(ee)), pe, () => {
      pe();
    });
  }
  function T(re, ...de) {
    de.forEach((V) => {
      if (typeof V == "string") {
        const G = V.split(" ").filter((q) => q !== "");
        re.classList.add(...G);
      }
    });
  }
  function O(re, ...de) {
    de.forEach((V) => {
      typeof V == "string" && re.classList.remove(...V.split(" "));
    });
  }
  function S(re, de) {
    for (const V of de)
      if (re.type.startsWith(V))
        return !0;
    return !1;
  }
  function x(re, de) {
    const V = re[Symbol.iterator]();
    return new Promise((G, q) => {
      const me = [], pe = () => {
        const {
          done: Z,
          value: ee
        } = V.next();
        if (Z)
          return G(me);
        const P = new FileReader();
        P.addEventListener("error", q), P.addEventListener("load", () => {
          const w = P.result;
          typeof w == "string" && me.push({
            file: ee,
            result: w
          }), pe();
        }), S(ee, de) ? P.readAsDataURL(ee) : pe();
      };
      pe();
    });
  }
  function D(re, de) {
    const V = [], G = (re || t.$getRoot()).getLatest(), q = de || (t.$isElementNode(G) ? G.getLastDescendant() : G);
    let me = G, pe = k(me);
    for (; me !== null && !me.is(q); )
      if (V.push({
        depth: pe,
        node: me
      }), t.$isElementNode(me) && me.getChildrenSize() > 0)
        me = me.getFirstChild(), pe++;
      else {
        let Z = null;
        for (; Z === null && me !== null; )
          Z = me.getNextSibling(), Z === null ? (me = me.getParent(), pe--) : me = Z;
      }
    return me !== null && me.is(q) && V.push({
      depth: pe,
      node: me
    }), V;
  }
  function k(re) {
    let de = re, V = 0;
    for (; (de = de.getParent()) !== null; )
      V++;
    return V;
  }
  function H(re, de) {
    let V = re;
    for (; V != null; ) {
      if (V instanceof de)
        return V;
      V = V.getParent();
    }
    return null;
  }
  function N(re) {
    const de = v(re, (V) => t.$isElementNode(V) && !V.isInline());
    if (!t.$isElementNode(de))
      throw Error(`Expected node ${re.__key} to have closest block element node.`);
    return de;
  }
  function v(re, de) {
    let V = re;
    for (; V !== t.$getRoot() && V != null; ) {
      if (de(V))
        return V;
      V = V.getParent();
    }
    return null;
  }
  function F(re, de, V, G) {
    const q = (Z) => Z instanceof de, me = (Z) => {
      const ee = Z.getChildren();
      for (let j = 0; j < ee.length; j++) {
        const ne = ee[j];
        if (q(ne))
          return null;
      }
      let P = Z, w = Z;
      for (; P !== null; )
        if (w = P, P = P.getParent(), q(P))
          return {
            child: w,
            parent: P
          };
      return null;
    }, pe = (Z) => {
      const ee = me(Z);
      if (ee !== null) {
        const {
          child: P,
          parent: w
        } = ee;
        if (P.is(Z)) {
          G(w, Z);
          const j = P.getNextSiblings(), ne = j.length;
          if (w.insertAfter(P), ne !== 0) {
            const Y = V(w);
            P.insertAfter(Y);
            for (let W = 0; W < ne; W++)
              Y.append(j[W]);
          }
          !w.canBeEmpty() && w.getChildrenSize() === 0 && w.remove();
        }
      }
    };
    return re.registerNodeTransform(de, pe);
  }
  function U(re, de) {
    const G = /* @__PURE__ */ new Map(), q = re._pendingEditorState;
    for (const [pe, Z] of de._nodeMap) {
      const ee = e.$cloneWithProperties(Z);
      t.$isTextNode(ee) && (ee.__text = Z.__text), G.set(pe, ee);
    }
    q && (q._nodeMap = G), re._dirtyType = 2;
    const me = de._selection;
    t.$setSelection(me === null ? null : me.clone());
  }
  function I(re) {
    const de = t.$getSelection() || t.$getPreviousSelection();
    if (t.$isRangeSelection(de)) {
      const {
        focus: V
      } = de, G = V.getNode(), q = V.offset;
      if (t.$isRootOrShadowRoot(G)) {
        const me = G.getChildAtIndex(q);
        me == null ? G.append(re) : me.insertBefore(re), re.selectNext();
      } else {
        let me, pe;
        t.$isTextNode(G) ? (me = G.getParentOrThrow(), pe = G.getIndexWithinParent(), q > 0 && (pe += 1, G.splitText(q))) : (me = G, pe = q);
        const [, Z] = t.$splitNode(me, pe);
        Z.insertBefore(re), Z.selectStart();
      }
    } else {
      if (de != null) {
        const G = de.getNodes();
        G[G.length - 1].getTopLevelElementOrThrow().insertAfter(re);
      } else
        t.$getRoot().append(re);
      const V = t.$createParagraphNode();
      re.insertAfter(V), V.select();
    }
    return re.getLatest();
  }
  function K(re, de) {
    const V = de();
    return re.replace(V), V.append(re), V;
  }
  function B(re, de) {
    return re !== null ? Object.getPrototypeOf(re).constructor.name === de.name : !1;
  }
  function z(re, de) {
    const V = [];
    for (let G = 0; G < re.length; G++) {
      const q = de(re[G]);
      q !== null && V.push(q);
    }
    return V;
  }
  function te(re, de) {
    const V = re.getFirstChild();
    V !== null ? V.insertBefore(de) : re.append(de);
  }
  return hn.$splitNode = t.$splitNode, hn.isHTMLAnchorElement = t.isHTMLAnchorElement, hn.isHTMLElement = t.isHTMLElement, hn.$dfs = D, hn.$filter = z, hn.$findMatchingParent = v, hn.$getNearestBlockElementAncestorOrThrow = N, hn.$getNearestNodeOfType = H, hn.$insertFirst = te, hn.$insertNodeToNearestRoot = I, hn.$restoreEditorState = U, hn.$wrapNodeInElement = K, hn.addClassNamesToElement = T, hn.isMimeType = S, hn.markSelection = C, hn.mediaFileReader = x, hn.mergeRegister = r, hn.objectKlassEquals = B, hn.positionNodeOnRange = h, hn.registerNestedElementResolver = F, hn.removeClassNamesFromElement = O, hn;
}
var Ga, ed;
function Jt() {
  return ed || (ed = 1, Ga = process.env.NODE_ENV === "development" ? t_() : e_()), Ga;
}
var Ya = {}, td;
function n_() {
  if (td)
    return Ya;
  td = 1;
  var e = kt();
  return Ya.registerDragonSupport = function(t) {
    let r = window.location.origin, o = (f) => {
      if (f.origin === r) {
        var h = t.getRootElement();
        if (document.activeElement === h && (h = f.data, typeof h == "string")) {
          try {
            var C = JSON.parse(h);
          } catch {
            return;
          }
          if (C && C.protocol === "nuanria_messaging" && C.type === "request" && (C = C.payload) && C.functionId === "makeChanges" && (C = C.args)) {
            const [T, O, S, x, D] = C;
            t.update(() => {
              const k = e.$getSelection();
              if (e.$isRangeSelection(k)) {
                var H = k.anchor;
                let N = H.getNode(), v = 0, F = 0;
                e.$isTextNode(N) && 0 <= T && 0 <= O && (v = T, F = T + O, k.setTextNodeRange(N, v, N, F)), (v !== F || S !== "") && (k.insertRawText(S), N = H.getNode()), e.$isTextNode(N) && (v = x, F = x + D, H = N.getTextContentSize(), v = v > H ? H : v, F = F > H ? H : F, k.setTextNodeRange(N, v, N, F)), f.stopImmediatePropagation();
              }
            });
          }
        }
      }
    };
    return window.addEventListener("message", o, !0), () => {
      window.removeEventListener("message", o, !0);
    };
  }, Ya;
}
var ja = {}, nd;
function r_() {
  if (nd)
    return ja;
  nd = 1;
  var e = kt();
  function t(r) {
    const o = window.location.origin, f = (h) => {
      if (h.origin !== o)
        return;
      const C = r.getRootElement();
      if (document.activeElement !== C)
        return;
      const T = h.data;
      if (typeof T == "string") {
        let O;
        try {
          O = JSON.parse(T);
        } catch {
          return;
        }
        if (O && O.protocol === "nuanria_messaging" && O.type === "request") {
          const S = O.payload;
          if (S && S.functionId === "makeChanges") {
            const x = S.args;
            if (x) {
              const [D, k, H, N, v, F] = x;
              r.update(() => {
                const U = e.$getSelection();
                if (e.$isRangeSelection(U)) {
                  const I = U.anchor;
                  let K = I.getNode(), B = 0, z = 0;
                  if (e.$isTextNode(K) && D >= 0 && k >= 0 && (B = D, z = D + k, U.setTextNodeRange(K, B, K, z)), (B !== z || H !== "") && (U.insertRawText(H), K = I.getNode()), e.$isTextNode(K)) {
                    B = N, z = N + v;
                    const te = K.getTextContentSize();
                    B = B > te ? te : B, z = z > te ? te : z, U.setTextNodeRange(K, B, K, z);
                  }
                  h.stopImmediatePropagation();
                }
              });
            }
          }
        }
      }
    };
    return window.addEventListener("message", f, !0), () => {
      window.removeEventListener("message", f, !0);
    };
  }
  return ja.registerDragonSupport = t, ja;
}
var qa, rd;
function lh() {
  return rd || (rd = 1, qa = process.env.NODE_ENV === "development" ? r_() : n_()), qa;
}
var Jr = {}, pi = {}, Vl = {}, id;
function i_() {
  if (id)
    return Vl;
  id = 1;
  var e = oo(), t = Jt(), r = kt();
  function o(C, T, O, S = null) {
    let x = S != null ? T.isSelected(S) : !0, D = r.$isElementNode(T) && T.excludeFromCopy("html");
    var k = T;
    S !== null && (k = e.$cloneWithProperties(T), k = r.$isTextNode(k) && S != null ? e.$sliceSelectedTextNodeContent(S, k) : k);
    let H = r.$isElementNode(k) ? k.getChildren() : [];
    var N = C._nodes.get(k.getType());
    N = N && N.exportDOM !== void 0 ? N.exportDOM(C, k) : k.exportDOM(C);
    let { element: v, after: F } = N;
    if (!v)
      return !1;
    N = document.createDocumentFragment();
    for (let U = 0; U < H.length; U++) {
      let I = H[U], K = o(C, I, N, S);
      !x && r.$isElementNode(T) && K && T.extractWithChild(I, S, "html") && (x = !0);
    }
    return x && !D ? (t.isHTMLElement(v) && v.append(N), O.append(v), F && (C = F.call(k, v)) && v.replaceWith(C)) : O.append(N), x;
  }
  let f = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
  function h(C, T, O = /* @__PURE__ */ new Map(), S) {
    let x = [];
    if (f.has(C.nodeName))
      return x;
    let D = null;
    var k, { nodeName: H } = C, N = T._htmlConversions.get(H.toLowerCase());
    if (H = null, N !== void 0)
      for (k of N)
        N = k(C), N !== null && (H === null || H.priority < N.priority) && (H = N);
    if (H = (k = H !== null ? H.conversion : null) ? k(C) : null, k = null, H !== null) {
      if (k = H.after, N = H.node, D = Array.isArray(N) ? N[N.length - 1] : N, D !== null) {
        for (var [, v] of O)
          if (D = v(D, S), !D)
            break;
        D && x.push(...Array.isArray(N) ? N : [D]);
      }
      H.forChild != null && O.set(C.nodeName, H.forChild);
    }
    for (C = C.childNodes, S = [], v = 0; v < C.length; v++)
      S.push(...h(C[v], T, new Map(O), D));
    return k != null && (S = k(S)), D == null ? x = x.concat(S) : r.$isElementNode(D) && D.append(...S), x;
  }
  return Vl.$generateHtmlFromNodes = function(C, T) {
    if (typeof document > "u" || typeof window > "u")
      throw Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
    let O = document.createElement("div"), S = r.$getRoot().getChildren();
    for (let x = 0; x < S.length; x++)
      o(C, S[x], O, T);
    return O.innerHTML;
  }, Vl.$generateNodesFromDOM = function(C, T) {
    T = T.body ? T.body.childNodes : [];
    let O = [];
    for (let x = 0; x < T.length; x++) {
      var S = T[x];
      f.has(S.nodeName) || (S = h(S, C), S !== null && (O = O.concat(S)));
    }
    return O;
  }, Vl;
}
var Jl = {}, od;
function o_() {
  if (od)
    return Jl;
  od = 1;
  var e = oo(), t = Jt(), r = kt();
  function o(S, x) {
    const D = x.body ? x.body.childNodes : [];
    let k = [];
    for (let H = 0; H < D.length; H++) {
      const N = D[H];
      if (!T.has(N.nodeName)) {
        const v = O(N, S);
        v !== null && (k = k.concat(v));
      }
    }
    return k;
  }
  function f(S, x) {
    if (typeof document > "u" || typeof window > "u")
      throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
    const D = document.createElement("div"), H = r.$getRoot().getChildren();
    for (let N = 0; N < H.length; N++) {
      const v = H[N];
      h(S, v, D, x);
    }
    return D.innerHTML;
  }
  function h(S, x, D, k = null) {
    let H = k != null ? x.isSelected(k) : !0;
    const N = r.$isElementNode(x) && x.excludeFromCopy("html");
    let v = x;
    if (k !== null) {
      let te = e.$cloneWithProperties(x);
      te = r.$isTextNode(te) && k != null ? e.$sliceSelectedTextNodeContent(k, te) : te, v = te;
    }
    const F = r.$isElementNode(v) ? v.getChildren() : [], U = S._nodes.get(v.getType());
    let I;
    U && U.exportDOM !== void 0 ? I = U.exportDOM(S, v) : I = v.exportDOM(S);
    const {
      element: K,
      after: B
    } = I;
    if (!K)
      return !1;
    const z = document.createDocumentFragment();
    for (let te = 0; te < F.length; te++) {
      const re = F[te], de = h(S, re, z, k);
      !H && r.$isElementNode(x) && de && x.extractWithChild(re, k, "html") && (H = !0);
    }
    if (H && !N) {
      if (t.isHTMLElement(K) && K.append(z), D.append(K), B) {
        const te = B.call(v, K);
        te && K.replaceWith(te);
      }
    } else
      D.append(z);
    return H;
  }
  function C(S, x) {
    const {
      nodeName: D
    } = S, k = x._htmlConversions.get(D.toLowerCase());
    let H = null;
    if (k !== void 0)
      for (const N of k) {
        const v = N(S);
        v !== null && (H === null || H.priority < v.priority) && (H = v);
      }
    return H !== null ? H.conversion : null;
  }
  const T = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
  function O(S, x, D = /* @__PURE__ */ new Map(), k) {
    let H = [];
    if (T.has(S.nodeName))
      return H;
    let N = null;
    const v = C(S, x), F = v ? v(S) : null;
    let U = null;
    if (F !== null) {
      U = F.after;
      const B = F.node;
      if (N = Array.isArray(B) ? B[B.length - 1] : B, N !== null) {
        for (const [, z] of D)
          if (N = z(N, k), !N)
            break;
        N && H.push(...Array.isArray(B) ? B : [N]);
      }
      F.forChild != null && D.set(S.nodeName, F.forChild);
    }
    const I = S.childNodes;
    let K = [];
    for (let B = 0; B < I.length; B++)
      K.push(...O(I[B], x, new Map(D), N));
    return U != null && (K = U(K)), N == null ? H = H.concat(K) : r.$isElementNode(N) && N.append(...K), H;
  }
  return Jl.$generateHtmlFromNodes = f, Jl.$generateNodesFromDOM = o, Jl;
}
var Va, sd;
function ah() {
  return sd || (sd = 1, Va = process.env.NODE_ENV === "development" ? o_() : i_()), Va;
}
var ld;
function s_() {
  if (ld)
    return pi;
  ld = 1;
  var e = ah(), t = oo(), r = Jt(), o = kt();
  function f(v) {
    let F = new URLSearchParams();
    F.append("code", v);
    for (let U = 1; U < arguments.length; U++)
      F.append("v", arguments[U]);
    throw Error(`Minified Lexical error #${v}; visit https://lexical.dev/docs/error?${F} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  let h = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
  function C(v) {
    let F = o.$getSelection();
    if (F == null)
      throw Error("Expected valid LexicalSelection");
    return o.$isRangeSelection(F) && F.isCollapsed() || F.getNodes().length === 0 ? "" : e.$generateHtmlFromNodes(v, F);
  }
  function T(v) {
    let F = o.$getSelection();
    if (F == null)
      throw Error("Expected valid LexicalSelection");
    return o.$isRangeSelection(F) && F.isCollapsed() || F.getNodes().length === 0 ? null : JSON.stringify(D(v, F));
  }
  function O(v, F, U) {
    let I = o.DEPRECATED_$isGridSelection(U), K = o.$isRangeSelection(U);
    (I || K && r.$findMatchingParent(U.anchor.getNode(), (B) => o.DEPRECATED_$isGridCellNode(B)) !== null && r.$findMatchingParent(U.focus.getNode(), (B) => o.DEPRECATED_$isGridCellNode(B)) !== null) && F.length === 1 && o.DEPRECATED_$isGridNode(F[0]) ? S(F, U, !1, v) : U.insertNodes(F);
  }
  function S(v, F, U, I) {
    v.length === 1 && o.DEPRECATED_$isGridNode(v[0]) || f(42);
    var K = v[0];
    v = K.getChildren(), U = K.getFirstChildOrThrow().getChildrenSize();
    var B = K.getChildrenSize(), z = r.$findMatchingParent(F.anchor.getNode(), (me) => o.DEPRECATED_$isGridCellNode(me));
    F = (K = z && r.$findMatchingParent(z, (me) => o.DEPRECATED_$isGridRowNode(me))) && r.$findMatchingParent(K, (me) => o.DEPRECATED_$isGridNode(me)), o.DEPRECATED_$isGridCellNode(z) && o.DEPRECATED_$isGridRowNode(K) && o.DEPRECATED_$isGridNode(F) || f(43);
    var te = K.getIndexWithinParent(), re = Math.min(F.getChildrenSize() - 1, te + B - 1);
    B = z.getIndexWithinParent(), z = Math.min(K.getChildrenSize() - 1, B + U - 1), U = Math.min(B, z), K = Math.min(te, re), B = Math.max(B, z), te = Math.max(te, re), re = F.getChildren(), z = 0;
    let de, V;
    for (let me = K; me <= te; me++) {
      var G = re[me];
      o.DEPRECATED_$isGridRowNode(G) || f(24);
      var q = v[z];
      o.DEPRECATED_$isGridRowNode(q) || f(24), G = G.getChildren(), q = q.getChildren();
      let pe = 0;
      for (let Z = U; Z <= B; Z++) {
        let ee = G[Z];
        o.DEPRECATED_$isGridCellNode(ee) || f(25);
        let P = q[pe];
        o.DEPRECATED_$isGridCellNode(P) || f(25), me === K && Z === U ? de = ee.getKey() : me === te && Z === B && (V = ee.getKey());
        let w = ee.getChildren();
        P.getChildren().forEach((j) => {
          o.$isTextNode(j) && o.$createParagraphNode().append(j), ee.append(j);
        }), w.forEach((j) => j.remove()), pe++;
      }
      z++;
    }
    de && V && (v = o.DEPRECATED_$createGridSelection(), v.set(F.getKey(), de, V), o.$setSelection(v), I.dispatchCommand(o.SELECTION_CHANGE_COMMAND, void 0));
  }
  function x(v, F, U, I = []) {
    let K = F != null ? U.isSelected(F) : !0, B = o.$isElementNode(U) && U.excludeFromCopy("html");
    var z = U;
    if (F !== null) {
      var te = t.$cloneWithProperties(U);
      z = te = o.$isTextNode(te) && F != null ? t.$sliceSelectedTextNodeContent(F, te) : te;
    }
    let re = o.$isElementNode(z) ? z.getChildren() : [];
    var de = z;
    te = de.exportJSON();
    var V = de.constructor;
    te.type !== V.getType() && f(58, V.name);
    let G = te.children;
    for (o.$isElementNode(de) && (Array.isArray(G) || f(59, V.name)), o.$isTextNode(z) && (z = z.__text, 0 < z.length ? te.text = z : K = !1), z = 0; z < re.length; z++)
      de = re[z], V = x(v, F, de, te.children), !K && o.$isElementNode(U) && V && U.extractWithChild(de, F, "clone") && (K = !0);
    if (K && !B)
      I.push(te);
    else if (Array.isArray(te.children))
      for (v = 0; v < te.children.length; v++)
        I.push(te.children[v]);
    return K;
  }
  function D(v, F) {
    let U = [], I = o.$getRoot().getChildren();
    for (let K = 0; K < I.length; K++)
      x(v, F, I[K], U);
    return { namespace: v._config.namespace, nodes: U };
  }
  function k(v) {
    let F = [];
    for (let U = 0; U < v.length; U++) {
      let I = o.$parseSerializedNode(v[U]);
      o.$isTextNode(I) && t.$addNodeStyle(I), F.push(I);
    }
    return F;
  }
  let H = null;
  function N(v, F) {
    var U = h ? (v._window || window).getSelection() : null;
    if (!U)
      return !1;
    var I = U.anchorNode;
    if (U = U.focusNode, I !== null && U !== null && !o.isSelectionWithinEditor(v, I, U) || (F.preventDefault(), F = F.clipboardData, I = o.$getSelection(), F === null || I === null))
      return !1;
    U = C(v), v = T(v);
    let K = "";
    return I !== null && (K = I.getTextContent()), U !== null && F.setData("text/html", U), v !== null && F.setData("application/x-lexical-editor", v), F.setData("text/plain", K), !0;
  }
  return pi.$generateJSONFromSelectedNodes = D, pi.$generateNodesFromSerializedNodes = k, pi.$getHtmlContent = C, pi.$getLexicalContent = T, pi.$insertDataTransferForPlainText = function(v, F) {
    v = v.getData("text/plain") || v.getData("text/uri-list"), v != null && F.insertRawText(v);
  }, pi.$insertDataTransferForRichText = function(v, F, U) {
    var I = v.getData("application/x-lexical-editor");
    if (I)
      try {
        let B = JSON.parse(I);
        if (B.namespace === U._config.namespace && Array.isArray(B.nodes)) {
          let z = k(B.nodes);
          return O(U, z, F);
        }
      } catch {
      }
    if (I = v.getData("text/html"))
      try {
        var K = new DOMParser().parseFromString(I, "text/html");
        let B = e.$generateNodesFromDOM(U, K);
        return O(U, B, F);
      } catch {
      }
    if (v = v.getData("text/plain") || v.getData("text/uri-list"), v != null)
      if (o.$isRangeSelection(F))
        for (v = v.split(/(\r?\n|\t)/), v[v.length - 1] === "" && v.pop(), U = 0; U < v.length; U++)
          K = v[U], K === `
` || K === `\r
` ? F.insertParagraph() : K === "	" ? F.insertNodes([o.$createTabNode()]) : F.insertText(K);
      else
        F.insertRawText(v);
  }, pi.$insertGeneratedNodes = O, pi.copyToClipboard = async function(v, F) {
    if (H !== null)
      return !1;
    if (F !== null)
      return new Promise((z) => {
        v.update(() => {
          z(N(v, F));
        });
      });
    var U = v.getRootElement();
    let I = v._window == null ? window.document : v._window.document, K = h ? (v._window || window).getSelection() : null;
    if (U === null || K === null)
      return !1;
    let B = I.createElement("span");
    return B.style.cssText = "position: fixed; top: -1000px;", B.append(I.createTextNode("#")), U.append(B), U = new Range(), U.setStart(B, 0), U.setEnd(B, 1), K.removeAllRanges(), K.addRange(U), new Promise((z) => {
      let te = v.registerCommand(o.COPY_COMMAND, (re) => (r.objectKlassEquals(re, ClipboardEvent) && (te(), H !== null && (window.clearTimeout(H), H = null), z(N(v, re))), !0), o.COMMAND_PRIORITY_CRITICAL);
      H = window.setTimeout(() => {
        te(), H = null, z(!1);
      }, 50), I.execCommand("copy"), B.remove();
    });
  }, pi;
}
var _i = {}, ad;
function l_() {
  if (ad)
    return _i;
  ad = 1;
  var e = ah(), t = oo(), r = Jt(), o = kt();
  const f = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", h = (B) => f ? (B || window).getSelection() : null;
  function C(B) {
    const z = o.$getSelection();
    if (z == null)
      throw Error("Expected valid LexicalSelection");
    return o.$isRangeSelection(z) && z.isCollapsed() || z.getNodes().length === 0 ? "" : e.$generateHtmlFromNodes(B, z);
  }
  function T(B) {
    const z = o.$getSelection();
    if (z == null)
      throw Error("Expected valid LexicalSelection");
    return o.$isRangeSelection(z) && z.isCollapsed() || z.getNodes().length === 0 ? null : JSON.stringify(N(B, z));
  }
  function O(B, z) {
    const te = B.getData("text/plain") || B.getData("text/uri-list");
    te != null && z.insertRawText(te);
  }
  function S(B, z, te) {
    const re = B.getData("application/x-lexical-editor");
    if (re)
      try {
        const G = JSON.parse(re);
        if (G.namespace === te._config.namespace && Array.isArray(G.nodes)) {
          const q = v(G.nodes);
          return x(te, q, z);
        }
      } catch {
      }
    const de = B.getData("text/html");
    if (de)
      try {
        const q = new DOMParser().parseFromString(de, "text/html"), me = e.$generateNodesFromDOM(te, q);
        return x(te, me, z);
      } catch {
      }
    const V = B.getData("text/plain") || B.getData("text/uri-list");
    if (V != null)
      if (o.$isRangeSelection(z)) {
        const G = V.split(/(\r?\n|\t)/);
        G[G.length - 1] === "" && G.pop();
        for (let q = 0; q < G.length; q++) {
          const me = G[q];
          me === `
` || me === `\r
` ? z.insertParagraph() : me === "	" ? z.insertNodes([o.$createTabNode()]) : z.insertText(me);
        }
      } else
        z.insertRawText(V);
  }
  function x(B, z, te) {
    const re = o.DEPRECATED_$isGridSelection(te), de = o.$isRangeSelection(te);
    if ((re || de && r.$findMatchingParent(te.anchor.getNode(), (G) => o.DEPRECATED_$isGridCellNode(G)) !== null && r.$findMatchingParent(te.focus.getNode(), (G) => o.DEPRECATED_$isGridCellNode(G)) !== null) && z.length === 1 && o.DEPRECATED_$isGridNode(z[0])) {
      D(z, te, !1, B);
      return;
    }
    te.insertNodes(z);
  }
  function D(B, z, te, re) {
    if (B.length !== 1 || !o.DEPRECATED_$isGridNode(B[0]))
      throw Error("$mergeGridNodesStrategy: Expected Grid insertion.");
    const de = B[0], V = de.getChildren(), G = de.getFirstChildOrThrow().getChildrenSize(), q = de.getChildrenSize(), me = r.$findMatchingParent(z.anchor.getNode(), (J) => o.DEPRECATED_$isGridCellNode(J)), pe = me && r.$findMatchingParent(me, (J) => o.DEPRECATED_$isGridRowNode(J)), Z = pe && r.$findMatchingParent(pe, (J) => o.DEPRECATED_$isGridNode(J));
    if (!o.DEPRECATED_$isGridCellNode(me) || !o.DEPRECATED_$isGridRowNode(pe) || !o.DEPRECATED_$isGridNode(Z))
      throw Error("$mergeGridNodesStrategy: Expected selection to be inside of a Grid.");
    const ee = pe.getIndexWithinParent(), P = Math.min(Z.getChildrenSize() - 1, ee + q - 1), w = me.getIndexWithinParent(), j = Math.min(pe.getChildrenSize() - 1, w + G - 1), ne = Math.min(w, j), Y = Math.min(ee, P), W = Math.max(w, j), Q = Math.max(ee, P), b = Z.getChildren();
    let g = 0, _, A;
    for (let J = Y; J <= Q; J++) {
      const ce = b[J];
      if (!o.DEPRECATED_$isGridRowNode(ce))
        throw Error("getNodes: expected to find GridRowNode");
      const ge = V[g];
      if (!o.DEPRECATED_$isGridRowNode(ge))
        throw Error("getNodes: expected to find GridRowNode");
      const ae = ce.getChildren(), Te = ge.getChildren();
      let Me = 0;
      for (let ze = ne; ze <= W; ze++) {
        const oe = ae[ze];
        if (!o.DEPRECATED_$isGridCellNode(oe))
          throw Error("getNodes: expected to find GridCellNode");
        const ie = Te[Me];
        if (!o.DEPRECATED_$isGridCellNode(ie))
          throw Error("getNodes: expected to find GridCellNode");
        J === Y && ze === ne ? _ = oe.getKey() : J === Q && ze === W && (A = oe.getKey());
        const ue = oe.getChildren();
        ie.getChildren().forEach((we) => {
          o.$isTextNode(we) && o.$createParagraphNode().append(we), oe.append(we);
        }), ue.forEach((we) => we.remove()), Me++;
      }
      g++;
    }
    if (_ && A) {
      const J = o.DEPRECATED_$createGridSelection();
      J.set(Z.getKey(), _, A), o.$setSelection(J), re.dispatchCommand(o.SELECTION_CHANGE_COMMAND, void 0);
    }
  }
  function k(B) {
    const z = B.exportJSON(), te = B.constructor;
    if (z.type !== te.getType())
      throw Error(`LexicalNode: Node ${te.name} does not implement .exportJSON().`);
    const re = z.children;
    if (o.$isElementNode(B) && !Array.isArray(re))
      throw Error(`LexicalNode: Node ${te.name} is an element but .exportJSON() does not have a children array.`);
    return z;
  }
  function H(B, z, te, re = []) {
    let de = z != null ? te.isSelected(z) : !0;
    const V = o.$isElementNode(te) && te.excludeFromCopy("html");
    let G = te;
    if (z !== null) {
      let pe = t.$cloneWithProperties(te);
      pe = o.$isTextNode(pe) && z != null ? t.$sliceSelectedTextNodeContent(z, pe) : pe, G = pe;
    }
    const q = o.$isElementNode(G) ? G.getChildren() : [], me = k(G);
    if (o.$isTextNode(G)) {
      const pe = G.__text;
      pe.length > 0 ? me.text = pe : de = !1;
    }
    for (let pe = 0; pe < q.length; pe++) {
      const Z = q[pe], ee = H(B, z, Z, me.children);
      !de && o.$isElementNode(te) && ee && te.extractWithChild(Z, z, "clone") && (de = !0);
    }
    if (de && !V)
      re.push(me);
    else if (Array.isArray(me.children))
      for (let pe = 0; pe < me.children.length; pe++) {
        const Z = me.children[pe];
        re.push(Z);
      }
    return de;
  }
  function N(B, z) {
    const te = [], de = o.$getRoot().getChildren();
    for (let V = 0; V < de.length; V++) {
      const G = de[V];
      H(B, z, G, te);
    }
    return {
      namespace: B._config.namespace,
      nodes: te
    };
  }
  function v(B) {
    const z = [];
    for (let te = 0; te < B.length; te++) {
      const re = B[te], de = o.$parseSerializedNode(re);
      o.$isTextNode(de) && t.$addNodeStyle(de), z.push(de);
    }
    return z;
  }
  const F = 50;
  let U = null;
  async function I(B, z) {
    if (U !== null)
      return !1;
    if (z !== null)
      return new Promise((q, me) => {
        B.update(() => {
          q(K(B, z));
        });
      });
    const te = B.getRootElement(), re = B._window == null ? window.document : B._window.document, de = h(B._window);
    if (te === null || de === null)
      return !1;
    const V = re.createElement("span");
    V.style.cssText = "position: fixed; top: -1000px;", V.append(re.createTextNode("#")), te.append(V);
    const G = new Range();
    return G.setStart(V, 0), G.setEnd(V, 1), de.removeAllRanges(), de.addRange(G), new Promise((q, me) => {
      const pe = B.registerCommand(o.COPY_COMMAND, (Z) => (r.objectKlassEquals(Z, ClipboardEvent) && (pe(), U !== null && (window.clearTimeout(U), U = null), q(K(B, Z))), !0), o.COMMAND_PRIORITY_CRITICAL);
      U = window.setTimeout(() => {
        pe(), U = null, q(!1);
      }, F), re.execCommand("copy"), V.remove();
    });
  }
  function K(B, z) {
    const te = h(B._window);
    if (!te)
      return !1;
    const re = te.anchorNode, de = te.focusNode;
    if (re !== null && de !== null && !o.isSelectionWithinEditor(B, re, de))
      return !1;
    z.preventDefault();
    const V = z.clipboardData, G = o.$getSelection();
    if (V === null || G === null)
      return !1;
    const q = C(B), me = T(B);
    let pe = "";
    return G !== null && (pe = G.getTextContent()), q !== null && V.setData("text/html", q), me !== null && V.setData("application/x-lexical-editor", me), V.setData("text/plain", pe), !0;
  }
  return _i.$generateJSONFromSelectedNodes = N, _i.$generateNodesFromSerializedNodes = v, _i.$getHtmlContent = C, _i.$getLexicalContent = T, _i.$insertDataTransferForPlainText = O, _i.$insertDataTransferForRichText = S, _i.$insertGeneratedNodes = x, _i.copyToClipboard = I, _i;
}
var Ja, cd;
function ch() {
  return cd || (cd = 1, Ja = process.env.NODE_ENV === "development" ? l_() : s_()), Ja;
}
var ud;
function a_() {
  if (ud)
    return Jr;
  ud = 1;
  var e = ch(), t = oo(), r = Jt(), o = kt();
  function f(V, G) {
    return typeof document.caretRangeFromPoint < "u" ? (V = document.caretRangeFromPoint(V, G), V === null ? null : { node: V.startContainer, offset: V.startOffset }) : document.caretPositionFromPoint !== "undefined" ? (V = document.caretPositionFromPoint(V, G), V === null ? null : { node: V.offsetNode, offset: V.offset }) : null;
  }
  let h = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", C = h && "documentMode" in document ? document.documentMode : null, T = h && "InputEvent" in window && !C ? "getTargetRanges" in new window.InputEvent("input") : !1, O = h && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), S = h && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, x = h && /^(?=.*Chrome).*/i.test(navigator.userAgent), D = h && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !x, k = o.createCommand("DRAG_DROP_PASTE_FILE");
  class H extends o.ElementNode {
    static getType() {
      return "quote";
    }
    static clone(G) {
      return new H(G.__key);
    }
    constructor(G) {
      super(G);
    }
    createDOM(G) {
      let q = document.createElement("blockquote");
      return r.addClassNamesToElement(q, G.theme.quote), q;
    }
    updateDOM() {
      return !1;
    }
    static importDOM() {
      return { blockquote: () => ({ conversion: I, priority: 0 }) };
    }
    exportDOM(G) {
      if ({ element: G } = super.exportDOM(G), G && r.isHTMLElement(G)) {
        this.isEmpty() && G.append(document.createElement("br"));
        var q = this.getFormatType();
        G.style.textAlign = q, (q = this.getDirection()) && (G.dir = q);
      }
      return { element: G };
    }
    static importJSON(G) {
      let q = N();
      return q.setFormat(G.format), q.setIndent(G.indent), q.setDirection(G.direction), q;
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "quote" };
    }
    insertNewAfter(G, q) {
      G = o.$createParagraphNode();
      let me = this.getDirection();
      return G.setDirection(me), this.insertAfter(G, q), G;
    }
    collapseAtStart() {
      let G = o.$createParagraphNode();
      return this.getChildren().forEach((q) => G.append(q)), this.replace(G), !0;
    }
  }
  function N() {
    return o.$applyNodeReplacement(new H());
  }
  class v extends o.ElementNode {
    static getType() {
      return "heading";
    }
    static clone(G) {
      return new v(G.__tag, G.__key);
    }
    constructor(G, q) {
      super(q), this.__tag = G;
    }
    getTag() {
      return this.__tag;
    }
    createDOM(G) {
      let q = this.__tag, me = document.createElement(q);
      return G = G.theme.heading, G !== void 0 && r.addClassNamesToElement(me, G[q]), me;
    }
    updateDOM() {
      return !1;
    }
    static importDOM() {
      return { h1: () => ({ conversion: U, priority: 0 }), h2: () => ({ conversion: U, priority: 0 }), h3: () => ({ conversion: U, priority: 0 }), h4: () => ({ conversion: U, priority: 0 }), h5: () => ({
        conversion: U,
        priority: 0
      }), h6: () => ({ conversion: U, priority: 0 }), p: (G) => (G = G.firstChild, G !== null && F(G) ? { conversion: () => ({ node: null }), priority: 3 } : null), span: (G) => F(G) ? { conversion: () => ({ node: K("h1") }), priority: 3 } : null };
    }
    exportDOM(G) {
      if ({ element: G } = super.exportDOM(G), G && r.isHTMLElement(G)) {
        this.isEmpty() && G.append(document.createElement("br"));
        var q = this.getFormatType();
        G.style.textAlign = q, (q = this.getDirection()) && (G.dir = q);
      }
      return { element: G };
    }
    static importJSON(G) {
      let q = K(G.tag);
      return q.setFormat(G.format), q.setIndent(G.indent), q.setDirection(G.direction), q;
    }
    exportJSON() {
      return { ...super.exportJSON(), tag: this.getTag(), type: "heading", version: 1 };
    }
    insertNewAfter(G, q = !0) {
      let me = G ? G.anchor.offset : 0, pe = me !== this.getTextContentSize() && G ? K(this.getTag()) : o.$createParagraphNode(), Z = this.getDirection();
      return pe.setDirection(Z), this.insertAfter(pe, q), me === 0 && !this.isEmpty() && G && (G = o.$createParagraphNode(), G.select(), this.replace(G, !0)), pe;
    }
    collapseAtStart() {
      let G = this.isEmpty() ? o.$createParagraphNode() : K(this.getTag());
      return this.getChildren().forEach((q) => G.append(q)), this.replace(G), !0;
    }
    extractWithChild() {
      return !0;
    }
  }
  function F(V) {
    return V.nodeName.toLowerCase() === "span" ? V.style.fontSize === "26pt" : !1;
  }
  function U(V) {
    let G = V.nodeName.toLowerCase(), q = null;
    return (G === "h1" || G === "h2" || G === "h3" || G === "h4" || G === "h5" || G === "h6") && (q = K(G), V.style !== null && q.setFormat(V.style.textAlign)), { node: q };
  }
  function I(V) {
    let G = N();
    return V.style !== null && G.setFormat(V.style.textAlign), { node: G };
  }
  function K(V) {
    return o.$applyNodeReplacement(new v(V));
  }
  function B(V, G) {
    V.preventDefault(), G.update(() => {
      let q = o.$getSelection(), me = V instanceof InputEvent || V instanceof KeyboardEvent ? null : V.clipboardData;
      me != null && o.$INTERNAL_isPointSelection(q) && e.$insertDataTransferForRichText(me, q, G);
    }, { tag: "paste" });
  }
  async function z(V, G) {
    await e.copyToClipboard(G, r.objectKlassEquals(V, ClipboardEvent) ? V : null), G.update(() => {
      let q = o.$getSelection();
      o.$isRangeSelection(q) ? q.removeText() : o.$isNodeSelection(q) && q.getNodes().forEach((me) => me.remove());
    });
  }
  function te(V) {
    let G = null;
    if (V instanceof DragEvent ? G = V.dataTransfer : V instanceof ClipboardEvent && (G = V.clipboardData), G === null)
      return [!1, [], !1];
    var q = G.types;
    return V = q.includes("Files"), q = q.includes("text/html") || q.includes("text/plain"), [V, Array.from(G.files), q];
  }
  function re(V) {
    var G = o.$getSelection();
    if (!o.$isRangeSelection(G))
      return !1;
    let q = /* @__PURE__ */ new Set();
    G = G.getNodes();
    for (let Z = 0; Z < G.length; Z++) {
      var me = G[Z], pe = me.getKey();
      q.has(pe) || (me = r.$getNearestBlockElementAncestorOrThrow(me), pe = me.getKey(), me.canIndent() && !q.has(pe) && (q.add(pe), V(me)));
    }
    return 0 < q.size;
  }
  function de(V) {
    return V = o.$getNearestNodeFromDOMNode(V), o.$isDecoratorNode(V);
  }
  return Jr.$createHeadingNode = K, Jr.$createQuoteNode = N, Jr.$isHeadingNode = function(V) {
    return V instanceof v;
  }, Jr.$isQuoteNode = function(V) {
    return V instanceof H;
  }, Jr.DRAG_DROP_PASTE = k, Jr.HeadingNode = v, Jr.QuoteNode = H, Jr.eventFiles = te, Jr.registerRichText = function(V) {
    return r.mergeRegister(
      V.registerCommand(o.CLICK_COMMAND, () => {
        const G = o.$getSelection();
        return o.$isNodeSelection(G) ? (G.clear(), !0) : !1;
      }, 0),
      V.registerCommand(o.DELETE_CHARACTER_COMMAND, (G) => {
        const q = o.$getSelection();
        return o.$isRangeSelection(q) ? (q.deleteCharacter(G), !0) : !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(o.DELETE_WORD_COMMAND, (G) => {
        const q = o.$getSelection();
        return o.$isRangeSelection(q) ? (q.deleteWord(G), !0) : !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(o.DELETE_LINE_COMMAND, (G) => {
        const q = o.$getSelection();
        return o.$isRangeSelection(q) ? (q.deleteLine(G), !0) : !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(o.CONTROLLED_TEXT_INSERTION_COMMAND, (G) => {
        const q = o.$getSelection();
        if (typeof G == "string")
          o.$INTERNAL_isPointSelection(q) && q.insertText(G);
        else {
          if (!o.$INTERNAL_isPointSelection(q))
            return !1;
          const me = G.dataTransfer;
          me != null ? e.$insertDataTransferForRichText(me, q, V) : o.$isRangeSelection(q) && (G = G.data) && q.insertText(G);
        }
        return !0;
      }, o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(o.REMOVE_TEXT_COMMAND, () => {
        const G = o.$getSelection();
        return o.$isRangeSelection(G) ? (G.removeText(), !0) : !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(o.FORMAT_TEXT_COMMAND, (G) => {
        const q = o.$getSelection();
        return o.$isRangeSelection(q) ? (q.formatText(G), !0) : !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(o.FORMAT_ELEMENT_COMMAND, (G) => {
        var q = o.$getSelection();
        if (!o.$isRangeSelection(q) && !o.$isNodeSelection(q))
          return !1;
        q = q.getNodes();
        for (const me of q)
          q = r.$findMatchingParent(
            me,
            (pe) => o.$isElementNode(pe) && !pe.isInline()
          ), q !== null && q.setFormat(G);
        return !0;
      }, o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(o.INSERT_LINE_BREAK_COMMAND, (G) => {
        const q = o.$getSelection();
        return o.$isRangeSelection(q) ? (q.insertLineBreak(G), !0) : !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(o.INSERT_PARAGRAPH_COMMAND, () => {
        const G = o.$getSelection();
        return o.$isRangeSelection(G) ? (G.insertParagraph(), !0) : !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(o.INSERT_TAB_COMMAND, () => (o.$insertNodes([o.$createTabNode()]), !0), o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(o.INDENT_CONTENT_COMMAND, () => re((G) => {
        const q = G.getIndent();
        G.setIndent(q + 1);
      }), o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(o.OUTDENT_CONTENT_COMMAND, () => re((G) => {
        const q = G.getIndent();
        0 < q && G.setIndent(q - 1);
      }), o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(o.KEY_ARROW_UP_COMMAND, (G) => {
        var q = o.$getSelection();
        if (o.$isNodeSelection(q) && !de(G.target)) {
          if (G = q.getNodes(), 0 < G.length)
            return G[0].selectPrevious(), !0;
        } else if (o.$isRangeSelection(q) && (q = o.$getAdjacentNode(
          q.focus,
          !0
        ), !G.shiftKey && o.$isDecoratorNode(q) && !q.isIsolated() && !q.isInline()))
          return q.selectPrevious(), G.preventDefault(), !0;
        return !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(o.KEY_ARROW_DOWN_COMMAND, (G) => {
        var q = o.$getSelection();
        if (o.$isNodeSelection(q)) {
          if (G = q.getNodes(), 0 < G.length)
            return G[0].selectNext(0, 0), !0;
        } else if (o.$isRangeSelection(q)) {
          let me = q.focus;
          if (me.key === "root" && me.offset === o.$getRoot().getChildrenSize())
            return G.preventDefault(), !0;
          if (q = o.$getAdjacentNode(q.focus, !1), !G.shiftKey && o.$isDecoratorNode(q) && !q.isIsolated() && !q.isInline())
            return q.selectNext(), G.preventDefault(), !0;
        }
        return !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(o.KEY_ARROW_LEFT_COMMAND, (G) => {
        const q = o.$getSelection();
        if (o.$isNodeSelection(q)) {
          var me = q.getNodes();
          if (0 < me.length)
            return G.preventDefault(), me[0].selectPrevious(), !0;
        }
        return o.$isRangeSelection(q) && t.$shouldOverrideDefaultCharacterSelection(q, !0) ? (me = G.shiftKey, G.preventDefault(), t.$moveCharacter(q, me, !0), !0) : !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(
        o.KEY_ARROW_RIGHT_COMMAND,
        (G) => {
          const q = o.$getSelection();
          if (o.$isNodeSelection(q) && !de(G.target)) {
            var me = q.getNodes();
            if (0 < me.length)
              return G.preventDefault(), me[0].selectNext(0, 0), !0;
          }
          return o.$isRangeSelection(q) ? (me = G.shiftKey, t.$shouldOverrideDefaultCharacterSelection(q, !1) ? (G.preventDefault(), t.$moveCharacter(q, me, !1), !0) : !1) : !1;
        },
        o.COMMAND_PRIORITY_EDITOR
      ),
      V.registerCommand(o.KEY_BACKSPACE_COMMAND, (G) => {
        if (de(G.target))
          return !1;
        const q = o.$getSelection();
        if (!o.$isRangeSelection(q))
          return !1;
        G.preventDefault(), { anchor: G } = q;
        const me = G.getNode();
        return q.isCollapsed() && G.offset === 0 && !o.$isRootNode(me) && 0 < r.$getNearestBlockElementAncestorOrThrow(me).getIndent() ? V.dispatchCommand(o.OUTDENT_CONTENT_COMMAND, void 0) : V.dispatchCommand(o.DELETE_CHARACTER_COMMAND, !0);
      }, o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(o.KEY_DELETE_COMMAND, (G) => {
        if (de(G.target))
          return !1;
        const q = o.$getSelection();
        return o.$isRangeSelection(q) ? (G.preventDefault(), V.dispatchCommand(o.DELETE_CHARACTER_COMMAND, !1)) : !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(
        o.KEY_ENTER_COMMAND,
        (G) => {
          const q = o.$getSelection();
          if (!o.$isRangeSelection(q))
            return !1;
          if (G !== null) {
            if ((S || O || D) && T)
              return !1;
            if (G.preventDefault(), G.shiftKey)
              return V.dispatchCommand(o.INSERT_LINE_BREAK_COMMAND, !1);
          }
          return V.dispatchCommand(o.INSERT_PARAGRAPH_COMMAND, void 0);
        },
        o.COMMAND_PRIORITY_EDITOR
      ),
      V.registerCommand(o.KEY_ESCAPE_COMMAND, () => {
        const G = o.$getSelection();
        return o.$isRangeSelection(G) ? (V.blur(), !0) : !1;
      }, o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(o.DROP_COMMAND, (G) => {
        const [, q] = te(G);
        if (0 < q.length) {
          var me = f(G.clientX, G.clientY);
          if (me !== null) {
            const { offset: Z, node: ee } = me;
            var pe = o.$getNearestNodeFromDOMNode(ee);
            if (pe !== null) {
              if (me = o.$createRangeSelection(), o.$isTextNode(pe))
                me.anchor.set(pe.getKey(), Z, "text"), me.focus.set(pe.getKey(), Z, "text");
              else {
                const P = pe.getParentOrThrow().getKey();
                pe = pe.getIndexWithinParent() + 1, me.anchor.set(P, pe, "element"), me.focus.set(P, pe, "element");
              }
              me = o.$normalizeSelection__EXPERIMENTAL(me), o.$setSelection(me);
            }
            V.dispatchCommand(k, q);
          }
          return G.preventDefault(), !0;
        }
        return G = o.$getSelection(), !!o.$isRangeSelection(G);
      }, o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(o.DRAGSTART_COMMAND, (G) => {
        [G] = te(G);
        const q = o.$getSelection();
        return !(G && !o.$isRangeSelection(q));
      }, o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(o.DRAGOVER_COMMAND, (G) => {
        var [q] = te(G);
        const me = o.$getSelection();
        return q && !o.$isRangeSelection(me) ? !1 : (q = f(G.clientX, G.clientY), q !== null && (q = o.$getNearestNodeFromDOMNode(q.node), o.$isDecoratorNode(q) && G.preventDefault()), !0);
      }, o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(o.SELECT_ALL_COMMAND, () => (o.$selectAll(), !0), o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(o.COPY_COMMAND, (G) => (e.copyToClipboard(V, r.objectKlassEquals(G, ClipboardEvent) ? G : null), !0), o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(o.CUT_COMMAND, (G) => (z(G, V), !0), o.COMMAND_PRIORITY_EDITOR),
      V.registerCommand(o.PASTE_COMMAND, (G) => {
        const [, q, me] = te(G);
        if (0 < q.length && !me)
          return V.dispatchCommand(k, q), !0;
        if (o.isSelectionCapturedInDecoratorInput(G.target))
          return !1;
        const pe = o.$getSelection();
        return o.$INTERNAL_isPointSelection(pe) ? (B(G, V), !0) : !1;
      }, o.COMMAND_PRIORITY_EDITOR)
    );
  }, Jr;
}
var Zr = {}, dd;
function c_() {
  if (dd)
    return Zr;
  dd = 1;
  var e = ch(), t = oo(), r = Jt(), o = kt();
  function f(pe, Z) {
    if (typeof document.caretRangeFromPoint < "u") {
      const ee = document.caretRangeFromPoint(pe, Z);
      return ee === null ? null : {
        node: ee.startContainer,
        offset: ee.startOffset
      };
    } else if (document.caretPositionFromPoint !== "undefined") {
      const ee = document.caretPositionFromPoint(pe, Z);
      return ee === null ? null : {
        node: ee.offsetNode,
        offset: ee.offset
      };
    } else
      return null;
  }
  const h = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", C = h && "documentMode" in document ? document.documentMode : null, T = h && "InputEvent" in window && !C ? "getTargetRanges" in new window.InputEvent("input") : !1, O = h && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), S = h && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, x = h && /^(?=.*Chrome).*/i.test(navigator.userAgent), D = h && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !x, k = o.createCommand("DRAG_DROP_PASTE_FILE");
  class H extends o.ElementNode {
    static getType() {
      return "quote";
    }
    static clone(Z) {
      return new H(Z.__key);
    }
    constructor(Z) {
      super(Z);
    }
    // View
    createDOM(Z) {
      const ee = document.createElement("blockquote");
      return r.addClassNamesToElement(ee, Z.theme.quote), ee;
    }
    updateDOM(Z, ee) {
      return !1;
    }
    static importDOM() {
      return {
        blockquote: (Z) => ({
          conversion: K,
          priority: 0
        })
      };
    }
    exportDOM(Z) {
      const {
        element: ee
      } = super.exportDOM(Z);
      if (ee && r.isHTMLElement(ee)) {
        this.isEmpty() && ee.append(document.createElement("br"));
        const P = this.getFormatType();
        ee.style.textAlign = P;
        const w = this.getDirection();
        w && (ee.dir = w);
      }
      return {
        element: ee
      };
    }
    static importJSON(Z) {
      const ee = N();
      return ee.setFormat(Z.format), ee.setIndent(Z.indent), ee.setDirection(Z.direction), ee;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "quote"
      };
    }
    // Mutation
    insertNewAfter(Z, ee) {
      const P = o.$createParagraphNode(), w = this.getDirection();
      return P.setDirection(w), this.insertAfter(P, ee), P;
    }
    collapseAtStart() {
      const Z = o.$createParagraphNode();
      return this.getChildren().forEach((P) => Z.append(P)), this.replace(Z), !0;
    }
  }
  function N() {
    return o.$applyNodeReplacement(new H());
  }
  function v(pe) {
    return pe instanceof H;
  }
  class F extends o.ElementNode {
    /** @internal */
    static getType() {
      return "heading";
    }
    static clone(Z) {
      return new F(Z.__tag, Z.__key);
    }
    constructor(Z, ee) {
      super(ee), this.__tag = Z;
    }
    getTag() {
      return this.__tag;
    }
    // View
    createDOM(Z) {
      const ee = this.__tag, P = document.createElement(ee), j = Z.theme.heading;
      if (j !== void 0) {
        const ne = j[ee];
        r.addClassNamesToElement(P, ne);
      }
      return P;
    }
    updateDOM(Z, ee) {
      return !1;
    }
    static importDOM() {
      return {
        h1: (Z) => ({
          conversion: I,
          priority: 0
        }),
        h2: (Z) => ({
          conversion: I,
          priority: 0
        }),
        h3: (Z) => ({
          conversion: I,
          priority: 0
        }),
        h4: (Z) => ({
          conversion: I,
          priority: 0
        }),
        h5: (Z) => ({
          conversion: I,
          priority: 0
        }),
        h6: (Z) => ({
          conversion: I,
          priority: 0
        }),
        p: (Z) => {
          const P = Z.firstChild;
          return P !== null && U(P) ? {
            conversion: () => ({
              node: null
            }),
            priority: 3
          } : null;
        },
        span: (Z) => U(Z) ? {
          conversion: (ee) => ({
            node: B("h1")
          }),
          priority: 3
        } : null
      };
    }
    exportDOM(Z) {
      const {
        element: ee
      } = super.exportDOM(Z);
      if (ee && r.isHTMLElement(ee)) {
        this.isEmpty() && ee.append(document.createElement("br"));
        const P = this.getFormatType();
        ee.style.textAlign = P;
        const w = this.getDirection();
        w && (ee.dir = w);
      }
      return {
        element: ee
      };
    }
    static importJSON(Z) {
      const ee = B(Z.tag);
      return ee.setFormat(Z.format), ee.setIndent(Z.indent), ee.setDirection(Z.direction), ee;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        tag: this.getTag(),
        type: "heading",
        version: 1
      };
    }
    // Mutation
    insertNewAfter(Z, ee = !0) {
      const P = Z ? Z.anchor.offset : 0, w = P === this.getTextContentSize() || !Z ? o.$createParagraphNode() : B(this.getTag()), j = this.getDirection();
      if (w.setDirection(j), this.insertAfter(w, ee), P === 0 && !this.isEmpty() && Z) {
        const ne = o.$createParagraphNode();
        ne.select(), this.replace(ne, !0);
      }
      return w;
    }
    collapseAtStart() {
      const Z = this.isEmpty() ? o.$createParagraphNode() : B(this.getTag());
      return this.getChildren().forEach((P) => Z.append(P)), this.replace(Z), !0;
    }
    extractWithChild() {
      return !0;
    }
  }
  function U(pe) {
    return pe.nodeName.toLowerCase() === "span" ? pe.style.fontSize === "26pt" : !1;
  }
  function I(pe) {
    const Z = pe.nodeName.toLowerCase();
    let ee = null;
    return (Z === "h1" || Z === "h2" || Z === "h3" || Z === "h4" || Z === "h5" || Z === "h6") && (ee = B(Z), pe.style !== null && ee.setFormat(pe.style.textAlign)), {
      node: ee
    };
  }
  function K(pe) {
    const Z = N();
    return pe.style !== null && Z.setFormat(pe.style.textAlign), {
      node: Z
    };
  }
  function B(pe) {
    return o.$applyNodeReplacement(new F(pe));
  }
  function z(pe) {
    return pe instanceof F;
  }
  function te(pe, Z) {
    pe.preventDefault(), Z.update(() => {
      const ee = o.$getSelection(), P = pe instanceof InputEvent || pe instanceof KeyboardEvent ? null : pe.clipboardData;
      P != null && o.$INTERNAL_isPointSelection(ee) && e.$insertDataTransferForRichText(P, ee, Z);
    }, {
      tag: "paste"
    });
  }
  async function re(pe, Z) {
    await e.copyToClipboard(Z, r.objectKlassEquals(pe, ClipboardEvent) ? pe : null), Z.update(() => {
      const ee = o.$getSelection();
      o.$isRangeSelection(ee) ? ee.removeText() : o.$isNodeSelection(ee) && ee.getNodes().forEach((P) => P.remove());
    });
  }
  function de(pe) {
    let Z = null;
    if (pe instanceof DragEvent ? Z = pe.dataTransfer : pe instanceof ClipboardEvent && (Z = pe.clipboardData), Z === null)
      return [!1, [], !1];
    const ee = Z.types, P = ee.includes("Files"), w = ee.includes("text/html") || ee.includes("text/plain");
    return [P, Array.from(Z.files), w];
  }
  function V(pe) {
    const Z = o.$getSelection();
    if (!o.$isRangeSelection(Z))
      return !1;
    const ee = /* @__PURE__ */ new Set(), P = Z.getNodes();
    for (let w = 0; w < P.length; w++) {
      const j = P[w], ne = j.getKey();
      if (ee.has(ne))
        continue;
      const Y = r.$getNearestBlockElementAncestorOrThrow(j), W = Y.getKey();
      Y.canIndent() && !ee.has(W) && (ee.add(W), pe(Y));
    }
    return ee.size > 0;
  }
  function G(pe) {
    const Z = o.$getNearestNodeFromDOMNode(pe);
    return o.$isDecoratorNode(Z);
  }
  function q(pe) {
    const Z = pe.focus;
    return Z.key === "root" && Z.offset === o.$getRoot().getChildrenSize();
  }
  function me(pe) {
    return r.mergeRegister(pe.registerCommand(o.CLICK_COMMAND, (ee) => {
      const P = o.$getSelection();
      return o.$isNodeSelection(P) ? (P.clear(), !0) : !1;
    }, 0), pe.registerCommand(o.DELETE_CHARACTER_COMMAND, (ee) => {
      const P = o.$getSelection();
      return o.$isRangeSelection(P) ? (P.deleteCharacter(ee), !0) : !1;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.DELETE_WORD_COMMAND, (ee) => {
      const P = o.$getSelection();
      return o.$isRangeSelection(P) ? (P.deleteWord(ee), !0) : !1;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.DELETE_LINE_COMMAND, (ee) => {
      const P = o.$getSelection();
      return o.$isRangeSelection(P) ? (P.deleteLine(ee), !0) : !1;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.CONTROLLED_TEXT_INSERTION_COMMAND, (ee) => {
      const P = o.$getSelection();
      if (typeof ee == "string")
        o.$INTERNAL_isPointSelection(P) && P.insertText(ee);
      else {
        if (!o.$INTERNAL_isPointSelection(P))
          return !1;
        const w = ee.dataTransfer;
        if (w != null)
          e.$insertDataTransferForRichText(w, P, pe);
        else if (o.$isRangeSelection(P)) {
          const j = ee.data;
          return j && P.insertText(j), !0;
        }
      }
      return !0;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.REMOVE_TEXT_COMMAND, () => {
      const ee = o.$getSelection();
      return o.$isRangeSelection(ee) ? (ee.removeText(), !0) : !1;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.FORMAT_TEXT_COMMAND, (ee) => {
      const P = o.$getSelection();
      return o.$isRangeSelection(P) ? (P.formatText(ee), !0) : !1;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.FORMAT_ELEMENT_COMMAND, (ee) => {
      const P = o.$getSelection();
      if (!o.$isRangeSelection(P) && !o.$isNodeSelection(P))
        return !1;
      const w = P.getNodes();
      for (const j of w) {
        const ne = r.$findMatchingParent(j, (Y) => o.$isElementNode(Y) && !Y.isInline());
        ne !== null && ne.setFormat(ee);
      }
      return !0;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.INSERT_LINE_BREAK_COMMAND, (ee) => {
      const P = o.$getSelection();
      return o.$isRangeSelection(P) ? (P.insertLineBreak(ee), !0) : !1;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.INSERT_PARAGRAPH_COMMAND, () => {
      const ee = o.$getSelection();
      return o.$isRangeSelection(ee) ? (ee.insertParagraph(), !0) : !1;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.INSERT_TAB_COMMAND, () => (o.$insertNodes([o.$createTabNode()]), !0), o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.INDENT_CONTENT_COMMAND, () => V((ee) => {
      const P = ee.getIndent();
      ee.setIndent(P + 1);
    }), o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.OUTDENT_CONTENT_COMMAND, () => V((ee) => {
      const P = ee.getIndent();
      P > 0 && ee.setIndent(P - 1);
    }), o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.KEY_ARROW_UP_COMMAND, (ee) => {
      const P = o.$getSelection();
      if (o.$isNodeSelection(P) && !G(ee.target)) {
        const w = P.getNodes();
        if (w.length > 0)
          return w[0].selectPrevious(), !0;
      } else if (o.$isRangeSelection(P)) {
        const w = o.$getAdjacentNode(P.focus, !0);
        if (!ee.shiftKey && o.$isDecoratorNode(w) && !w.isIsolated() && !w.isInline())
          return w.selectPrevious(), ee.preventDefault(), !0;
      }
      return !1;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.KEY_ARROW_DOWN_COMMAND, (ee) => {
      const P = o.$getSelection();
      if (o.$isNodeSelection(P)) {
        const w = P.getNodes();
        if (w.length > 0)
          return w[0].selectNext(0, 0), !0;
      } else if (o.$isRangeSelection(P)) {
        if (q(P))
          return ee.preventDefault(), !0;
        const w = o.$getAdjacentNode(P.focus, !1);
        if (!ee.shiftKey && o.$isDecoratorNode(w) && !w.isIsolated() && !w.isInline())
          return w.selectNext(), ee.preventDefault(), !0;
      }
      return !1;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.KEY_ARROW_LEFT_COMMAND, (ee) => {
      const P = o.$getSelection();
      if (o.$isNodeSelection(P)) {
        const w = P.getNodes();
        if (w.length > 0)
          return ee.preventDefault(), w[0].selectPrevious(), !0;
      }
      if (!o.$isRangeSelection(P))
        return !1;
      if (t.$shouldOverrideDefaultCharacterSelection(P, !0)) {
        const w = ee.shiftKey;
        return ee.preventDefault(), t.$moveCharacter(P, w, !0), !0;
      }
      return !1;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.KEY_ARROW_RIGHT_COMMAND, (ee) => {
      const P = o.$getSelection();
      if (o.$isNodeSelection(P) && !G(ee.target)) {
        const j = P.getNodes();
        if (j.length > 0)
          return ee.preventDefault(), j[0].selectNext(0, 0), !0;
      }
      if (!o.$isRangeSelection(P))
        return !1;
      const w = ee.shiftKey;
      return t.$shouldOverrideDefaultCharacterSelection(P, !1) ? (ee.preventDefault(), t.$moveCharacter(P, w, !1), !0) : !1;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.KEY_BACKSPACE_COMMAND, (ee) => {
      if (G(ee.target))
        return !1;
      const P = o.$getSelection();
      if (!o.$isRangeSelection(P))
        return !1;
      ee.preventDefault();
      const {
        anchor: w
      } = P, j = w.getNode();
      return P.isCollapsed() && w.offset === 0 && !o.$isRootNode(j) && r.$getNearestBlockElementAncestorOrThrow(j).getIndent() > 0 ? pe.dispatchCommand(o.OUTDENT_CONTENT_COMMAND, void 0) : pe.dispatchCommand(o.DELETE_CHARACTER_COMMAND, !0);
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.KEY_DELETE_COMMAND, (ee) => {
      if (G(ee.target))
        return !1;
      const P = o.$getSelection();
      return o.$isRangeSelection(P) ? (ee.preventDefault(), pe.dispatchCommand(o.DELETE_CHARACTER_COMMAND, !1)) : !1;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.KEY_ENTER_COMMAND, (ee) => {
      const P = o.$getSelection();
      if (!o.$isRangeSelection(P))
        return !1;
      if (ee !== null) {
        if ((S || O || D) && T)
          return !1;
        if (ee.preventDefault(), ee.shiftKey)
          return pe.dispatchCommand(o.INSERT_LINE_BREAK_COMMAND, !1);
      }
      return pe.dispatchCommand(o.INSERT_PARAGRAPH_COMMAND, void 0);
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.KEY_ESCAPE_COMMAND, () => {
      const ee = o.$getSelection();
      return o.$isRangeSelection(ee) ? (pe.blur(), !0) : !1;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.DROP_COMMAND, (ee) => {
      const [, P] = de(ee);
      if (P.length > 0) {
        const j = ee.clientX, ne = ee.clientY, Y = f(j, ne);
        if (Y !== null) {
          const {
            offset: W,
            node: Q
          } = Y, b = o.$getNearestNodeFromDOMNode(Q);
          if (b !== null) {
            const g = o.$createRangeSelection();
            if (o.$isTextNode(b))
              g.anchor.set(b.getKey(), W, "text"), g.focus.set(b.getKey(), W, "text");
            else {
              const A = b.getParentOrThrow().getKey(), J = b.getIndexWithinParent() + 1;
              g.anchor.set(A, J, "element"), g.focus.set(A, J, "element");
            }
            const _ = o.$normalizeSelection__EXPERIMENTAL(g);
            o.$setSelection(_);
          }
          pe.dispatchCommand(k, P);
        }
        return ee.preventDefault(), !0;
      }
      const w = o.$getSelection();
      return !!o.$isRangeSelection(w);
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.DRAGSTART_COMMAND, (ee) => {
      const [P] = de(ee), w = o.$getSelection();
      return !(P && !o.$isRangeSelection(w));
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.DRAGOVER_COMMAND, (ee) => {
      const [P] = de(ee), w = o.$getSelection();
      if (P && !o.$isRangeSelection(w))
        return !1;
      const j = ee.clientX, ne = ee.clientY, Y = f(j, ne);
      if (Y !== null) {
        const W = o.$getNearestNodeFromDOMNode(Y.node);
        o.$isDecoratorNode(W) && ee.preventDefault();
      }
      return !0;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.SELECT_ALL_COMMAND, () => (o.$selectAll(), !0), o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.COPY_COMMAND, (ee) => (e.copyToClipboard(pe, r.objectKlassEquals(ee, ClipboardEvent) ? ee : null), !0), o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.CUT_COMMAND, (ee) => (re(ee, pe), !0), o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.PASTE_COMMAND, (ee) => {
      const [, P, w] = de(ee);
      if (P.length > 0 && !w)
        return pe.dispatchCommand(k, P), !0;
      if (o.isSelectionCapturedInDecoratorInput(ee.target))
        return !1;
      const j = o.$getSelection();
      return o.$INTERNAL_isPointSelection(j) ? (te(ee, pe), !0) : !1;
    }, o.COMMAND_PRIORITY_EDITOR));
  }
  return Zr.$createHeadingNode = B, Zr.$createQuoteNode = N, Zr.$isHeadingNode = z, Zr.$isQuoteNode = v, Zr.DRAG_DROP_PASTE = k, Zr.HeadingNode = F, Zr.QuoteNode = H, Zr.eventFiles = de, Zr.registerRichText = me, Zr;
}
var Za, fd;
function $c() {
  return fd || (fd = 1, Za = process.env.NODE_ENV === "development" ? c_() : a_()), Za;
}
var hd;
function u_() {
  if (hd)
    return Ba;
  hd = 1;
  var e = kn(), t = oh(), r = rn, o = sh(), f = Jt(), h = Hf, C = lh(), T = $c(), O = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? r.useLayoutEffect : r.useEffect;
  function S(N) {
    return N.getEditorState().read(o.$canShowPlaceholderCurry(N.isComposing()));
  }
  function x(N) {
    let [v, F] = r.useState(() => S(N));
    return O(() => {
      function U() {
        let I = S(N);
        F(I);
      }
      return U(), f.mergeRegister(N.registerUpdateListener(() => {
        U();
      }), N.registerEditableListener(() => {
        U();
      }));
    }, [N]), v;
  }
  function D(N, v) {
    let [F, U] = r.useState(() => N.getDecorators());
    return O(() => N.registerDecoratorListener((I) => {
      h.flushSync(() => {
        U(I);
      });
    }), [N]), r.useEffect(() => {
      U(N.getDecorators());
    }, [N]), r.useMemo(() => {
      let I = [], K = Object.keys(F);
      for (let B = 0; B < K.length; B++) {
        let z = K[B], te = r.createElement(v, { onError: (de) => N._onError(de) }, r.createElement(r.Suspense, { fallback: null }, F[z])), re = N.getElementByKey(z);
        re !== null && I.push(h.createPortal(te, re, z));
      }
      return I;
    }, [v, F, N]);
  }
  function k(N) {
    O(() => f.mergeRegister(T.registerRichText(N), C.registerDragonSupport(N)), [N]);
  }
  function H({ content: N }) {
    var [v] = e.useLexicalComposerContext();
    v = x(v);
    let F = t();
    return v ? typeof N == "function" ? N(F) : N : null;
  }
  return Ba.RichTextPlugin = function({ contentEditable: N, placeholder: v, ErrorBoundary: F }) {
    let [U] = e.useLexicalComposerContext();
    return F = D(U, F), k(U), r.createElement(r.Fragment, null, N, r.createElement(H, { content: v }), F);
  }, Ba;
}
var Xa = {}, gd;
function d_() {
  if (gd)
    return Xa;
  gd = 1;
  var e = kn(), t = oh(), r = rn, o = sh(), f = Jt(), h = Hf, C = lh(), T = $c(), x = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? r.useLayoutEffect : r.useEffect;
  function D(U) {
    return U.getEditorState().read(o.$canShowPlaceholderCurry(U.isComposing()));
  }
  function k(U) {
    const [I, K] = r.useState(() => D(U));
    return x(() => {
      function B() {
        const z = D(U);
        K(z);
      }
      return B(), f.mergeRegister(U.registerUpdateListener(() => {
        B();
      }), U.registerEditableListener(() => {
        B();
      }));
    }, [U]), I;
  }
  function H(U, I) {
    const [K, B] = r.useState(() => U.getDecorators());
    return x(() => U.registerDecoratorListener((z) => {
      h.flushSync(() => {
        B(z);
      });
    }), [U]), r.useEffect(() => {
      B(U.getDecorators());
    }, [U]), r.useMemo(() => {
      const z = [], te = Object.keys(K);
      for (let re = 0; re < te.length; re++) {
        const de = te[re], V = /* @__PURE__ */ r.createElement(I, {
          onError: (q) => U._onError(q)
        }, /* @__PURE__ */ r.createElement(r.Suspense, {
          fallback: null
        }, K[de])), G = U.getElementByKey(de);
        G !== null && z.push(/* @__PURE__ */ h.createPortal(V, G, de));
      }
      return z;
    }, [I, K, U]);
  }
  function N(U) {
    x(() => f.mergeRegister(T.registerRichText(U), C.registerDragonSupport(U)), [U]);
  }
  function v({
    contentEditable: U,
    placeholder: I,
    ErrorBoundary: K
  }) {
    const [B] = e.useLexicalComposerContext(), z = H(B, K);
    return N(B), /* @__PURE__ */ r.createElement(r.Fragment, null, U, /* @__PURE__ */ r.createElement(F, {
      content: I
    }), z);
  }
  function F({
    content: U
  }) {
    const [I] = e.useLexicalComposerContext(), K = k(I), B = t();
    return K ? typeof U == "function" ? U(B) : U : null;
  }
  return Xa.RichTextPlugin = v, Xa;
}
const f_ = process.env.NODE_ENV === "development" ? d_() : u_();
var h_ = f_, Qa = {}, pd;
function g_() {
  if (pd)
    return Qa;
  pd = 1;
  var e = kn(), t = rn;
  function r() {
    return r = Object.assign ? Object.assign.bind() : function(f) {
      for (var h = 1; h < arguments.length; h++) {
        var C = arguments[h], T;
        for (T in C)
          Object.prototype.hasOwnProperty.call(C, T) && (f[T] = C[T]);
      }
      return f;
    }, r.apply(this, arguments);
  }
  var o = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? t.useLayoutEffect : t.useEffect;
  return Qa.ContentEditable = function({ ariaActiveDescendant: f, ariaAutoComplete: h, ariaControls: C, ariaDescribedBy: T, ariaExpanded: O, ariaLabel: S, ariaLabelledBy: x, ariaMultiline: D, ariaOwns: k, ariaRequired: H, autoCapitalize: N, className: v, id: F, role: U = "textbox", spellCheck: I = !0, style: K, tabIndex: B, "data-testid": z, ...te }) {
    let [re] = e.useLexicalComposerContext(), [de, V] = t.useState(!1), G = t.useCallback((q) => {
      re.setRootElement(q);
    }, [re]);
    return o(() => (V(re.isEditable()), re.registerEditableListener((q) => {
      V(q);
    })), [re]), t.createElement(
      "div",
      r({}, te, { "aria-activedescendant": de ? f : void 0, "aria-autocomplete": de ? h : "none", "aria-controls": de ? C : void 0, "aria-describedby": T, "aria-expanded": de && U === "combobox" ? !!O : void 0, "aria-label": S, "aria-labelledby": x, "aria-multiline": D, "aria-owns": de ? k : void 0, "aria-readonly": de ? void 0 : !0, "aria-required": H, autoCapitalize: N, className: v, contentEditable: de, "data-testid": z, id: F, ref: G, role: U, spellCheck: I, style: K, tabIndex: B })
    );
  }, Qa;
}
var ec = {}, _d;
function p_() {
  if (_d)
    return ec;
  _d = 1;
  var e = kn(), t = rn;
  function r() {
    return r = Object.assign ? Object.assign.bind() : function(T) {
      for (var O = 1; O < arguments.length; O++) {
        var S = arguments[O];
        for (var x in S)
          Object.prototype.hasOwnProperty.call(S, x) && (T[x] = S[x]);
      }
      return T;
    }, r.apply(this, arguments);
  }
  var h = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? t.useLayoutEffect : t.useEffect;
  function C({
    ariaActiveDescendant: T,
    ariaAutoComplete: O,
    ariaControls: S,
    ariaDescribedBy: x,
    ariaExpanded: D,
    ariaLabel: k,
    ariaLabelledBy: H,
    ariaMultiline: N,
    ariaOwns: v,
    ariaRequired: F,
    autoCapitalize: U,
    className: I,
    id: K,
    role: B = "textbox",
    spellCheck: z = !0,
    style: te,
    tabIndex: re,
    "data-testid": de,
    ...V
  }) {
    const [G] = e.useLexicalComposerContext(), [q, me] = t.useState(!1), pe = t.useCallback((Z) => {
      G.setRootElement(Z);
    }, [G]);
    return h(() => (me(G.isEditable()), G.registerEditableListener((Z) => {
      me(Z);
    })), [G]), /* @__PURE__ */ t.createElement("div", r({}, V, {
      "aria-activedescendant": q ? T : void 0,
      "aria-autocomplete": q ? O : "none",
      "aria-controls": q ? S : void 0,
      "aria-describedby": x,
      "aria-expanded": q && B === "combobox" ? !!D : void 0,
      "aria-label": k,
      "aria-labelledby": H,
      "aria-multiline": N,
      "aria-owns": q ? v : void 0,
      "aria-readonly": q ? void 0 : !0,
      "aria-required": F,
      autoCapitalize: U,
      className: I,
      contentEditable: q,
      "data-testid": de,
      id: K,
      ref: pe,
      role: B,
      spellCheck: z,
      style: te,
      tabIndex: re
    }));
  }
  return ec.ContentEditable = C, ec;
}
const __ = process.env.NODE_ENV === "development" ? p_() : g_();
var m_ = __, tc, md;
function y_() {
  if (md)
    return tc;
  md = 1;
  var e = rn;
  function t(C, T) {
    return t = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(O, S) {
      return O.__proto__ = S, O;
    }, t(C, T);
  }
  function r(C, T) {
    C.prototype = Object.create(T.prototype), C.prototype.constructor = C, t(C, T);
  }
  function o(C, T) {
    return C === void 0 && (C = []), T === void 0 && (T = []), C.length !== T.length || C.some(function(O, S) {
      return !Object.is(O, T[S]);
    });
  }
  var f = { error: null }, h = function(C) {
    function T() {
      for (var S, x = arguments.length, D = Array(x), k = 0; k < x; k++)
        D[k] = arguments[k];
      return S = C.call.apply(C, [this].concat(D)) || this, S.state = f, S.resetErrorBoundary = function() {
        for (var H, N = arguments.length, v = Array(N), F = 0; F < N; F++)
          v[F] = arguments[F];
        S.props.onReset == null || (H = S.props).onReset.apply(H, v), S.reset();
      }, S;
    }
    r(T, C), T.getDerivedStateFromError = function(S) {
      return { error: S };
    };
    var O = T.prototype;
    return O.reset = function() {
      this.setState(f);
    }, O.componentDidCatch = function(S, x) {
      var D, k;
      (D = (k = this.props).onError) == null || D.call(k, S, x);
    }, O.componentDidUpdate = function(S, x) {
      var D = this.props.resetKeys;
      if (this.state.error !== null && x.error !== null && o(S.resetKeys, D)) {
        var k, H;
        (k = (H = this.props).onResetKeysChange) == null || k.call(H, S.resetKeys, D), this.reset();
      }
    }, O.render = function() {
      var S = this.state.error, x = this.props, D = x.fallbackRender, k = x.FallbackComponent;
      if (x = x.fallback, S !== null) {
        if (S = { error: S, resetErrorBoundary: this.resetErrorBoundary }, e.isValidElement(x))
          return x;
        if (typeof D == "function")
          return D(S);
        if (k)
          return e.createElement(k, S);
        throw Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
      }
      return this.props.children;
    }, T;
  }(e.Component);
  return tc = function({ children: C, onError: T }) {
    return e.createElement(h, { fallback: e.createElement("div", { style: { border: "1px solid #f00", color: "#f00", padding: "8px" } }, "An error was thrown."), onError: T }, C);
  }, tc;
}
var nc, yd;
function C_() {
  if (yd)
    return nc;
  yd = 1;
  var e = rn;
  function t(T, O) {
    return t = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(x, D) {
      return x.__proto__ = D, x;
    }, t(T, O);
  }
  function r(T, O) {
    T.prototype = Object.create(O.prototype), T.prototype.constructor = T, t(T, O);
  }
  var o = function(O, S) {
    return O === void 0 && (O = []), S === void 0 && (S = []), O.length !== S.length || O.some(function(x, D) {
      return !Object.is(x, S[D]);
    });
  }, f = {
    error: null
  }, h = /* @__PURE__ */ function(T) {
    r(O, T);
    function O() {
      for (var x, D = arguments.length, k = new Array(D), H = 0; H < D; H++)
        k[H] = arguments[H];
      return x = T.call.apply(T, [this].concat(k)) || this, x.state = f, x.resetErrorBoundary = function() {
        for (var N, v = arguments.length, F = new Array(v), U = 0; U < v; U++)
          F[U] = arguments[U];
        x.props.onReset == null || (N = x.props).onReset.apply(N, F), x.reset();
      }, x;
    }
    O.getDerivedStateFromError = function(D) {
      return {
        error: D
      };
    };
    var S = O.prototype;
    return S.reset = function() {
      this.setState(f);
    }, S.componentDidCatch = function(D, k) {
      var H, N;
      (H = (N = this.props).onError) == null || H.call(N, D, k);
    }, S.componentDidUpdate = function(D, k) {
      var H = this.state.error, N = this.props.resetKeys;
      if (H !== null && k.error !== null && o(D.resetKeys, N)) {
        var v, F;
        (v = (F = this.props).onResetKeysChange) == null || v.call(F, D.resetKeys, N), this.reset();
      }
    }, S.render = function() {
      var D = this.state.error, k = this.props, H = k.fallbackRender, N = k.FallbackComponent, v = k.fallback;
      if (D !== null) {
        var F = {
          error: D,
          resetErrorBoundary: this.resetErrorBoundary
        };
        if (/* @__PURE__ */ e.isValidElement(v))
          return v;
        if (typeof H == "function")
          return H(F);
        if (N)
          return /* @__PURE__ */ e.createElement(N, F);
        throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
      }
      return this.props.children;
    }, O;
  }(e.Component);
  function C({
    children: T,
    onError: O
  }) {
    return /* @__PURE__ */ e.createElement(h, {
      fallback: /* @__PURE__ */ e.createElement("div", {
        style: {
          border: "1px solid #f00",
          color: "#f00",
          padding: "8px"
        }
      }, "An error was thrown."),
      onError: O
    }, T);
  }
  return nc = C, nc;
}
const N_ = process.env.NODE_ENV === "development" ? C_() : y_();
var E_ = N_;
const T_ = /* @__PURE__ */ bc(E_);
var rc = {}, qn = {}, Cd;
function x_() {
  if (Cd)
    return qn;
  Cd = 1;
  var e = kt(), t = Jt();
  function r(P) {
    let w = new URLSearchParams();
    w.append("code", P);
    for (let j = 1; j < arguments.length; j++)
      w.append("v", arguments[j]);
    throw Error(`Minified Lexical error #${P}; visit https://lexical.dev/docs/error?${w} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  function o(P) {
    let w = 1;
    for (P = P.getParent(); P != null; ) {
      if (B(P)) {
        if (P = P.getParent(), q(P)) {
          w++, P = P.getParent();
          continue;
        }
        r(40);
      }
      break;
    }
    return w;
  }
  function f(P) {
    P = P.getParent(), q(P) || r(40);
    let w = P;
    for (; w !== null; )
      w = w.getParent(), q(w) && (P = w);
    return P;
  }
  function h(P) {
    let w = [];
    P = P.getChildren().filter(B);
    for (let j = 0; j < P.length; j++) {
      let ne = P[j], Y = ne.getFirstChild();
      q(Y) ? w = w.concat(h(Y)) : w.push(ne);
    }
    return w;
  }
  function C(P) {
    return B(P) && q(P.getFirstChild());
  }
  function T(P) {
    for (; P.getNextSibling() == null && P.getPreviousSibling() == null; ) {
      let w = P.getParent();
      if (w == null || !B(P) && !q(P))
        break;
      P = w;
    }
    P.remove();
  }
  function O(P) {
    return K().append(P);
  }
  function S(P, w) {
    return B(P) && (w.length === 0 || w.length === 1 && P.is(w[0]) && P.getChildrenSize() === 0);
  }
  function x(P, w) {
    P.splice(P.getChildrenSize(), 0, w);
  }
  function D(P, w) {
    if (q(P))
      return P;
    let j = P.getPreviousSibling(), ne = P.getNextSibling(), Y = K();
    return Y.setFormat(P.getFormatType()), Y.setIndent(P.getIndent()), x(Y, P.getChildren()), q(j) && w === j.getListType() ? (j.append(Y), P.remove(), q(ne) && w === ne.getListType() && (x(j, ne.getChildren()), ne.remove()), j) : q(ne) && w === ne.getListType() ? (ne.getFirstChildOrThrow().insertBefore(Y), P.remove(), ne) : (w = G(w), w.append(Y), P.replace(w), H(w), w);
  }
  function k(P, w) {
    var j = P.getLastChild();
    let ne = w.getFirstChild();
    j && ne && C(j) && C(ne) && (k(j.getFirstChild(), ne.getFirstChild()), ne.remove()), j = w.getChildren(), 0 < j.length && (P.append(...j), H(P)), w.remove();
  }
  function H(P, w) {
    if (P = w || P.getChildren(), P !== void 0)
      for (w = 0; w < P.length; w++) {
        let W = P[w];
        if (B(W)) {
          let Q = W.getValue();
          var j = W, ne = j.getParent(), Y = 1;
          for (ne != null && (q(ne) ? Y = ne.getStart() : r(44)), j = j.getPreviousSiblings(), ne = 0; ne < j.length; ne++) {
            let b = j[ne];
            B(b) && !q(b.getFirstChild()) && Y++;
          }
          Q !== Y && W.setValue(Y);
        }
      }
  }
  function N(P) {
    if (!C(P)) {
      var w = P.getParent(), j = w ? w.getParent() : void 0, ne = j ? j.getParent() : void 0;
      if (q(ne) && B(j) && q(w)) {
        var Y = w ? w.getFirstChild() : void 0, W = w ? w.getLastChild() : void 0;
        if (P.is(Y))
          j.insertBefore(P), w.isEmpty() && j.remove();
        else if (P.is(W))
          j.insertAfter(P), w.isEmpty() && j.remove();
        else {
          var Q = w.getListType();
          Y = K();
          let b = G(Q);
          Y.append(b), P.getPreviousSiblings().forEach((g) => b.append(g)), W = K(), Q = G(Q), W.append(Q), x(Q, P.getNextSiblings()), j.insertBefore(Y), j.insertAfter(W), j.replace(P);
        }
        H(w), H(ne);
      }
    }
  }
  class v extends e.ElementNode {
    static getType() {
      return "listitem";
    }
    static clone(w) {
      return new v(w.__value, w.__checked, w.__key);
    }
    constructor(w, j, ne) {
      super(ne), this.__value = w === void 0 ? 1 : w, this.__checked = j;
    }
    createDOM(w) {
      let j = document.createElement("li"), ne = this.getParent();
      return q(ne) && ne.getListType() === "check" && U(j, this, null), j.value = this.__value, F(j, w.theme, this), j;
    }
    updateDOM(w, j, ne) {
      let Y = this.getParent();
      return q(Y) && Y.getListType() === "check" && U(j, this, w), j.value = this.__value, F(j, ne.theme, this), !1;
    }
    static transform() {
      return (w) => {
        let j = w.getParent();
        q(j) && (H(j), j.getListType() !== "check" && w.getChecked() != null && w.setChecked(void 0));
      };
    }
    static importDOM() {
      return { li: () => ({ conversion: I, priority: 0 }) };
    }
    static importJSON(w) {
      let j = K();
      return j.setChecked(w.checked), j.setValue(w.value), j.setFormat(w.format), j.setDirection(w.direction), j;
    }
    exportDOM(w) {
      return w = this.createDOM(w._config), w.style.textAlign = this.getFormatType(), { element: w };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        checked: this.getChecked(),
        type: "listitem",
        value: this.getValue(),
        version: 1
      };
    }
    append(...w) {
      for (let j = 0; j < w.length; j++) {
        let ne = w[j];
        if (e.$isElementNode(ne) && this.canMergeWith(ne)) {
          let Y = ne.getChildren();
          this.append(...Y), ne.remove();
        } else
          super.append(ne);
      }
      return this;
    }
    replace(w, j) {
      if (B(w))
        return super.replace(w);
      this.setIndent(0);
      let ne = this.getParentOrThrow();
      if (!q(ne))
        return w;
      if (ne.__first === this.getKey())
        ne.insertBefore(w);
      else if (ne.__last === this.getKey())
        ne.insertAfter(w);
      else {
        let Y = G(ne.getListType()), W = this.getNextSibling();
        for (; W; ) {
          let Q = W;
          W = W.getNextSibling(), Y.append(Q);
        }
        ne.insertAfter(w), w.insertAfter(Y);
      }
      return j && this.getChildren().forEach((Y) => {
        w.append(Y);
      }), this.remove(), ne.getChildrenSize() === 0 && ne.remove(), w;
    }
    insertAfter(w, j = !0) {
      var ne = this.getParentOrThrow();
      q(ne) || r(39);
      var Y = this.getNextSiblings();
      if (B(w))
        return j = super.insertAfter(w, j), w = w.getParentOrThrow(), q(w) && H(w), j;
      if (q(w)) {
        for (ne = w, w = w.getChildren(), Y = w.length - 1; 0 <= Y; Y--)
          ne = w[Y], this.insertAfter(ne, j);
        return ne;
      }
      if (ne.insertAfter(w, j), Y.length !== 0) {
        let W = G(ne.getListType());
        Y.forEach((Q) => W.append(Q)), w.insertAfter(W, j);
      }
      return w;
    }
    remove(w) {
      let j = this.getPreviousSibling(), ne = this.getNextSibling();
      super.remove(w), j && ne && C(j) && C(ne) ? (k(j.getFirstChild(), ne.getFirstChild()), ne.remove()) : ne && (w = ne.getParent(), q(w) && H(w));
    }
    insertNewAfter(w, j = !0) {
      return w = K(this.__checked == null ? void 0 : !1), this.insertAfter(w, j), w;
    }
    collapseAtStart(w) {
      let j = e.$createParagraphNode();
      this.getChildren().forEach((Q) => j.append(Q));
      var ne = this.getParentOrThrow(), Y = ne.getParentOrThrow();
      let W = B(Y);
      return ne.getChildrenSize() === 1 ? W ? (ne.remove(), Y.select()) : (ne.insertBefore(j), ne.remove(), ne = w.anchor, w = w.focus, Y = j.getKey(), ne.type === "element" && ne.getNode().is(this) && ne.set(Y, ne.offset, "element"), w.type === "element" && w.getNode().is(this) && w.set(Y, w.offset, "element")) : (ne.insertBefore(j), this.remove()), !0;
    }
    getValue() {
      return this.getLatest().__value;
    }
    setValue(w) {
      this.getWritable().__value = w;
    }
    getChecked() {
      return this.getLatest().__checked;
    }
    setChecked(w) {
      this.getWritable().__checked = w;
    }
    toggleChecked() {
      this.setChecked(!this.__checked);
    }
    getIndent() {
      var w = this.getParent();
      if (w === null)
        return this.getLatest().__indent;
      w = w.getParentOrThrow();
      let j = 0;
      for (; B(w); )
        w = w.getParentOrThrow().getParentOrThrow(), j++;
      return j;
    }
    setIndent(w) {
      typeof w == "number" && -1 < w || r(117);
      let j = this.getIndent();
      for (; j !== w; )
        if (j < w) {
          e: {
            var ne = /* @__PURE__ */ new Set();
            if (C(this) || ne.has(this.getKey()))
              break e;
            let b = this.getParent();
            var Y = this.getNextSibling(), W = this.getPreviousSibling();
            if (C(Y) && C(W)) {
              if (W = W.getFirstChild(), q(W)) {
                W.append(this);
                var Q = Y.getFirstChild();
                q(Q) && (Q = Q.getChildren(), x(W, Q), Y.remove(), ne.add(Y.getKey())), H(W);
              }
            } else
              C(Y) ? (Y = Y.getFirstChild(), q(Y) && (ne = Y.getFirstChild(), ne !== null && ne.insertBefore(this), H(Y))) : C(W) ? (Y = W.getFirstChild(), q(Y) && (Y.append(this), H(Y))) : q(b) && (ne = K(), Q = G(b.getListType()), ne.append(Q), Q.append(this), W ? W.insertAfter(ne) : Y ? Y.insertBefore(ne) : b.append(ne), H(Q));
            q(b) && H(b);
          }
          j++;
        } else
          N(this), j--;
      return this;
    }
    insertBefore(w) {
      if (B(w)) {
        let j = this.getParentOrThrow();
        if (q(j)) {
          let ne = this.getNextSiblings();
          H(j, ne);
        }
      }
      return super.insertBefore(w);
    }
    canInsertAfter(w) {
      return B(w);
    }
    canReplaceWith(w) {
      return B(w);
    }
    canMergeWith(w) {
      return e.$isParagraphNode(w) || B(w);
    }
    extractWithChild(w, j) {
      if (!e.$isRangeSelection(j))
        return !1;
      w = j.anchor.getNode();
      let ne = j.focus.getNode();
      return this.isParentOf(w) && this.isParentOf(ne) && this.getTextContent().length === j.getTextContent().length;
    }
    isParentRequired() {
      return !0;
    }
    createParentElementNode() {
      return G("bullet");
    }
  }
  function F(P, w, j) {
    let ne = [], Y = [];
    var W = (w = w.list) ? w.listitem : void 0;
    if (w && w.nested)
      var Q = w.nested.listitem;
    if (W !== void 0 && (W = W.split(" "), ne.push(...W)), w) {
      W = j.getParent(), W = q(W) && W.getListType() === "check";
      let b = j.getChecked();
      W && !b || Y.push(w.listitemUnchecked), W && b || Y.push(w.listitemChecked), W && ne.push(b ? w.listitemChecked : w.listitemUnchecked);
    }
    Q !== void 0 && (Q = Q.split(" "), j.getChildren().some((b) => q(b)) ? ne.push(...Q) : Y.push(...Q)), 0 < Y.length && t.removeClassNamesFromElement(P, ...Y), 0 < ne.length && t.addClassNamesToElement(
      P,
      ...ne
    );
  }
  function U(P, w, j) {
    q(w.getFirstChild()) ? (P.removeAttribute("role"), P.removeAttribute("tabIndex"), P.removeAttribute("aria-checked")) : (P.setAttribute("role", "checkbox"), P.setAttribute("tabIndex", "-1"), j && w.__checked === j.__checked || P.setAttribute("aria-checked", w.getChecked() ? "true" : "false"));
  }
  function I(P) {
    return P = t.isHTMLElement(P) && P.getAttribute("aria-checked") === "true", { node: K(P) };
  }
  function K(P) {
    return e.$applyNodeReplacement(new v(void 0, P));
  }
  function B(P) {
    return P instanceof v;
  }
  class z extends e.ElementNode {
    static getType() {
      return "list";
    }
    static clone(w) {
      return new z(w.__listType || V[w.__tag], w.__start, w.__key);
    }
    constructor(w, j, ne) {
      super(ne), this.__listType = w = V[w] || w, this.__tag = w === "number" ? "ol" : "ul", this.__start = j;
    }
    getTag() {
      return this.__tag;
    }
    setListType(w) {
      let j = this.getWritable();
      j.__listType = w, j.__tag = w === "number" ? "ol" : "ul";
    }
    getListType() {
      return this.__listType;
    }
    getStart() {
      return this.__start;
    }
    createDOM(w) {
      let j = document.createElement(this.__tag);
      return this.__start !== 1 && j.setAttribute(
        "start",
        String(this.__start)
      ), j.__lexicalListType = this.__listType, te(j, w.theme, this), j;
    }
    updateDOM(w, j, ne) {
      return w.__tag !== this.__tag ? !0 : (te(j, ne.theme, this), !1);
    }
    static importDOM() {
      return { ol: () => ({ conversion: de, priority: 0 }), ul: () => ({ conversion: de, priority: 0 }) };
    }
    static importJSON(w) {
      let j = G(w.listType, w.start);
      return j.setFormat(w.format), j.setIndent(w.indent), j.setDirection(w.direction), j;
    }
    exportDOM(w) {
      return { element: w } = super.exportDOM(w), w && t.isHTMLElement(w) && (this.__start !== 1 && w.setAttribute("start", String(this.__start)), this.__listType === "check" && w.setAttribute("__lexicalListType", "check")), { element: w };
    }
    exportJSON() {
      return { ...super.exportJSON(), listType: this.getListType(), start: this.getStart(), tag: this.getTag(), type: "list", version: 1 };
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
    append(...w) {
      for (let ne = 0; ne < w.length; ne++) {
        var j = w[ne];
        if (B(j))
          super.append(j);
        else {
          let Y = K();
          q(j) || e.$isElementNode(j) && (j = e.$createTextNode(j.getTextContent())), Y.append(j), super.append(Y);
        }
      }
      return H(this), this;
    }
    extractWithChild(w) {
      return B(w);
    }
  }
  function te(P, w, j) {
    let ne = [], Y = [];
    var W = w.list;
    if (W !== void 0) {
      let b = W[`${j.__tag}Depth`] || [];
      w = o(j) - 1;
      let g = w % b.length;
      var Q = b[g];
      let _ = W[j.__tag], A;
      if (W = W.nested, W !== void 0 && W.list && (A = W.list), _ !== void 0 && ne.push(_), Q !== void 0)
        for (Q = Q.split(" "), ne.push(...Q), Q = 0; Q < b.length; Q++)
          Q !== g && Y.push(j.__tag + Q);
      A !== void 0 && (j = A.split(" "), 1 < w ? ne.push(...j) : Y.push(...j));
    }
    0 < Y.length && t.removeClassNamesFromElement(P, ...Y), 0 < ne.length && t.addClassNamesToElement(P, ...ne);
  }
  function re(P) {
    let w = [];
    for (let ne = 0; ne < P.length; ne++) {
      var j = P[ne];
      B(j) ? (w.push(j), j = j.getChildren(), 1 < j.length && j.forEach((Y) => {
        q(Y) && w.push(O(Y));
      })) : w.push(O(j));
    }
    return w;
  }
  function de(P) {
    let w = P.nodeName.toLowerCase(), j = null;
    return w === "ol" ? j = G("number", P.start) : w === "ul" && (j = t.isHTMLElement(P) && P.getAttribute("__lexicallisttype") === "check" ? G("check") : G("bullet")), { after: re, node: j };
  }
  let V = { ol: "number", ul: "bullet" };
  function G(P, w = 1) {
    return e.$applyNodeReplacement(new z(P, w));
  }
  function q(P) {
    return P instanceof z;
  }
  let me = e.createCommand("INSERT_UNORDERED_LIST_COMMAND"), pe = e.createCommand("INSERT_ORDERED_LIST_COMMAND"), Z = e.createCommand("INSERT_CHECK_LIST_COMMAND"), ee = e.createCommand("REMOVE_LIST_COMMAND");
  return qn.$createListItemNode = K, qn.$createListNode = G, qn.$getListDepth = o, qn.$handleListInsertParagraph = function() {
    var P = e.$getSelection();
    if (!e.$isRangeSelection(P) || !P.isCollapsed() || (P = P.anchor.getNode(), !B(P) || P.getChildrenSize() !== 0))
      return !1;
    var w = f(P), j = P.getParent();
    q(j) || r(40);
    let ne = j.getParent(), Y;
    if (e.$isRootOrShadowRoot(ne))
      Y = e.$createParagraphNode(), w.insertAfter(Y);
    else if (B(ne))
      Y = K(), ne.insertAfter(Y);
    else
      return !1;
    if (Y.select(), w = P.getNextSiblings(), 0 < w.length) {
      let W = G(j.getListType());
      e.$isParagraphNode(Y) ? Y.insertAfter(W) : (j = K(), j.append(W), Y.insertAfter(j)), w.forEach((Q) => {
        Q.remove(), W.append(Q);
      });
    }
    return T(P), !0;
  }, qn.$isListItemNode = B, qn.$isListNode = q, qn.INSERT_CHECK_LIST_COMMAND = Z, qn.INSERT_ORDERED_LIST_COMMAND = pe, qn.INSERT_UNORDERED_LIST_COMMAND = me, qn.ListItemNode = v, qn.ListNode = z, qn.REMOVE_LIST_COMMAND = ee, qn.insertList = function(P, w) {
    P.update(() => {
      var j = e.$getSelection();
      if (e.$INTERNAL_isPointSelection(j)) {
        var ne = j.getNodes();
        j = j.anchor.getNode();
        var Y = j.getParent();
        if (S(j, ne))
          ne = G(w), e.$isRootOrShadowRoot(Y) ? (j.replace(ne), Y = K(), e.$isElementNode(j) && (Y.setFormat(j.getFormatType()), Y.setIndent(j.getIndent())), ne.append(Y)) : B(j) && (j = j.getParentOrThrow(), x(ne, j.getChildren()), j.replace(ne));
        else
          for (j = /* @__PURE__ */ new Set(), Y = 0; Y < ne.length; Y++) {
            var W = ne[Y];
            if (e.$isElementNode(W) && W.isEmpty() && !B(W) && !j.has(W.getKey()))
              D(
                W,
                w
              );
            else if (e.$isLeafNode(W))
              for (W = W.getParent(); W != null; ) {
                let b = W.getKey();
                if (q(W)) {
                  if (!j.has(b)) {
                    var Q = G(w);
                    x(Q, W.getChildren()), W.replace(Q), H(Q), j.add(b);
                  }
                  break;
                } else {
                  if (Q = W.getParent(), e.$isRootOrShadowRoot(Q) && !j.has(b)) {
                    j.add(b), D(W, w);
                    break;
                  }
                  W = Q;
                }
              }
          }
      }
    });
  }, qn.removeList = function(P) {
    P.update(() => {
      let w = e.$getSelection();
      if (e.$isRangeSelection(w)) {
        var j = /* @__PURE__ */ new Set(), ne = w.getNodes(), Y = w.anchor.getNode();
        if (S(Y, ne))
          j.add(f(Y));
        else
          for (Y = 0; Y < ne.length; Y++) {
            var W = ne[Y];
            e.$isLeafNode(W) && (W = t.$getNearestNodeOfType(W, v), W != null && j.add(f(W)));
          }
        for (let Q of j) {
          j = Q, ne = h(Q);
          for (let b of ne)
            ne = e.$createParagraphNode(), x(ne, b.getChildren()), j.insertAfter(ne), j = ne, b.__key === w.anchor.key && w.anchor.set(ne.getKey(), 0, "element"), b.__key === w.focus.key && w.focus.set(ne.getKey(), 0, "element"), b.remove();
          Q.remove();
        }
      }
    });
  }, qn;
}
var Vn = {}, Nd;
function v_() {
  if (Nd)
    return Vn;
  Nd = 1;
  var e = kt(), t = Jt();
  function r(Y) {
    let W = 1, Q = Y.getParent();
    for (; Q != null; ) {
      if (de(Q)) {
        const b = Q.getParent();
        if (ee(b)) {
          W++, Q = b.getParent();
          continue;
        }
        throw Error("A ListItemNode must have a ListNode for a parent.");
      }
      return W;
    }
    return W;
  }
  function o(Y) {
    let W = Y.getParent();
    if (!ee(W))
      throw Error("A ListItemNode must have a ListNode for a parent.");
    let Q = W;
    for (; Q !== null; )
      Q = Q.getParent(), ee(Q) && (W = Q);
    return W;
  }
  function f(Y) {
    let W = [];
    const Q = Y.getChildren().filter(de);
    for (let b = 0; b < Q.length; b++) {
      const g = Q[b], _ = g.getFirstChild();
      ee(_) ? W = W.concat(f(_)) : W.push(g);
    }
    return W;
  }
  function h(Y) {
    return de(Y) && ee(Y.getFirstChild());
  }
  function C(Y) {
    let W = Y;
    for (; W.getNextSibling() == null && W.getPreviousSibling() == null; ) {
      const Q = W.getParent();
      if (Q == null || !(de(W) || ee(W)))
        break;
      W = Q;
    }
    W.remove();
  }
  function T(Y) {
    return re().append(Y);
  }
  function O(Y, W) {
    return de(Y) && (W.length === 0 || W.length === 1 && Y.is(W[0]) && Y.getChildrenSize() === 0);
  }
  function S(Y) {
    const W = Y.getParent();
    let Q = 1;
    if (W != null)
      if (ee(W))
        Q = W.getStart();
      else
        throw Error("$getListItemValue: list node is not parent of list item node");
    const b = Y.getPreviousSiblings();
    for (let g = 0; g < b.length; g++) {
      const _ = b[g];
      de(_) && !ee(_.getFirstChild()) && Q++;
    }
    return Q;
  }
  function x(Y, W) {
    Y.update(() => {
      const Q = e.$getSelection();
      if (e.$INTERNAL_isPointSelection(Q)) {
        const b = Q.getNodes(), _ = Q.anchor.getNode(), A = _.getParent();
        if (O(_, b)) {
          const J = Z(W);
          if (e.$isRootOrShadowRoot(A)) {
            _.replace(J);
            const ce = re();
            e.$isElementNode(_) && (ce.setFormat(_.getFormatType()), ce.setIndent(_.getIndent())), J.append(ce);
          } else if (de(_)) {
            const ce = _.getParentOrThrow();
            D(J, ce.getChildren()), ce.replace(J);
          }
          return;
        } else {
          const J = /* @__PURE__ */ new Set();
          for (let ce = 0; ce < b.length; ce++) {
            const ge = b[ce];
            if (e.$isElementNode(ge) && ge.isEmpty() && !de(ge) && !J.has(ge.getKey())) {
              k(ge, W);
              continue;
            }
            if (e.$isLeafNode(ge)) {
              let ae = ge.getParent();
              for (; ae != null; ) {
                const Te = ae.getKey();
                if (ee(ae)) {
                  if (!J.has(Te)) {
                    const Me = Z(W);
                    D(Me, ae.getChildren()), ae.replace(Me), v(Me), J.add(Te);
                  }
                  break;
                } else {
                  const Me = ae.getParent();
                  if (e.$isRootOrShadowRoot(Me) && !J.has(Te)) {
                    J.add(Te), k(ae, W);
                    break;
                  }
                  ae = Me;
                }
              }
            }
          }
        }
      }
    });
  }
  function D(Y, W) {
    Y.splice(Y.getChildrenSize(), 0, W);
  }
  function k(Y, W) {
    if (ee(Y))
      return Y;
    const Q = Y.getPreviousSibling(), b = Y.getNextSibling(), g = re();
    if (g.setFormat(Y.getFormatType()), g.setIndent(Y.getIndent()), D(g, Y.getChildren()), ee(Q) && W === Q.getListType())
      return Q.append(g), Y.remove(), ee(b) && W === b.getListType() && (D(Q, b.getChildren()), b.remove()), Q;
    if (ee(b) && W === b.getListType())
      return b.getFirstChildOrThrow().insertBefore(g), Y.remove(), b;
    {
      const _ = Z(W);
      return _.append(g), Y.replace(_), v(_), _;
    }
  }
  function H(Y, W) {
    const Q = Y.getLastChild(), b = W.getFirstChild();
    Q && b && h(Q) && h(b) && (H(Q.getFirstChild(), b.getFirstChild()), b.remove());
    const g = W.getChildren();
    g.length > 0 && (Y.append(...g), v(Y)), W.remove();
  }
  function N(Y) {
    Y.update(() => {
      const W = e.$getSelection();
      if (e.$isRangeSelection(W)) {
        const Q = /* @__PURE__ */ new Set(), b = W.getNodes(), g = W.anchor.getNode();
        if (O(g, b))
          Q.add(o(g));
        else
          for (let _ = 0; _ < b.length; _++) {
            const A = b[_];
            if (e.$isLeafNode(A)) {
              const J = t.$getNearestNodeOfType(A, K);
              J != null && Q.add(o(J));
            }
          }
        for (const _ of Q) {
          let A = _;
          const J = f(_);
          for (const ce of J) {
            const ge = e.$createParagraphNode();
            D(ge, ce.getChildren()), A.insertAfter(ge), A = ge, ce.__key === W.anchor.key && W.anchor.set(ge.getKey(), 0, "element"), ce.__key === W.focus.key && W.focus.set(ge.getKey(), 0, "element"), ce.remove();
          }
          _.remove();
        }
      }
    });
  }
  function v(Y, W) {
    const Q = W || Y.getChildren();
    if (Q !== void 0)
      for (let b = 0; b < Q.length; b++) {
        const g = Q[b];
        if (de(g)) {
          const _ = g.getValue(), A = S(g);
          _ !== A && g.setValue(A);
        }
      }
  }
  function F(Y) {
    const W = /* @__PURE__ */ new Set();
    if (h(Y) || W.has(Y.getKey()))
      return;
    const Q = Y.getParent(), b = Y.getNextSibling(), g = Y.getPreviousSibling();
    if (h(b) && h(g)) {
      const _ = g.getFirstChild();
      if (ee(_)) {
        _.append(Y);
        const A = b.getFirstChild();
        if (ee(A)) {
          const J = A.getChildren();
          D(_, J), b.remove(), W.add(b.getKey());
        }
        v(_);
      }
    } else if (h(b)) {
      const _ = b.getFirstChild();
      if (ee(_)) {
        const A = _.getFirstChild();
        A !== null && A.insertBefore(Y), v(_);
      }
    } else if (h(g)) {
      const _ = g.getFirstChild();
      ee(_) && (_.append(Y), v(_));
    } else if (ee(Q)) {
      const _ = re(), A = Z(Q.getListType());
      _.append(A), A.append(Y), g ? g.insertAfter(_) : b ? b.insertBefore(_) : Q.append(_), v(A);
    }
    ee(Q) && v(Q);
  }
  function U(Y) {
    if (h(Y))
      return;
    const W = Y.getParent(), Q = W ? W.getParent() : void 0, b = Q ? Q.getParent() : void 0;
    if (ee(b) && de(Q) && ee(W)) {
      const g = W ? W.getFirstChild() : void 0, _ = W ? W.getLastChild() : void 0;
      if (Y.is(g))
        Q.insertBefore(Y), W.isEmpty() && Q.remove();
      else if (Y.is(_))
        Q.insertAfter(Y), W.isEmpty() && Q.remove();
      else {
        const A = W.getListType(), J = re(), ce = Z(A);
        J.append(ce), Y.getPreviousSiblings().forEach((Te) => ce.append(Te));
        const ge = re(), ae = Z(A);
        ge.append(ae), D(ae, Y.getNextSiblings()), Q.insertBefore(J), Q.insertAfter(ge), Q.replace(Y);
      }
      v(W), v(b);
    }
  }
  function I() {
    const Y = e.$getSelection();
    if (!e.$isRangeSelection(Y) || !Y.isCollapsed())
      return !1;
    const W = Y.anchor.getNode();
    if (!de(W) || W.getChildrenSize() !== 0)
      return !1;
    const Q = o(W), b = W.getParent();
    if (!ee(b))
      throw Error("A ListItemNode must have a ListNode for a parent.");
    const g = b.getParent();
    let _;
    if (e.$isRootOrShadowRoot(g))
      _ = e.$createParagraphNode(), Q.insertAfter(_);
    else if (de(g))
      _ = re(), g.insertAfter(_);
    else
      return !1;
    _.select();
    const A = W.getNextSiblings();
    if (A.length > 0) {
      const J = Z(b.getListType());
      if (e.$isParagraphNode(_))
        _.insertAfter(J);
      else {
        const ce = re();
        ce.append(J), _.insertAfter(ce);
      }
      A.forEach((ce) => {
        ce.remove(), J.append(ce);
      });
    }
    return C(W), !0;
  }
  class K extends e.ElementNode {
    /** @internal */
    /** @internal */
    static getType() {
      return "listitem";
    }
    static clone(W) {
      return new K(W.__value, W.__checked, W.__key);
    }
    constructor(W, Q, b) {
      super(b), this.__value = W === void 0 ? 1 : W, this.__checked = Q;
    }
    createDOM(W) {
      const Q = document.createElement("li"), b = this.getParent();
      return ee(b) && b.getListType() === "check" && z(Q, this, null), Q.value = this.__value, B(Q, W.theme, this), Q;
    }
    updateDOM(W, Q, b) {
      const g = this.getParent();
      return ee(g) && g.getListType() === "check" && z(Q, this, W), Q.value = this.__value, B(Q, b.theme, this), !1;
    }
    static transform() {
      return (W) => {
        const Q = W.getParent();
        ee(Q) && (v(Q), Q.getListType() !== "check" && W.getChecked() != null && W.setChecked(void 0));
      };
    }
    static importDOM() {
      return {
        li: (W) => ({
          conversion: te,
          priority: 0
        })
      };
    }
    static importJSON(W) {
      const Q = re();
      return Q.setChecked(W.checked), Q.setValue(W.value), Q.setFormat(W.format), Q.setDirection(W.direction), Q;
    }
    exportDOM(W) {
      const Q = this.createDOM(W._config);
      return Q.style.textAlign = this.getFormatType(), {
        element: Q
      };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        checked: this.getChecked(),
        type: "listitem",
        value: this.getValue(),
        version: 1
      };
    }
    append(...W) {
      for (let Q = 0; Q < W.length; Q++) {
        const b = W[Q];
        if (e.$isElementNode(b) && this.canMergeWith(b)) {
          const g = b.getChildren();
          this.append(...g), b.remove();
        } else
          super.append(b);
      }
      return this;
    }
    replace(W, Q) {
      if (de(W))
        return super.replace(W);
      this.setIndent(0);
      const b = this.getParentOrThrow();
      if (!ee(b))
        return W;
      if (b.__first === this.getKey())
        b.insertBefore(W);
      else if (b.__last === this.getKey())
        b.insertAfter(W);
      else {
        const g = Z(b.getListType());
        let _ = this.getNextSibling();
        for (; _; ) {
          const A = _;
          _ = _.getNextSibling(), g.append(A);
        }
        b.insertAfter(W), W.insertAfter(g);
      }
      return Q && this.getChildren().forEach((g) => {
        W.append(g);
      }), this.remove(), b.getChildrenSize() === 0 && b.remove(), W;
    }
    insertAfter(W, Q = !0) {
      const b = this.getParentOrThrow();
      if (!ee(b))
        throw Error("insertAfter: list node is not parent of list item node");
      const g = this.getNextSiblings();
      if (de(W)) {
        const _ = super.insertAfter(W, Q), A = W.getParentOrThrow();
        return ee(A) && v(A), _;
      }
      if (ee(W)) {
        let _ = W;
        const A = W.getChildren();
        for (let J = A.length - 1; J >= 0; J--)
          _ = A[J], this.insertAfter(_, Q);
        return _;
      }
      if (b.insertAfter(W, Q), g.length !== 0) {
        const _ = Z(b.getListType());
        g.forEach((A) => _.append(A)), W.insertAfter(_, Q);
      }
      return W;
    }
    remove(W) {
      const Q = this.getPreviousSibling(), b = this.getNextSibling();
      if (super.remove(W), Q && b && h(Q) && h(b))
        H(Q.getFirstChild(), b.getFirstChild()), b.remove();
      else if (b) {
        const g = b.getParent();
        ee(g) && v(g);
      }
    }
    insertNewAfter(W, Q = !0) {
      const b = re(this.__checked == null ? void 0 : !1);
      return this.insertAfter(b, Q), b;
    }
    collapseAtStart(W) {
      const Q = e.$createParagraphNode();
      this.getChildren().forEach((J) => Q.append(J));
      const g = this.getParentOrThrow(), _ = g.getParentOrThrow(), A = de(_);
      if (g.getChildrenSize() === 1)
        if (A)
          g.remove(), _.select();
        else {
          g.insertBefore(Q), g.remove();
          const J = W.anchor, ce = W.focus, ge = Q.getKey();
          J.type === "element" && J.getNode().is(this) && J.set(ge, J.offset, "element"), ce.type === "element" && ce.getNode().is(this) && ce.set(ge, ce.offset, "element");
        }
      else
        g.insertBefore(Q), this.remove();
      return !0;
    }
    getValue() {
      return this.getLatest().__value;
    }
    setValue(W) {
      const Q = this.getWritable();
      Q.__value = W;
    }
    getChecked() {
      return this.getLatest().__checked;
    }
    setChecked(W) {
      const Q = this.getWritable();
      Q.__checked = W;
    }
    toggleChecked() {
      this.setChecked(!this.__checked);
    }
    getIndent() {
      const W = this.getParent();
      if (W === null)
        return this.getLatest().__indent;
      let Q = W.getParentOrThrow(), b = 0;
      for (; de(Q); )
        Q = Q.getParentOrThrow().getParentOrThrow(), b++;
      return b;
    }
    setIndent(W) {
      if (!(typeof W == "number" && W > -1))
        throw Error("Invalid indent value.");
      let Q = this.getIndent();
      for (; Q !== W; )
        Q < W ? (F(this), Q++) : (U(this), Q--);
      return this;
    }
    insertBefore(W) {
      if (de(W)) {
        const Q = this.getParentOrThrow();
        if (ee(Q)) {
          const b = this.getNextSiblings();
          v(Q, b);
        }
      }
      return super.insertBefore(W);
    }
    canInsertAfter(W) {
      return de(W);
    }
    canReplaceWith(W) {
      return de(W);
    }
    canMergeWith(W) {
      return e.$isParagraphNode(W) || de(W);
    }
    extractWithChild(W, Q) {
      if (!e.$isRangeSelection(Q))
        return !1;
      const b = Q.anchor.getNode(), g = Q.focus.getNode();
      return this.isParentOf(b) && this.isParentOf(g) && this.getTextContent().length === Q.getTextContent().length;
    }
    isParentRequired() {
      return !0;
    }
    createParentElementNode() {
      return Z("bullet");
    }
  }
  function B(Y, W, Q) {
    const b = [], g = [], _ = W.list, A = _ ? _.listitem : void 0;
    let J;
    if (_ && _.nested && (J = _.nested.listitem), A !== void 0) {
      const ce = A.split(" ");
      b.push(...ce);
    }
    if (_) {
      const ce = Q.getParent(), ge = ee(ce) && ce.getListType() === "check", ae = Q.getChecked();
      (!ge || ae) && g.push(_.listitemUnchecked), (!ge || !ae) && g.push(_.listitemChecked), ge && b.push(ae ? _.listitemChecked : _.listitemUnchecked);
    }
    if (J !== void 0) {
      const ce = J.split(" ");
      Q.getChildren().some((ge) => ee(ge)) ? b.push(...ce) : g.push(...ce);
    }
    g.length > 0 && t.removeClassNamesFromElement(Y, ...g), b.length > 0 && t.addClassNamesToElement(Y, ...b);
  }
  function z(Y, W, Q, b) {
    ee(W.getFirstChild()) ? (Y.removeAttribute("role"), Y.removeAttribute("tabIndex"), Y.removeAttribute("aria-checked")) : (Y.setAttribute("role", "checkbox"), Y.setAttribute("tabIndex", "-1"), (!Q || W.__checked !== Q.__checked) && Y.setAttribute("aria-checked", W.getChecked() ? "true" : "false"));
  }
  function te(Y) {
    const W = t.isHTMLElement(Y) && Y.getAttribute("aria-checked") === "true";
    return {
      node: re(W)
    };
  }
  function re(Y) {
    return e.$applyNodeReplacement(new K(void 0, Y));
  }
  function de(Y) {
    return Y instanceof K;
  }
  class V extends e.ElementNode {
    /** @internal */
    /** @internal */
    /** @internal */
    static getType() {
      return "list";
    }
    static clone(W) {
      const Q = W.__listType || pe[W.__tag];
      return new V(Q, W.__start, W.__key);
    }
    constructor(W, Q, b) {
      super(b);
      const g = pe[W] || W;
      this.__listType = g, this.__tag = g === "number" ? "ol" : "ul", this.__start = Q;
    }
    getTag() {
      return this.__tag;
    }
    setListType(W) {
      const Q = this.getWritable();
      Q.__listType = W, Q.__tag = W === "number" ? "ol" : "ul";
    }
    getListType() {
      return this.__listType;
    }
    getStart() {
      return this.__start;
    }
    // View
    createDOM(W, Q) {
      const b = this.__tag, g = document.createElement(b);
      return this.__start !== 1 && g.setAttribute("start", String(this.__start)), g.__lexicalListType = this.__listType, G(g, W.theme, this), g;
    }
    updateDOM(W, Q, b) {
      return W.__tag !== this.__tag ? !0 : (G(Q, b.theme, this), !1);
    }
    static importDOM() {
      return {
        ol: (W) => ({
          conversion: me,
          priority: 0
        }),
        ul: (W) => ({
          conversion: me,
          priority: 0
        })
      };
    }
    static importJSON(W) {
      const Q = Z(W.listType, W.start);
      return Q.setFormat(W.format), Q.setIndent(W.indent), Q.setDirection(W.direction), Q;
    }
    exportDOM(W) {
      const {
        element: Q
      } = super.exportDOM(W);
      return Q && t.isHTMLElement(Q) && (this.__start !== 1 && Q.setAttribute("start", String(this.__start)), this.__listType === "check" && Q.setAttribute("__lexicalListType", "check")), {
        element: Q
      };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        listType: this.getListType(),
        start: this.getStart(),
        tag: this.getTag(),
        type: "list",
        version: 1
      };
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
    append(...W) {
      for (let Q = 0; Q < W.length; Q++) {
        const b = W[Q];
        if (de(b))
          super.append(b);
        else {
          const g = re();
          if (ee(b))
            g.append(b);
          else if (e.$isElementNode(b)) {
            const _ = e.$createTextNode(b.getTextContent());
            g.append(_);
          } else
            g.append(b);
          super.append(g);
        }
      }
      return v(this), this;
    }
    extractWithChild(W) {
      return de(W);
    }
  }
  function G(Y, W, Q) {
    const b = [], g = [], _ = W.list;
    if (_ !== void 0) {
      const A = _[`${Q.__tag}Depth`] || [], J = r(Q) - 1, ce = J % A.length, ge = A[ce], ae = _[Q.__tag];
      let Te;
      const Me = _.nested;
      if (Me !== void 0 && Me.list && (Te = Me.list), ae !== void 0 && b.push(ae), ge !== void 0) {
        const ze = ge.split(" ");
        b.push(...ze);
        for (let oe = 0; oe < A.length; oe++)
          oe !== ce && g.push(Q.__tag + oe);
      }
      if (Te !== void 0) {
        const ze = Te.split(" ");
        J > 1 ? b.push(...ze) : g.push(...ze);
      }
    }
    g.length > 0 && t.removeClassNamesFromElement(Y, ...g), b.length > 0 && t.addClassNamesToElement(Y, ...b);
  }
  function q(Y) {
    const W = [];
    for (let Q = 0; Q < Y.length; Q++) {
      const b = Y[Q];
      if (de(b)) {
        W.push(b);
        const g = b.getChildren();
        g.length > 1 && g.forEach((_) => {
          ee(_) && W.push(T(_));
        });
      } else
        W.push(T(b));
    }
    return W;
  }
  function me(Y) {
    const W = Y.nodeName.toLowerCase();
    let Q = null;
    if (W === "ol") {
      const b = Y.start;
      Q = Z("number", b);
    } else
      W === "ul" && (t.isHTMLElement(Y) && Y.getAttribute("__lexicallisttype") === "check" ? Q = Z("check") : Q = Z("bullet"));
    return {
      after: q,
      node: Q
    };
  }
  const pe = {
    ol: "number",
    ul: "bullet"
  };
  function Z(Y, W = 1) {
    return e.$applyNodeReplacement(new V(Y, W));
  }
  function ee(Y) {
    return Y instanceof V;
  }
  const P = e.createCommand("INSERT_UNORDERED_LIST_COMMAND"), w = e.createCommand("INSERT_ORDERED_LIST_COMMAND"), j = e.createCommand("INSERT_CHECK_LIST_COMMAND"), ne = e.createCommand("REMOVE_LIST_COMMAND");
  return Vn.$createListItemNode = re, Vn.$createListNode = Z, Vn.$getListDepth = r, Vn.$handleListInsertParagraph = I, Vn.$isListItemNode = de, Vn.$isListNode = ee, Vn.INSERT_CHECK_LIST_COMMAND = j, Vn.INSERT_ORDERED_LIST_COMMAND = w, Vn.INSERT_UNORDERED_LIST_COMMAND = P, Vn.ListItemNode = K, Vn.ListNode = V, Vn.REMOVE_LIST_COMMAND = ne, Vn.insertList = x, Vn.removeList = N, Vn;
}
var ic, Ed;
function Fc() {
  return Ed || (Ed = 1, ic = process.env.NODE_ENV === "development" ? v_() : x_()), ic;
}
var Td;
function S_() {
  if (Td)
    return rc;
  Td = 1;
  var e = Fc(), t = kn(), r = rn, o = Jt(), f = kt();
  function h(C) {
    r.useEffect(() => o.mergeRegister(C.registerCommand(e.INSERT_ORDERED_LIST_COMMAND, () => (e.insertList(C, "number"), !0), f.COMMAND_PRIORITY_LOW), C.registerCommand(e.INSERT_UNORDERED_LIST_COMMAND, () => (e.insertList(C, "bullet"), !0), f.COMMAND_PRIORITY_LOW), C.registerCommand(e.REMOVE_LIST_COMMAND, () => (e.removeList(C), !0), f.COMMAND_PRIORITY_LOW), C.registerCommand(f.INSERT_PARAGRAPH_COMMAND, () => !!e.$handleListInsertParagraph(), f.COMMAND_PRIORITY_LOW)), [C]);
  }
  return rc.ListPlugin = function() {
    let [C] = t.useLexicalComposerContext();
    return r.useEffect(() => {
      if (!C.hasNodes([e.ListNode, e.ListItemNode]))
        throw Error("ListPlugin: ListNode and/or ListItemNode not registered on editor");
    }, [C]), h(C), null;
  }, rc;
}
var oc = {}, xd;
function w_() {
  if (xd)
    return oc;
  xd = 1;
  var e = Fc(), t = kn(), r = rn, o = Jt(), f = kt();
  function h(T) {
    r.useEffect(() => o.mergeRegister(T.registerCommand(e.INSERT_ORDERED_LIST_COMMAND, () => (e.insertList(T, "number"), !0), f.COMMAND_PRIORITY_LOW), T.registerCommand(e.INSERT_UNORDERED_LIST_COMMAND, () => (e.insertList(T, "bullet"), !0), f.COMMAND_PRIORITY_LOW), T.registerCommand(e.REMOVE_LIST_COMMAND, () => (e.removeList(T), !0), f.COMMAND_PRIORITY_LOW), T.registerCommand(f.INSERT_PARAGRAPH_COMMAND, () => !!e.$handleListInsertParagraph(), f.COMMAND_PRIORITY_LOW)), [T]);
  }
  function C() {
    const [T] = t.useLexicalComposerContext();
    return r.useEffect(() => {
      if (!T.hasNodes([e.ListNode, e.ListItemNode]))
        throw new Error("ListPlugin: ListNode and/or ListItemNode not registered on editor");
    }, [T]), h(T), null;
  }
  return oc.ListPlugin = C, oc;
}
const O_ = process.env.NODE_ENV === "development" ? w_() : S_();
var R_ = O_, sc = {}, mi = {}, vd;
function D_() {
  if (vd)
    return mi;
  vd = 1;
  var e = Jt(), t = kt();
  let r = /* @__PURE__ */ new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
  class o extends t.ElementNode {
    static getType() {
      return "link";
    }
    static clone(k) {
      return new o(k.__url, { rel: k.__rel, target: k.__target, title: k.__title }, k.__key);
    }
    constructor(k, H = {}, N) {
      super(N);
      let { target: v = null, rel: F = null, title: U = null } = H;
      this.__url = k, this.__target = v, this.__rel = F, this.__title = U;
    }
    createDOM(k) {
      let H = document.createElement("a");
      return H.href = this.sanitizeUrl(this.__url), this.__target !== null && (H.target = this.__target), this.__rel !== null && (H.rel = this.__rel), this.__title !== null && (H.title = this.__title), e.addClassNamesToElement(
        H,
        k.theme.link
      ), H;
    }
    updateDOM(k, H) {
      let N = this.__url, v = this.__target, F = this.__rel, U = this.__title;
      return N !== k.__url && (H.href = N), v !== k.__target && (v ? H.target = v : H.removeAttribute("target")), F !== k.__rel && (F ? H.rel = F : H.removeAttribute("rel")), U !== k.__title && (U ? H.title = U : H.removeAttribute("title")), !1;
    }
    static importDOM() {
      return { a: () => ({ conversion: f, priority: 1 }) };
    }
    static importJSON(k) {
      let H = h(k.url, { rel: k.rel, target: k.target, title: k.title });
      return H.setFormat(k.format), H.setIndent(k.indent), H.setDirection(k.direction), H;
    }
    sanitizeUrl(k) {
      try {
        let H = new URL(k);
        if (!r.has(H.protocol))
          return "about:blank";
      } catch {
      }
      return k;
    }
    exportJSON() {
      return { ...super.exportJSON(), rel: this.getRel(), target: this.getTarget(), title: this.getTitle(), type: "link", url: this.getURL(), version: 1 };
    }
    getURL() {
      return this.getLatest().__url;
    }
    setURL(k) {
      this.getWritable().__url = k;
    }
    getTarget() {
      return this.getLatest().__target;
    }
    setTarget(k) {
      this.getWritable().__target = k;
    }
    getRel() {
      return this.getLatest().__rel;
    }
    setRel(k) {
      this.getWritable().__rel = k;
    }
    getTitle() {
      return this.getLatest().__title;
    }
    setTitle(k) {
      this.getWritable().__title = k;
    }
    insertNewAfter(k, H = !0) {
      return k = h(this.__url, { rel: this.__rel, target: this.__target, title: this.__title }), this.insertAfter(k, H), k;
    }
    canInsertTextBefore() {
      return !1;
    }
    canInsertTextAfter() {
      return !1;
    }
    canBeEmpty() {
      return !1;
    }
    isInline() {
      return !0;
    }
    extractWithChild(k, H) {
      if (!t.$isRangeSelection(H))
        return !1;
      k = H.anchor.getNode();
      let N = H.focus.getNode();
      return this.isParentOf(k) && this.isParentOf(N) && 0 < H.getTextContent().length;
    }
  }
  function f(D) {
    let k = null;
    if (e.isHTMLAnchorElement(D)) {
      let H = D.textContent;
      (H !== null && H !== "" || 0 < D.children.length) && (k = h(D.getAttribute("href") || "", { rel: D.getAttribute("rel"), target: D.getAttribute("target"), title: D.getAttribute("title") }));
    }
    return { node: k };
  }
  function h(D, k) {
    return t.$applyNodeReplacement(new o(D, k));
  }
  function C(D) {
    return D instanceof o;
  }
  class T extends o {
    static getType() {
      return "autolink";
    }
    static clone(k) {
      return new T(k.__url, { rel: k.__rel, target: k.__target, title: k.__title }, k.__key);
    }
    static importJSON(k) {
      let H = O(k.url, { rel: k.rel, target: k.target, title: k.title });
      return H.setFormat(k.format), H.setIndent(k.indent), H.setDirection(k.direction), H;
    }
    static importDOM() {
      return null;
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "autolink", version: 1 };
    }
    insertNewAfter(k, H = !0) {
      return k = this.getParentOrThrow().insertNewAfter(k, H), t.$isElementNode(k) ? (H = O(this.__url, { rel: this.__rel, target: this.__target, title: this.__title }), k.append(H), H) : null;
    }
  }
  function O(D, k) {
    return t.$applyNodeReplacement(new T(D, k));
  }
  let S = t.createCommand("TOGGLE_LINK_COMMAND");
  function x(D, k) {
    for (; D !== null && D.getParent() !== null && !k(D); )
      D = D.getParentOrThrow();
    return k(D) ? D : null;
  }
  return mi.$createAutoLinkNode = O, mi.$createLinkNode = h, mi.$isAutoLinkNode = function(D) {
    return D instanceof T;
  }, mi.$isLinkNode = C, mi.AutoLinkNode = T, mi.LinkNode = o, mi.TOGGLE_LINK_COMMAND = S, mi.toggleLink = function(D, k = {}) {
    let { target: H, title: N } = k, v = k.rel === void 0 ? "noreferrer" : k.rel;
    if (k = t.$getSelection(), t.$isRangeSelection(k))
      if (k = k.extract(), D === null)
        k.forEach((F) => {
          if (F = F.getParent(), C(F)) {
            let U = F.getChildren();
            for (let I = 0; I < U.length; I++)
              F.insertBefore(U[I]);
            F.remove();
          }
        });
      else {
        if (k.length === 1) {
          let I = x(k[0], C);
          if (I !== null) {
            I.setURL(D), H !== void 0 && I.setTarget(H), v !== null && I.setRel(v), N !== void 0 && I.setTitle(N);
            return;
          }
        }
        let F = null, U = null;
        k.forEach((I) => {
          var K = I.getParent();
          if (K !== U && K !== null && (!t.$isElementNode(I) || I.isInline()))
            if (C(K))
              U = K, K.setURL(D), H !== void 0 && K.setTarget(H), v !== null && U.setRel(v), N !== void 0 && U.setTitle(N);
            else if (K.is(F) || (F = K, U = h(D, { rel: v, target: H, title: N }), C(K) ? I.getPreviousSibling() === null ? K.insertBefore(U) : K.insertAfter(U) : I.insertBefore(U)), C(I)) {
              if (!I.is(U)) {
                if (U !== null) {
                  K = I.getChildren();
                  for (let B = 0; B < K.length; B++)
                    U.append(K[B]);
                }
                I.remove();
              }
            } else
              U !== null && U.append(I);
        });
      }
  }, mi;
}
var yi = {}, Sd;
function A_() {
  if (Sd)
    return yi;
  Sd = 1;
  var e = Jt(), t = kt();
  const r = /* @__PURE__ */ new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
  class o extends t.ElementNode {
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    static getType() {
      return "link";
    }
    static clone(N) {
      return new o(N.__url, {
        rel: N.__rel,
        target: N.__target,
        title: N.__title
      }, N.__key);
    }
    constructor(N, v = {}, F) {
      super(F);
      const {
        target: U = null,
        rel: I = null,
        title: K = null
      } = v;
      this.__url = N, this.__target = U, this.__rel = I, this.__title = K;
    }
    createDOM(N) {
      const v = document.createElement("a");
      return v.href = this.sanitizeUrl(this.__url), this.__target !== null && (v.target = this.__target), this.__rel !== null && (v.rel = this.__rel), this.__title !== null && (v.title = this.__title), e.addClassNamesToElement(v, N.theme.link), v;
    }
    updateDOM(N, v, F) {
      const U = this.__url, I = this.__target, K = this.__rel, B = this.__title;
      return U !== N.__url && (v.href = U), I !== N.__target && (I ? v.target = I : v.removeAttribute("target")), K !== N.__rel && (K ? v.rel = K : v.removeAttribute("rel")), B !== N.__title && (B ? v.title = B : v.removeAttribute("title")), !1;
    }
    static importDOM() {
      return {
        a: (N) => ({
          conversion: f,
          priority: 1
        })
      };
    }
    static importJSON(N) {
      const v = h(N.url, {
        rel: N.rel,
        target: N.target,
        title: N.title
      });
      return v.setFormat(N.format), v.setIndent(N.indent), v.setDirection(N.direction), v;
    }
    sanitizeUrl(N) {
      try {
        const v = new URL(N);
        if (!r.has(v.protocol))
          return "about:blank";
      } catch {
        return N;
      }
      return N;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        rel: this.getRel(),
        target: this.getTarget(),
        title: this.getTitle(),
        type: "link",
        url: this.getURL(),
        version: 1
      };
    }
    getURL() {
      return this.getLatest().__url;
    }
    setURL(N) {
      const v = this.getWritable();
      v.__url = N;
    }
    getTarget() {
      return this.getLatest().__target;
    }
    setTarget(N) {
      const v = this.getWritable();
      v.__target = N;
    }
    getRel() {
      return this.getLatest().__rel;
    }
    setRel(N) {
      const v = this.getWritable();
      v.__rel = N;
    }
    getTitle() {
      return this.getLatest().__title;
    }
    setTitle(N) {
      const v = this.getWritable();
      v.__title = N;
    }
    insertNewAfter(N, v = !0) {
      const F = h(this.__url, {
        rel: this.__rel,
        target: this.__target,
        title: this.__title
      });
      return this.insertAfter(F, v), F;
    }
    canInsertTextBefore() {
      return !1;
    }
    canInsertTextAfter() {
      return !1;
    }
    canBeEmpty() {
      return !1;
    }
    isInline() {
      return !0;
    }
    extractWithChild(N, v, F) {
      if (!t.$isRangeSelection(v))
        return !1;
      const U = v.anchor.getNode(), I = v.focus.getNode();
      return this.isParentOf(U) && this.isParentOf(I) && v.getTextContent().length > 0;
    }
  }
  function f(H) {
    let N = null;
    if (e.isHTMLAnchorElement(H)) {
      const v = H.textContent;
      (v !== null && v !== "" || H.children.length > 0) && (N = h(H.getAttribute("href") || "", {
        rel: H.getAttribute("rel"),
        target: H.getAttribute("target"),
        title: H.getAttribute("title")
      }));
    }
    return {
      node: N
    };
  }
  function h(H, N) {
    return t.$applyNodeReplacement(new o(H, N));
  }
  function C(H) {
    return H instanceof o;
  }
  class T extends o {
    static getType() {
      return "autolink";
    }
    static clone(N) {
      return new T(N.__url, {
        rel: N.__rel,
        target: N.__target,
        title: N.__title
      }, N.__key);
    }
    static importJSON(N) {
      const v = O(N.url, {
        rel: N.rel,
        target: N.target,
        title: N.title
      });
      return v.setFormat(N.format), v.setIndent(N.indent), v.setDirection(N.direction), v;
    }
    static importDOM() {
      return null;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "autolink",
        version: 1
      };
    }
    insertNewAfter(N, v = !0) {
      const F = this.getParentOrThrow().insertNewAfter(N, v);
      if (t.$isElementNode(F)) {
        const U = O(this.__url, {
          rel: this.__rel,
          target: this.__target,
          title: this.__title
        });
        return F.append(U), U;
      }
      return null;
    }
  }
  function O(H, N) {
    return t.$applyNodeReplacement(new T(H, N));
  }
  function S(H) {
    return H instanceof T;
  }
  const x = t.createCommand("TOGGLE_LINK_COMMAND");
  function D(H, N = {}) {
    const {
      target: v,
      title: F
    } = N, U = N.rel === void 0 ? "noreferrer" : N.rel, I = t.$getSelection();
    if (!t.$isRangeSelection(I))
      return;
    const K = I.extract();
    if (H === null)
      K.forEach((B) => {
        const z = B.getParent();
        if (C(z)) {
          const te = z.getChildren();
          for (let re = 0; re < te.length; re++)
            z.insertBefore(te[re]);
          z.remove();
        }
      });
    else {
      if (K.length === 1) {
        const te = K[0], re = k(te, C);
        if (re !== null) {
          re.setURL(H), v !== void 0 && re.setTarget(v), U !== null && re.setRel(U), F !== void 0 && re.setTitle(F);
          return;
        }
      }
      let B = null, z = null;
      K.forEach((te) => {
        const re = te.getParent();
        if (!(re === z || re === null || t.$isElementNode(te) && !te.isInline())) {
          if (C(re)) {
            z = re, re.setURL(H), v !== void 0 && re.setTarget(v), U !== null && z.setRel(U), F !== void 0 && z.setTitle(F);
            return;
          }
          if (re.is(B) || (B = re, z = h(H, {
            rel: U,
            target: v,
            title: F
          }), C(re) ? te.getPreviousSibling() === null ? re.insertBefore(z) : re.insertAfter(z) : te.insertBefore(z)), C(te)) {
            if (te.is(z))
              return;
            if (z !== null) {
              const de = te.getChildren();
              for (let V = 0; V < de.length; V++)
                z.append(de[V]);
            }
            te.remove();
            return;
          }
          z !== null && z.append(te);
        }
      });
    }
  }
  function k(H, N) {
    let v = H;
    for (; v !== null && v.getParent() !== null && !N(v); )
      v = v.getParentOrThrow();
    return N(v) ? v : null;
  }
  return yi.$createAutoLinkNode = O, yi.$createLinkNode = h, yi.$isAutoLinkNode = S, yi.$isLinkNode = C, yi.AutoLinkNode = T, yi.LinkNode = o, yi.TOGGLE_LINK_COMMAND = x, yi.toggleLink = D, yi;
}
var lc, wd;
function Bc() {
  return wd || (wd = 1, lc = process.env.NODE_ENV === "development" ? A_() : D_()), lc;
}
var Od;
function b_() {
  if (Od)
    return sc;
  Od = 1;
  var e = Bc(), t = kn(), r = Jt(), o = kt(), f = rn;
  return sc.LinkPlugin = function({ validateUrl: h }) {
    let [C] = t.useLexicalComposerContext();
    return f.useEffect(() => {
      if (!C.hasNodes([e.LinkNode]))
        throw Error("LinkPlugin: LinkNode not registered on editor");
      return r.mergeRegister(C.registerCommand(e.TOGGLE_LINK_COMMAND, (T) => {
        if (T === null)
          return e.toggleLink(T), !0;
        if (typeof T == "string")
          return h === void 0 || h(T) ? (e.toggleLink(T), !0) : !1;
        let { url: O, target: S, rel: x, title: D } = T;
        return e.toggleLink(O, { rel: x, target: S, title: D }), !0;
      }, o.COMMAND_PRIORITY_LOW), h !== void 0 ? C.registerCommand(
        o.PASTE_COMMAND,
        (T) => {
          let O = o.$getSelection();
          if (!o.$isRangeSelection(O) || O.isCollapsed() || !(T instanceof ClipboardEvent) || T.clipboardData == null)
            return !1;
          let S = T.clipboardData.getData("text");
          return h(S) ? O.getNodes().some((x) => o.$isElementNode(x)) ? !1 : (C.dispatchCommand(e.TOGGLE_LINK_COMMAND, S), T.preventDefault(), !0) : !1;
        },
        o.COMMAND_PRIORITY_LOW
      ) : () => {
      });
    }, [C, h]), null;
  }, sc;
}
var ac = {}, Rd;
function M_() {
  if (Rd)
    return ac;
  Rd = 1;
  var e = Bc(), t = kn(), r = Jt(), o = kt(), f = rn;
  function h({
    validateUrl: C
  }) {
    const [T] = t.useLexicalComposerContext();
    return f.useEffect(() => {
      if (!T.hasNodes([e.LinkNode]))
        throw new Error("LinkPlugin: LinkNode not registered on editor");
      return r.mergeRegister(T.registerCommand(e.TOGGLE_LINK_COMMAND, (O) => {
        if (O === null)
          return e.toggleLink(O), !0;
        if (typeof O == "string")
          return C === void 0 || C(O) ? (e.toggleLink(O), !0) : !1;
        {
          const {
            url: S,
            target: x,
            rel: D,
            title: k
          } = O;
          return e.toggleLink(S, {
            rel: D,
            target: x,
            title: k
          }), !0;
        }
      }, o.COMMAND_PRIORITY_LOW), C !== void 0 ? T.registerCommand(o.PASTE_COMMAND, (O) => {
        const S = o.$getSelection();
        if (!o.$isRangeSelection(S) || S.isCollapsed() || !(O instanceof ClipboardEvent) || O.clipboardData == null)
          return !1;
        const x = O.clipboardData.getData("text");
        return C(x) ? S.getNodes().some((D) => o.$isElementNode(D)) ? !1 : (T.dispatchCommand(e.TOGGLE_LINK_COMMAND, x), O.preventDefault(), !0) : !1;
      }, o.COMMAND_PRIORITY_LOW) : () => {
      });
    }, [T, C]), null;
  }
  return ac.LinkPlugin = h, ac;
}
const L_ = process.env.NODE_ENV === "development" ? M_() : b_();
var P_ = L_, cc = {}, Ht = {}, Dd;
function I_() {
  if (Dd)
    return Ht;
  Dd = 1;
  var e = kt(), t = Jt();
  let r = /^(\d+(?:\.\d+)?)px$/, o = { BOTH: 3, COLUMN: 2, NO_STATUS: 0, ROW: 1 };
  class f extends e.DEPRECATED_GridCellNode {
    static getType() {
      return "tablecell";
    }
    static clone(_) {
      let A = new f(_.__headerState, _.__colSpan, _.__width, _.__key);
      return A.__rowSpan = _.__rowSpan, A.__backgroundColor = _.__backgroundColor, A;
    }
    static importDOM() {
      return { td: () => ({ conversion: h, priority: 0 }), th: () => ({ conversion: h, priority: 0 }) };
    }
    static importJSON(_) {
      let A = _.rowSpan || 1, J = C(_.headerState, _.colSpan || 1, _.width || void 0);
      return J.__rowSpan = A, J.__backgroundColor = _.backgroundColor || null, J;
    }
    constructor(_ = o.NO_STATUS, A = 1, J, ce) {
      super(A, ce), this.__headerState = _, this.__width = J, this.__backgroundColor = null;
    }
    createDOM(_) {
      let A = document.createElement(this.getTag());
      return this.__width && (A.style.width = `${this.__width}px`), 1 < this.__colSpan && (A.colSpan = this.__colSpan), 1 < this.__rowSpan && (A.rowSpan = this.__rowSpan), this.__backgroundColor !== null && (A.style.backgroundColor = this.__backgroundColor), t.addClassNamesToElement(A, _.theme.tableCell, this.hasHeader() && _.theme.tableCellHeader), A;
    }
    exportDOM(_) {
      if ({ element: _ } = super.exportDOM(_), _) {
        var A = this.getParentOrThrow().getChildrenSize();
        _.style.border = "1px solid black", 1 < this.__colSpan && (_.colSpan = this.__colSpan), 1 < this.__rowSpan && (_.rowSpan = this.__rowSpan), _.style.width = `${this.getWidth() || Math.max(90, 700 / A)}px`, _.style.verticalAlign = "top", _.style.textAlign = "start", A = this.getBackgroundColor(), A !== null ? _.style.backgroundColor = A : this.hasHeader() && (_.style.backgroundColor = "#f2f3f5");
      }
      return { element: _ };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        backgroundColor: this.getBackgroundColor(),
        headerState: this.__headerState,
        type: "tablecell",
        width: this.getWidth()
      };
    }
    getTag() {
      return this.hasHeader() ? "th" : "td";
    }
    setHeaderStyles(_) {
      return this.getWritable().__headerState = _, this.__headerState;
    }
    getHeaderStyles() {
      return this.getLatest().__headerState;
    }
    setWidth(_) {
      return this.getWritable().__width = _, this.__width;
    }
    getWidth() {
      return this.getLatest().__width;
    }
    getBackgroundColor() {
      return this.getLatest().__backgroundColor;
    }
    setBackgroundColor(_) {
      this.getWritable().__backgroundColor = _;
    }
    toggleHeaderStyle(_) {
      let A = this.getWritable();
      return A.__headerState = (A.__headerState & _) === _ ? A.__headerState - _ : A.__headerState + _, A;
    }
    hasHeaderState(_) {
      return (this.getHeaderStyles() & _) === _;
    }
    hasHeader() {
      return this.getLatest().__headerState !== o.NO_STATUS;
    }
    updateDOM(_) {
      return _.__headerState !== this.__headerState || _.__width !== this.__width || _.__colSpan !== this.__colSpan || _.__rowSpan !== this.__rowSpan || _.__backgroundColor !== this.__backgroundColor;
    }
    isShadowRoot() {
      return !0;
    }
    collapseAtStart() {
      return !0;
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
  }
  function h(g) {
    var _ = g.nodeName.toLowerCase();
    let A;
    return r.test(g.style.width) && (A = parseFloat(g.style.width)), _ = C(_ === "th" ? o.ROW : o.NO_STATUS, g.colSpan, A), _.__rowSpan = g.rowSpan, g = g.style.backgroundColor, g !== "" && (_.__backgroundColor = g), { forChild: (J, ce) => T(ce) && !e.$isElementNode(J) ? (ce = e.$createParagraphNode(), e.$isLineBreakNode(J) && J.getTextContent() === `
` ? null : (ce.append(J), ce)) : J, node: _ };
  }
  function C(g, _ = 1, A) {
    return e.$applyNodeReplacement(new f(g, _, A));
  }
  function T(g) {
    return g instanceof f;
  }
  class O extends e.DEPRECATED_GridRowNode {
    static getType() {
      return "tablerow";
    }
    static clone(_) {
      return new O(_.__height, _.__key);
    }
    static importDOM() {
      return { tr: () => ({ conversion: S, priority: 0 }) };
    }
    static importJSON(_) {
      return x(_.height);
    }
    constructor(_, A) {
      super(A), this.__height = _;
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "tablerow", version: 1 };
    }
    createDOM(_) {
      let A = document.createElement("tr");
      return this.__height && (A.style.height = `${this.__height}px`), t.addClassNamesToElement(A, _.theme.tableRow), A;
    }
    isShadowRoot() {
      return !0;
    }
    setHeight(_) {
      return this.getWritable().__height = _, this.__height;
    }
    getHeight() {
      return this.getLatest().__height;
    }
    updateDOM(_) {
      return _.__height !== this.__height;
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
  }
  function S(g) {
    let _;
    return r.test(g.style.height) && (_ = parseFloat(g.style.height)), { node: x(_) };
  }
  function x(g) {
    return e.$applyNodeReplacement(new O(g));
  }
  function D(g) {
    return g instanceof O;
  }
  function k(g) {
    let _ = new URLSearchParams();
    _.append("code", g);
    for (let A = 1; A < arguments.length; A++)
      _.append("v", arguments[A]);
    throw Error(`Minified Lexical error #${g}; visit https://lexical.dev/docs/error?${_} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  let H = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
  class N {
    constructor(_, A) {
      this.isHighlightingCells = !1, this.focusY = this.focusX = this.anchorY = this.anchorX = -1, this.listenersToRemove = /* @__PURE__ */ new Set(), this.tableNodeKey = A, this.editor = _, this.grid = { cells: [], columns: 0, rows: 0 }, this.focusCell = this.anchorCell = this.focusCellNodeKey = this.anchorCellNodeKey = this.gridSelection = null, this.hasHijackedSelectionStyles = !1, this.trackTableGrid();
    }
    getGrid() {
      return this.grid;
    }
    removeListeners() {
      Array.from(this.listenersToRemove).forEach((_) => _());
    }
    trackTableGrid() {
      let _ = new MutationObserver((A) => {
        this.editor.update(() => {
          var J = !1;
          for (let ce = 0; ce < A.length; ce++) {
            const ge = A[ce].target.nodeName;
            if (ge === "TABLE" || ge === "TR") {
              J = !0;
              break;
            }
          }
          if (J) {
            if (J = this.editor.getElementByKey(this.tableNodeKey), !J)
              throw Error("Expected to find TableElement in DOM");
            this.grid = F(J);
          }
        });
      });
      this.editor.update(() => {
        let A = this.editor.getElementByKey(this.tableNodeKey);
        if (!A)
          throw Error("Expected to find TableElement in DOM");
        this.grid = F(A), _.observe(A, { childList: !0, subtree: !0 });
      });
    }
    clearHighlight() {
      let _ = this.editor;
      this.isHighlightingCells = !1, this.focusY = this.focusX = this.anchorY = this.anchorX = -1, this.focusCell = this.anchorCell = this.focusCellNodeKey = this.anchorCellNodeKey = this.gridSelection = null, this.hasHijackedSelectionStyles = !1, this.enableHighlightStyle(), _.update(() => {
        var A = e.$getNodeByKey(this.tableNodeKey);
        if (!w(A))
          throw Error("Expected TableNode.");
        if (A = _.getElementByKey(this.tableNodeKey), !A)
          throw Error("Expected to find TableElement in DOM");
        A = F(A), U(_, A, null), e.$setSelection(null), _.dispatchCommand(
          e.SELECTION_CHANGE_COMMAND,
          void 0
        );
      });
    }
    enableHighlightStyle() {
      let _ = this.editor;
      _.update(() => {
        let A = _.getElementByKey(this.tableNodeKey);
        if (!A)
          throw Error("Expected to find TableElement in DOM");
        t.removeClassNamesFromElement(A, _._config.theme.tableSelection), A.classList.remove("disable-selection"), this.hasHijackedSelectionStyles = !1;
      });
    }
    disableHighlightStyle() {
      let _ = this.editor;
      _.update(() => {
        let A = _.getElementByKey(this.tableNodeKey);
        if (!A)
          throw Error("Expected to find TableElement in DOM");
        t.addClassNamesToElement(A, _._config.theme.tableSelection), this.hasHijackedSelectionStyles = !0;
      });
    }
    updateTableGridSelection(_) {
      if (_ != null && _.gridKey === this.tableNodeKey) {
        let A = this.editor;
        this.gridSelection = _, this.isHighlightingCells = !0, this.disableHighlightStyle(), U(A, this.grid, this.gridSelection);
      } else
        _ == null ? this.clearHighlight() : (this.tableNodeKey = _.gridKey, this.updateTableGridSelection(_));
    }
    setFocusCellForSelection(_, A = !1) {
      let J = this.editor;
      J.update(() => {
        var ce = e.$getNodeByKey(this.tableNodeKey);
        if (!w(ce))
          throw Error("Expected TableNode.");
        if (!J.getElementByKey(this.tableNodeKey))
          throw Error("Expected to find TableElement in DOM");
        ce = _.x;
        let ge = _.y;
        if (this.focusCell = _, this.anchorCell !== null) {
          let ae = H ? (J._window || window).getSelection() : null;
          ae && ae.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);
        }
        if (!this.isHighlightingCells && (this.anchorX !== ce || this.anchorY !== ge || A))
          this.isHighlightingCells = !0, this.disableHighlightStyle();
        else if (ce === this.focusX && ge === this.focusY)
          return;
        this.focusX = ce, this.focusY = ge, this.isHighlightingCells && (ce = e.$getNearestNodeFromDOMNode(_.elem), this.gridSelection != null && this.anchorCellNodeKey != null && T(ce) && (ce = ce.getKey(), this.gridSelection = this.gridSelection.clone() || e.DEPRECATED_$createGridSelection(), this.focusCellNodeKey = ce, this.gridSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey), e.$setSelection(this.gridSelection), J.dispatchCommand(e.SELECTION_CHANGE_COMMAND, void 0), U(J, this.grid, this.gridSelection)));
      });
    }
    setAnchorCellForSelection(_) {
      this.isHighlightingCells = !1, this.anchorCell = _, this.anchorX = _.x, this.anchorY = _.y, this.editor.update(() => {
        var A = e.$getNearestNodeFromDOMNode(_.elem);
        T(A) && (A = A.getKey(), this.gridSelection = this.gridSelection != null ? this.gridSelection.clone() : e.DEPRECATED_$createGridSelection(), this.anchorCellNodeKey = A);
      });
    }
    formatCells(_) {
      this.editor.update(() => {
        let A = e.$getSelection();
        e.DEPRECATED_$isGridSelection(A) || k(11);
        let J = e.$createRangeSelection(), ce = J.anchor, ge = J.focus;
        A.getNodes().forEach((ae) => {
          T(ae) && ae.getTextContentSize() !== 0 && (ce.set(ae.getKey(), 0, "element"), ge.set(ae.getKey(), ae.getChildrenSize(), "element"), J.formatText(_));
        }), e.$setSelection(A), this.editor.dispatchCommand(
          e.SELECTION_CHANGE_COMMAND,
          void 0
        );
      });
    }
    clearText() {
      let _ = this.editor;
      _.update(() => {
        let A = e.$getNodeByKey(this.tableNodeKey);
        if (!w(A))
          throw Error("Expected TableNode.");
        var J = e.$getSelection();
        e.DEPRECATED_$isGridSelection(J) || k(11), J = J.getNodes().filter(T), J.length === this.grid.columns * this.grid.rows ? (A.selectPrevious(), A.remove(), e.$getRoot().selectStart()) : (J.forEach((ce) => {
          if (e.$isElementNode(ce)) {
            let ge = e.$createParagraphNode(), ae = e.$createTextNode();
            ge.append(ae), ce.append(ge), ce.getChildren().forEach((Te) => {
              Te !== ge && Te.remove();
            });
          }
        }), U(
          _,
          this.grid,
          null
        ), e.$setSelection(null), _.dispatchCommand(e.SELECTION_CHANGE_COMMAND, void 0));
      });
    }
  }
  function v(g) {
    for (; g != null; ) {
      let _ = g.nodeName;
      if (_ === "TD" || _ === "TH") {
        if (g = g._cell, g === void 0)
          break;
        return g;
      }
      g = g.parentNode;
    }
    return null;
  }
  function F(g) {
    let _ = [], A = { cells: _, columns: 0, rows: 0 };
    var J = g.firstChild;
    let ce = g = 0;
    for (_.length = 0; J != null; ) {
      var ge = J.nodeName;
      if (ge === "TD" || ge === "TH") {
        ge = J, ge = { elem: ge, hasBackgroundColor: ge.style.backgroundColor !== "", highlighted: !1, x: g, y: ce }, J._cell = ge;
        let ae = _[ce];
        ae === void 0 && (ae = _[ce] = []), ae[g] = ge;
      } else if (ge = J.firstChild, ge != null) {
        J = ge;
        continue;
      }
      if (ge = J.nextSibling, ge != null)
        g++, J = ge;
      else if (ge = J.parentNode, ge != null) {
        if (J = ge.nextSibling, J == null)
          break;
        ce++, g = 0;
      }
    }
    return A.columns = g + 1, A.rows = ce + 1, A;
  }
  function U(g, _, A) {
    let J = new Set(A ? A.getNodes() : []);
    I(_, (ce, ge) => {
      let ae = ce.elem;
      J.has(ge) ? (ce.highlighted = !0, de(g, ce)) : (ce.highlighted = !1, V(g, ce), ae.getAttribute("style") || ae.removeAttribute("style"));
    });
  }
  function I(g, _) {
    ({ cells: g } = g);
    for (let A = 0; A < g.length; A++) {
      let J = g[A];
      if (J)
        for (let ce = 0; ce < J.length; ce++) {
          let ge = J[ce];
          if (!ge)
            continue;
          let ae = e.$getNearestNodeFromDOMNode(ge.elem);
          ae !== null && _(ge, ae, { x: ce, y: A });
        }
    }
  }
  function K(g, _) {
    _.disableHighlightStyle(), I(_.grid, (A) => {
      A.highlighted = !0, de(g, A);
    });
  }
  function B(g, _) {
    _.enableHighlightStyle(), I(_.grid, (A) => {
      let J = A.elem;
      A.highlighted = !1, V(g, A), J.getAttribute("style") || J.removeAttribute("style");
    });
  }
  let z = (g, _, A, J, ce) => {
    const ge = ce === "forward";
    switch (ce) {
      case "backward":
      case "forward":
        return A !== (ge ? g.grid.columns - 1 : 0) ? (g = _.getCellNodeFromCordsOrThrow(A + (ge ? 1 : -1), J, g.grid), ge ? g.selectStart() : g.selectEnd()) : J !== (ge ? g.grid.rows - 1 : 0) ? (g = _.getCellNodeFromCordsOrThrow(ge ? 0 : g.grid.columns - 1, J + (ge ? 1 : -1), g.grid), ge ? g.selectStart() : g.selectEnd()) : ge ? _.selectNext() : _.selectPrevious(), !0;
      case "up":
        return J !== 0 ? _.getCellNodeFromCordsOrThrow(A, J - 1, g.grid).selectEnd() : _.selectPrevious(), !0;
      case "down":
        return J !== g.grid.rows - 1 ? _.getCellNodeFromCordsOrThrow(A, J + 1, g.grid).selectStart() : _.selectNext(), !0;
      default:
        return !1;
    }
  }, te = (g, _, A, J, ce) => {
    const ge = ce === "forward";
    switch (ce) {
      case "backward":
      case "forward":
        return A !== (ge ? g.grid.columns - 1 : 0) && g.setFocusCellForSelection(_.getCellFromCordsOrThrow(A + (ge ? 1 : -1), J, g.grid)), !0;
      case "up":
        return J !== 0 ? (g.setFocusCellForSelection(_.getCellFromCordsOrThrow(A, J - 1, g.grid)), !0) : !1;
      case "down":
        return J !== g.grid.rows - 1 ? (g.setFocusCellForSelection(_.getCellFromCordsOrThrow(A, J + 1, g.grid)), !0) : !1;
      default:
        return !1;
    }
  };
  function re(g, _) {
    if (e.$isRangeSelection(g) || e.DEPRECATED_$isGridSelection(g)) {
      let A = _.isParentOf(g.anchor.getNode());
      return g = _.isParentOf(g.focus.getNode()), A && g;
    }
    return !1;
  }
  function de(g, _) {
    g = _.elem, _ = e.$getNearestNodeFromDOMNode(g), T(_) || k(131), _.getBackgroundColor() === null ? g.style.setProperty("background-color", "rgb(172,206,247)") : g.style.setProperty("background-image", "linear-gradient(to right, rgba(172,206,247,0.85), rgba(172,206,247,0.85))"), g.style.setProperty("caret-color", "transparent");
  }
  function V(g, _) {
    g = _.elem, _ = e.$getNearestNodeFromDOMNode(g), T(_) || k(131), _.getBackgroundColor() === null && g.style.removeProperty("background-color"), g.style.removeProperty("background-image"), g.style.removeProperty("caret-color");
  }
  function G(g) {
    return g = t.$findMatchingParent(g, T), T(g) ? g : null;
  }
  function q(g) {
    return g = t.$findMatchingParent(g, w), w(g) ? g : null;
  }
  function me(g, _, A, J, ce) {
    let ge = e.$getSelection();
    if (!re(ge, J))
      return !1;
    if (e.$isRangeSelection(ge) && ge.isCollapsed()) {
      if (A === "backward" || A === "forward")
        return !1;
      let { anchor: ze, focus: oe } = ge;
      var ae = t.$findMatchingParent(ze.getNode(), T), Te = t.$findMatchingParent(oe.getNode(), T);
      if (!T(ae) || !ae.is(Te))
        return !1;
      if (Te = q(ae), Te !== J && Te != null) {
        var Me = g.getElementByKey(Te.getKey());
        if (Me != null)
          return ce.grid = F(Me), me(g, _, A, Te, ce);
      }
      if (Te = g.getElementByKey(ae.__key), Me = g.getElementByKey(ze.key), Me == null || Te == null)
        return !1;
      if (ze.type === "element")
        Te = Me.getBoundingClientRect();
      else {
        if (Te = window.getSelection(), Te === null || Te.rangeCount === 0)
          return !1;
        Te = Te.getRangeAt(0).getBoundingClientRect();
      }
      if (Me = A === "up" ? ae.getFirstChild() : ae.getLastChild(), Me == null || (g = g.getElementByKey(Me.__key), g == null))
        return !1;
      if (g = g.getBoundingClientRect(), A === "up" ? g.top > Te.top - Te.height : Te.bottom + Te.height > g.bottom) {
        if (pe(_), g = J.getCordsFromCellNode(ae, ce.grid), _.shiftKey)
          A = J.getCellFromCordsOrThrow(g.x, g.y, ce.grid), ce.setAnchorCellForSelection(A), ce.setFocusCellForSelection(A, !0);
        else
          return z(ce, J, g.x, g.y, A);
        return !0;
      }
    } else if (e.DEPRECATED_$isGridSelection(ge)) {
      let { anchor: ze, focus: oe } = ge;
      return Me = t.$findMatchingParent(ze.getNode(), T), Te = t.$findMatchingParent(oe.getNode(), T), [ae] = ge.getNodes(), g = g.getElementByKey(ae.getKey()), !T(Me) || !T(Te) || !w(ae) || g == null ? !1 : (ce.updateTableGridSelection(ge), g = F(g), Me = J.getCordsFromCellNode(Me, g), Me = J.getCellFromCordsOrThrow(Me.x, Me.y, g), ce.setAnchorCellForSelection(Me), pe(_), _.shiftKey ? (_ = J.getCordsFromCellNode(Te, g), te(ce, ae, _.x, _.y, A)) : (Te.selectEnd(), !0));
    }
    return !1;
  }
  function pe(g) {
    g.preventDefault(), g.stopImmediatePropagation(), g.stopPropagation();
  }
  class Z extends e.DEPRECATED_GridNode {
    static getType() {
      return "table";
    }
    static clone(_) {
      return new Z(_.__key);
    }
    static importDOM() {
      return { table: () => ({ conversion: ee, priority: 1 }) };
    }
    static importJSON() {
      return P();
    }
    constructor(_) {
      super(_);
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "table", version: 1 };
    }
    createDOM(_) {
      let A = document.createElement("table");
      return t.addClassNamesToElement(A, _.theme.table), A;
    }
    updateDOM() {
      return !1;
    }
    exportDOM(_) {
      return { ...super.exportDOM(_), after: (A) => {
        if (A) {
          let J = A.cloneNode(), ce = document.createElement("colgroup"), ge = document.createElement("tbody");
          if (t.isHTMLElement(A) && ge.append(...A.children), A = this.getFirstChildOrThrow(), !D(A))
            throw Error("Expected to find row node.");
          A = A.getChildrenSize();
          for (let ae = 0; ae < A; ae++) {
            let Te = document.createElement("col");
            ce.append(Te);
          }
          return J.replaceChildren(ce, ge), J;
        }
      } };
    }
    canExtractContents() {
      return !1;
    }
    canBeEmpty() {
      return !1;
    }
    isShadowRoot() {
      return !0;
    }
    getCordsFromCellNode(_, A) {
      let { rows: J, cells: ce } = A;
      for (A = 0; A < J; A++) {
        var ge = ce[A];
        if (ge != null && (ge = ge.findIndex((ae) => {
          if (ae)
            return { elem: ae } = ae, e.$getNearestNodeFromDOMNode(ae) === _;
        }), ge !== -1))
          return { x: ge, y: A };
      }
      throw Error("Cell not found in table.");
    }
    getCellFromCords(_, A, J) {
      return { cells: J } = J, A = J[A], A == null ? null : (_ = A[_], _ ?? null);
    }
    getCellFromCordsOrThrow(_, A, J) {
      if (_ = this.getCellFromCords(_, A, J), !_)
        throw Error("Cell not found at cords.");
      return _;
    }
    getCellNodeFromCords(_, A, J) {
      return _ = this.getCellFromCords(_, A, J), _ == null ? null : (_ = e.$getNearestNodeFromDOMNode(_.elem), T(_) ? _ : null);
    }
    getCellNodeFromCordsOrThrow(_, A, J) {
      if (_ = this.getCellNodeFromCords(_, A, J), !_)
        throw Error("Node at cords not TableCellNode.");
      return _;
    }
    canSelectBefore() {
      return !0;
    }
    canIndent() {
      return !1;
    }
  }
  function ee() {
    return { node: P() };
  }
  function P() {
    return e.$applyNodeReplacement(new Z());
  }
  function w(g) {
    return g instanceof Z;
  }
  function j(g) {
    if (g = t.$findMatchingParent(g, (_) => D(_)), D(g))
      return g;
    throw Error("Expected table cell to be inside of table row.");
  }
  function ne(g) {
    if (g = t.$findMatchingParent(g, (_) => w(_)), w(g))
      return g;
    throw Error("Expected table cell to be inside of table.");
  }
  function Y(g, _) {
    let A = ne(g), { x: J, y: ce } = A.getCordsFromCellNode(g, _);
    return { above: A.getCellNodeFromCords(J, ce - 1, _), below: A.getCellNodeFromCords(J, ce + 1, _), left: A.getCellNodeFromCords(J - 1, ce, _), right: A.getCellNodeFromCords(J + 1, ce, _) };
  }
  function W(g) {
    let _ = g.getFirstDescendant();
    _ == null ? g.selectStart() : _.getParentOrThrow().selectStart();
  }
  function Q(g, _) {
    let A = g.getFirstChild();
    A !== null ? A.insertBefore(_) : g.append(_);
  }
  let b = e.createCommand("INSERT_TABLE_COMMAND");
  return Ht.$createTableCellNode = C, Ht.$createTableNode = P, Ht.$createTableNodeWithDimensions = function(g, _, A = !0) {
    let J = P();
    for (let ge = 0; ge < g; ge++) {
      let ae = x();
      for (let Te = 0; Te < _; Te++) {
        var ce = o.NO_STATUS;
        typeof A == "object" ? (ge === 0 && A.rows && (ce |= o.ROW), Te === 0 && A.columns && (ce |= o.COLUMN)) : A && (ge === 0 && (ce |= o.ROW), Te === 0 && (ce |= o.COLUMN)), ce = C(ce);
        let Me = e.$createParagraphNode();
        Me.append(e.$createTextNode()), ce.append(Me), ae.append(ce);
      }
      J.append(ae);
    }
    return J;
  }, Ht.$createTableRowNode = x, Ht.$deleteTableColumn = function(g, _) {
    let A = g.getChildren();
    for (let ce = 0; ce < A.length; ce++) {
      var J = A[ce];
      if (D(J)) {
        if (J = J.getChildren(), _ >= J.length || 0 > _)
          throw Error("Table column target index out of range");
        J[_].remove();
      }
    }
    return g;
  }, Ht.$deleteTableColumn__EXPERIMENTAL = function() {
    var g = e.$getSelection();
    if (!e.$INTERNAL_isPointSelection(g))
      throw Error("Expected a INTERNAL_PointSelection");
    var _ = g.anchor.getNode();
    g = g.focus.getNode();
    let [A, , J] = e.DEPRECATED_$getNodeTriplet(_);
    [_] = e.DEPRECATED_$getNodeTriplet(g);
    let [ce, ge, ae] = e.DEPRECATED_$computeGridMap(J, A, _);
    var { startColumn: Te } = ge;
    let { startRow: Me, startColumn: ze } = ae;
    g = Math.min(Te, ze), Te = Math.max(Te + A.__colSpan - 1, ze + _.__colSpan - 1);
    let oe = Te - g + 1;
    if (ce[0].length === Te - g + 1)
      J.selectPrevious(), J.remove();
    else {
      var ie = ce.length;
      for (let ue = 0; ue < ie; ue++)
        for (let we = g; we <= Te; we++) {
          let { cell: Le, startColumn: Be } = ce[ue][we];
          Be < g ? we === g && Le.setColSpan(Le.__colSpan - Math.min(oe, Le.__colSpan - (g - Be))) : Be + Le.__colSpan - 1 > Te ? we === Te && Le.setColSpan(Le.__colSpan - (Te - Be + 1)) : Le.remove();
        }
      g = ce[Me], _ = g[ze + _.__colSpan], _ !== void 0 ? ({ cell: _ } = _, W(_)) : ({ cell: _ } = g[ze - 1], W(_));
    }
  }, Ht.$deleteTableRow__EXPERIMENTAL = function() {
    var g = e.$getSelection();
    if (!e.$INTERNAL_isPointSelection(g))
      throw Error("Expected a INTERNAL_PointSelection");
    var _ = g.anchor.getNode();
    g = g.focus.getNode();
    let [A, , J] = e.DEPRECATED_$getNodeTriplet(_);
    [g] = e.DEPRECATED_$getNodeTriplet(g);
    let [ce, ge, ae] = e.DEPRECATED_$computeGridMap(J, A, g);
    ({ startRow: _ } = ge);
    var { startRow: Te } = ae;
    if (g = Te + g.__rowSpan - 1, ce.length === g - _ + 1)
      J.remove();
    else {
      Te = ce[0].length;
      var Me = ce[g + 1], ze = J.getChildAtIndex(g + 1);
      for (let ie = g; ie >= _; ie--) {
        for (var oe = Te - 1; 0 <= oe; oe--) {
          let { cell: ue, startRow: we, startColumn: Le } = ce[ie][oe];
          if (Le === oe && (ie === _ && we < _ && ue.setRowSpan(ue.__rowSpan - (we - _)), we >= _ && we + ue.__rowSpan - 1 > g))
            if (ue.setRowSpan(ue.__rowSpan - (g - we + 1)), ze === null && k(122), oe === 0)
              Q(ze, ue);
            else {
              let { cell: Be } = Me[oe - 1];
              Be.insertAfter(ue);
            }
        }
        oe = J.getChildAtIndex(ie), e.DEPRECATED_$isGridRowNode(oe) || k(123, String(ie)), oe.remove();
      }
      Me !== void 0 ? ({ cell: _ } = Me[0], W(_)) : ({ cell: _ } = ce[_ - 1][0], W(_));
    }
  }, Ht.$getElementGridForTableNode = function(g, _) {
    if (g = g.getElementByKey(_.getKey()), g == null)
      throw Error("Table Element Not Found");
    return F(g);
  }, Ht.$getTableCellNodeFromLexicalNode = function(g) {
    return g = t.$findMatchingParent(g, (_) => T(_)), T(g) ? g : null;
  }, Ht.$getTableColumnIndexFromTableCellNode = function(g) {
    return j(g).getChildren().findIndex((_) => _.is(g));
  }, Ht.$getTableNodeFromLexicalNodeOrThrow = ne, Ht.$getTableRowIndexFromTableCellNode = function(g) {
    let _ = j(g);
    return ne(_).getChildren().findIndex((A) => A.is(_));
  }, Ht.$getTableRowNodeFromTableCellNodeOrThrow = j, Ht.$insertTableColumn = function(g, _, A = !0, J, ce) {
    let ge = g.getChildren(), ae = [];
    for (let ze = 0; ze < ge.length; ze++) {
      let oe = ge[ze];
      if (D(oe))
        for (let ie = 0; ie < J; ie++) {
          var Te = oe.getChildren();
          if (_ >= Te.length || 0 > _)
            throw Error("Table column target index out of range");
          Te = Te[_], T(Te) || k(12);
          let { left: ue, right: we } = Y(Te, ce);
          var Me = o.NO_STATUS;
          (ue && ue.hasHeaderState(o.ROW) || we && we.hasHeaderState(o.ROW)) && (Me |= o.ROW), Me = C(Me), Me.append(e.$createParagraphNode()), ae.push({ newTableCell: Me, targetCell: Te });
        }
    }
    return ae.forEach(({ newTableCell: ze, targetCell: oe }) => {
      A ? oe.insertAfter(ze) : oe.insertBefore(ze);
    }), g;
  }, Ht.$insertTableColumn__EXPERIMENTAL = function(g = !0) {
    function _() {
      let ie = C(o.NO_STATUS).append(e.$createParagraphNode());
      return ze === null && (ze = ie), ie;
    }
    var A = e.$getSelection();
    if (!e.$INTERNAL_isPointSelection(A))
      throw Error("Expected a PointSeleciton");
    var J = A.anchor.getNode();
    A = A.focus.getNode(), [J] = e.DEPRECATED_$getNodeTriplet(J);
    let [ce, , ge] = e.DEPRECATED_$getNodeTriplet(A), [ae, Te, Me] = e.DEPRECATED_$computeGridMap(ge, ce, J);
    J = ae.length, A = g ? Math.max(Te.startColumn, Me.startColumn) : Math.min(Te.startColumn, Me.startColumn), g = g ? A + ce.__colSpan - 1 : A - 1, A = ge.getFirstChild(), e.DEPRECATED_$isGridRowNode(A) || k(120);
    let ze = null;
    var oe = A;
    e:
      for (A = 0; A < J; A++) {
        A !== 0 && (oe = oe.getNextSibling(), e.DEPRECATED_$isGridRowNode(oe) || k(121));
        let ie = ae[A];
        if (0 > g) {
          Q(oe, _());
          continue;
        }
        let { cell: ue, startColumn: we, startRow: Le } = ie[g];
        if (we + ue.__colSpan - 1 <= g) {
          let Be = ue, Ye = Le, st = g;
          for (; Ye !== A && 1 < Be.__rowSpan; )
            if (st -= ue.__colSpan, 0 <= st) {
              let { cell: pt, startRow: at } = ie[st];
              Be = pt, Ye = at;
            } else {
              oe.append(_());
              continue e;
            }
          Be.insertAfter(_());
        } else
          ue.setColSpan(ue.__colSpan + 1);
      }
    ze !== null && W(ze);
  }, Ht.$insertTableRow = function(g, _, A = !0, J, ce) {
    var ge = g.getChildren();
    if (_ >= ge.length || 0 > _)
      throw Error("Table row target index out of range");
    if (_ = ge[_], D(_))
      for (ge = 0; ge < J; ge++) {
        let Te = _.getChildren(), Me = Te.length, ze = x();
        for (let oe = 0; oe < Me; oe++) {
          var ae = Te[oe];
          T(ae) || k(12);
          let { above: ie, below: ue } = Y(ae, ce);
          ae = o.NO_STATUS;
          let we = ie && ie.getWidth() || ue && ue.getWidth() || void 0;
          (ie && ie.hasHeaderState(o.COLUMN) || ue && ue.hasHeaderState(o.COLUMN)) && (ae |= o.COLUMN), ae = C(ae, 1, we), ae.append(e.$createParagraphNode()), ze.append(ae);
        }
        A ? _.insertAfter(ze) : _.insertBefore(ze);
      }
    else
      throw Error("Row before insertion index does not exist.");
    return g;
  }, Ht.$insertTableRow__EXPERIMENTAL = function(g = !0) {
    var _ = e.$getSelection();
    if (!e.$INTERNAL_isPointSelection(_))
      throw Error("Expected a INTERNAL_PointSelection");
    _ = _.focus.getNode();
    let [A, , J] = e.DEPRECATED_$getNodeTriplet(_), [ce, ge] = e.DEPRECATED_$computeGridMap(J, A, A);
    _ = ce[0].length;
    var { startRow: ae } = ge;
    if (g) {
      g = ae + A.__rowSpan - 1;
      var Te = ce[g];
      ae = x();
      for (var Me = 0; Me < _; Me++) {
        let { cell: ze, startRow: oe } = Te[Me];
        oe + ze.__rowSpan - 1 <= g ? ae.append(C(o.NO_STATUS)) : ze.setRowSpan(ze.__rowSpan + 1);
      }
      _ = J.getChildAtIndex(g), e.DEPRECATED_$isGridRowNode(_) || k(119), _.insertAfter(ae);
    } else {
      for (Te = ce[ae], g = x(), Me = 0; Me < _; Me++) {
        let { cell: ze, startRow: oe } = Te[Me];
        oe === ae ? g.append(C(o.NO_STATUS)) : ze.setRowSpan(ze.__rowSpan + 1);
      }
      _ = J.getChildAtIndex(ae), e.DEPRECATED_$isGridRowNode(_) || k(119), _.insertBefore(g);
    }
  }, Ht.$isTableCellNode = T, Ht.$isTableNode = w, Ht.$isTableRowNode = D, Ht.$removeTableRowAtIndex = function(g, _) {
    let A = g.getChildren();
    if (_ >= A.length || 0 > _)
      throw Error("Expected table cell to be inside of table row.");
    return A[_].remove(), g;
  }, Ht.$unmergeCell = function() {
    var g = e.$getSelection();
    if (!e.$INTERNAL_isPointSelection(g))
      throw Error("Expected a INTERNAL_PointSelection");
    g = g.anchor.getNode();
    let [_, A, J] = e.DEPRECATED_$getNodeTriplet(g);
    g = _.__colSpan;
    let ce = _.__rowSpan;
    if (1 < g) {
      for (var ge = 1; ge < g; ge++)
        _.insertAfter(C(o.NO_STATUS));
      _.setColSpan(1);
    }
    if (1 < ce) {
      let [Me, ze] = e.DEPRECATED_$computeGridMap(J, _, _), { startColumn: oe, startRow: ie } = ze, ue;
      for (ge = 1; ge < ce; ge++) {
        var ae = ie + ge;
        let we = Me[ae];
        ue = (ue || A).getNextSibling(), e.DEPRECATED_$isGridRowNode(ue) || k(125);
        var Te = null;
        for (let Le = 0; Le < oe; Le++) {
          let Be = we[Le], Ye = Be.cell;
          Be.startRow === ae && (Te = Ye), 1 < Ye.__colSpan && (Le += Ye.__colSpan - 1);
        }
        if (Te === null)
          for (Te = 0; Te < g; Te++)
            Q(ue, C(o.NO_STATUS));
        else
          for (ae = 0; ae < g; ae++)
            Te.insertAfter(C(o.NO_STATUS));
      }
      _.setRowSpan(1);
    }
  }, Ht.INSERT_TABLE_COMMAND = b, Ht.TableCellHeaderStates = o, Ht.TableCellNode = f, Ht.TableNode = Z, Ht.TableRowNode = O, Ht.TableSelection = N, Ht.applyTableHandlers = function(g, _, A, J) {
    function ce(oe) {
      return oe = g.getCordsFromCellNode(oe, ae.grid), g.getCellFromCordsOrThrow(oe.x, oe.y, ae.grid);
    }
    let ge = A.getRootElement();
    if (ge === null)
      throw Error("No root element.");
    let ae = new N(A, g.getKey()), Te = A._window || window;
    _.__lexicalTableSelection = ae, _.addEventListener("mousedown", (oe) => {
      setTimeout(() => {
        if (oe.button === 0 && Te) {
          var ie = v(oe.target);
          ie !== null && (pe(oe), ae.setAnchorCellForSelection(ie));
          var ue = () => {
            Te.removeEventListener("mouseup", ue), Te.removeEventListener(
              "mousemove",
              we
            );
          }, we = (Le) => {
            const Be = v(Le.target);
            Be === null || ae.anchorX === Be.x && ae.anchorY === Be.y || (Le.preventDefault(), ae.setFocusCellForSelection(Be));
          };
          Te.addEventListener("mouseup", ue), Te.addEventListener("mousemove", we);
        }
      }, 0);
    });
    let Me = (oe) => {
      oe.button === 0 && A.update(() => {
        const ie = e.$getSelection(), ue = oe.target;
        e.DEPRECATED_$isGridSelection(ie) && ie.gridKey === ae.tableNodeKey && ge.contains(ue) && ae.clearHighlight();
      });
    };
    Te.addEventListener("mousedown", Me), ae.listenersToRemove.add(() => Te.removeEventListener("mousedown", Me)), ae.listenersToRemove.add(A.registerCommand(
      e.KEY_ARROW_DOWN_COMMAND,
      (oe) => me(A, oe, "down", g, ae),
      e.COMMAND_PRIORITY_HIGH
    )), ae.listenersToRemove.add(A.registerCommand(e.KEY_ARROW_UP_COMMAND, (oe) => me(A, oe, "up", g, ae), e.COMMAND_PRIORITY_HIGH)), ae.listenersToRemove.add(A.registerCommand(e.KEY_ARROW_LEFT_COMMAND, (oe) => me(A, oe, "backward", g, ae), e.COMMAND_PRIORITY_HIGH)), ae.listenersToRemove.add(A.registerCommand(e.KEY_ARROW_RIGHT_COMMAND, (oe) => me(A, oe, "forward", g, ae), e.COMMAND_PRIORITY_HIGH)), ae.listenersToRemove.add(A.registerCommand(e.KEY_ESCAPE_COMMAND, (oe) => {
      var ie = e.$getSelection();
      return e.DEPRECATED_$isGridSelection(ie) && (ie = t.$findMatchingParent(ie.focus.getNode(), T), T(ie)) ? (pe(oe), ie.selectEnd(), !0) : !1;
    }, e.COMMAND_PRIORITY_HIGH));
    let ze = (oe) => () => {
      var ie = e.$getSelection();
      if (!re(ie, g))
        return !1;
      if (e.DEPRECATED_$isGridSelection(ie))
        return ae.clearText(), !0;
      if (e.$isRangeSelection(ie)) {
        const Le = t.$findMatchingParent(ie.anchor.getNode(), (Be) => T(Be));
        if (!T(Le))
          return !1;
        var ue = ie.anchor.getNode(), we = ie.focus.getNode();
        if (ue = g.isParentOf(ue), we = g.isParentOf(we), ue && !we || we && !ue)
          return ae.clearText(), !0;
        if (ue = (we = t.$findMatchingParent(ie.anchor.getNode(), (Be) => e.$isElementNode(Be))) && t.$findMatchingParent(we, (Be) => e.$isElementNode(Be) && T(Be.getParent())), !e.$isElementNode(ue) || !e.$isElementNode(we))
          return !1;
        if (oe === e.DELETE_LINE_COMMAND && ue.getPreviousSibling() === null)
          return !0;
        if ((oe === e.DELETE_CHARACTER_COMMAND || oe === e.DELETE_WORD_COMMAND) && ie.isCollapsed() && ie.anchor.offset === 0 && we !== ue) {
          ie = we.getChildren();
          const Be = e.$createParagraphNode();
          return ie.forEach((Ye) => Be.append(Ye)), we.replace(Be), we.getWritable().__parent = Le.getKey(), !0;
        }
      }
      return !1;
    };
    return [e.DELETE_WORD_COMMAND, e.DELETE_LINE_COMMAND, e.DELETE_CHARACTER_COMMAND].forEach((oe) => {
      ae.listenersToRemove.add(A.registerCommand(oe, ze(oe), e.COMMAND_PRIORITY_CRITICAL));
    }), _ = (oe) => {
      const ie = e.$getSelection();
      return re(ie, g) ? e.DEPRECATED_$isGridSelection(ie) ? (oe.preventDefault(), oe.stopPropagation(), ae.clearText(), !0) : (e.$isRangeSelection(ie) && (oe = t.$findMatchingParent(ie.anchor.getNode(), (ue) => T(ue)), T(oe)), !1) : !1;
    }, ae.listenersToRemove.add(A.registerCommand(e.KEY_BACKSPACE_COMMAND, _, e.COMMAND_PRIORITY_CRITICAL)), ae.listenersToRemove.add(A.registerCommand(e.KEY_DELETE_COMMAND, _, e.COMMAND_PRIORITY_CRITICAL)), ae.listenersToRemove.add(A.registerCommand(e.FORMAT_TEXT_COMMAND, (oe) => {
      let ie = e.$getSelection();
      return re(ie, g) ? e.DEPRECATED_$isGridSelection(ie) ? (ae.formatCells(oe), !0) : (e.$isRangeSelection(ie) && (oe = t.$findMatchingParent(ie.anchor.getNode(), (ue) => T(ue)), T(oe)), !1) : !1;
    }, e.COMMAND_PRIORITY_CRITICAL)), ae.listenersToRemove.add(A.registerCommand(e.CONTROLLED_TEXT_INSERTION_COMMAND, () => {
      var oe = e.$getSelection();
      return re(oe, g) && (e.DEPRECATED_$isGridSelection(oe) ? ae.clearHighlight() : e.$isRangeSelection(oe) && (oe = t.$findMatchingParent(oe.anchor.getNode(), (ie) => T(ie)), T(oe))), !1;
    }, e.COMMAND_PRIORITY_CRITICAL)), J && ae.listenersToRemove.add(A.registerCommand(e.KEY_TAB_COMMAND, (oe) => {
      var ie = e.$getSelection();
      return !e.$isRangeSelection(ie) || !ie.isCollapsed() || !re(ie, g) || (ie = G(ie.anchor.getNode()), ie === null) ? !1 : (pe(oe), ie = g.getCordsFromCellNode(ie, ae.grid), z(ae, g, ie.x, ie.y, oe.shiftKey ? "backward" : "forward"), !0);
    }, e.COMMAND_PRIORITY_CRITICAL)), ae.listenersToRemove.add(A.registerCommand(
      e.FOCUS_COMMAND,
      () => g.isSelected(),
      e.COMMAND_PRIORITY_HIGH
    )), ae.listenersToRemove.add(A.registerCommand(e.SELECTION_CHANGE_COMMAND, () => {
      let oe = e.$getSelection(), ie = e.$getPreviousSelection();
      if (e.$isRangeSelection(oe)) {
        let { anchor: Ye, focus: st } = oe;
        var ue = Ye.getNode(), we = st.getNode();
        ue = G(ue), we = G(we);
        var Le = ue && g.is(q(ue)), Be = we && g.is(q(we));
        let pt = Le !== Be;
        Be = Le && Be, Le = oe.isBackward(), pt ? (ue = oe.clone(), ue.focus.set(g.getKey(), Le ? 0 : g.getChildrenSize(), "element"), e.$setSelection(ue), K(A, ae)) : Be && !ue.is(we) && (ae.setAnchorCellForSelection(ce(ue)), ae.setFocusCellForSelection(
          ce(we),
          !0
        ));
      }
      return oe && !oe.is(ie) && (e.DEPRECATED_$isGridSelection(oe) || e.DEPRECATED_$isGridSelection(ie)) && ae.gridSelection && !ae.gridSelection.is(ie) ? (e.DEPRECATED_$isGridSelection(oe) && oe.gridKey === ae.tableNodeKey ? ae.updateTableGridSelection(oe) : !e.DEPRECATED_$isGridSelection(oe) && e.DEPRECATED_$isGridSelection(ie) && ie.gridKey === ae.tableNodeKey && ae.updateTableGridSelection(null), !1) : (ae.hasHijackedSelectionStyles && !g.isSelected() ? B(A, ae) : !ae.hasHijackedSelectionStyles && g.isSelected() && K(A, ae), !1);
    }, e.COMMAND_PRIORITY_CRITICAL)), ae;
  }, Ht.getCellFromTarget = v, Ht.getTableSelectionFromTableElement = function(g) {
    return g.__lexicalTableSelection;
  }, Ht;
}
var Ut = {}, Ad;
function k_() {
  if (Ad)
    return Ut;
  Ad = 1;
  var e = kt(), t = Jt();
  const r = /^(\d+(?:\.\d+)?)px$/, o = {
    BOTH: 3,
    COLUMN: 2,
    NO_STATUS: 0,
    ROW: 1
  };
  class f extends e.DEPRECATED_GridCellNode {
    /** @internal */
    /** @internal */
    /** @internal */
    static getType() {
      return "tablecell";
    }
    static clone(se) {
      const he = new f(se.__headerState, se.__colSpan, se.__width, se.__key);
      return he.__rowSpan = se.__rowSpan, he.__backgroundColor = se.__backgroundColor, he;
    }
    static importDOM() {
      return {
        td: (se) => ({
          conversion: h,
          priority: 0
        }),
        th: (se) => ({
          conversion: h,
          priority: 0
        })
      };
    }
    static importJSON(se) {
      const he = se.colSpan || 1, Oe = se.rowSpan || 1, be = C(se.headerState, he, se.width || void 0);
      return be.__rowSpan = Oe, be.__backgroundColor = se.backgroundColor || null, be;
    }
    constructor(se = o.NO_STATUS, he = 1, Oe, be) {
      super(he, be), this.__headerState = se, this.__width = Oe, this.__backgroundColor = null;
    }
    createDOM(se) {
      const he = document.createElement(this.getTag());
      return this.__width && (he.style.width = `${this.__width}px`), this.__colSpan > 1 && (he.colSpan = this.__colSpan), this.__rowSpan > 1 && (he.rowSpan = this.__rowSpan), this.__backgroundColor !== null && (he.style.backgroundColor = this.__backgroundColor), t.addClassNamesToElement(he, se.theme.tableCell, this.hasHeader() && se.theme.tableCellHeader), he;
    }
    exportDOM(se) {
      const {
        element: he
      } = super.exportDOM(se);
      if (he) {
        const Oe = he, be = 700, Re = this.getParentOrThrow().getChildrenSize();
        Oe.style.border = "1px solid black", this.__colSpan > 1 && (Oe.colSpan = this.__colSpan), this.__rowSpan > 1 && (Oe.rowSpan = this.__rowSpan), Oe.style.width = `${this.getWidth() || Math.max(90, be / Re)}px`, Oe.style.verticalAlign = "top", Oe.style.textAlign = "start";
        const He = this.getBackgroundColor();
        He !== null ? Oe.style.backgroundColor = He : this.hasHeader() && (Oe.style.backgroundColor = "#f2f3f5");
      }
      return {
        element: he
      };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        backgroundColor: this.getBackgroundColor(),
        headerState: this.__headerState,
        type: "tablecell",
        width: this.getWidth()
      };
    }
    getTag() {
      return this.hasHeader() ? "th" : "td";
    }
    setHeaderStyles(se) {
      const he = this.getWritable();
      return he.__headerState = se, this.__headerState;
    }
    getHeaderStyles() {
      return this.getLatest().__headerState;
    }
    setWidth(se) {
      const he = this.getWritable();
      return he.__width = se, this.__width;
    }
    getWidth() {
      return this.getLatest().__width;
    }
    getBackgroundColor() {
      return this.getLatest().__backgroundColor;
    }
    setBackgroundColor(se) {
      this.getWritable().__backgroundColor = se;
    }
    toggleHeaderStyle(se) {
      const he = this.getWritable();
      return (he.__headerState & se) === se ? he.__headerState -= se : he.__headerState += se, he;
    }
    hasHeaderState(se) {
      return (this.getHeaderStyles() & se) === se;
    }
    hasHeader() {
      return this.getLatest().__headerState !== o.NO_STATUS;
    }
    updateDOM(se) {
      return se.__headerState !== this.__headerState || se.__width !== this.__width || se.__colSpan !== this.__colSpan || se.__rowSpan !== this.__rowSpan || se.__backgroundColor !== this.__backgroundColor;
    }
    isShadowRoot() {
      return !0;
    }
    collapseAtStart() {
      return !0;
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
  }
  function h(ve) {
    const se = ve, he = ve.nodeName.toLowerCase();
    let Oe;
    r.test(se.style.width) && (Oe = parseFloat(se.style.width));
    const be = C(he === "th" ? o.ROW : o.NO_STATUS, se.colSpan, Oe);
    be.__rowSpan = se.rowSpan;
    const Re = se.style.backgroundColor;
    return Re !== "" && (be.__backgroundColor = Re), {
      forChild: (He, Ve) => {
        if (T(Ve) && !e.$isElementNode(He)) {
          const Qe = e.$createParagraphNode();
          return e.$isLineBreakNode(He) && He.getTextContent() === `
` ? null : (Qe.append(He), Qe);
        }
        return He;
      },
      node: be
    };
  }
  function C(ve, se = 1, he) {
    return e.$applyNodeReplacement(new f(ve, se, he));
  }
  function T(ve) {
    return ve instanceof f;
  }
  class O extends e.DEPRECATED_GridRowNode {
    /** @internal */
    static getType() {
      return "tablerow";
    }
    static clone(se) {
      return new O(se.__height, se.__key);
    }
    static importDOM() {
      return {
        tr: (se) => ({
          conversion: S,
          priority: 0
        })
      };
    }
    static importJSON(se) {
      return x(se.height);
    }
    constructor(se, he) {
      super(he), this.__height = se;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "tablerow",
        version: 1
      };
    }
    createDOM(se) {
      const he = document.createElement("tr");
      return this.__height && (he.style.height = `${this.__height}px`), t.addClassNamesToElement(he, se.theme.tableRow), he;
    }
    isShadowRoot() {
      return !0;
    }
    setHeight(se) {
      const he = this.getWritable();
      return he.__height = se, this.__height;
    }
    getHeight() {
      return this.getLatest().__height;
    }
    updateDOM(se) {
      return se.__height !== this.__height;
    }
    canBeEmpty() {
      return !1;
    }
    canIndent() {
      return !1;
    }
  }
  function S(ve) {
    const se = ve;
    let he;
    return r.test(se.style.height) && (he = parseFloat(se.style.height)), {
      node: x(he)
    };
  }
  function x(ve) {
    return e.$applyNodeReplacement(new O(ve));
  }
  function D(ve) {
    return ve instanceof O;
  }
  const k = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", H = (ve) => k ? (ve || window).getSelection() : null;
  class N {
    constructor(se, he) {
      this.isHighlightingCells = !1, this.anchorX = -1, this.anchorY = -1, this.focusX = -1, this.focusY = -1, this.listenersToRemove = /* @__PURE__ */ new Set(), this.tableNodeKey = he, this.editor = se, this.grid = {
        cells: [],
        columns: 0,
        rows: 0
      }, this.gridSelection = null, this.anchorCellNodeKey = null, this.focusCellNodeKey = null, this.anchorCell = null, this.focusCell = null, this.hasHijackedSelectionStyles = !1, this.trackTableGrid();
    }
    getGrid() {
      return this.grid;
    }
    removeListeners() {
      Array.from(this.listenersToRemove).forEach((se) => se());
    }
    trackTableGrid() {
      const se = new MutationObserver((he) => {
        this.editor.update(() => {
          let Oe = !1;
          for (let Re = 0; Re < he.length; Re++) {
            const Qe = he[Re].target.nodeName;
            if (Qe === "TABLE" || Qe === "TR") {
              Oe = !0;
              break;
            }
          }
          if (!Oe)
            return;
          const be = this.editor.getElementByKey(this.tableNodeKey);
          if (!be)
            throw new Error("Expected to find TableElement in DOM");
          this.grid = B(be);
        });
      });
      this.editor.update(() => {
        const he = this.editor.getElementByKey(this.tableNodeKey);
        if (!he)
          throw new Error("Expected to find TableElement in DOM");
        this.grid = B(he), se.observe(he, {
          childList: !0,
          subtree: !0
        });
      });
    }
    clearHighlight() {
      const se = this.editor;
      this.isHighlightingCells = !1, this.anchorX = -1, this.anchorY = -1, this.focusX = -1, this.focusY = -1, this.gridSelection = null, this.anchorCellNodeKey = null, this.focusCellNodeKey = null, this.anchorCell = null, this.focusCell = null, this.hasHijackedSelectionStyles = !1, this.enableHighlightStyle(), se.update(() => {
        const he = e.$getNodeByKey(this.tableNodeKey);
        if (!g(he))
          throw new Error("Expected TableNode.");
        const Oe = se.getElementByKey(this.tableNodeKey);
        if (!Oe)
          throw new Error("Expected to find TableElement in DOM");
        const be = B(Oe);
        z(se, be, null), e.$setSelection(null), se.dispatchCommand(e.SELECTION_CHANGE_COMMAND, void 0);
      });
    }
    enableHighlightStyle() {
      const se = this.editor;
      se.update(() => {
        const he = se.getElementByKey(this.tableNodeKey);
        if (!he)
          throw new Error("Expected to find TableElement in DOM");
        t.removeClassNamesFromElement(he, se._config.theme.tableSelection), he.classList.remove("disable-selection"), this.hasHijackedSelectionStyles = !1;
      });
    }
    disableHighlightStyle() {
      const se = this.editor;
      se.update(() => {
        const he = se.getElementByKey(this.tableNodeKey);
        if (!he)
          throw new Error("Expected to find TableElement in DOM");
        t.addClassNamesToElement(he, se._config.theme.tableSelection), this.hasHijackedSelectionStyles = !0;
      });
    }
    updateTableGridSelection(se) {
      if (se != null && se.gridKey === this.tableNodeKey) {
        const he = this.editor;
        this.gridSelection = se, this.isHighlightingCells = !0, this.disableHighlightStyle(), z(he, this.grid, this.gridSelection);
      } else
        se == null ? this.clearHighlight() : (this.tableNodeKey = se.gridKey, this.updateTableGridSelection(se));
    }
    setFocusCellForSelection(se, he = !1) {
      const Oe = this.editor;
      Oe.update(() => {
        const be = e.$getNodeByKey(this.tableNodeKey);
        if (!g(be))
          throw new Error("Expected TableNode.");
        if (!Oe.getElementByKey(this.tableNodeKey))
          throw new Error("Expected to find TableElement in DOM");
        const He = se.x, Ve = se.y;
        if (this.focusCell = se, this.anchorCell !== null) {
          const Qe = H(Oe._window);
          Qe && Qe.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);
        }
        if (!this.isHighlightingCells && (this.anchorX !== He || this.anchorY !== Ve || he))
          this.isHighlightingCells = !0, this.disableHighlightStyle();
        else if (He === this.focusX && Ve === this.focusY)
          return;
        if (this.focusX = He, this.focusY = Ve, this.isHighlightingCells) {
          const Qe = e.$getNearestNodeFromDOMNode(se.elem);
          if (this.gridSelection != null && this.anchorCellNodeKey != null && T(Qe)) {
            const ct = Qe.getKey();
            this.gridSelection = this.gridSelection.clone() || e.DEPRECATED_$createGridSelection(), this.focusCellNodeKey = ct, this.gridSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey), e.$setSelection(this.gridSelection), Oe.dispatchCommand(e.SELECTION_CHANGE_COMMAND, void 0), z(Oe, this.grid, this.gridSelection);
          }
        }
      });
    }
    setAnchorCellForSelection(se) {
      this.isHighlightingCells = !1, this.anchorCell = se, this.anchorX = se.x, this.anchorY = se.y, this.editor.update(() => {
        const he = e.$getNearestNodeFromDOMNode(se.elem);
        if (T(he)) {
          const Oe = he.getKey();
          this.gridSelection = this.gridSelection != null ? this.gridSelection.clone() : e.DEPRECATED_$createGridSelection(), this.anchorCellNodeKey = Oe;
        }
      });
    }
    formatCells(se) {
      this.editor.update(() => {
        const he = e.$getSelection();
        if (!e.DEPRECATED_$isGridSelection(he))
          throw Error("Expected grid selection");
        const Oe = e.$createRangeSelection(), be = Oe.anchor, Re = Oe.focus;
        he.getNodes().forEach((He) => {
          T(He) && He.getTextContentSize() !== 0 && (be.set(He.getKey(), 0, "element"), Re.set(He.getKey(), He.getChildrenSize(), "element"), Oe.formatText(se));
        }), e.$setSelection(he), this.editor.dispatchCommand(e.SELECTION_CHANGE_COMMAND, void 0);
      });
    }
    clearText() {
      const se = this.editor;
      se.update(() => {
        const he = e.$getNodeByKey(this.tableNodeKey);
        if (!g(he))
          throw new Error("Expected TableNode.");
        const Oe = e.$getSelection();
        if (!e.DEPRECATED_$isGridSelection(Oe))
          throw Error("Expected grid selection");
        const be = Oe.getNodes().filter(T);
        if (be.length === this.grid.columns * this.grid.rows) {
          he.selectPrevious(), he.remove(), e.$getRoot().selectStart();
          return;
        }
        be.forEach((Re) => {
          if (e.$isElementNode(Re)) {
            const He = e.$createParagraphNode(), Ve = e.$createTextNode();
            He.append(Ve), Re.append(He), Re.getChildren().forEach((Qe) => {
              Qe !== He && Qe.remove();
            });
          }
        }), z(se, this.grid, null), e.$setSelection(null), se.dispatchCommand(e.SELECTION_CHANGE_COMMAND, void 0);
      });
    }
  }
  const v = "__lexicalTableSelection";
  function F(ve, se, he, Oe) {
    const be = he.getRootElement();
    if (be === null)
      throw new Error("No root element.");
    const Re = new N(he, ve.getKey()), He = he._window || window;
    U(se, Re), se.addEventListener("mousedown", (je) => {
      setTimeout(() => {
        if (je.button !== 0 || !He)
          return;
        const qe = K(je.target);
        qe !== null && (ne(je), Re.setAnchorCellForSelection(qe));
        const nt = () => {
          He.removeEventListener("mouseup", nt), He.removeEventListener("mousemove", gt);
        }, gt = (Ct) => {
          const xt = K(Ct.target);
          xt !== null && (Re.anchorX !== xt.x || Re.anchorY !== xt.y) && (Ct.preventDefault(), Re.setFocusCellForSelection(xt));
        };
        He.addEventListener("mouseup", nt), He.addEventListener("mousemove", gt);
      }, 0);
    });
    const Ve = (je) => {
      je.button === 0 && he.update(() => {
        const qe = e.$getSelection(), nt = je.target;
        e.DEPRECATED_$isGridSelection(qe) && qe.gridKey === Re.tableNodeKey && be.contains(nt) && Re.clearHighlight();
      });
    };
    He.addEventListener("mousedown", Ve), Re.listenersToRemove.add(() => He.removeEventListener("mousedown", Ve)), Re.listenersToRemove.add(he.registerCommand(e.KEY_ARROW_DOWN_COMMAND, (je) => j(he, je, "down", ve, Re), e.COMMAND_PRIORITY_HIGH)), Re.listenersToRemove.add(he.registerCommand(e.KEY_ARROW_UP_COMMAND, (je) => j(he, je, "up", ve, Re), e.COMMAND_PRIORITY_HIGH)), Re.listenersToRemove.add(he.registerCommand(e.KEY_ARROW_LEFT_COMMAND, (je) => j(he, je, "backward", ve, Re), e.COMMAND_PRIORITY_HIGH)), Re.listenersToRemove.add(he.registerCommand(e.KEY_ARROW_RIGHT_COMMAND, (je) => j(he, je, "forward", ve, Re), e.COMMAND_PRIORITY_HIGH)), Re.listenersToRemove.add(he.registerCommand(e.KEY_ESCAPE_COMMAND, (je) => {
      const qe = e.$getSelection();
      if (e.DEPRECATED_$isGridSelection(qe)) {
        const nt = t.$findMatchingParent(qe.focus.getNode(), T);
        if (T(nt))
          return ne(je), nt.selectEnd(), !0;
      }
      return !1;
    }, e.COMMAND_PRIORITY_HIGH));
    const Qe = (je) => () => {
      const qe = e.$getSelection();
      if (!q(qe, ve))
        return !1;
      if (e.DEPRECATED_$isGridSelection(qe))
        return Re.clearText(), !0;
      if (e.$isRangeSelection(qe)) {
        const nt = t.$findMatchingParent(qe.anchor.getNode(), (Dt) => T(Dt));
        if (!T(nt))
          return !1;
        const gt = qe.anchor.getNode(), Ct = qe.focus.getNode(), xt = ve.isParentOf(gt), St = ve.isParentOf(Ct);
        if (xt && !St || St && !xt)
          return Re.clearText(), !0;
        const Et = t.$findMatchingParent(qe.anchor.getNode(), (Dt) => e.$isElementNode(Dt)), Yt = Et && t.$findMatchingParent(Et, (Dt) => e.$isElementNode(Dt) && T(Dt.getParent()));
        if (!e.$isElementNode(Yt) || !e.$isElementNode(Et))
          return !1;
        if (je === e.DELETE_LINE_COMMAND && Yt.getPreviousSibling() === null)
          return !0;
        if ((je === e.DELETE_CHARACTER_COMMAND || je === e.DELETE_WORD_COMMAND) && qe.isCollapsed() && qe.anchor.offset === 0 && Et !== Yt) {
          const Dt = Et.getChildren(), Kt = e.$createParagraphNode();
          return Dt.forEach((bt) => Kt.append(bt)), Et.replace(Kt), Et.getWritable().__parent = nt.getKey(), !0;
        }
      }
      return !1;
    };
    [e.DELETE_WORD_COMMAND, e.DELETE_LINE_COMMAND, e.DELETE_CHARACTER_COMMAND].forEach((je) => {
      Re.listenersToRemove.add(he.registerCommand(je, Qe(je), e.COMMAND_PRIORITY_CRITICAL));
    });
    const ct = (je) => {
      const qe = e.$getSelection();
      if (!q(qe, ve))
        return !1;
      if (e.DEPRECATED_$isGridSelection(qe))
        return je.preventDefault(), je.stopPropagation(), Re.clearText(), !0;
      if (e.$isRangeSelection(qe)) {
        const nt = t.$findMatchingParent(qe.anchor.getNode(), (gt) => T(gt));
        if (!T(nt))
          return !1;
      }
      return !1;
    };
    Re.listenersToRemove.add(he.registerCommand(e.KEY_BACKSPACE_COMMAND, ct, e.COMMAND_PRIORITY_CRITICAL)), Re.listenersToRemove.add(he.registerCommand(e.KEY_DELETE_COMMAND, ct, e.COMMAND_PRIORITY_CRITICAL)), Re.listenersToRemove.add(he.registerCommand(e.FORMAT_TEXT_COMMAND, (je) => {
      const qe = e.$getSelection();
      if (!q(qe, ve))
        return !1;
      if (e.DEPRECATED_$isGridSelection(qe))
        return Re.formatCells(je), !0;
      if (e.$isRangeSelection(qe)) {
        const nt = t.$findMatchingParent(qe.anchor.getNode(), (gt) => T(gt));
        if (!T(nt))
          return !1;
      }
      return !1;
    }, e.COMMAND_PRIORITY_CRITICAL)), Re.listenersToRemove.add(he.registerCommand(e.CONTROLLED_TEXT_INSERTION_COMMAND, (je) => {
      const qe = e.$getSelection();
      if (!q(qe, ve))
        return !1;
      if (e.DEPRECATED_$isGridSelection(qe))
        return Re.clearHighlight(), !1;
      if (e.$isRangeSelection(qe)) {
        const nt = t.$findMatchingParent(qe.anchor.getNode(), (gt) => T(gt));
        if (!T(nt))
          return !1;
      }
      return !1;
    }, e.COMMAND_PRIORITY_CRITICAL)), Oe && Re.listenersToRemove.add(he.registerCommand(e.KEY_TAB_COMMAND, (je) => {
      const qe = e.$getSelection();
      if (!e.$isRangeSelection(qe) || !qe.isCollapsed() || !q(qe, ve))
        return !1;
      const nt = P(qe.anchor.getNode());
      if (nt === null)
        return !1;
      ne(je);
      const gt = ve.getCordsFromCellNode(nt, Re.grid);
      return V(Re, ve, gt.x, gt.y, je.shiftKey ? "backward" : "forward"), !0;
    }, e.COMMAND_PRIORITY_CRITICAL)), Re.listenersToRemove.add(he.registerCommand(e.FOCUS_COMMAND, (je) => ve.isSelected(), e.COMMAND_PRIORITY_HIGH));
    function At(je) {
      const qe = ve.getCordsFromCellNode(je, Re.grid);
      return ve.getCellFromCordsOrThrow(qe.x, qe.y, Re.grid);
    }
    return Re.listenersToRemove.add(he.registerCommand(e.SELECTION_CHANGE_COMMAND, () => {
      const je = e.$getSelection(), qe = e.$getPreviousSelection();
      if (e.$isRangeSelection(je)) {
        const {
          anchor: nt,
          focus: gt
        } = je, Ct = nt.getNode(), xt = gt.getNode(), St = P(Ct), wt = P(xt), Et = St && ve.is(w(St)), Yt = wt && ve.is(w(wt)), Dt = Et !== Yt, Kt = Et && Yt, bt = je.isBackward();
        if (Dt) {
          const nr = je.clone();
          nr.focus.set(ve.getKey(), bt ? 0 : ve.getChildrenSize(), "element"), e.$setSelection(nr), re(he, Re);
        } else
          Kt && (St.is(wt) || (Re.setAnchorCellForSelection(At(St)), Re.setFocusCellForSelection(At(wt), !0)));
      }
      return je && !je.is(qe) && (e.DEPRECATED_$isGridSelection(je) || e.DEPRECATED_$isGridSelection(qe)) && Re.gridSelection && !Re.gridSelection.is(qe) ? (e.DEPRECATED_$isGridSelection(je) && je.gridKey === Re.tableNodeKey ? Re.updateTableGridSelection(je) : !e.DEPRECATED_$isGridSelection(je) && e.DEPRECATED_$isGridSelection(qe) && qe.gridKey === Re.tableNodeKey && Re.updateTableGridSelection(null), !1) : (Re.hasHijackedSelectionStyles && !ve.isSelected() ? de(he, Re) : !Re.hasHijackedSelectionStyles && ve.isSelected() && re(he, Re), !1);
    }, e.COMMAND_PRIORITY_CRITICAL)), Re;
  }
  function U(ve, se) {
    ve[v] = se;
  }
  function I(ve) {
    return ve[v];
  }
  function K(ve) {
    let se = ve;
    for (; se != null; ) {
      const he = se.nodeName;
      if (he === "TD" || he === "TH") {
        const Oe = se._cell;
        return Oe === void 0 ? null : Oe;
      }
      se = se.parentNode;
    }
    return null;
  }
  function B(ve) {
    const se = [], he = {
      cells: se,
      columns: 0,
      rows: 0
    };
    let Oe = ve.firstChild, be = 0, Re = 0;
    for (se.length = 0; Oe != null; ) {
      const He = Oe.nodeName;
      if (He === "TD" || He === "TH") {
        const ct = Oe, At = {
          elem: ct,
          hasBackgroundColor: ct.style.backgroundColor !== "",
          highlighted: !1,
          x: be,
          y: Re
        };
        Oe._cell = At;
        let je = se[Re];
        je === void 0 && (je = se[Re] = []), je[be] = At;
      } else {
        const ct = Oe.firstChild;
        if (ct != null) {
          Oe = ct;
          continue;
        }
      }
      const Ve = Oe.nextSibling;
      if (Ve != null) {
        be++, Oe = Ve;
        continue;
      }
      const Qe = Oe.parentNode;
      if (Qe != null) {
        const ct = Qe.nextSibling;
        if (ct == null)
          break;
        Re++, be = 0, Oe = ct;
      }
    }
    return he.columns = be + 1, he.rows = Re + 1, he;
  }
  function z(ve, se, he) {
    const Oe = new Set(he ? he.getNodes() : []);
    te(se, (be, Re) => {
      const He = be.elem;
      Oe.has(Re) ? (be.highlighted = !0, Z(ve, be)) : (be.highlighted = !1, ee(ve, be), He.getAttribute("style") || He.removeAttribute("style"));
    });
  }
  function te(ve, se) {
    const {
      cells: he
    } = ve;
    for (let Oe = 0; Oe < he.length; Oe++) {
      const be = he[Oe];
      if (be)
        for (let Re = 0; Re < be.length; Re++) {
          const He = be[Re];
          if (!He)
            continue;
          const Ve = e.$getNearestNodeFromDOMNode(He.elem);
          Ve !== null && se(He, Ve, {
            x: Re,
            y: Oe
          });
        }
    }
  }
  function re(ve, se) {
    se.disableHighlightStyle(), te(se.grid, (he) => {
      he.highlighted = !0, Z(ve, he);
    });
  }
  function de(ve, se) {
    se.enableHighlightStyle(), te(se.grid, (he) => {
      const Oe = he.elem;
      he.highlighted = !1, ee(ve, he), Oe.getAttribute("style") || Oe.removeAttribute("style");
    });
  }
  const V = (ve, se, he, Oe, be) => {
    const Re = be === "forward";
    switch (be) {
      case "backward":
      case "forward":
        return he !== (Re ? ve.grid.columns - 1 : 0) ? me(se.getCellNodeFromCordsOrThrow(he + (Re ? 1 : -1), Oe, ve.grid), Re) : Oe !== (Re ? ve.grid.rows - 1 : 0) ? me(se.getCellNodeFromCordsOrThrow(Re ? 0 : ve.grid.columns - 1, Oe + (Re ? 1 : -1), ve.grid), Re) : Re ? se.selectNext() : se.selectPrevious(), !0;
      case "up":
        return Oe !== 0 ? me(se.getCellNodeFromCordsOrThrow(he, Oe - 1, ve.grid), !1) : se.selectPrevious(), !0;
      case "down":
        return Oe !== ve.grid.rows - 1 ? me(se.getCellNodeFromCordsOrThrow(he, Oe + 1, ve.grid), !0) : se.selectNext(), !0;
      default:
        return !1;
    }
  }, G = (ve, se, he, Oe, be) => {
    const Re = be === "forward";
    switch (be) {
      case "backward":
      case "forward":
        return he !== (Re ? ve.grid.columns - 1 : 0) && ve.setFocusCellForSelection(se.getCellFromCordsOrThrow(he + (Re ? 1 : -1), Oe, ve.grid)), !0;
      case "up":
        return Oe !== 0 ? (ve.setFocusCellForSelection(se.getCellFromCordsOrThrow(he, Oe - 1, ve.grid)), !0) : !1;
      case "down":
        return Oe !== ve.grid.rows - 1 ? (ve.setFocusCellForSelection(se.getCellFromCordsOrThrow(he, Oe + 1, ve.grid)), !0) : !1;
      default:
        return !1;
    }
  };
  function q(ve, se) {
    if (e.$isRangeSelection(ve) || e.DEPRECATED_$isGridSelection(ve)) {
      const he = se.isParentOf(ve.anchor.getNode()), Oe = se.isParentOf(ve.focus.getNode());
      return he && Oe;
    }
    return !1;
  }
  function me(ve, se) {
    se ? ve.selectStart() : ve.selectEnd();
  }
  const pe = "172,206,247";
  function Z(ve, se) {
    const he = se.elem, Oe = e.$getNearestNodeFromDOMNode(he);
    if (!T(Oe))
      throw Error("Expected to find LexicalNode from Table Cell DOMNode");
    Oe.getBackgroundColor() === null ? he.style.setProperty("background-color", `rgb(${pe})`) : he.style.setProperty("background-image", `linear-gradient(to right, rgba(${pe},0.85), rgba(${pe},0.85))`), he.style.setProperty("caret-color", "transparent");
  }
  function ee(ve, se) {
    const he = se.elem, Oe = e.$getNearestNodeFromDOMNode(he);
    if (!T(Oe))
      throw Error("Expected to find LexicalNode from Table Cell DOMNode");
    Oe.getBackgroundColor() === null && he.style.removeProperty("background-color"), he.style.removeProperty("background-image"), he.style.removeProperty("caret-color");
  }
  function P(ve) {
    const se = t.$findMatchingParent(ve, T);
    return T(se) ? se : null;
  }
  function w(ve) {
    const se = t.$findMatchingParent(ve, g);
    return g(se) ? se : null;
  }
  function j(ve, se, he, Oe, be) {
    const Re = e.$getSelection();
    if (!q(Re, Oe))
      return !1;
    if (e.$isRangeSelection(Re) && Re.isCollapsed()) {
      if (he === "backward" || he === "forward")
        return !1;
      const {
        anchor: He,
        focus: Ve
      } = Re, Qe = t.$findMatchingParent(He.getNode(), T), ct = t.$findMatchingParent(Ve.getNode(), T);
      if (!T(Qe) || !Qe.is(ct))
        return !1;
      const At = w(Qe);
      if (At !== Oe && At != null) {
        const wt = ve.getElementByKey(At.getKey());
        if (wt != null)
          return be.grid = B(wt), j(ve, se, he, At, be);
      }
      const je = ve.getElementByKey(Qe.__key), qe = ve.getElementByKey(He.key);
      if (qe == null || je == null)
        return !1;
      let nt;
      if (He.type === "element")
        nt = qe.getBoundingClientRect();
      else {
        const wt = window.getSelection();
        if (wt === null || wt.rangeCount === 0)
          return !1;
        nt = wt.getRangeAt(0).getBoundingClientRect();
      }
      const gt = he === "up" ? Qe.getFirstChild() : Qe.getLastChild();
      if (gt == null)
        return !1;
      const Ct = ve.getElementByKey(gt.__key);
      if (Ct == null)
        return !1;
      const xt = Ct.getBoundingClientRect();
      if (he === "up" ? xt.top > nt.top - nt.height : nt.bottom + nt.height > xt.bottom) {
        ne(se);
        const wt = Oe.getCordsFromCellNode(Qe, be.grid);
        if (se.shiftKey) {
          const Et = Oe.getCellFromCordsOrThrow(wt.x, wt.y, be.grid);
          be.setAnchorCellForSelection(Et), be.setFocusCellForSelection(Et, !0);
        } else
          return V(be, Oe, wt.x, wt.y, he);
        return !0;
      }
    } else if (e.DEPRECATED_$isGridSelection(Re)) {
      const {
        anchor: He,
        focus: Ve
      } = Re, Qe = t.$findMatchingParent(He.getNode(), T), ct = t.$findMatchingParent(Ve.getNode(), T), [At] = Re.getNodes(), je = ve.getElementByKey(At.getKey());
      if (!T(Qe) || !T(ct) || !g(At) || je == null)
        return !1;
      be.updateTableGridSelection(Re);
      const qe = B(je), nt = Oe.getCordsFromCellNode(Qe, qe), gt = Oe.getCellFromCordsOrThrow(nt.x, nt.y, qe);
      if (be.setAnchorCellForSelection(gt), ne(se), se.shiftKey) {
        const Ct = Oe.getCordsFromCellNode(ct, qe);
        return G(be, At, Ct.x, Ct.y, he);
      } else
        ct.selectEnd();
      return !0;
    }
    return !1;
  }
  function ne(ve) {
    ve.preventDefault(), ve.stopImmediatePropagation(), ve.stopPropagation();
  }
  class Y extends e.DEPRECATED_GridNode {
    /** @internal */
    static getType() {
      return "table";
    }
    static clone(se) {
      return new Y(se.__key);
    }
    static importDOM() {
      return {
        table: (se) => ({
          conversion: Q,
          priority: 1
        })
      };
    }
    static importJSON(se) {
      return b();
    }
    constructor(se) {
      super(se);
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "table",
        version: 1
      };
    }
    createDOM(se, he) {
      const Oe = document.createElement("table");
      return t.addClassNamesToElement(Oe, se.theme.table), Oe;
    }
    updateDOM() {
      return !1;
    }
    exportDOM(se) {
      return {
        ...super.exportDOM(se),
        after: (he) => {
          if (he) {
            const Oe = he.cloneNode(), be = document.createElement("colgroup"), Re = document.createElement("tbody");
            t.isHTMLElement(he) && Re.append(...he.children);
            const He = this.getFirstChildOrThrow();
            if (!D(He))
              throw new Error("Expected to find row node.");
            const Ve = He.getChildrenSize();
            for (let Qe = 0; Qe < Ve; Qe++) {
              const ct = document.createElement("col");
              be.append(ct);
            }
            return Oe.replaceChildren(be, Re), Oe;
          }
        }
      };
    }
    // TODO 0.10 deprecate
    canExtractContents() {
      return !1;
    }
    canBeEmpty() {
      return !1;
    }
    isShadowRoot() {
      return !0;
    }
    getCordsFromCellNode(se, he) {
      const {
        rows: Oe,
        cells: be
      } = he;
      for (let Re = 0; Re < Oe; Re++) {
        const He = be[Re];
        if (He == null)
          continue;
        const Ve = He.findIndex((Qe) => {
          if (!Qe)
            return;
          const {
            elem: ct
          } = Qe;
          return e.$getNearestNodeFromDOMNode(ct) === se;
        });
        if (Ve !== -1)
          return {
            x: Ve,
            y: Re
          };
      }
      throw new Error("Cell not found in table.");
    }
    getCellFromCords(se, he, Oe) {
      const {
        cells: be
      } = Oe, Re = be[he];
      if (Re == null)
        return null;
      const He = Re[se];
      return He ?? null;
    }
    getCellFromCordsOrThrow(se, he, Oe) {
      const be = this.getCellFromCords(se, he, Oe);
      if (!be)
        throw new Error("Cell not found at cords.");
      return be;
    }
    getCellNodeFromCords(se, he, Oe) {
      const be = this.getCellFromCords(se, he, Oe);
      if (be == null)
        return null;
      const Re = e.$getNearestNodeFromDOMNode(be.elem);
      return T(Re) ? Re : null;
    }
    getCellNodeFromCordsOrThrow(se, he, Oe) {
      const be = this.getCellNodeFromCords(se, he, Oe);
      if (!be)
        throw new Error("Node at cords not TableCellNode.");
      return be;
    }
    canSelectBefore() {
      return !0;
    }
    canIndent() {
      return !1;
    }
  }
  function W(ve, se) {
    const he = ve.getElementByKey(se.getKey());
    if (he == null)
      throw new Error("Table Element Not Found");
    return B(he);
  }
  function Q(ve) {
    return {
      node: b()
    };
  }
  function b() {
    return e.$applyNodeReplacement(new Y());
  }
  function g(ve) {
    return ve instanceof Y;
  }
  function _(ve, se, he = !0) {
    const Oe = b();
    for (let be = 0; be < ve; be++) {
      const Re = x();
      for (let He = 0; He < se; He++) {
        let Ve = o.NO_STATUS;
        typeof he == "object" ? (be === 0 && he.rows && (Ve |= o.ROW), He === 0 && he.columns && (Ve |= o.COLUMN)) : he && (be === 0 && (Ve |= o.ROW), He === 0 && (Ve |= o.COLUMN));
        const Qe = C(Ve), ct = e.$createParagraphNode();
        ct.append(e.$createTextNode()), Qe.append(ct), Re.append(Qe);
      }
      Oe.append(Re);
    }
    return Oe;
  }
  function A(ve) {
    const se = t.$findMatchingParent(ve, (he) => T(he));
    return T(se) ? se : null;
  }
  function J(ve) {
    const se = t.$findMatchingParent(ve, (he) => D(he));
    if (D(se))
      return se;
    throw new Error("Expected table cell to be inside of table row.");
  }
  function ce(ve) {
    const se = t.$findMatchingParent(ve, (he) => g(he));
    if (g(se))
      return se;
    throw new Error("Expected table cell to be inside of table.");
  }
  function ge(ve) {
    const se = J(ve);
    return ce(se).getChildren().findIndex((Oe) => Oe.is(se));
  }
  function ae(ve) {
    return J(ve).getChildren().findIndex((he) => he.is(ve));
  }
  function Te(ve, se) {
    const he = ce(ve), {
      x: Oe,
      y: be
    } = he.getCordsFromCellNode(ve, se);
    return {
      above: he.getCellNodeFromCords(Oe, be - 1, se),
      below: he.getCellNodeFromCords(Oe, be + 1, se),
      left: he.getCellNodeFromCords(Oe - 1, be, se),
      right: he.getCellNodeFromCords(Oe + 1, be, se)
    };
  }
  function Me(ve, se) {
    const he = ve.getChildren();
    if (se >= he.length || se < 0)
      throw new Error("Expected table cell to be inside of table row.");
    return he[se].remove(), ve;
  }
  function ze(ve, se, he = !0, Oe, be) {
    const Re = ve.getChildren();
    if (se >= Re.length || se < 0)
      throw new Error("Table row target index out of range");
    const He = Re[se];
    if (D(He))
      for (let Ve = 0; Ve < Oe; Ve++) {
        const Qe = He.getChildren(), ct = Qe.length, At = x();
        for (let je = 0; je < ct; je++) {
          const qe = Qe[je];
          if (!T(qe))
            throw Error("Expected table cell");
          const {
            above: nt,
            below: gt
          } = Te(qe, be);
          let Ct = o.NO_STATUS;
          const xt = nt && nt.getWidth() || gt && gt.getWidth() || void 0;
          (nt && nt.hasHeaderState(o.COLUMN) || gt && gt.hasHeaderState(o.COLUMN)) && (Ct |= o.COLUMN);
          const St = C(Ct, 1, xt);
          St.append(e.$createParagraphNode()), At.append(St);
        }
        he ? He.insertAfter(At) : He.insertBefore(At);
      }
    else
      throw new Error("Row before insertion index does not exist.");
    return ve;
  }
  function oe(ve = !0) {
    const se = e.$getSelection();
    if (!e.$INTERNAL_isPointSelection(se))
      throw Error("Expected a INTERNAL_PointSelection");
    const he = se.focus.getNode(), [Oe, , be] = e.DEPRECATED_$getNodeTriplet(he), [Re, He] = e.DEPRECATED_$computeGridMap(be, Oe, Oe), Ve = Re[0].length, {
      startRow: Qe
    } = He;
    if (ve) {
      const ct = Qe + Oe.__rowSpan - 1, At = Re[ct], je = x();
      for (let nt = 0; nt < Ve; nt++) {
        const {
          cell: gt,
          startRow: Ct
        } = At[nt];
        Ct + gt.__rowSpan - 1 <= ct ? je.append(C(o.NO_STATUS)) : gt.setRowSpan(gt.__rowSpan + 1);
      }
      const qe = be.getChildAtIndex(ct);
      if (!e.DEPRECATED_$isGridRowNode(qe))
        throw Error("focusEndRow is not a GridRowNode");
      qe.insertAfter(je);
    } else {
      const ct = Re[Qe], At = x();
      for (let qe = 0; qe < Ve; qe++) {
        const {
          cell: nt,
          startRow: gt
        } = ct[qe];
        gt === Qe ? At.append(C(o.NO_STATUS)) : nt.setRowSpan(nt.__rowSpan + 1);
      }
      const je = be.getChildAtIndex(Qe);
      if (!e.DEPRECATED_$isGridRowNode(je))
        throw Error("focusEndRow is not a GridRowNode");
      je.insertBefore(At);
    }
  }
  function ie(ve, se, he = !0, Oe, be) {
    const Re = ve.getChildren(), He = [];
    for (let Ve = 0; Ve < Re.length; Ve++) {
      const Qe = Re[Ve];
      if (D(Qe))
        for (let ct = 0; ct < Oe; ct++) {
          const At = Qe.getChildren();
          if (se >= At.length || se < 0)
            throw new Error("Table column target index out of range");
          const je = At[se];
          if (!T(je))
            throw Error("Expected table cell");
          const {
            left: qe,
            right: nt
          } = Te(je, be);
          let gt = o.NO_STATUS;
          (qe && qe.hasHeaderState(o.ROW) || nt && nt.hasHeaderState(o.ROW)) && (gt |= o.ROW);
          const Ct = C(gt);
          Ct.append(e.$createParagraphNode()), He.push({
            newTableCell: Ct,
            targetCell: je
          });
        }
    }
    return He.forEach(({
      newTableCell: Ve,
      targetCell: Qe
    }) => {
      he ? Qe.insertAfter(Ve) : Qe.insertBefore(Ve);
    }), ve;
  }
  function ue(ve = !0) {
    const se = e.$getSelection();
    if (!e.$INTERNAL_isPointSelection(se))
      throw Error("Expected a PointSeleciton");
    const he = se.anchor.getNode(), Oe = se.focus.getNode(), [be] = e.DEPRECATED_$getNodeTriplet(he), [Re, , He] = e.DEPRECATED_$getNodeTriplet(Oe), [Ve, Qe, ct] = e.DEPRECATED_$computeGridMap(He, Re, be), At = Ve.length, je = ve ? Math.max(Qe.startColumn, ct.startColumn) : Math.min(Qe.startColumn, ct.startColumn), qe = ve ? je + Re.__colSpan - 1 : je - 1, nt = He.getFirstChild();
    if (!e.DEPRECATED_$isGridRowNode(nt))
      throw Error("Expected firstTable child to be a row");
    let gt = null;
    function Ct() {
      const St = C(o.NO_STATUS).append(e.$createParagraphNode());
      return gt === null && (gt = St), St;
    }
    let xt = nt;
    e:
      for (let St = 0; St < At; St++) {
        if (St !== 0) {
          const Kt = xt.getNextSibling();
          if (!e.DEPRECATED_$isGridRowNode(Kt))
            throw Error("Expected row nextSibling to be a row");
          xt = Kt;
        }
        const wt = Ve[St];
        if (qe < 0) {
          st(xt, Ct());
          continue;
        }
        const {
          cell: Et,
          startColumn: Yt,
          startRow: Dt
        } = wt[qe];
        if (Yt + Et.__colSpan - 1 <= qe) {
          let Kt = Et, bt = Dt, nr = qe;
          for (; bt !== St && Kt.__rowSpan > 1; )
            if (nr -= Et.__colSpan, nr >= 0) {
              const {
                cell: gr,
                startRow: Ci
              } = wt[nr];
              Kt = gr, bt = Ci;
            } else {
              xt.append(Ct());
              continue e;
            }
          Kt.insertAfter(Ct());
        } else
          Et.setColSpan(Et.__colSpan + 1);
      }
    gt !== null && Ye(gt);
  }
  function we(ve, se) {
    const he = ve.getChildren();
    for (let Oe = 0; Oe < he.length; Oe++) {
      const be = he[Oe];
      if (D(be)) {
        const Re = be.getChildren();
        if (se >= Re.length || se < 0)
          throw new Error("Table column target index out of range");
        Re[se].remove();
      }
    }
    return ve;
  }
  function Le() {
    const ve = e.$getSelection();
    if (!e.$INTERNAL_isPointSelection(ve))
      throw Error("Expected a INTERNAL_PointSelection");
    const se = ve.anchor.getNode(), he = ve.focus.getNode(), [Oe, , be] = e.DEPRECATED_$getNodeTriplet(se), [Re] = e.DEPRECATED_$getNodeTriplet(he), [He, Ve, Qe] = e.DEPRECATED_$computeGridMap(be, Oe, Re), {
      startRow: ct
    } = Ve, {
      startRow: At
    } = Qe, je = At + Re.__rowSpan - 1;
    if (He.length === je - ct + 1) {
      be.remove();
      return;
    }
    const qe = He[0].length, nt = He[je + 1], gt = be.getChildAtIndex(je + 1);
    for (let Ct = je; Ct >= ct; Ct--) {
      for (let St = qe - 1; St >= 0; St--) {
        const {
          cell: wt,
          startRow: Et,
          startColumn: Yt
        } = He[Ct][St];
        if (Yt === St && (Ct === ct && Et < ct && wt.setRowSpan(wt.__rowSpan - (Et - ct)), Et >= ct && Et + wt.__rowSpan - 1 > je)) {
          if (wt.setRowSpan(wt.__rowSpan - (je - Et + 1)), gt === null)
            throw Error("Expected nextRowNode not to be null");
          if (St === 0)
            st(gt, wt);
          else {
            const {
              cell: Dt
            } = nt[St - 1];
            Dt.insertAfter(wt);
          }
        }
      }
      const xt = be.getChildAtIndex(Ct);
      if (!e.DEPRECATED_$isGridRowNode(xt))
        throw Error(`Expected GridNode childAtIndex(${String(Ct)}) to be RowNode`);
      xt.remove();
    }
    if (nt !== void 0) {
      const {
        cell: Ct
      } = nt[0];
      Ye(Ct);
    } else {
      const Ct = He[ct - 1], {
        cell: xt
      } = Ct[0];
      Ye(xt);
    }
  }
  function Be() {
    const ve = e.$getSelection();
    if (!e.$INTERNAL_isPointSelection(ve))
      throw Error("Expected a INTERNAL_PointSelection");
    const se = ve.anchor.getNode(), he = ve.focus.getNode(), [Oe, , be] = e.DEPRECATED_$getNodeTriplet(se), [Re] = e.DEPRECATED_$getNodeTriplet(he), [He, Ve, Qe] = e.DEPRECATED_$computeGridMap(be, Oe, Re), {
      startColumn: ct
    } = Ve, {
      startRow: At,
      startColumn: je
    } = Qe, qe = Math.min(ct, je), nt = Math.max(ct + Oe.__colSpan - 1, je + Re.__colSpan - 1), gt = nt - qe + 1;
    if (He[0].length === nt - qe + 1) {
      be.selectPrevious(), be.remove();
      return;
    }
    const xt = He.length;
    for (let Et = 0; Et < xt; Et++)
      for (let Yt = qe; Yt <= nt; Yt++) {
        const {
          cell: Dt,
          startColumn: Kt
        } = He[Et][Yt];
        if (Kt < qe) {
          if (Yt === qe) {
            const bt = qe - Kt;
            Dt.setColSpan(Dt.__colSpan - // Possible overflow right too
            Math.min(gt, Dt.__colSpan - bt));
          }
        } else if (Kt + Dt.__colSpan - 1 > nt) {
          if (Yt === nt) {
            const bt = nt - Kt + 1;
            Dt.setColSpan(Dt.__colSpan - bt);
          }
        } else
          Dt.remove();
      }
    const St = He[At], wt = St[je + Re.__colSpan];
    if (wt !== void 0) {
      const {
        cell: Et
      } = wt;
      Ye(Et);
    } else {
      const Et = St[je - 1], {
        cell: Yt
      } = Et;
      Ye(Yt);
    }
  }
  function Ye(ve) {
    const se = ve.getFirstDescendant();
    se == null ? ve.selectStart() : se.getParentOrThrow().selectStart();
  }
  function st(ve, se) {
    const he = ve.getFirstChild();
    he !== null ? he.insertBefore(se) : ve.append(se);
  }
  function pt() {
    const ve = e.$getSelection();
    if (!e.$INTERNAL_isPointSelection(ve))
      throw Error("Expected a INTERNAL_PointSelection");
    const se = ve.anchor.getNode(), [he, Oe, be] = e.DEPRECATED_$getNodeTriplet(se), Re = he.__colSpan, He = he.__rowSpan;
    if (Re > 1) {
      for (let Ve = 1; Ve < Re; Ve++)
        he.insertAfter(C(o.NO_STATUS));
      he.setColSpan(1);
    }
    if (He > 1) {
      const [Ve, Qe] = e.DEPRECATED_$computeGridMap(be, he, he), {
        startColumn: ct,
        startRow: At
      } = Qe;
      let je;
      for (let qe = 1; qe < He; qe++) {
        const nt = At + qe, gt = Ve[nt];
        if (je = (je || Oe).getNextSibling(), !e.DEPRECATED_$isGridRowNode(je))
          throw Error("Expected row next sibling to be a row");
        let Ct = null;
        for (let xt = 0; xt < ct; xt++) {
          const St = gt[xt], wt = St.cell;
          St.startRow === nt && (Ct = wt), wt.__colSpan > 1 && (xt += wt.__colSpan - 1);
        }
        if (Ct === null)
          for (let xt = 0; xt < Re; xt++)
            st(je, C(o.NO_STATUS));
        else
          for (let xt = 0; xt < Re; xt++)
            Ct.insertAfter(C(o.NO_STATUS));
      }
      he.setRowSpan(1);
    }
  }
  const at = e.createCommand("INSERT_TABLE_COMMAND");
  return Ut.$createTableCellNode = C, Ut.$createTableNode = b, Ut.$createTableNodeWithDimensions = _, Ut.$createTableRowNode = x, Ut.$deleteTableColumn = we, Ut.$deleteTableColumn__EXPERIMENTAL = Be, Ut.$deleteTableRow__EXPERIMENTAL = Le, Ut.$getElementGridForTableNode = W, Ut.$getTableCellNodeFromLexicalNode = A, Ut.$getTableColumnIndexFromTableCellNode = ae, Ut.$getTableNodeFromLexicalNodeOrThrow = ce, Ut.$getTableRowIndexFromTableCellNode = ge, Ut.$getTableRowNodeFromTableCellNodeOrThrow = J, Ut.$insertTableColumn = ie, Ut.$insertTableColumn__EXPERIMENTAL = ue, Ut.$insertTableRow = ze, Ut.$insertTableRow__EXPERIMENTAL = oe, Ut.$isTableCellNode = T, Ut.$isTableNode = g, Ut.$isTableRowNode = D, Ut.$removeTableRowAtIndex = Me, Ut.$unmergeCell = pt, Ut.INSERT_TABLE_COMMAND = at, Ut.TableCellHeaderStates = o, Ut.TableCellNode = f, Ut.TableNode = Y, Ut.TableRowNode = O, Ut.TableSelection = N, Ut.applyTableHandlers = F, Ut.getCellFromTarget = K, Ut.getTableSelectionFromTableElement = I, Ut;
}
var uc, bd;
function Kc() {
  return bd || (bd = 1, uc = process.env.NODE_ENV === "development" ? k_() : I_()), uc;
}
var Md;
function $_() {
  if (Md)
    return cc;
  Md = 1;
  var e = kn(), t = Kc(), r = Jt(), o = kt(), f = rn;
  function h(C) {
    let T = new URLSearchParams();
    T.append("code", C);
    for (let O = 1; O < arguments.length; O++)
      T.append("v", arguments[O]);
    throw Error(`Minified Lexical error #${C}; visit https://lexical.dev/docs/error?${T} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }
  return cc.TablePlugin = function({ hasCellMerge: C = !0, hasCellBackgroundColor: T = !0, hasTabHandler: O = !0 }) {
    let [S] = e.useLexicalComposerContext();
    return f.useEffect(() => (S.hasNodes([t.TableNode, t.TableCellNode, t.TableRowNode]) || h(10), S.registerCommand(t.INSERT_TABLE_COMMAND, ({ columns: x, rows: D, includeHeaders: k }) => (x = t.$createTableNodeWithDimensions(Number(D), Number(x), k), r.$insertNodeToNearestRoot(x), x = x.getFirstDescendant(), o.$isTextNode(x) && x.select(), !0), o.COMMAND_PRIORITY_EDITOR)), [S]), f.useEffect(
      () => {
        let x = /* @__PURE__ */ new Map(), D = (H) => {
          const N = H.getKey(), v = S.getElementByKey(N);
          v && !x.has(N) && (H = t.applyTableHandlers(H, v, S, O), x.set(N, H));
        };
        S.getEditorState().read(() => {
          let H = o.$nodesOfType(t.TableNode);
          for (let N of H)
            t.$isTableNode(N) && D(N);
        });
        let k = S.registerMutationListener(t.TableNode, (H) => {
          for (const [N, v] of H)
            v === "created" ? S.getEditorState().read(() => {
              const F = o.$getNodeByKey(N);
              t.$isTableNode(F) && D(F);
            }) : v === "destroyed" && (H = x.get(N), H !== void 0 && (H.removeListeners(), x.delete(N)));
        });
        return () => {
          k();
          for (let [, H] of x)
            H.removeListeners();
        };
      },
      [S, O]
    ), f.useEffect(() => {
      if (!C)
        return S.registerNodeTransform(t.TableCellNode, (x) => {
          if (1 < x.getColSpan() || 1 < x.getRowSpan()) {
            var [, , D] = o.DEPRECATED_$getNodeTriplet(x);
            [x] = o.DEPRECATED_$computeGridMap(D, x, x);
            let H = x.length, N = x[0].length;
            if (D = D.getFirstChild(), !o.DEPRECATED_$isGridRowNode(D))
              throw Error("Expected TableNode first child to be a RowNode");
            let v = [];
            for (let F = 0; F < H; F++) {
              if (F !== 0 && (D = D.getNextSibling(), !o.DEPRECATED_$isGridRowNode(D)))
                throw Error("Expected TableNode first child to be a RowNode");
              let U = null;
              for (let I = 0; I < N; I++) {
                var k = x[F][I];
                let K = k.cell;
                k.startRow === F && k.startColumn === I ? (U = K, v.push(K)) : (1 < K.getColSpan() || 1 < K.getRowSpan()) && (k = t.$createTableCellNode(K.__headerState), U !== null ? U.insertAfter(k) : r.$insertFirst(D, k));
              }
            }
            for (let F of v)
              F.setColSpan(1), F.setRowSpan(1);
          }
        });
    }, [S, C]), f.useEffect(() => {
      if (!T)
        return S.registerNodeTransform(t.TableCellNode, (x) => {
          x.getBackgroundColor() !== null && x.setBackgroundColor(null);
        });
    }, [S, T, C]), null;
  }, cc;
}
var dc = {}, Ld;
function F_() {
  if (Ld)
    return dc;
  Ld = 1;
  var e = kn(), t = Kc(), r = Jt(), o = kt(), f = rn;
  function h({
    hasCellMerge: C = !0,
    hasCellBackgroundColor: T = !0,
    hasTabHandler: O = !0
  }) {
    const [S] = e.useLexicalComposerContext();
    return f.useEffect(() => {
      if (!S.hasNodes([t.TableNode, t.TableCellNode, t.TableRowNode]))
        throw Error("TablePlugin: TableNode, TableCellNode or TableRowNode not registered on editor");
      return S.registerCommand(t.INSERT_TABLE_COMMAND, ({
        columns: x,
        rows: D,
        includeHeaders: k
      }) => {
        const H = t.$createTableNodeWithDimensions(Number(D), Number(x), k);
        r.$insertNodeToNearestRoot(H);
        const N = H.getFirstDescendant();
        return o.$isTextNode(N) && N.select(), !0;
      }, o.COMMAND_PRIORITY_EDITOR);
    }, [S]), f.useEffect(() => {
      const x = /* @__PURE__ */ new Map(), D = (H) => {
        const N = H.getKey(), v = S.getElementByKey(N);
        if (v && !x.has(N)) {
          const F = t.applyTableHandlers(H, v, S, O);
          x.set(N, F);
        }
      };
      S.getEditorState().read(() => {
        const H = o.$nodesOfType(t.TableNode);
        for (const N of H)
          t.$isTableNode(N) && D(N);
      });
      const k = S.registerMutationListener(t.TableNode, (H) => {
        for (const [N, v] of H)
          if (v === "created")
            S.getEditorState().read(() => {
              const F = o.$getNodeByKey(N);
              t.$isTableNode(F) && D(F);
            });
          else if (v === "destroyed") {
            const F = x.get(N);
            F !== void 0 && (F.removeListeners(), x.delete(N));
          }
      });
      return () => {
        k();
        for (const [, H] of x)
          H.removeListeners();
      };
    }, [S, O]), f.useEffect(() => {
      if (!C)
        return S.registerNodeTransform(t.TableCellNode, (x) => {
          if (x.getColSpan() > 1 || x.getRowSpan() > 1) {
            const [, , D] = o.DEPRECATED_$getNodeTriplet(x), [k] = o.DEPRECATED_$computeGridMap(D, x, x), H = k.length, N = k[0].length;
            let v = D.getFirstChild();
            if (!o.DEPRECATED_$isGridRowNode(v))
              throw Error("Expected TableNode first child to be a RowNode");
            const F = [];
            for (let U = 0; U < H; U++) {
              if (U !== 0 && (v = v.getNextSibling(), !o.DEPRECATED_$isGridRowNode(v)))
                throw Error("Expected TableNode first child to be a RowNode");
              let I = null;
              for (let K = 0; K < N; K++) {
                const B = k[U][K], z = B.cell;
                if (B.startRow === U && B.startColumn === K)
                  I = z, F.push(z);
                else if (z.getColSpan() > 1 || z.getRowSpan() > 1) {
                  const te = t.$createTableCellNode(z.__headerState);
                  I !== null ? I.insertAfter(te) : r.$insertFirst(v, te);
                }
              }
            }
            for (const U of F)
              U.setColSpan(1), U.setRowSpan(1);
          }
        });
    }, [S, C]), f.useEffect(() => {
      if (!T)
        return S.registerNodeTransform(t.TableCellNode, (x) => {
          x.getBackgroundColor() !== null && x.setBackgroundColor(null);
        });
    }, [S, T, C]), null;
  }
  return dc.TablePlugin = h, dc;
}
const B_ = process.env.NODE_ENV === "development" ? F_() : $_();
var K_ = B_, En = {}, fc = { exports: {} }, Pd;
function uh() {
  return Pd || (Pd = 1, function(e) {
    var t = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};
    /**
     * Prism: Lightweight, robust, elegant syntax highlighting
     *
     * @license MIT <https://opensource.org/licenses/MIT>
     * @author Lea Verou <https://lea.verou.me>
     * @namespace
     * @public
     */
    var r = function(o) {
      var f = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, h = 0, C = {}, T = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: o.Prism && o.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: o.Prism && o.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function I(K) {
            return K instanceof O ? new O(K.type, I(K.content), K.alias) : Array.isArray(K) ? K.map(I) : K.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(I) {
            return Object.prototype.toString.call(I).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(I) {
            return I.__id || Object.defineProperty(I, "__id", { value: ++h }), I.__id;
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function I(K, B) {
            B = B || {};
            var z, te;
            switch (T.util.type(K)) {
              case "Object":
                if (te = T.util.objId(K), B[te])
                  return B[te];
                z = /** @type {Record<string, any>} */
                {}, B[te] = z;
                for (var re in K)
                  K.hasOwnProperty(re) && (z[re] = I(K[re], B));
                return (
                  /** @type {any} */
                  z
                );
              case "Array":
                return te = T.util.objId(K), B[te] ? B[te] : (z = [], B[te] = z, /** @type {Array} */
                /** @type {any} */
                K.forEach(function(de, V) {
                  z[V] = I(de, B);
                }), /** @type {any} */
                z);
              default:
                return K;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(I) {
            for (; I; ) {
              var K = f.exec(I.className);
              if (K)
                return K[1].toLowerCase();
              I = I.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(I, K) {
            I.className = I.className.replace(RegExp(f, "gi"), ""), I.classList.add("language-" + K);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document > "u")
              return null;
            if ("currentScript" in document && 1 < 2)
              return (
                /** @type {any} */
                document.currentScript
              );
            try {
              throw new Error();
            } catch (z) {
              var I = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(z.stack) || [])[1];
              if (I) {
                var K = document.getElementsByTagName("script");
                for (var B in K)
                  if (K[B].src == I)
                    return K[B];
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(I, K, B) {
            for (var z = "no-" + K; I; ) {
              var te = I.classList;
              if (te.contains(K))
                return !0;
              if (te.contains(z))
                return !1;
              I = I.parentElement;
            }
            return !!B;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: C,
          plaintext: C,
          text: C,
          txt: C,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(I, K) {
            var B = T.util.clone(T.languages[I]);
            for (var z in K)
              B[z] = K[z];
            return B;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(I, K, B, z) {
            z = z || /** @type {any} */
            T.languages;
            var te = z[I], re = {};
            for (var de in te)
              if (te.hasOwnProperty(de)) {
                if (de == K)
                  for (var V in B)
                    B.hasOwnProperty(V) && (re[V] = B[V]);
                B.hasOwnProperty(de) || (re[de] = te[de]);
              }
            var G = z[I];
            return z[I] = re, T.languages.DFS(T.languages, function(q, me) {
              me === G && q != I && (this[q] = re);
            }), re;
          },
          // Traverse a language definition with Depth First Search
          DFS: function I(K, B, z, te) {
            te = te || {};
            var re = T.util.objId;
            for (var de in K)
              if (K.hasOwnProperty(de)) {
                B.call(K, de, K[de], z || de);
                var V = K[de], G = T.util.type(V);
                G === "Object" && !te[re(V)] ? (te[re(V)] = !0, I(V, B, null, te)) : G === "Array" && !te[re(V)] && (te[re(V)] = !0, I(V, B, de, te));
              }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prism’s API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function(I, K) {
          T.highlightAllUnder(document, I, K);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function(I, K, B) {
          var z = {
            callback: B,
            container: I,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          T.hooks.run("before-highlightall", z), z.elements = Array.prototype.slice.apply(z.container.querySelectorAll(z.selector)), T.hooks.run("before-all-elements-highlight", z);
          for (var te = 0, re; re = z.elements[te++]; )
            T.highlightElement(re, K === !0, z.callback);
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function(I, K, B) {
          var z = T.util.getLanguage(I), te = T.languages[z];
          T.util.setLanguage(I, z);
          var re = I.parentElement;
          re && re.nodeName.toLowerCase() === "pre" && T.util.setLanguage(re, z);
          var de = I.textContent, V = {
            element: I,
            language: z,
            grammar: te,
            code: de
          };
          function G(me) {
            V.highlightedCode = me, T.hooks.run("before-insert", V), V.element.innerHTML = V.highlightedCode, T.hooks.run("after-highlight", V), T.hooks.run("complete", V), B && B.call(V.element);
          }
          if (T.hooks.run("before-sanity-check", V), re = V.element.parentElement, re && re.nodeName.toLowerCase() === "pre" && !re.hasAttribute("tabindex") && re.setAttribute("tabindex", "0"), !V.code) {
            T.hooks.run("complete", V), B && B.call(V.element);
            return;
          }
          if (T.hooks.run("before-highlight", V), !V.grammar) {
            G(T.util.encode(V.code));
            return;
          }
          if (K && o.Worker) {
            var q = new Worker(T.filename);
            q.onmessage = function(me) {
              G(me.data);
            }, q.postMessage(JSON.stringify({
              language: V.language,
              code: V.code,
              immediateClose: !0
            }));
          } else
            G(T.highlight(V.code, V.grammar, V.language));
        },
        /**
         * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(I, K, B) {
          var z = {
            code: I,
            grammar: K,
            language: B
          };
          if (T.hooks.run("before-tokenize", z), !z.grammar)
            throw new Error('The language "' + z.language + '" has no grammar.');
          return z.tokens = T.tokenize(z.code, z.grammar), T.hooks.run("after-tokenize", z), O.stringify(T.util.encode(z.tokens), z.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(I, K) {
          var B = K.rest;
          if (B) {
            for (var z in B)
              K[z] = B[z];
            delete K.rest;
          }
          var te = new D();
          return k(te, te.head, I), x(I, te, K, te.head, 0), N(te);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(I, K) {
            var B = T.hooks.all;
            B[I] = B[I] || [], B[I].push(K);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(I, K) {
            var B = T.hooks.all[I];
            if (!(!B || !B.length))
              for (var z = 0, te; te = B[z++]; )
                te(K);
          }
        },
        Token: O
      };
      o.Prism = T;
      function O(I, K, B, z) {
        this.type = I, this.content = K, this.alias = B, this.length = (z || "").length | 0;
      }
      O.stringify = function I(K, B) {
        if (typeof K == "string")
          return K;
        if (Array.isArray(K)) {
          var z = "";
          return K.forEach(function(G) {
            z += I(G, B);
          }), z;
        }
        var te = {
          type: K.type,
          content: I(K.content, B),
          tag: "span",
          classes: ["token", K.type],
          attributes: {},
          language: B
        }, re = K.alias;
        re && (Array.isArray(re) ? Array.prototype.push.apply(te.classes, re) : te.classes.push(re)), T.hooks.run("wrap", te);
        var de = "";
        for (var V in te.attributes)
          de += " " + V + '="' + (te.attributes[V] || "").replace(/"/g, "&quot;") + '"';
        return "<" + te.tag + ' class="' + te.classes.join(" ") + '"' + de + ">" + te.content + "</" + te.tag + ">";
      };
      function S(I, K, B, z) {
        I.lastIndex = K;
        var te = I.exec(B);
        if (te && z && te[1]) {
          var re = te[1].length;
          te.index += re, te[0] = te[0].slice(re);
        }
        return te;
      }
      function x(I, K, B, z, te, re) {
        for (var de in B)
          if (!(!B.hasOwnProperty(de) || !B[de])) {
            var V = B[de];
            V = Array.isArray(V) ? V : [V];
            for (var G = 0; G < V.length; ++G) {
              if (re && re.cause == de + "," + G)
                return;
              var q = V[G], me = q.inside, pe = !!q.lookbehind, Z = !!q.greedy, ee = q.alias;
              if (Z && !q.pattern.global) {
                var P = q.pattern.toString().match(/[imsuy]*$/)[0];
                q.pattern = RegExp(q.pattern.source, P + "g");
              }
              for (var w = q.pattern || q, j = z.next, ne = te; j !== K.tail && !(re && ne >= re.reach); ne += j.value.length, j = j.next) {
                var Y = j.value;
                if (K.length > I.length)
                  return;
                if (!(Y instanceof O)) {
                  var W = 1, Q;
                  if (Z) {
                    if (Q = S(w, ne, I, pe), !Q || Q.index >= I.length)
                      break;
                    var A = Q.index, b = Q.index + Q[0].length, g = ne;
                    for (g += j.value.length; A >= g; )
                      j = j.next, g += j.value.length;
                    if (g -= j.value.length, ne = g, j.value instanceof O)
                      continue;
                    for (var _ = j; _ !== K.tail && (g < b || typeof _.value == "string"); _ = _.next)
                      W++, g += _.value.length;
                    W--, Y = I.slice(ne, g), Q.index -= ne;
                  } else if (Q = S(w, 0, Y, pe), !Q)
                    continue;
                  var A = Q.index, J = Q[0], ce = Y.slice(0, A), ge = Y.slice(A + J.length), ae = ne + Y.length;
                  re && ae > re.reach && (re.reach = ae);
                  var Te = j.prev;
                  ce && (Te = k(K, Te, ce), ne += ce.length), H(K, Te, W);
                  var Me = new O(de, me ? T.tokenize(J, me) : J, ee, J);
                  if (j = k(K, Te, Me), ge && k(K, j, ge), W > 1) {
                    var ze = {
                      cause: de + "," + G,
                      reach: ae
                    };
                    x(I, K, B, j.prev, ne, ze), re && ze.reach > re.reach && (re.reach = ze.reach);
                  }
                }
              }
            }
          }
      }
      function D() {
        var I = { value: null, prev: null, next: null }, K = { value: null, prev: I, next: null };
        I.next = K, this.head = I, this.tail = K, this.length = 0;
      }
      function k(I, K, B) {
        var z = K.next, te = { value: B, prev: K, next: z };
        return K.next = te, z.prev = te, I.length++, te;
      }
      function H(I, K, B) {
        for (var z = K.next, te = 0; te < B && z !== I.tail; te++)
          z = z.next;
        K.next = z, z.prev = K, I.length -= te;
      }
      function N(I) {
        for (var K = [], B = I.head.next; B !== I.tail; )
          K.push(B.value), B = B.next;
        return K;
      }
      if (!o.document)
        return o.addEventListener && (T.disableWorkerMessageHandler || o.addEventListener("message", function(I) {
          var K = JSON.parse(I.data), B = K.language, z = K.code, te = K.immediateClose;
          o.postMessage(T.highlight(z, T.languages[B], B)), te && o.close();
        }, !1)), T;
      var v = T.util.currentScript();
      v && (T.filename = v.src, v.hasAttribute("data-manual") && (T.manual = !0));
      function F() {
        T.manual || T.highlightAll();
      }
      if (!T.manual) {
        var U = document.readyState;
        U === "loading" || U === "interactive" && v && v.defer ? document.addEventListener("DOMContentLoaded", F) : window.requestAnimationFrame ? window.requestAnimationFrame(F) : window.setTimeout(F, 16);
      }
      return T;
    }(t);
    e.exports && (e.exports = r), typeof Cc < "u" && (Cc.Prism = r), r.languages.markup = {
      comment: {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: !0
      },
      prolog: {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: !0
      },
      doctype: {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: !0,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: !0,
            greedy: !0,
            inside: null
            // see below
          },
          string: {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: !0
          },
          punctuation: /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          name: /[^\s<>'"]+/
        }
      },
      cdata: {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: !0
      },
      tag: {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: !0,
        inside: {
          tag: {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              punctuation: /^<\/?/,
              namespace: /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: !0
                }
              ]
            }
          },
          punctuation: /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              namespace: /^[^\s>\/:]+:/
            }
          }
        }
      },
      entity: [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    }, r.languages.markup.tag.inside["attr-value"].inside.entity = r.languages.markup.entity, r.languages.markup.doctype.inside["internal-subset"].inside = r.languages.markup, r.hooks.add("wrap", function(o) {
      o.type === "entity" && (o.attributes.title = o.content.replace(/&amp;/, "&"));
    }), Object.defineProperty(r.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function(f, h) {
        var C = {};
        C["language-" + h] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: !0,
          inside: r.languages[h]
        }, C.cdata = /^<!\[CDATA\[|\]\]>$/i;
        var T = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: C
          }
        };
        T["language-" + h] = {
          pattern: /[\s\S]+/,
          inside: r.languages[h]
        };
        var O = {};
        O[f] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return f;
          }), "i"),
          lookbehind: !0,
          greedy: !0,
          inside: T
        }, r.languages.insertBefore("markup", "cdata", O);
      }
    }), Object.defineProperty(r.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(o, f) {
        r.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + o + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: !0,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                value: {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: !0,
                  alias: [f, "language-" + f],
                  inside: r.languages[f]
                },
                punctuation: [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    }), r.languages.html = r.languages.markup, r.languages.mathml = r.languages.markup, r.languages.svg = r.languages.markup, r.languages.xml = r.languages.extend("markup", {}), r.languages.ssml = r.languages.xml, r.languages.atom = r.languages.xml, r.languages.rss = r.languages.xml, function(o) {
      var f = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      o.languages.css = {
        comment: /\/\*[\s\S]*?\*\//,
        atrule: {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + f.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            rule: /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: !0,
              alias: "selector"
            },
            keyword: {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: !0
            }
            // See rest below
          }
        },
        url: {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp("\\burl\\((?:" + f.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: !0,
          inside: {
            function: /^url/i,
            punctuation: /^\(|\)$/,
            string: {
              pattern: RegExp("^" + f.source + "$"),
              alias: "url"
            }
          }
        },
        selector: {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + f.source + ")*(?=\\s*\\{)"),
          lookbehind: !0
        },
        string: {
          pattern: f,
          greedy: !0
        },
        property: {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: !0
        },
        important: /!important\b/i,
        function: {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: !0
        },
        punctuation: /[(){};:,]/
      }, o.languages.css.atrule.inside.rest = o.languages.css;
      var h = o.languages.markup;
      h && (h.tag.addInlined("style", "css"), h.tag.addAttribute("style", "css"));
    }(r), r.languages.clike = {
      comment: [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: !0,
        inside: {
          punctuation: /[.\\]/
        }
      },
      keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      boolean: /\b(?:false|true)\b/,
      function: /\b\w+(?=\()/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      punctuation: /[{}[\];(),.:]/
    }, r.languages.javascript = r.languages.extend("clike", {
      "class-name": [
        r.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: !0
        }
      ],
      keyword: [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: !0
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: !0
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      number: {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: !0
      },
      operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    }), r.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, r.languages.insertBefore("javascript", "keyword", {
      regex: {
        pattern: RegExp(
          // lookbehind
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
          // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
          // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
          // with the only syntax, so we have to define 2 different regex patterns.
          /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
          /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
          /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: !0,
            alias: "language-regex",
            inside: r.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      parameter: [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: !0,
          inside: r.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: !0,
          inside: r.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: !0,
          inside: r.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: !0,
          inside: r.languages.javascript
        }
      ],
      constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    }), r.languages.insertBefore("javascript", "string", {
      hashbang: {
        pattern: /^#!.*/,
        greedy: !0,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: !0,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: !0,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: r.languages.javascript
            }
          },
          string: /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: !0,
        greedy: !0,
        alias: "property"
      }
    }), r.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: !0,
        alias: "property"
      }
    }), r.languages.markup && (r.languages.markup.tag.addInlined("script", "javascript"), r.languages.markup.tag.addAttribute(
      /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
      "javascript"
    )), r.languages.js = r.languages.javascript, function() {
      if (typeof r > "u" || typeof document > "u")
        return;
      Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
      var o = "Loading…", f = function(v, F) {
        return "✖ Error " + v + " while fetching file: " + F;
      }, h = "✖ Error: File does not exist or is empty", C = {
        js: "javascript",
        py: "python",
        rb: "ruby",
        ps1: "powershell",
        psm1: "powershell",
        sh: "bash",
        bat: "batch",
        h: "c",
        tex: "latex"
      }, T = "data-src-status", O = "loading", S = "loaded", x = "failed", D = "pre[data-src]:not([" + T + '="' + S + '"]):not([' + T + '="' + O + '"])';
      function k(v, F, U) {
        var I = new XMLHttpRequest();
        I.open("GET", v, !0), I.onreadystatechange = function() {
          I.readyState == 4 && (I.status < 400 && I.responseText ? F(I.responseText) : I.status >= 400 ? U(f(I.status, I.statusText)) : U(h));
        }, I.send(null);
      }
      function H(v) {
        var F = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(v || "");
        if (F) {
          var U = Number(F[1]), I = F[2], K = F[3];
          return I ? K ? [U, Number(K)] : [U, void 0] : [U, U];
        }
      }
      r.hooks.add("before-highlightall", function(v) {
        v.selector += ", " + D;
      }), r.hooks.add("before-sanity-check", function(v) {
        var F = (
          /** @type {HTMLPreElement} */
          v.element
        );
        if (F.matches(D)) {
          v.code = "", F.setAttribute(T, O);
          var U = F.appendChild(document.createElement("CODE"));
          U.textContent = o;
          var I = F.getAttribute("data-src"), K = v.language;
          if (K === "none") {
            var B = (/\.(\w+)$/.exec(I) || [, "none"])[1];
            K = C[B] || B;
          }
          r.util.setLanguage(U, K), r.util.setLanguage(F, K);
          var z = r.plugins.autoloader;
          z && z.loadLanguages(K), k(
            I,
            function(te) {
              F.setAttribute(T, S);
              var re = H(F.getAttribute("data-range"));
              if (re) {
                var de = te.split(/\r\n?|\n/g), V = re[0], G = re[1] == null ? de.length : re[1];
                V < 0 && (V += de.length), V = Math.max(0, Math.min(V - 1, de.length)), G < 0 && (G += de.length), G = Math.max(0, Math.min(G, de.length)), te = de.slice(V, G).join(`
`), F.hasAttribute("data-start") || F.setAttribute("data-start", String(V + 1));
              }
              U.textContent = te, r.highlightElement(U);
            },
            function(te) {
              F.setAttribute(T, x), U.textContent = te;
            }
          );
        }
      }), r.plugins.fileHighlight = {
        /**
         * Executes the File Highlight plugin for all matching `pre` elements under the given container.
         *
         * Note: Elements which are already loaded or currently loading will not be touched by this method.
         *
         * @param {ParentNode} [container=document]
         */
        highlight: function(F) {
          for (var U = (F || document).querySelectorAll(D), I = 0, K; K = U[I++]; )
            r.highlightElement(K);
        }
      };
      var N = !1;
      r.fileHighlight = function() {
        N || (console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."), N = !0), r.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    }();
  }(fc)), fc.exports;
}
var Id = {}, kd;
function dh() {
  return kd || (kd = 1, Prism.languages.clike = {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        greedy: !0
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: !0,
      inside: {
        punctuation: /[.\\]/
      }
    },
    keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
  }), Id;
}
var $d = {}, Fd;
function fh() {
  return Fd || (Fd = 1, Prism.languages.javascript = Prism.languages.extend("clike", {
    "class-name": [
      Prism.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: !0
      }
    ],
    keyword: [
      {
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: !0
      }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    number: {
      pattern: RegExp(
        /(^|[^\w$])/.source + "(?:" + // constant
        (/NaN|Infinity/.source + "|" + // binary integer
        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
        /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
      ),
      lookbehind: !0
    },
    operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  }), Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, Prism.languages.insertBefore("javascript", "keyword", {
    regex: {
      pattern: RegExp(
        // lookbehind
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
        // with the only syntax, so we have to define 2 different regex patterns.
        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: !0,
          alias: "language-regex",
          inside: Prism.languages.regex
        },
        "regex-delimiter": /^\/|\/$/,
        "regex-flags": /^[a-z]+$/
      }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    },
    parameter: [
      {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: !0,
        inside: Prism.languages.javascript
      },
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: !0,
        inside: Prism.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: !0,
        inside: Prism.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: !0,
        inside: Prism.languages.javascript
      }
    ],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  }), Prism.languages.insertBefore("javascript", "string", {
    hashbang: {
      pattern: /^#!.*/,
      greedy: !0,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: !0,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: !0,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            rest: Prism.languages.javascript
          }
        },
        string: /[\s\S]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: !0,
      greedy: !0,
      alias: "property"
    }
  }), Prism.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: !0,
      alias: "property"
    }
  }), Prism.languages.markup && (Prism.languages.markup.tag.addInlined("script", "javascript"), Prism.languages.markup.tag.addAttribute(
    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    "javascript"
  )), Prism.languages.js = Prism.languages.javascript), $d;
}
var Bd = {}, Kd;
function hh() {
  return Kd || (Kd = 1, Prism.languages.markup = {
    comment: {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: !0
    },
    prolog: {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: !0
    },
    doctype: {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: !0,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: !0,
          greedy: !0,
          inside: null
          // see below
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: !0
        },
        punctuation: /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        name: /[^\s<>'"]+/
      }
    },
    cdata: {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: !0
    },
    tag: {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: !0,
      inside: {
        tag: {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            punctuation: /^<\/?/,
            namespace: /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            punctuation: [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: !0
              }
            ]
          }
        },
        punctuation: /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            namespace: /^[^\s>\/:]+:/
          }
        }
      }
    },
    entity: [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  }, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup, Prism.hooks.add("wrap", function(e) {
    e.type === "entity" && (e.attributes.title = e.content.replace(/&amp;/, "&"));
  }), Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function(t, r) {
      var o = {};
      o["language-" + r] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: !0,
        inside: Prism.languages[r]
      }, o.cdata = /^<!\[CDATA\[|\]\]>$/i;
      var f = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: o
        }
      };
      f["language-" + r] = {
        pattern: /[\s\S]+/,
        inside: Prism.languages[r]
      };
      var h = {};
      h[t] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return t;
        }), "i"),
        lookbehind: !0,
        greedy: !0,
        inside: f
      }, Prism.languages.insertBefore("markup", "cdata", h);
    }
  }), Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: function(e, t) {
      Prism.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + e + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: !0,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              value: {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: !0,
                alias: [t, "language-" + t],
                inside: Prism.languages[t]
              },
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  }), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend("markup", {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml), Bd;
}
var Hd = {}, Ud;
function gh() {
  return Ud || (Ud = 1, function(e) {
    var t = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
    function r(x) {
      return x = x.replace(/<inner>/g, function() {
        return t;
      }), RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + x + ")");
    }
    var o = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source, f = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
      return o;
    }), h = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
    e.languages.markdown = e.languages.extend("markup", {}), e.languages.insertBefore("markdown", "prolog", {
      "front-matter-block": {
        pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          punctuation: /^---|---$/,
          "front-matter": {
            pattern: /\S+(?:\s+\S+)*/,
            alias: ["yaml", "language-yaml"],
            inside: e.languages.yaml
          }
        }
      },
      blockquote: {
        // > ...
        pattern: /^>(?:[\t ]*>)*/m,
        alias: "punctuation"
      },
      table: {
        pattern: RegExp("^" + f + h + "(?:" + f + ")*", "m"),
        inside: {
          "table-data-rows": {
            pattern: RegExp("^(" + f + h + ")(?:" + f + ")*$"),
            lookbehind: !0,
            inside: {
              "table-data": {
                pattern: RegExp(o),
                inside: e.languages.markdown
              },
              punctuation: /\|/
            }
          },
          "table-line": {
            pattern: RegExp("^(" + f + ")" + h + "$"),
            lookbehind: !0,
            inside: {
              punctuation: /\||:?-{3,}:?/
            }
          },
          "table-header-row": {
            pattern: RegExp("^" + f + "$"),
            inside: {
              "table-header": {
                pattern: RegExp(o),
                alias: "important",
                inside: e.languages.markdown
              },
              punctuation: /\|/
            }
          }
        }
      },
      code: [
        {
          // Prefixed by 4 spaces or 1 tab and preceded by an empty line
          pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
          lookbehind: !0,
          alias: "keyword"
        },
        {
          // ```optional language
          // code block
          // ```
          pattern: /^```[\s\S]*?^```$/m,
          greedy: !0,
          inside: {
            "code-block": {
              pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
              lookbehind: !0
            },
            "code-language": {
              pattern: /^(```).+/,
              lookbehind: !0
            },
            punctuation: /```/
          }
        }
      ],
      title: [
        {
          // title 1
          // =======
          // title 2
          // -------
          pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
          alias: "important",
          inside: {
            punctuation: /==+$|--+$/
          }
        },
        {
          // # title 1
          // ###### title 6
          pattern: /(^\s*)#.+/m,
          lookbehind: !0,
          alias: "important",
          inside: {
            punctuation: /^#+|#+$/
          }
        }
      ],
      hr: {
        // ***
        // ---
        // * * *
        // -----------
        pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
        lookbehind: !0,
        alias: "punctuation"
      },
      list: {
        // * item
        // + item
        // - item
        // 1. item
        pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
        lookbehind: !0,
        alias: "punctuation"
      },
      "url-reference": {
        // [id]: http://example.com "Optional title"
        // [id]: http://example.com 'Optional title'
        // [id]: http://example.com (Optional title)
        // [id]: <http://example.com> "Optional title"
        pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
        inside: {
          variable: {
            pattern: /^(!?\[)[^\]]+/,
            lookbehind: !0
          },
          string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
          punctuation: /^[\[\]!:]|[<>]/
        },
        alias: "url"
      },
      bold: {
        // **strong**
        // __strong__
        // allow one nested instance of italic text using the same delimiter
        pattern: r(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
        lookbehind: !0,
        greedy: !0,
        inside: {
          content: {
            pattern: /(^..)[\s\S]+(?=..$)/,
            lookbehind: !0,
            inside: {}
            // see below
          },
          punctuation: /\*\*|__/
        }
      },
      italic: {
        // *em*
        // _em_
        // allow one nested instance of bold text using the same delimiter
        pattern: r(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
        lookbehind: !0,
        greedy: !0,
        inside: {
          content: {
            pattern: /(^.)[\s\S]+(?=.$)/,
            lookbehind: !0,
            inside: {}
            // see below
          },
          punctuation: /[*_]/
        }
      },
      strike: {
        // ~~strike through~~
        // ~strike~
        // eslint-disable-next-line regexp/strict
        pattern: r(/(~~?)(?:(?!~)<inner>)+\2/.source),
        lookbehind: !0,
        greedy: !0,
        inside: {
          content: {
            pattern: /(^~~?)[\s\S]+(?=\1$)/,
            lookbehind: !0,
            inside: {}
            // see below
          },
          punctuation: /~~?/
        }
      },
      "code-snippet": {
        // `code`
        // ``code``
        pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
        lookbehind: !0,
        greedy: !0,
        alias: ["code", "keyword"]
      },
      url: {
        // [example](http://example.com "Optional title")
        // [example][id]
        // [example] [id]
        pattern: r(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
        lookbehind: !0,
        greedy: !0,
        inside: {
          operator: /^!/,
          content: {
            pattern: /(^\[)[^\]]+(?=\])/,
            lookbehind: !0,
            inside: {}
            // see below
          },
          variable: {
            pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
            lookbehind: !0
          },
          url: {
            pattern: /(^\]\()[^\s)]+/,
            lookbehind: !0
          },
          string: {
            pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
            lookbehind: !0
          }
        }
      }
    }), ["url", "bold", "italic", "strike"].forEach(function(x) {
      ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(D) {
        x !== D && (e.languages.markdown[x].inside.content.inside[D] = e.languages.markdown[D]);
      });
    }), e.hooks.add("after-tokenize", function(x) {
      if (x.language !== "markdown" && x.language !== "md")
        return;
      function D(k) {
        if (!(!k || typeof k == "string"))
          for (var H = 0, N = k.length; H < N; H++) {
            var v = k[H];
            if (v.type !== "code") {
              D(v.content);
              continue;
            }
            var F = v.content[1], U = v.content[3];
            if (F && U && F.type === "code-language" && U.type === "code-block" && typeof F.content == "string") {
              var I = F.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
              I = (/[a-z][\w-]*/i.exec(I) || [""])[0].toLowerCase();
              var K = "language-" + I;
              U.alias ? typeof U.alias == "string" ? U.alias = [U.alias, K] : U.alias.push(K) : U.alias = [K];
            }
          }
      }
      D(x.tokens);
    }), e.hooks.add("wrap", function(x) {
      if (x.type === "code-block") {
        for (var D = "", k = 0, H = x.classes.length; k < H; k++) {
          var N = x.classes[k], v = /language-(.+)/.exec(N);
          if (v) {
            D = v[1];
            break;
          }
        }
        var F = e.languages[D];
        if (F)
          x.content = e.highlight(S(x.content), F, D);
        else if (D && D !== "none" && e.plugins.autoloader) {
          var U = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
          x.attributes.id = U, e.plugins.autoloader.loadLanguages(D, function() {
            var I = document.getElementById(U);
            I && (I.innerHTML = e.highlight(I.textContent, e.languages[D], D));
          });
        }
      }
    });
    var C = RegExp(e.languages.markup.tag.pattern.source, "gi"), T = {
      amp: "&",
      lt: "<",
      gt: ">",
      quot: '"'
    }, O = String.fromCodePoint || String.fromCharCode;
    function S(x) {
      var D = x.replace(C, "");
      return D = D.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(k, H) {
        if (H = H.toLowerCase(), H[0] === "#") {
          var N;
          return H[1] === "x" ? N = parseInt(H.slice(2), 16) : N = Number(H.slice(1)), O(N);
        } else {
          var v = T[H];
          return v || k;
        }
      }), D;
    }
    e.languages.md = e.languages.markdown;
  }(Prism)), Hd;
}
var Wd = {}, zd;
function ph() {
  return zd || (zd = 1, Prism.languages.c = Prism.languages.extend("clike", {
    comment: {
      pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
      greedy: !0
    },
    string: {
      // https://en.cppreference.com/w/c/language/string_literal
      pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
      lookbehind: !0
    },
    keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
    operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
  }), Prism.languages.insertBefore("c", "string", {
    char: {
      // https://en.cppreference.com/w/c/language/character_constant
      pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
      greedy: !0
    }
  }), Prism.languages.insertBefore("c", "string", {
    macro: {
      // allow for multiline macro definitions
      // spaces after the # character compile fine with gcc
      pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
      lookbehind: !0,
      greedy: !0,
      alias: "property",
      inside: {
        string: [
          {
            // highlight the path of the include statement as a string
            pattern: /^(#\s*include\s*)<[^>]+>/,
            lookbehind: !0
          },
          Prism.languages.c.string
        ],
        char: Prism.languages.c.char,
        comment: Prism.languages.c.comment,
        "macro-name": [
          {
            pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
            lookbehind: !0
          },
          {
            pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
            lookbehind: !0,
            alias: "function"
          }
        ],
        // highlight macro directives as keywords
        directive: {
          pattern: /^(#\s*)[a-z]+/,
          lookbehind: !0,
          alias: "keyword"
        },
        "directive-hash": /^#/,
        punctuation: /##|\\(?=[\r\n])/,
        expression: {
          pattern: /\S[\s\S]*/,
          inside: Prism.languages.c
        }
      }
    }
  }), Prism.languages.insertBefore("c", "function", {
    // highlight predefined macros as constants
    constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
  }), delete Prism.languages.c.boolean), Wd;
}
var Gd = {}, Yd;
function _h() {
  return Yd || (Yd = 1, function(e) {
    var t = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    e.languages.css = {
      comment: /\/\*[\s\S]*?\*\//,
      atrule: {
        pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + t.source + ")*?" + /(?:;|(?=\s*\{))/.source),
        inside: {
          rule: /^@[\w-]+/,
          "selector-function-argument": {
            pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
            lookbehind: !0,
            alias: "selector"
          },
          keyword: {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: !0
          }
          // See rest below
        }
      },
      url: {
        // https://drafts.csswg.org/css-values-3/#urls
        pattern: RegExp("\\burl\\((?:" + t.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
        greedy: !0,
        inside: {
          function: /^url/i,
          punctuation: /^\(|\)$/,
          string: {
            pattern: RegExp("^" + t.source + "$"),
            alias: "url"
          }
        }
      },
      selector: {
        pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + t.source + ")*(?=\\s*\\{)"),
        lookbehind: !0
      },
      string: {
        pattern: t,
        greedy: !0
      },
      property: {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: !0
      },
      important: /!important\b/i,
      function: {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: !0
      },
      punctuation: /[(){};:,]/
    }, e.languages.css.atrule.inside.rest = e.languages.css;
    var r = e.languages.markup;
    r && (r.tag.addInlined("style", "css"), r.tag.addAttribute("style", "css"));
  }(Prism)), Gd;
}
var jd = {}, qd;
function mh() {
  return qd || (qd = 1, Prism.languages.objectivec = Prism.languages.extend("c", {
    string: {
      pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: !0
    },
    keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
    operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
  }), delete Prism.languages.objectivec["class-name"], Prism.languages.objc = Prism.languages.objectivec), jd;
}
var Vd = {}, Jd;
function yh() {
  return Jd || (Jd = 1, Prism.languages.sql = {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
      lookbehind: !0
    },
    variable: [
      {
        pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
        greedy: !0
      },
      /@[\w.$]+/
    ],
    string: {
      pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
      greedy: !0,
      lookbehind: !0
    },
    identifier: {
      pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
      greedy: !0,
      lookbehind: !0,
      inside: {
        punctuation: /^`|`$/
      }
    },
    function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
    // Should we highlight user defined functions too?
    keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
    boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
    number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
    operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
    punctuation: /[;[\]()`,.]/
  }), Vd;
}
var Zd = {}, Xd;
function Ch() {
  return Xd || (Xd = 1, Prism.languages.python = {
    comment: {
      pattern: /(^|[^\\])#.*/,
      lookbehind: !0,
      greedy: !0
    },
    "string-interpolation": {
      pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
      greedy: !0,
      inside: {
        interpolation: {
          // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
          pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
          lookbehind: !0,
          inside: {
            "format-spec": {
              pattern: /(:)[^:(){}]+(?=\}$)/,
              lookbehind: !0
            },
            "conversion-option": {
              pattern: /![sra](?=[:}]$)/,
              alias: "punctuation"
            },
            rest: null
          }
        },
        string: /[\s\S]+/
      }
    },
    "triple-quoted-string": {
      pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
      greedy: !0,
      alias: "string"
    },
    string: {
      pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
      greedy: !0
    },
    function: {
      pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
      lookbehind: !0
    },
    "class-name": {
      pattern: /(\bclass\s+)\w+/i,
      lookbehind: !0
    },
    decorator: {
      pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
      lookbehind: !0,
      alias: ["annotation", "punctuation"],
      inside: {
        punctuation: /\./
      }
    },
    keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
    builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
    boolean: /\b(?:False|None|True)\b/,
    number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
    operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
    punctuation: /[{}[\];(),.:]/
  }, Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python, Prism.languages.py = Prism.languages.python), Zd;
}
var Qd = {}, ef;
function Nh() {
  return ef || (ef = 1, function(e) {
    for (var t = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source, r = 0; r < 2; r++)
      t = t.replace(/<self>/g, function() {
        return t;
      });
    t = t.replace(/<self>/g, function() {
      return /[^\s\S]/.source;
    }), e.languages.rust = {
      comment: [
        {
          pattern: RegExp(/(^|[^\\])/.source + t),
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      string: {
        pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
        greedy: !0
      },
      char: {
        pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
        greedy: !0
      },
      attribute: {
        pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
        greedy: !0,
        alias: "attr-name",
        inside: {
          string: null
          // see below
        }
      },
      // Closure params should not be confused with bitwise OR |
      "closure-params": {
        pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          "closure-punctuation": {
            pattern: /^\||\|$/,
            alias: "punctuation"
          },
          rest: null
          // see below
        }
      },
      "lifetime-annotation": {
        pattern: /'\w+/,
        alias: "symbol"
      },
      "fragment-specifier": {
        pattern: /(\$\w+:)[a-z]+/,
        lookbehind: !0,
        alias: "punctuation"
      },
      variable: /\$\w+/,
      "function-definition": {
        pattern: /(\bfn\s+)\w+/,
        lookbehind: !0,
        alias: "function"
      },
      "type-definition": {
        pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
        lookbehind: !0,
        alias: "class-name"
      },
      "module-declaration": [
        {
          pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
          lookbehind: !0,
          alias: "namespace"
        },
        {
          pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
          lookbehind: !0,
          alias: "namespace",
          inside: {
            punctuation: /::/
          }
        }
      ],
      keyword: [
        // https://github.com/rust-lang/reference/blob/master/src/keywords.md
        /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
        // primitives and str
        // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
        /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
      ],
      // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
      // and Rust's naming conventions recommend snake_case anyway.
      // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
      function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
      macro: {
        pattern: /\b\w+!/,
        alias: "property"
      },
      constant: /\b[A-Z_][A-Z_\d]+\b/,
      "class-name": /\b[A-Z]\w*\b/,
      namespace: {
        pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
        inside: {
          punctuation: /::/
        }
      },
      // Hex, oct, bin, dec numbers with visual separators and type suffix
      number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
      boolean: /\b(?:false|true)\b/,
      punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
      operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
    }, e.languages.rust["closure-params"].inside.rest = e.languages.rust, e.languages.rust.attribute.inside.string = e.languages.rust.string;
  }(Prism)), Qd;
}
var tf = {}, nf;
function Eh() {
  return nf || (nf = 1, Prism.languages.swift = {
    comment: {
      // Nested comments are supported up to 2 levels
      pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
      lookbehind: !0,
      greedy: !0
    },
    "string-literal": [
      // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
      {
        pattern: RegExp(
          /(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: !0,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\\($/,
            alias: "punctuation"
          },
          punctuation: /\\(?=[\r\n])/,
          string: /[\s\S]+/
        }
      },
      {
        pattern: RegExp(
          /(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: !0,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\#+\($/,
            alias: "punctuation"
          },
          string: /[\s\S]+/
        }
      }
    ],
    directive: {
      // directives with conditions
      pattern: RegExp(
        /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
      ),
      alias: "property",
      inside: {
        "directive-name": /^#\w+/,
        boolean: /\b(?:false|true)\b/,
        number: /\b\d+(?:\.\d+)*\b/,
        operator: /!|&&|\|\||[<>]=?/,
        punctuation: /[(),]/
      }
    },
    literal: {
      pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
      alias: "constant"
    },
    "other-directive": {
      pattern: /#\w+\b/,
      alias: "property"
    },
    attribute: {
      pattern: /@\w+/,
      alias: "atrule"
    },
    "function-definition": {
      pattern: /(\bfunc\s+)\w+/,
      lookbehind: !0,
      alias: "function"
    },
    label: {
      // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
      pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
      lookbehind: !0,
      alias: "important"
    },
    keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
    boolean: /\b(?:false|true)\b/,
    nil: {
      pattern: /\bnil\b/,
      alias: "constant"
    },
    "short-argument": /\$\d+\b/,
    omit: {
      pattern: /\b_\b/,
      alias: "keyword"
    },
    number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
    // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
    "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
    // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
    // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
    // This regex only supports ASCII operators.
    operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
    punctuation: /[{}[\]();,.:\\]/
  }, Prism.languages.swift["string-literal"].forEach(function(e) {
    e.inside.interpolation.inside = Prism.languages.swift;
  })), tf;
}
var rf = {}, of;
function Th() {
  return of || (of = 1, function(e) {
    e.languages.typescript = e.languages.extend("javascript", {
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
        lookbehind: !0,
        greedy: !0,
        inside: null
        // see below
      },
      builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
    }), e.languages.typescript.keyword.push(
      /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
      // keywords that have to be followed by an identifier
      /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
      // This is for `import type *, {}`
      /\btype\b(?=\s*(?:[\{*]|$))/
    ), delete e.languages.typescript.parameter, delete e.languages.typescript["literal-property"];
    var t = e.languages.extend("typescript", {});
    delete t["class-name"], e.languages.typescript["class-name"].inside = t, e.languages.insertBefore("typescript", "function", {
      decorator: {
        pattern: /@[$\w\xA0-\uFFFF]+/,
        inside: {
          at: {
            pattern: /^@/,
            alias: "operator"
          },
          function: /^[\s\S]+/
        }
      },
      "generic-function": {
        // e.g. foo<T extends "bar" | "baz">( ...
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
        greedy: !0,
        inside: {
          function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
          generic: {
            pattern: /<[\s\S]+/,
            // everything after the first <
            alias: "class-name",
            inside: t
          }
        }
      }
    }), e.languages.ts = e.languages.typescript;
  }(Prism)), rf;
}
var sf = {}, lf;
function xh() {
  return lf || (lf = 1, function(e) {
    var t = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/, r = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source, o = {
      pattern: RegExp(/(^|[^\w.])/.source + r + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
      lookbehind: !0,
      inside: {
        namespace: {
          pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
          inside: {
            punctuation: /\./
          }
        },
        punctuation: /\./
      }
    };
    e.languages.java = e.languages.extend("clike", {
      string: {
        pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
        lookbehind: !0,
        greedy: !0
      },
      "class-name": [
        o,
        {
          // variables, parameters, and constructor references
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(/(^|[^\w.])/.source + r + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
          lookbehind: !0,
          inside: o.inside
        },
        {
          // class names based on keyword
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + r + /[A-Z]\w*\b/.source),
          lookbehind: !0,
          inside: o.inside
        }
      ],
      keyword: t,
      function: [
        e.languages.clike.function,
        {
          pattern: /(::\s*)[a-z_]\w*/,
          lookbehind: !0
        }
      ],
      number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
      operator: {
        pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
        lookbehind: !0
      },
      constant: /\b[A-Z][A-Z_\d]+\b/
    }), e.languages.insertBefore("java", "string", {
      "triple-quoted-string": {
        // http://openjdk.java.net/jeps/355#Description
        pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
        greedy: !0,
        alias: "string"
      },
      char: {
        pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
        greedy: !0
      }
    }), e.languages.insertBefore("java", "class-name", {
      annotation: {
        pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
        lookbehind: !0,
        alias: "punctuation"
      },
      generics: {
        pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
        inside: {
          "class-name": o,
          keyword: t,
          punctuation: /[<>(),.:]/,
          operator: /[?&|]/
        }
      },
      import: [
        {
          pattern: RegExp(/(\bimport\s+)/.source + r + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
          lookbehind: !0,
          inside: {
            namespace: o.inside.namespace,
            punctuation: /\./,
            operator: /\*/,
            "class-name": /\w+/
          }
        },
        {
          pattern: RegExp(/(\bimport\s+static\s+)/.source + r + /(?:\w+|\*)(?=\s*;)/.source),
          lookbehind: !0,
          alias: "static",
          inside: {
            namespace: o.inside.namespace,
            static: /\b\w+$/,
            punctuation: /\./,
            operator: /\*/,
            "class-name": /\w+/
          }
        }
      ],
      namespace: {
        pattern: RegExp(
          /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
            return t.source;
          })
        ),
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      }
    });
  }(Prism)), sf;
}
var af = {}, cf;
function vh() {
  return cf || (cf = 1, function(e) {
    var t = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, r = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
      return t.source;
    });
    e.languages.cpp = e.languages.extend("c", {
      "class-name": [
        {
          pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
            return t.source;
          })),
          lookbehind: !0
        },
        // This is intended to capture the class name of method implementations like:
        //   void foo::bar() const {}
        // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
        // it starts with an uppercase letter. This approximation should give decent results.
        /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
        // This will capture the class name before destructors like:
        //   Foo::~Foo() {}
        /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
        // This also intends to capture the class name of method implementations but here the class has template
        // parameters, so it can't be a namespace (until C++ adds generic namespaces).
        /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
      ],
      keyword: t,
      number: {
        pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
        greedy: !0
      },
      operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
      boolean: /\b(?:false|true)\b/
    }), e.languages.insertBefore("cpp", "string", {
      module: {
        // https://en.cppreference.com/w/cpp/language/modules
        pattern: RegExp(
          /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
          /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
          /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
            return r;
          }) + ")"
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          string: /^[<"][\s\S]+/,
          operator: /:/,
          punctuation: /\./
        }
      },
      "raw-string": {
        pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
        alias: "string",
        greedy: !0
      }
    }), e.languages.insertBefore("cpp", "keyword", {
      "generic-function": {
        pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
        inside: {
          function: /^\w+/,
          generic: {
            pattern: /<[\s\S]+/,
            alias: "class-name",
            inside: e.languages.cpp
          }
        }
      }
    }), e.languages.insertBefore("cpp", "operator", {
      "double-colon": {
        pattern: /::/,
        alias: "punctuation"
      }
    }), e.languages.insertBefore("cpp", "class-name", {
      // the base clause is an optional list of parent classes
      // https://en.cppreference.com/w/cpp/language/class
      "base-clause": {
        pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
        lookbehind: !0,
        greedy: !0,
        inside: e.languages.extend("cpp", {})
      }
    }), e.languages.insertBefore("inside", "double-colon", {
      // All untokenized words that are not namespaces should be class names
      "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
    }, e.languages.cpp["base-clause"]);
  }(Prism)), af;
}
var uf;
function H_() {
  if (uf)
    return En;
  uf = 1;
  var e = uh();
  dh(), fh(), hh(), gh(), ph(), _h(), mh(), yh(), Ch(), Nh(), Eh(), Th(), xh(), vh();
  var t = Jt(), r = kt();
  let o = (b) => b != null && e.languages.hasOwnProperty(b) ? b : void 0;
  function f(b, g) {
    for (let _ of b.childNodes) {
      if (t.isHTMLElement(_) && _.tagName === g)
        return !0;
      f(_, g);
    }
    return !1;
  }
  class h extends r.ElementNode {
    static getType() {
      return "code";
    }
    static clone(g) {
      return new h(g.__language, g.__key);
    }
    constructor(g, _) {
      super(_), this.__language = o(g);
    }
    createDOM(g) {
      let _ = document.createElement("code");
      return t.addClassNamesToElement(_, g.theme.code), _.setAttribute("spellcheck", "false"), (g = this.getLanguage()) && _.setAttribute("data-highlight-language", g), _;
    }
    updateDOM(g, _) {
      let A = this.__language;
      return g = g.__language, A ? A !== g && _.setAttribute("data-highlight-language", A) : g && _.removeAttribute("data-highlight-language"), !1;
    }
    exportDOM() {
      let g = document.createElement("pre");
      g.setAttribute("spellcheck", "false");
      let _ = this.getLanguage();
      return _ && g.setAttribute("data-highlight-language", _), { element: g };
    }
    static importDOM() {
      return { code: (g) => g.textContent != null && (/\r?\n/.test(g.textContent) || f(g, "BR")) ? { conversion: O, priority: 1 } : null, div: () => ({ conversion: S, priority: 1 }), pre: () => ({ conversion: O, priority: 0 }), table: (g) => N(g) ? { conversion: x, priority: 3 } : null, td: (g) => {
        let _ = g.closest("table");
        return g.classList.contains("js-file-line") ? { conversion: k, priority: 3 } : _ && N(_) ? { conversion: D, priority: 3 } : null;
      }, tr: (g) => (g = g.closest("table")) && N(g) ? { conversion: D, priority: 3 } : null };
    }
    static importJSON(g) {
      let _ = C(g.language);
      return _.setFormat(g.format), _.setIndent(g.indent), _.setDirection(g.direction), _;
    }
    exportJSON() {
      return { ...super.exportJSON(), language: this.getLanguage(), type: "code", version: 1 };
    }
    insertNewAfter(g, _ = !0) {
      var A = this.getChildren(), J = A.length;
      if (2 <= J && A[J - 1].getTextContent() === `
` && A[J - 2].getTextContent() === `
` && g.isCollapsed() && g.anchor.key === this.__key && g.anchor.offset === J)
        return A[J - 1].remove(), A[J - 2].remove(), g = r.$createParagraphNode(), this.insertAfter(g, _), g;
      let { anchor: ce, focus: ge } = g;
      if (_ = (ce.isBefore(ge) ? ce : ge).getNode(), r.$isTextNode(_)) {
        for (J = te(_), A = []; ; )
          if (r.$isTabNode(J))
            A.push(r.$createTabNode()), J = J.getNextSibling();
          else if (z(J)) {
            for (var ae = 0, Te = J.getTextContent(), Me = J.getTextContentSize(); ae < Me && Te[ae] === " "; ae++)
              ;
            if (ae !== 0 && A.push(B(" ".repeat(ae))), ae !== Me)
              break;
            J = J.getNextSibling();
          } else
            break;
        J = _.splitText(ce.offset)[0], ae = ce.offset === 0 ? 0 : 1, ae = J.getIndexWithinParent() + ae, Te = _.getParentOrThrow(), Me = [r.$createLineBreakNode(), ...A], Te.splice(ae, 0, Me), (A = A[A.length - 1]) ? A.select() : ce.offset === 0 ? J.selectPrevious() : J.getNextSibling().selectNext(0, 0);
      }
      return T(_) && ({ offset: g } = g.anchor, _.splice(g, 0, [r.$createLineBreakNode()]), _.select(g + 1, g + 1)), null;
    }
    canIndent() {
      return !1;
    }
    collapseAtStart() {
      let g = r.$createParagraphNode();
      return this.getChildren().forEach((_) => g.append(_)), this.replace(g), !0;
    }
    setLanguage(g) {
      this.getWritable().__language = o(g);
    }
    getLanguage() {
      return this.getLatest().__language;
    }
  }
  function C(b) {
    return r.$applyNodeReplacement(new h(b));
  }
  function T(b) {
    return b instanceof h;
  }
  function O(b) {
    let g;
    return t.isHTMLElement(b) && (g = b.getAttribute("data-highlight-language")), { node: C(g) };
  }
  function S(b) {
    let g = b.style.fontFamily.match("monospace") !== null;
    return g || H(b) ? { after: (_) => {
      let A = b.parentNode;
      return A != null && b !== A.lastChild && _.push(r.$createLineBreakNode()), _;
    }, node: g ? C() : null } : { node: null };
  }
  function x() {
    return { node: C() };
  }
  function D() {
    return { node: null };
  }
  function k(b) {
    return { after: (g) => (b.parentNode && b.parentNode.nextSibling && g.push(r.$createLineBreakNode()), g), node: null };
  }
  function H(b) {
    for (b = b.parentElement; b !== null; ) {
      if (b.style.fontFamily.match("monospace") !== null)
        return !0;
      b = b.parentElement;
    }
    return !1;
  }
  function N(b) {
    return b.classList.contains("js-file-line-container");
  }
  let v = { c: "C", clike: "C-like", cpp: "C++", css: "CSS", html: "HTML", java: "Java", js: "JavaScript", markdown: "Markdown", objc: "Objective-C", plain: "Plain Text", py: "Python", rust: "Rust", sql: "SQL", swift: "Swift", typescript: "TypeScript", xml: "XML" }, F = { cpp: "cpp", java: "java", javascript: "js", md: "markdown", plaintext: "plain", python: "py", text: "plain", ts: "typescript" };
  function U(b) {
    return F[b] || b;
  }
  class I extends r.TextNode {
    constructor(g, _, A) {
      super(g, A), this.__highlightType = _;
    }
    static getType() {
      return "code-highlight";
    }
    static clone(g) {
      return new I(g.__text, g.__highlightType || void 0, g.__key);
    }
    getHighlightType() {
      return this.getLatest().__highlightType;
    }
    createDOM(g) {
      let _ = super.createDOM(g);
      return g = K(g.theme, this.__highlightType), t.addClassNamesToElement(_, g), _;
    }
    updateDOM(g, _, A) {
      let J = super.updateDOM(g, _, A);
      return g = K(A.theme, g.__highlightType), A = K(A.theme, this.__highlightType), g !== A && (g && t.removeClassNamesFromElement(
        _,
        g
      ), A && t.addClassNamesToElement(_, A)), J;
    }
    static importJSON(g) {
      let _ = B(g.text, g.highlightType);
      return _.setFormat(g.format), _.setDetail(g.detail), _.setMode(g.mode), _.setStyle(g.style), _;
    }
    exportJSON() {
      return { ...super.exportJSON(), highlightType: this.getHighlightType(), type: "code-highlight", version: 1 };
    }
    setFormat() {
      return this;
    }
    isParentRequired() {
      return !0;
    }
    createParentElementNode() {
      return C();
    }
  }
  function K(b, g) {
    return g && b && b.codeHighlight && b.codeHighlight[g];
  }
  function B(b, g) {
    return r.$applyNodeReplacement(new I(b, g));
  }
  function z(b) {
    return b instanceof I;
  }
  function te(b) {
    let g = b;
    for (; z(b) || r.$isTabNode(b); )
      g = b, b = b.getPreviousSibling();
    return g;
  }
  function re(b) {
    let g = b;
    for (; z(b) || r.$isTabNode(b); )
      g = b, b = b.getNextSibling();
    return g;
  }
  let de = { defaultLanguage: "javascript", tokenize(b, g) {
    return e.tokenize(b, e.languages[g || ""] || e.languages[this.defaultLanguage]);
  } };
  function V(b, g) {
    let _ = null;
    var A = null, J = b;
    let ce = g, ge = b.getTextContent();
    for (; ; ) {
      if (ce === 0) {
        if (J = J.getPreviousSibling(), J === null)
          break;
        if (!(z(J) || r.$isTabNode(J) || r.$isLineBreakNode(J)))
          throw Error("Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode");
        if (r.$isLineBreakNode(J)) {
          _ = { node: J, offset: 1 };
          break;
        }
        ce = Math.max(0, J.getTextContentSize() - 1), ge = J.getTextContent();
      } else
        ce--;
      let ae = ge[ce];
      z(J) && ae !== " " && (A = { node: J, offset: ce });
    }
    if (A !== null)
      return A;
    if (A = null, g < b.getTextContentSize() ? z(b) && (A = b.getTextContent()[g]) : (J = b.getNextSibling(), z(J) && (A = J.getTextContent()[0])), A !== null && A !== " ")
      return _;
    e:
      for (A = b, J = b.getTextContent(), b = b.getTextContentSize(); ; ) {
        if (!z(A) || g === b) {
          if (A = A.getNextSibling(), A === null || r.$isLineBreakNode(A)) {
            b = null;
            break e;
          }
          z(A) && (g = 0, J = A.getTextContent(), b = A.getTextContentSize());
        }
        if (z(A)) {
          if (J[g] !== " ") {
            b = { node: A, offset: g };
            break e;
          }
          g++;
        }
      }
    return b !== null ? b : _;
  }
  function G(b) {
    if (b = re(b), r.$isLineBreakNode(b))
      throw Error("Unexpected lineBreakNode in getEndOfCodeInLine");
    return b;
  }
  function q(b, g, _) {
    let A = b.getParent();
    T(A) ? pe(A, g, _) : z(b) && b.replace(r.$createTextNode(b.__text));
  }
  let me = /* @__PURE__ */ new Set();
  function pe(b, g, _) {
    let A = b.getKey();
    me.has(A) || (me.add(A), b.getLanguage() === void 0 && b.setLanguage(_.defaultLanguage), g.update(() => {
      ee(A, () => {
        var J = r.$getNodeByKey(A);
        if (!T(J) || !J.isAttached())
          return !1;
        var ce = J.getTextContent();
        ce = _.tokenize(ce, J.getLanguage() || _.defaultLanguage), ce = Z(ce);
        var ge = J.getChildren();
        for (J = 0; J < ge.length && P(ge[J], ce[J]); )
          J++;
        var ae = ge.length;
        let Te = ce.length, Me = Math.min(ae, Te) - J, ze = 0;
        for (; ze < Me; )
          if (ze++, !P(ge[ae - ze], ce[Te - ze])) {
            ze--;
            break;
          }
        ge = J, ae -= ze, ce = ce.slice(J, Te - ze);
        let { from: oe, to: ie, nodesForReplacement: ue } = { from: ge, nodesForReplacement: ce, to: ae };
        return oe !== ie || ue.length ? (b.splice(oe, ie - oe, ue), !0) : !1;
      });
    }, { onUpdate: () => {
      me.delete(A);
    }, skipTransforms: !0 }));
  }
  function Z(b, g) {
    let _ = [];
    for (let A of b)
      if (typeof A == "string") {
        b = A.split(/(\n|\t)/);
        let J = b.length;
        for (let ce = 0; ce < J; ce++) {
          let ge = b[ce];
          ge === `
` || ge === `\r
` ? _.push(r.$createLineBreakNode()) : ge === "	" ? _.push(r.$createTabNode()) : 0 < ge.length && _.push(B(ge, g));
        }
      } else
        ({ content: b } = A), typeof b == "string" ? _.push(...Z([b], A.type)) : Array.isArray(b) && _.push(...Z(b, A.type));
    return _;
  }
  function ee(b, g) {
    if (b = r.$getNodeByKey(b), T(b) && b.isAttached()) {
      var _ = r.$getSelection();
      if (r.$isRangeSelection(_)) {
        _ = _.anchor;
        var A = _.offset, J = _.type === "element" && r.$isLineBreakNode(b.getChildAtIndex(_.offset - 1)), ce = 0;
        if (!J) {
          let ge = _.getNode();
          ce = A + ge.getPreviousSiblings().reduce((ae, Te) => ae + Te.getTextContentSize(), 0);
        }
        g() && (J ? _.getNode().select(A, A) : b.getChildren().some((ge) => {
          let ae = r.$isTextNode(ge);
          if (ae || r.$isLineBreakNode(ge)) {
            let Te = ge.getTextContentSize();
            if (ae && Te >= ce)
              return ge.select(ce, ce), !0;
            ce -= Te;
          }
          return !1;
        }));
      } else
        g();
    }
  }
  function P(b, g) {
    return z(b) && z(g) && b.__text === g.__text && b.__highlightType === g.__highlightType || r.$isTabNode(b) && r.$isTabNode(g) || r.$isLineBreakNode(b) && r.$isLineBreakNode(g);
  }
  function w(b) {
    if (!r.$isRangeSelection(b))
      return !1;
    var g = b.anchor.getNode();
    return b = b.focus.getNode(), g.is(b) && T(g) ? !0 : (g = g.getParent(), T(g) && g.is(b.getParent()));
  }
  function j(b) {
    b = b.getNodes();
    let g = [[]];
    if (b.length === 1 && T(b[0]))
      return g;
    let _ = g[0];
    for (let A = 0; A < b.length; A++) {
      let J = b[A];
      if (!(z(J) || r.$isTabNode(J) || r.$isLineBreakNode(J)))
        throw Error("Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode");
      r.$isLineBreakNode(J) ? A !== 0 && 0 < _.length && (_ = [], g.push(_)) : _.push(J);
    }
    return g;
  }
  function ne(b) {
    var g = r.$getSelection();
    if (!r.$isRangeSelection(g) || !w(g))
      return null;
    let _ = b ? r.OUTDENT_CONTENT_COMMAND : r.INDENT_CONTENT_COMMAND;
    if (b = b ? r.OUTDENT_CONTENT_COMMAND : r.INSERT_TAB_COMMAND, 1 < j(g).length)
      return _;
    var A = g.getNodes()[0];
    if (!(T(A) || z(A) || r.$isTabNode(A) || r.$isLineBreakNode(A)))
      throw Error("Expected selection firstNode to be CodeHighlightNode or TabNode");
    if (T(A))
      return _;
    let J = te(A);
    A = re(A);
    var ce = g.anchor;
    let ge = g.focus;
    return ge.isBefore(ce) ? g = ge : (g = ce, ce = ge), J !== null && A !== null && g.key === J.getKey() && g.offset === 0 && ce.key === A.getKey() && ce.offset === A.getTextContentSize() ? _ : b;
  }
  function Y(b) {
    var g = r.$getSelection();
    if (!r.$isRangeSelection(g) || !w(g))
      return !1;
    var _ = j(g);
    let A = _.length;
    if (1 < _.length) {
      for (g = 0; g < A; g++) {
        var J = _[g];
        0 < J.length && (J = J[0], g === 0 && (J = te(J)), J !== null && (b === r.INDENT_CONTENT_COMMAND ? J.insertBefore(r.$createTabNode()) : r.$isTabNode(J) && J.remove()));
      }
      return !0;
    }
    if (_ = g.getNodes()[0], !(T(_) || z(_) || r.$isTabNode(_) || r.$isLineBreakNode(_)))
      throw Error("Expected selection firstNode to be CodeHighlightNode or CodeTabNode");
    if (T(_))
      return b === r.INDENT_CONTENT_COMMAND && g.insertNodes([r.$createTabNode()]), !0;
    if (_ = te(_), _ === null)
      throw Error("Expected getFirstCodeNodeOfLine to return a valid Code Node");
    return b === r.INDENT_CONTENT_COMMAND ? r.$isLineBreakNode(_) ? _.insertAfter(r.$createTabNode()) : _.insertBefore(r.$createTabNode()) : r.$isTabNode(_) && _.remove(), !0;
  }
  function W(b, g) {
    let _ = r.$getSelection();
    if (!r.$isRangeSelection(_))
      return !1;
    let { anchor: A, focus: J } = _, ce = A.offset, ge = J.offset, ae = A.getNode(), Te = J.getNode();
    var Me = b === r.KEY_ARROW_UP_COMMAND;
    if (!w(_) || !z(ae) && !r.$isTabNode(ae) || !z(Te) && !r.$isTabNode(Te))
      return !1;
    if (!g.altKey) {
      if (_.isCollapsed()) {
        if (b = ae.getParentOrThrow(), Me && ce === 0 && ae.getPreviousSibling() === null) {
          if (b.getPreviousSibling() === null)
            return b.selectPrevious(), g.preventDefault(), !0;
        } else if (!Me && ce === ae.getTextContentSize() && ae.getNextSibling() === null && b.getNextSibling() === null)
          return b.selectNext(), g.preventDefault(), !0;
      }
      return !1;
    }
    let ze;
    if (ae.isBefore(Te)) {
      var oe = te(ae);
      ze = re(Te);
    } else
      oe = te(Te), ze = re(ae);
    if (oe == null || ze == null)
      return !1;
    let ie = oe.getNodesBetween(ze);
    for (let we = 0; we < ie.length; we++) {
      let Le = ie[we];
      if (!z(Le) && !r.$isTabNode(Le) && !r.$isLineBreakNode(Le))
        return !1;
    }
    if (g.preventDefault(), g.stopPropagation(), g = Me ? oe.getPreviousSibling() : ze.getNextSibling(), !r.$isLineBreakNode(g) || (oe = Me ? g.getPreviousSibling() : g.getNextSibling(), oe == null))
      return !0;
    Me = z(oe) || r.$isTabNode(oe) || r.$isLineBreakNode(oe) ? Me ? te(oe) : re(oe) : null;
    let ue = Me ?? oe;
    return g.remove(), ie.forEach((we) => we.remove()), b === r.KEY_ARROW_UP_COMMAND ? (ie.forEach((we) => ue.insertBefore(we)), ue.insertBefore(g)) : (ue.insertAfter(g), ue = g, ie.forEach((we) => {
      ue.insertAfter(we), ue = we;
    })), _.setTextNodeRange(ae, ce, Te, ge), !0;
  }
  function Q(b, g) {
    let _ = r.$getSelection();
    if (!r.$isRangeSelection(_))
      return !1;
    let { anchor: A, focus: J } = _;
    var ce = A.getNode();
    let ge = J.getNode();
    if (b = b === r.MOVE_TO_START, !z(ce) && !r.$isTabNode(ce) || !z(ge) && !r.$isTabNode(ge))
      return !1;
    if (b)
      if (ce = V(ge, J.offset), ce !== null) {
        let { node: ae, offset: Te } = ce;
        r.$isLineBreakNode(ae) ? ae.selectNext(0, 0) : _.setTextNodeRange(ae, Te, ae, Te);
      } else
        ge.getParentOrThrow().selectStart();
    else
      G(ge).select();
    return g.preventDefault(), g.stopPropagation(), !0;
  }
  return En.$createCodeHighlightNode = B, En.$createCodeNode = C, En.$isCodeHighlightNode = z, En.$isCodeNode = T, En.CODE_LANGUAGE_FRIENDLY_NAME_MAP = v, En.CODE_LANGUAGE_MAP = F, En.CodeHighlightNode = I, En.CodeNode = h, En.DEFAULT_CODE_LANGUAGE = "javascript", En.PrismTokenizer = de, En.getCodeLanguages = () => Object.keys(e.languages).filter((b) => typeof e.languages[b] != "function").sort(), En.getDefaultCodeLanguage = () => "javascript", En.getEndOfCodeInLine = G, En.getFirstCodeNodeOfLine = te, En.getLanguageFriendlyName = function(b) {
    return b = U(b), v[b] || b;
  }, En.getLastCodeNodeOfLine = re, En.getStartOfCodeInLine = V, En.normalizeCodeLang = U, En.registerCodeHighlighting = function(b, g) {
    if (!b.hasNodes([h, I]))
      throw Error("CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor");
    return g == null && (g = de), t.mergeRegister(
      b.registerMutationListener(h, (_) => {
        b.update(() => {
          for (let [ce, ge] of _)
            if (ge !== "destroyed") {
              var A = r.$getNodeByKey(ce);
              if (A !== null)
                e: {
                  var J = A;
                  if (A = b.getElementByKey(J.getKey()), A === null)
                    break e;
                  J = J.getChildren();
                  let ae = J.length;
                  if (ae === A.__cachedChildrenLength)
                    break e;
                  A.__cachedChildrenLength = ae;
                  let Te = "1", Me = 1;
                  for (let ze = 0; ze < ae; ze++)
                    r.$isLineBreakNode(J[ze]) && (Te += `
` + ++Me);
                  A.setAttribute("data-gutter", Te);
                }
            }
        });
      }),
      b.registerNodeTransform(h, (_) => pe(_, b, g)),
      b.registerNodeTransform(r.TextNode, (_) => q(_, b, g)),
      b.registerNodeTransform(I, (_) => q(_, b, g)),
      b.registerCommand(r.KEY_TAB_COMMAND, (_) => {
        let A = ne(_.shiftKey);
        return A === null ? !1 : (_.preventDefault(), b.dispatchCommand(A, void 0), !0);
      }, r.COMMAND_PRIORITY_LOW),
      b.registerCommand(r.INSERT_TAB_COMMAND, () => {
        let _ = r.$getSelection();
        return w(_) ? (r.$insertNodes([r.$createTabNode()]), !0) : !1;
      }, r.COMMAND_PRIORITY_LOW),
      b.registerCommand(r.INDENT_CONTENT_COMMAND, () => Y(r.INDENT_CONTENT_COMMAND), r.COMMAND_PRIORITY_LOW),
      b.registerCommand(r.OUTDENT_CONTENT_COMMAND, () => Y(r.OUTDENT_CONTENT_COMMAND), r.COMMAND_PRIORITY_LOW),
      b.registerCommand(r.KEY_ARROW_UP_COMMAND, (_) => W(r.KEY_ARROW_UP_COMMAND, _), r.COMMAND_PRIORITY_LOW),
      b.registerCommand(r.KEY_ARROW_DOWN_COMMAND, (_) => W(r.KEY_ARROW_DOWN_COMMAND, _), r.COMMAND_PRIORITY_LOW),
      b.registerCommand(r.MOVE_TO_END, (_) => Q(r.MOVE_TO_END, _), r.COMMAND_PRIORITY_LOW),
      b.registerCommand(r.MOVE_TO_START, (_) => Q(r.MOVE_TO_START, _), r.COMMAND_PRIORITY_LOW)
    );
  }, En;
}
var Tn = {}, df;
function U_() {
  if (df)
    return Tn;
  df = 1;
  var e = uh();
  dh(), fh(), hh(), gh(), ph(), _h(), mh(), yh(), Ch(), Nh(), Eh(), Th(), xh(), vh();
  var t = Jt(), r = kt();
  const o = (oe) => oe != null && e.languages.hasOwnProperty(oe) ? oe : void 0;
  function f(oe, ie) {
    for (const ue of oe.childNodes) {
      if (t.isHTMLElement(ue) && ue.tagName === ie)
        return !0;
      f(ue, ie);
    }
    return !1;
  }
  const h = "data-highlight-language";
  class C extends r.ElementNode {
    /** @internal */
    static getType() {
      return "code";
    }
    static clone(ie) {
      return new C(ie.__language, ie.__key);
    }
    constructor(ie, ue) {
      super(ue), this.__language = o(ie);
    }
    // View
    createDOM(ie) {
      const ue = document.createElement("code");
      t.addClassNamesToElement(ue, ie.theme.code), ue.setAttribute("spellcheck", "false");
      const we = this.getLanguage();
      return we && ue.setAttribute(h, we), ue;
    }
    updateDOM(ie, ue, we) {
      const Le = this.__language, Be = ie.__language;
      return Le ? Le !== Be && ue.setAttribute(h, Le) : Be && ue.removeAttribute(h), !1;
    }
    exportDOM() {
      const ie = document.createElement("pre");
      ie.setAttribute("spellcheck", "false");
      const ue = this.getLanguage();
      return ue && ie.setAttribute(h, ue), {
        element: ie
      };
    }
    static importDOM() {
      return {
        // Typically <pre> is used for code blocks, and <code> for inline code styles
        // but if it's a multi line <code> we'll create a block. Pass through to
        // inline format handled by TextNode otherwise.
        code: (ie) => ie.textContent != null && (/\r?\n/.test(ie.textContent) || f(ie, "BR")) ? {
          conversion: S,
          priority: 1
        } : null,
        div: (ie) => ({
          conversion: x,
          priority: 1
        }),
        pre: (ie) => ({
          conversion: S,
          priority: 0
        }),
        table: (ie) => U(ie) ? {
          conversion: D,
          priority: 3
        } : null,
        td: (ie) => {
          const ue = ie, we = ue.closest("table");
          return F(ue) ? {
            conversion: H,
            priority: 3
          } : we && U(we) ? {
            conversion: k,
            priority: 3
          } : null;
        },
        tr: (ie) => {
          const we = ie.closest("table");
          return we && U(we) ? {
            conversion: k,
            priority: 3
          } : null;
        }
      };
    }
    static importJSON(ie) {
      const ue = T(ie.language);
      return ue.setFormat(ie.format), ue.setIndent(ie.indent), ue.setDirection(ie.direction), ue;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        language: this.getLanguage(),
        type: "code",
        version: 1
      };
    }
    // Mutation
    insertNewAfter(ie, ue = !0) {
      const we = this.getChildren(), Le = we.length;
      if (Le >= 2 && we[Le - 1].getTextContent() === `
` && we[Le - 2].getTextContent() === `
` && ie.isCollapsed() && ie.anchor.key === this.__key && ie.anchor.offset === Le) {
        we[Le - 1].remove(), we[Le - 2].remove();
        const at = r.$createParagraphNode();
        return this.insertAfter(at, ue), at;
      }
      const {
        anchor: Be,
        focus: Ye
      } = ie, pt = (Be.isBefore(Ye) ? Be : Ye).getNode();
      if (r.$isTextNode(pt)) {
        let at = pe(pt);
        const ve = [];
        for (; ; )
          if (r.$isTabNode(at))
            ve.push(r.$createTabNode()), at = at.getNextSibling();
          else if (me(at)) {
            let Ve = 0;
            const Qe = at.getTextContent(), ct = at.getTextContentSize();
            for (; Ve < ct && Qe[Ve] === " "; Ve++)
              ;
            if (Ve !== 0 && ve.push(q(" ".repeat(Ve))), Ve !== ct)
              break;
            at = at.getNextSibling();
          } else
            break;
        const se = pt.splitText(Be.offset)[0], he = Be.offset === 0 ? 0 : 1, Oe = se.getIndexWithinParent() + he, be = pt.getParentOrThrow(), Re = [r.$createLineBreakNode(), ...ve];
        be.splice(Oe, 0, Re);
        const He = ve[ve.length - 1];
        He ? He.select() : Be.offset === 0 ? se.selectPrevious() : se.getNextSibling().selectNext(0, 0);
      }
      if (O(pt)) {
        const {
          offset: at
        } = ie.anchor;
        pt.splice(at, 0, [r.$createLineBreakNode()]), pt.select(at + 1, at + 1);
      }
      return null;
    }
    canIndent() {
      return !1;
    }
    collapseAtStart() {
      const ie = r.$createParagraphNode();
      return this.getChildren().forEach((we) => ie.append(we)), this.replace(ie), !0;
    }
    setLanguage(ie) {
      const ue = this.getWritable();
      ue.__language = o(ie);
    }
    getLanguage() {
      return this.getLatest().__language;
    }
  }
  function T(oe) {
    return r.$applyNodeReplacement(new C(oe));
  }
  function O(oe) {
    return oe instanceof C;
  }
  function S(oe) {
    let ie;
    return t.isHTMLElement(oe) && (ie = oe.getAttribute(h)), {
      node: T(ie)
    };
  }
  function x(oe) {
    const ie = oe, ue = N(ie);
    return !ue && !v(ie) ? {
      node: null
    } : {
      after: (we) => {
        const Le = oe.parentNode;
        return Le != null && oe !== Le.lastChild && we.push(r.$createLineBreakNode()), we;
      },
      node: ue ? T() : null
    };
  }
  function D() {
    return {
      node: T()
    };
  }
  function k() {
    return {
      node: null
    };
  }
  function H(oe) {
    const ie = oe;
    return {
      after: (ue) => (ie.parentNode && ie.parentNode.nextSibling && ue.push(r.$createLineBreakNode()), ue),
      node: null
    };
  }
  function N(oe) {
    return oe.style.fontFamily.match("monospace") !== null;
  }
  function v(oe) {
    let ie = oe.parentElement;
    for (; ie !== null; ) {
      if (N(ie))
        return !0;
      ie = ie.parentElement;
    }
    return !1;
  }
  function F(oe) {
    return oe.classList.contains("js-file-line");
  }
  function U(oe) {
    return oe.classList.contains("js-file-line-container");
  }
  const I = "javascript", K = {
    c: "C",
    clike: "C-like",
    cpp: "C++",
    css: "CSS",
    html: "HTML",
    java: "Java",
    js: "JavaScript",
    markdown: "Markdown",
    objc: "Objective-C",
    plain: "Plain Text",
    py: "Python",
    rust: "Rust",
    sql: "SQL",
    swift: "Swift",
    typescript: "TypeScript",
    xml: "XML"
  }, B = {
    cpp: "cpp",
    java: "java",
    javascript: "js",
    md: "markdown",
    plaintext: "plain",
    python: "py",
    text: "plain",
    ts: "typescript"
  };
  function z(oe) {
    return B[oe] || oe;
  }
  function te(oe) {
    const ie = z(oe);
    return K[ie] || ie;
  }
  const re = () => I, de = () => Object.keys(e.languages).filter(
    // Prism has several language helpers mixed into languages object
    // so filtering them out here to get langs list
    (oe) => typeof e.languages[oe] != "function"
  ).sort();
  class V extends r.TextNode {
    /** @internal */
    constructor(ie, ue, we) {
      super(ie, we), this.__highlightType = ue;
    }
    static getType() {
      return "code-highlight";
    }
    static clone(ie) {
      return new V(ie.__text, ie.__highlightType || void 0, ie.__key);
    }
    getHighlightType() {
      return this.getLatest().__highlightType;
    }
    createDOM(ie) {
      const ue = super.createDOM(ie), we = G(ie.theme, this.__highlightType);
      return t.addClassNamesToElement(ue, we), ue;
    }
    updateDOM(ie, ue, we) {
      const Le = super.updateDOM(ie, ue, we), Be = G(we.theme, ie.__highlightType), Ye = G(we.theme, this.__highlightType);
      return Be !== Ye && (Be && t.removeClassNamesFromElement(ue, Be), Ye && t.addClassNamesToElement(ue, Ye)), Le;
    }
    static importJSON(ie) {
      const ue = q(ie.text, ie.highlightType);
      return ue.setFormat(ie.format), ue.setDetail(ie.detail), ue.setMode(ie.mode), ue.setStyle(ie.style), ue;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        highlightType: this.getHighlightType(),
        type: "code-highlight",
        version: 1
      };
    }
    // Prevent formatting (bold, underline, etc)
    setFormat(ie) {
      return this;
    }
    isParentRequired() {
      return !0;
    }
    createParentElementNode() {
      return T();
    }
  }
  function G(oe, ie) {
    return ie && oe && oe.codeHighlight && oe.codeHighlight[ie];
  }
  function q(oe, ie) {
    return r.$applyNodeReplacement(new V(oe, ie));
  }
  function me(oe) {
    return oe instanceof V;
  }
  function pe(oe) {
    let ie = oe, ue = oe;
    for (; me(ue) || r.$isTabNode(ue); )
      ie = ue, ue = ue.getPreviousSibling();
    return ie;
  }
  function Z(oe) {
    let ie = oe, ue = oe;
    for (; me(ue) || r.$isTabNode(ue); )
      ie = ue, ue = ue.getNextSibling();
    return ie;
  }
  const ee = {
    defaultLanguage: I,
    tokenize(oe, ie) {
      return e.tokenize(oe, e.languages[ie || ""] || e.languages[this.defaultLanguage]);
    }
  };
  function P(oe, ie) {
    let ue = null, we = null, Le = oe, Be = ie, Ye = oe.getTextContent();
    for (; ; ) {
      if (Be === 0) {
        if (Le = Le.getPreviousSibling(), Le === null)
          break;
        if (!(me(Le) || r.$isTabNode(Le) || r.$isLineBreakNode(Le)))
          throw Error("Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode");
        if (r.$isLineBreakNode(Le)) {
          ue = {
            node: Le,
            offset: 1
          };
          break;
        }
        Be = Math.max(0, Le.getTextContentSize() - 1), Ye = Le.getTextContent();
      } else
        Be--;
      const pt = Ye[Be];
      me(Le) && pt !== " " && (we = {
        node: Le,
        offset: Be
      });
    }
    if (we !== null)
      return we;
    let st = null;
    if (ie < oe.getTextContentSize())
      me(oe) && (st = oe.getTextContent()[ie]);
    else {
      const pt = oe.getNextSibling();
      me(pt) && (st = pt.getTextContent()[0]);
    }
    if (st !== null && st !== " ")
      return ue;
    {
      const pt = w(oe, ie);
      return pt !== null ? pt : ue;
    }
  }
  function w(oe, ie) {
    let ue = oe, we = ie, Le = oe.getTextContent(), Be = oe.getTextContentSize();
    for (; ; ) {
      if (!me(ue) || we === Be) {
        if (ue = ue.getNextSibling(), ue === null || r.$isLineBreakNode(ue))
          return null;
        me(ue) && (we = 0, Le = ue.getTextContent(), Be = ue.getTextContentSize());
      }
      if (me(ue)) {
        if (Le[we] !== " ")
          return {
            node: ue,
            offset: we
          };
        we++;
      }
    }
  }
  function j(oe) {
    const ie = Z(oe);
    if (r.$isLineBreakNode(ie))
      throw Error("Unexpected lineBreakNode in getEndOfCodeInLine");
    return ie;
  }
  function ne(oe, ie, ue) {
    const we = oe.getParent();
    O(we) ? Q(we, ie, ue) : me(oe) && oe.replace(r.$createTextNode(oe.__text));
  }
  function Y(oe, ie) {
    const ue = ie.getElementByKey(oe.getKey());
    if (ue === null)
      return;
    const we = oe.getChildren(), Le = we.length;
    if (Le === ue.__cachedChildrenLength)
      return;
    ue.__cachedChildrenLength = Le;
    let Be = "1", Ye = 1;
    for (let st = 0; st < Le; st++)
      r.$isLineBreakNode(we[st]) && (Be += `
` + ++Ye);
    ue.setAttribute("data-gutter", Be);
  }
  const W = /* @__PURE__ */ new Set();
  function Q(oe, ie, ue) {
    const we = oe.getKey();
    W.has(we) || (W.add(we), oe.getLanguage() === void 0 && oe.setLanguage(ue.defaultLanguage), ie.update(() => {
      g(we, () => {
        const Le = r.$getNodeByKey(we);
        if (!O(Le) || !Le.isAttached())
          return !1;
        const Be = Le.getTextContent(), Ye = ue.tokenize(Be, Le.getLanguage() || ue.defaultLanguage), st = b(Ye), pt = _(Le.getChildren(), st), {
          from: at,
          to: ve,
          nodesForReplacement: se
        } = pt;
        return at !== ve || se.length ? (oe.splice(at, ve - at, se), !0) : !1;
      });
    }, {
      onUpdate: () => {
        W.delete(we);
      },
      skipTransforms: !0
    }));
  }
  function b(oe, ie) {
    const ue = [];
    for (const we of oe)
      if (typeof we == "string") {
        const Le = we.split(/(\n|\t)/), Be = Le.length;
        for (let Ye = 0; Ye < Be; Ye++) {
          const st = Le[Ye];
          st === `
` || st === `\r
` ? ue.push(r.$createLineBreakNode()) : st === "	" ? ue.push(r.$createTabNode()) : st.length > 0 && ue.push(q(st, ie));
        }
      } else {
        const {
          content: Le
        } = we;
        typeof Le == "string" ? ue.push(...b([Le], we.type)) : Array.isArray(Le) && ue.push(...b(Le, we.type));
      }
    return ue;
  }
  function g(oe, ie) {
    const ue = r.$getNodeByKey(oe);
    if (!O(ue) || !ue.isAttached())
      return;
    const we = r.$getSelection();
    if (!r.$isRangeSelection(we)) {
      ie();
      return;
    }
    const Le = we.anchor, Be = Le.offset, Ye = Le.type === "element" && r.$isLineBreakNode(ue.getChildAtIndex(Le.offset - 1));
    let st = 0;
    if (!Ye) {
      const at = Le.getNode();
      st = Be + at.getPreviousSiblings().reduce((ve, se) => ve + se.getTextContentSize(), 0);
    }
    if (ie()) {
      if (Ye) {
        Le.getNode().select(Be, Be);
        return;
      }
      ue.getChildren().some((at) => {
        const ve = r.$isTextNode(at);
        if (ve || r.$isLineBreakNode(at)) {
          const se = at.getTextContentSize();
          if (ve && se >= st)
            return at.select(st, st), !0;
          st -= se;
        }
        return !1;
      });
    }
  }
  function _(oe, ie) {
    let ue = 0;
    for (; ue < oe.length && A(oe[ue], ie[ue]); )
      ue++;
    const we = oe.length, Le = ie.length, Be = Math.min(we, Le) - ue;
    let Ye = 0;
    for (; Ye < Be; )
      if (Ye++, !A(oe[we - Ye], ie[Le - Ye])) {
        Ye--;
        break;
      }
    const st = ue, pt = we - Ye, at = ie.slice(ue, Le - Ye);
    return {
      from: st,
      nodesForReplacement: at,
      to: pt
    };
  }
  function A(oe, ie) {
    return me(oe) && me(ie) && oe.__text === ie.__text && oe.__highlightType === ie.__highlightType || r.$isTabNode(oe) && r.$isTabNode(ie) || r.$isLineBreakNode(oe) && r.$isLineBreakNode(ie);
  }
  function J(oe) {
    if (!r.$isRangeSelection(oe))
      return !1;
    const ie = oe.anchor.getNode(), ue = oe.focus.getNode();
    if (ie.is(ue) && O(ie))
      return !0;
    const we = ie.getParent();
    return O(we) && we.is(ue.getParent());
  }
  function ce(oe) {
    const ie = oe.getNodes(), ue = [[]];
    if (ie.length === 1 && O(ie[0]))
      return ue;
    let we = ue[0];
    for (let Le = 0; Le < ie.length; Le++) {
      const Be = ie[Le];
      if (!(me(Be) || r.$isTabNode(Be) || r.$isLineBreakNode(Be)))
        throw Error("Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode");
      r.$isLineBreakNode(Be) ? Le !== 0 && we.length > 0 && (we = [], ue.push(we)) : we.push(Be);
    }
    return ue;
  }
  function ge(oe) {
    const ie = r.$getSelection();
    if (!r.$isRangeSelection(ie) || !J(ie))
      return null;
    const ue = oe ? r.OUTDENT_CONTENT_COMMAND : r.INDENT_CONTENT_COMMAND, we = oe ? r.OUTDENT_CONTENT_COMMAND : r.INSERT_TAB_COMMAND;
    if (ce(ie).length > 1)
      return ue;
    const Ye = ie.getNodes()[0];
    if (!(O(Ye) || me(Ye) || r.$isTabNode(Ye) || r.$isLineBreakNode(Ye)))
      throw Error("Expected selection firstNode to be CodeHighlightNode or TabNode");
    if (O(Ye))
      return ue;
    const st = pe(Ye), pt = Z(Ye), at = ie.anchor, ve = ie.focus;
    let se, he;
    return ve.isBefore(at) ? (se = ve, he = at) : (se = at, he = ve), st !== null && pt !== null && se.key === st.getKey() && se.offset === 0 && he.key === pt.getKey() && he.offset === pt.getTextContentSize() ? ue : we;
  }
  function ae(oe) {
    const ie = r.$getSelection();
    if (!r.$isRangeSelection(ie) || !J(ie))
      return !1;
    const ue = ce(ie), we = ue.length;
    if (ue.length > 1) {
      for (let st = 0; st < we; st++) {
        const pt = ue[st];
        if (pt.length > 0) {
          let at = pt[0];
          st === 0 && (at = pe(at)), at !== null && (oe === r.INDENT_CONTENT_COMMAND ? at.insertBefore(r.$createTabNode()) : r.$isTabNode(at) && at.remove());
        }
      }
      return !0;
    }
    const Be = ie.getNodes()[0];
    if (!(O(Be) || me(Be) || r.$isTabNode(Be) || r.$isLineBreakNode(Be)))
      throw Error("Expected selection firstNode to be CodeHighlightNode or CodeTabNode");
    if (O(Be))
      return oe === r.INDENT_CONTENT_COMMAND && ie.insertNodes([r.$createTabNode()]), !0;
    const Ye = pe(Be);
    if (Ye === null)
      throw Error("Expected getFirstCodeNodeOfLine to return a valid Code Node");
    return oe === r.INDENT_CONTENT_COMMAND ? r.$isLineBreakNode(Ye) ? Ye.insertAfter(r.$createTabNode()) : Ye.insertBefore(r.$createTabNode()) : r.$isTabNode(Ye) && Ye.remove(), !0;
  }
  function Te(oe, ie) {
    const ue = r.$getSelection();
    if (!r.$isRangeSelection(ue))
      return !1;
    const {
      anchor: we,
      focus: Le
    } = ue, Be = we.offset, Ye = Le.offset, st = we.getNode(), pt = Le.getNode(), at = oe === r.KEY_ARROW_UP_COMMAND;
    if (!J(ue) || !(me(st) || r.$isTabNode(st)) || !(me(pt) || r.$isTabNode(pt)))
      return !1;
    if (!ie.altKey) {
      if (ue.isCollapsed()) {
        const Ve = st.getParentOrThrow();
        if (at && Be === 0 && st.getPreviousSibling() === null) {
          if (Ve.getPreviousSibling() === null)
            return Ve.selectPrevious(), ie.preventDefault(), !0;
        } else if (!at && Be === st.getTextContentSize() && st.getNextSibling() === null && Ve.getNextSibling() === null)
          return Ve.selectNext(), ie.preventDefault(), !0;
      }
      return !1;
    }
    let ve, se;
    if (st.isBefore(pt) ? (ve = pe(st), se = Z(pt)) : (ve = pe(pt), se = Z(st)), ve == null || se == null)
      return !1;
    const he = ve.getNodesBetween(se);
    for (let Ve = 0; Ve < he.length; Ve++) {
      const Qe = he[Ve];
      if (!me(Qe) && !r.$isTabNode(Qe) && !r.$isLineBreakNode(Qe))
        return !1;
    }
    ie.preventDefault(), ie.stopPropagation();
    const Oe = at ? ve.getPreviousSibling() : se.getNextSibling();
    if (!r.$isLineBreakNode(Oe))
      return !0;
    const be = at ? Oe.getPreviousSibling() : Oe.getNextSibling();
    if (be == null)
      return !0;
    const Re = me(be) || r.$isTabNode(be) || r.$isLineBreakNode(be) ? at ? pe(be) : Z(be) : null;
    let He = Re ?? be;
    return Oe.remove(), he.forEach((Ve) => Ve.remove()), oe === r.KEY_ARROW_UP_COMMAND ? (he.forEach((Ve) => He.insertBefore(Ve)), He.insertBefore(Oe)) : (He.insertAfter(Oe), He = Oe, he.forEach((Ve) => {
      He.insertAfter(Ve), He = Ve;
    })), ue.setTextNodeRange(st, Be, pt, Ye), !0;
  }
  function Me(oe, ie) {
    const ue = r.$getSelection();
    if (!r.$isRangeSelection(ue))
      return !1;
    const {
      anchor: we,
      focus: Le
    } = ue, Be = we.getNode(), Ye = Le.getNode(), st = oe === r.MOVE_TO_START;
    if (!(me(Be) || r.$isTabNode(Be)) || !(me(Ye) || r.$isTabNode(Ye)))
      return !1;
    if (st) {
      const pt = P(Ye, Le.offset);
      if (pt !== null) {
        const {
          node: at,
          offset: ve
        } = pt;
        r.$isLineBreakNode(at) ? at.selectNext(0, 0) : ue.setTextNodeRange(at, ve, at, ve);
      } else
        Ye.getParentOrThrow().selectStart();
    } else
      j(Ye).select();
    return ie.preventDefault(), ie.stopPropagation(), !0;
  }
  function ze(oe, ie) {
    if (!oe.hasNodes([C, V]))
      throw new Error("CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor");
    return ie == null && (ie = ee), t.mergeRegister(oe.registerMutationListener(C, (ue) => {
      oe.update(() => {
        for (const [we, Le] of ue)
          if (Le !== "destroyed") {
            const Be = r.$getNodeByKey(we);
            Be !== null && Y(Be, oe);
          }
      });
    }), oe.registerNodeTransform(C, (ue) => Q(ue, oe, ie)), oe.registerNodeTransform(r.TextNode, (ue) => ne(ue, oe, ie)), oe.registerNodeTransform(V, (ue) => ne(ue, oe, ie)), oe.registerCommand(r.KEY_TAB_COMMAND, (ue) => {
      const we = ge(ue.shiftKey);
      return we === null ? !1 : (ue.preventDefault(), oe.dispatchCommand(we, void 0), !0);
    }, r.COMMAND_PRIORITY_LOW), oe.registerCommand(r.INSERT_TAB_COMMAND, () => {
      const ue = r.$getSelection();
      return J(ue) ? (r.$insertNodes([r.$createTabNode()]), !0) : !1;
    }, r.COMMAND_PRIORITY_LOW), oe.registerCommand(r.INDENT_CONTENT_COMMAND, (ue) => ae(r.INDENT_CONTENT_COMMAND), r.COMMAND_PRIORITY_LOW), oe.registerCommand(r.OUTDENT_CONTENT_COMMAND, (ue) => ae(r.OUTDENT_CONTENT_COMMAND), r.COMMAND_PRIORITY_LOW), oe.registerCommand(r.KEY_ARROW_UP_COMMAND, (ue) => Te(r.KEY_ARROW_UP_COMMAND, ue), r.COMMAND_PRIORITY_LOW), oe.registerCommand(r.KEY_ARROW_DOWN_COMMAND, (ue) => Te(r.KEY_ARROW_DOWN_COMMAND, ue), r.COMMAND_PRIORITY_LOW), oe.registerCommand(r.MOVE_TO_END, (ue) => Me(r.MOVE_TO_END, ue), r.COMMAND_PRIORITY_LOW), oe.registerCommand(r.MOVE_TO_START, (ue) => Me(r.MOVE_TO_START, ue), r.COMMAND_PRIORITY_LOW));
  }
  return Tn.$createCodeHighlightNode = q, Tn.$createCodeNode = T, Tn.$isCodeHighlightNode = me, Tn.$isCodeNode = O, Tn.CODE_LANGUAGE_FRIENDLY_NAME_MAP = K, Tn.CODE_LANGUAGE_MAP = B, Tn.CodeHighlightNode = V, Tn.CodeNode = C, Tn.DEFAULT_CODE_LANGUAGE = I, Tn.PrismTokenizer = ee, Tn.getCodeLanguages = de, Tn.getDefaultCodeLanguage = re, Tn.getEndOfCodeInLine = j, Tn.getFirstCodeNodeOfLine = pe, Tn.getLanguageFriendlyName = te, Tn.getLastCodeNodeOfLine = Z, Tn.getStartOfCodeInLine = P, Tn.normalizeCodeLang = z, Tn.registerCodeHighlighting = ze, Tn;
}
const W_ = process.env.NODE_ENV === "development" ? U_() : H_();
var vc = W_, Hc = kn();
function z_() {
  const [e] = Hc.useLexicalComposerContext();
  return fr(() => vc.registerCodeHighlighting(e), [e]), null;
}
var ff = Jt(), vn = kt();
function G_({
  src: e,
  altText: t,
  width: r,
  height: o,
  maxWidth: f
}) {
  const h = Kf(() => ({ height: o, width: r, maxWidth: f }), [o, r, f]);
  return /* @__PURE__ */ yt.jsx("img", { src: e, alt: t, style: h });
}
function Sh({
  altText: e,
  height: t,
  maxWidth: r = 500,
  src: o,
  width: f,
  key: h
}) {
  return vn.$applyNodeReplacement(
    new Ts(o, e, r, f, t, h)
  );
}
function Y_(e) {
  return e instanceof Ts;
}
class Ts extends vn.DecoratorNode {
  constructor(r, o, f, h, C, T) {
    super(T);
    Ln(this, "__src");
    Ln(this, "__altText");
    Ln(this, "__width");
    Ln(this, "__height");
    Ln(this, "__maxWidth");
    this.__src = r, this.__altText = o, this.__maxWidth = f, this.__width = h || "inherit", this.__height = C || "inherit";
  }
  static getType() {
    return "image";
  }
  static clone(r) {
    return new Ts(
      r.__src,
      r.__altText,
      r.__maxWidth,
      r.__width,
      r.__height,
      r.__key
    );
  }
  getSrc() {
    return this.getLatest().__src;
  }
  getAltText() {
    return this.getLatest().__altText;
  }
  /**
   * Defines the JSON Serialization strategy for an {@link ImageNode}.
   */
  exportJSON() {
    return {
      altText: this.getAltText(),
      height: this.__height === "inherit" ? 0 : this.__height,
      maxWidth: this.__maxWidth,
      src: this.getSrc(),
      type: "image",
      version: 1,
      width: this.__width === "inherit" ? 0 : this.__width
    };
  }
  /**
   * Static constructor for creating an {@link ImageNode} from a JSON serialized Node.
   */
  static importJSON(r) {
    return Sh(r);
  }
  /**
   * Inserts the {@link ImageNode}'s placeholder {@link HTMLElement} into the Lexical Dev's DOM.
   */
  createDOM(r) {
    const o = document.createElement("span"), f = r.theme.image;
    return f && (o.className = f), o;
  }
  /**
   * Since this Node will only be used in a read-only context, we don't need to worry about
   * updating the DOM when its attributes change.
   */
  updateDOM() {
    return !1;
  }
  decorate() {
    return /* @__PURE__ */ yt.jsx(
      G_,
      {
        src: this.__src,
        altText: this.__altText,
        width: this.__width,
        height: this.__height,
        maxWidth: this.__maxWidth
      }
    );
  }
}
const j_ = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", q_ = (e) => j_ ? (e || window).getSelection() : null, wh = vn.createCommand(
  "INSERT_IMAGE_COMMAND"
);
function V_() {
  const [e] = Hc.useLexicalComposerContext();
  return fr(() => {
    if (!e.hasNodes([Ts]))
      throw new Error("ImagePlugin: ImageNode not registered on editor");
    return ff.mergeRegister(
      e.registerCommand(
        wh,
        (t) => {
          const r = Sh(t);
          return vn.$insertNodes([r]), vn.$isRootOrShadowRoot(r.getParentOrThrow()) && ff.$wrapNodeInElement(r, vn.$createParagraphNode).selectEnd(), !0;
        },
        vn.COMMAND_PRIORITY_EDITOR
      ),
      e.registerCommand(
        vn.DRAGSTART_COMMAND,
        (t) => J_(t),
        vn.COMMAND_PRIORITY_HIGH
      ),
      e.registerCommand(
        vn.DRAGOVER_COMMAND,
        (t) => Z_(t),
        vn.COMMAND_PRIORITY_LOW
      ),
      e.registerCommand(
        vn.DROP_COMMAND,
        (t) => X_(t, e),
        vn.COMMAND_PRIORITY_HIGH
      )
    );
  }, [e]), null;
}
function J_(e) {
  const t = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", r = document.createElement("img");
  r.src = t;
  const o = Uc();
  if (!o)
    return !1;
  const f = e.dataTransfer;
  return f ? (f.setData("text/plain", "_"), f.setDragImage(r, 0, 0), f.setData(
    "application/x-lexical-drag",
    JSON.stringify({
      data: {
        altText: o.__altText,
        height: o.__height,
        key: o.getKey(),
        maxWidth: o.__maxWidth,
        src: o.__src,
        width: o.__width
      },
      type: "image"
    })
  ), !0) : !1;
}
function Z_(e) {
  return Uc() ? (Oh(e) || e.preventDefault(), !0) : !1;
}
function X_(e, t) {
  const r = Uc();
  if (!r)
    return !1;
  const o = Q_(e);
  if (!o)
    return !1;
  if (e.preventDefault(), Oh(e)) {
    const f = em(e);
    r.remove();
    const h = vn.$createRangeSelection();
    f != null && h.applyDOMRange(f), vn.$setSelection(h), t.dispatchCommand(wh, o);
  }
  return !0;
}
function Uc() {
  const e = vn.$getSelection();
  if (!vn.$isNodeSelection(e))
    return null;
  const r = e.getNodes()[0];
  return Y_(r) ? r : null;
}
function Q_(e) {
  var f;
  const t = (f = e.dataTransfer) == null ? void 0 : f.getData("application/x-lexical-drag");
  if (!t)
    return null;
  const { type: r, data: o } = JSON.parse(t);
  return r !== "image" ? null : o;
}
function Oh(e) {
  const t = e.target;
  return !!(t && t instanceof HTMLElement && !t.closest("code, span.yext-default-richtextv2-theme__image") && t.parentElement);
}
function em(e) {
  let t;
  const r = e.target, o = r === null || !(r instanceof Node) ? null : r.nodeType === 9 ? r.defaultView : r.ownerDocument.defaultView, f = q_(o);
  if (document.caretRangeFromPoint)
    t = document.caretRangeFromPoint(e.clientX, e.clientY);
  else if (e.rangeParent && f !== null)
    f.collapse(e.rangeParent, e.rangeOffset || 0), t = f.getRangeAt(0);
  else
    throw Error("Cannot get the selection when dragging");
  return t;
}
var Io = Fc();
function tm(e) {
  const t = e.getNodes();
  return t.length === 0 ? /* @__PURE__ */ new Set([
    e.anchor.getNode().getParentOrThrow(),
    e.focus.getNode().getParentOrThrow()
  ]) : new Set(
    t.map((r) => vn.$isElementNode(r) ? r : r.getParentOrThrow())
  );
}
const nm = 3;
function rm(e) {
  const t = vn.$getSelection();
  if (!vn.$isRangeSelection(t))
    return !1;
  const r = tm(t);
  let o = 0;
  for (const f of r)
    if (Io.$isListNode(f))
      o = Math.max(Io.$getListDepth(f) + 1, o);
    else if (Io.$isListItemNode(f)) {
      const h = f.getParent();
      if (!Io.$isListNode(h))
        throw new Error(
          "ListMaxIndentLevelPlugin: A ListItemNode must have a ListNode for a parent."
        );
      o = Math.max(Io.$getListDepth(h) + 1, o);
    }
  return o <= e;
}
function im({ maxDepth: e }) {
  const [t] = Hc.useLexicalComposerContext();
  return fr(() => t.registerCommand(
    vn.INDENT_CONTENT_COMMAND,
    () => !rm(e || 7),
    nm
  ), [t, e]), null;
}
var hc = Kc(), hf = Bc(), gf = $c(), tl = {}, pf;
function om() {
  if (pf)
    return tl;
  pf = 1;
  var e = Jt(), t = kt();
  class r extends t.TextNode {
    static getType() {
      return "hashtag";
    }
    static clone(h) {
      return new r(h.__text, h.__key);
    }
    constructor(h, C) {
      super(h, C);
    }
    createDOM(h) {
      let C = super.createDOM(h);
      return e.addClassNamesToElement(C, h.theme.hashtag), C;
    }
    static importJSON(h) {
      let C = o(h.text);
      return C.setFormat(h.format), C.setDetail(h.detail), C.setMode(h.mode), C.setStyle(h.style), C;
    }
    exportJSON() {
      return { ...super.exportJSON(), type: "hashtag" };
    }
    canInsertTextBefore() {
      return !1;
    }
    isTextEntity() {
      return !0;
    }
  }
  function o(f = "") {
    return t.$applyNodeReplacement(new r(f));
  }
  return tl.$createHashtagNode = o, tl.$isHashtagNode = function(f) {
    return f instanceof r;
  }, tl.HashtagNode = r, tl;
}
var nl = {}, _f;
function sm() {
  if (_f)
    return nl;
  _f = 1;
  var e = Jt(), t = kt();
  class r extends t.TextNode {
    static getType() {
      return "hashtag";
    }
    static clone(C) {
      return new r(C.__text, C.__key);
    }
    constructor(C, T) {
      super(C, T);
    }
    createDOM(C) {
      const T = super.createDOM(C);
      return e.addClassNamesToElement(T, C.theme.hashtag), T;
    }
    static importJSON(C) {
      const T = o(C.text);
      return T.setFormat(C.format), T.setDetail(C.detail), T.setMode(C.mode), T.setStyle(C.style), T;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "hashtag"
      };
    }
    canInsertTextBefore() {
      return !1;
    }
    isTextEntity() {
      return !0;
    }
  }
  function o(h = "") {
    return t.$applyNodeReplacement(new r(h));
  }
  function f(h) {
    return h instanceof r;
  }
  return nl.$createHashtagNode = o, nl.$isHashtagNode = f, nl.HashtagNode = r, nl;
}
const lm = process.env.NODE_ENV === "development" ? sm() : om();
var am = lm;
const cm = "_rtl_13v3w_295", um = "_selected_13v3w_370", ot = {
  "yext-default-richtextv2-theme__ul1": "_yext-default-richtextv2-theme__ul1_13v3w_17",
  "yext-default-richtextv2-theme__ul2": "_yext-default-richtextv2-theme__ul2_13v3w_25",
  "yext-default-richtextv2-theme__ul3": "_yext-default-richtextv2-theme__ul3_13v3w_33",
  "yext-default-richtextv2-theme__ltr": "_yext-default-richtextv2-theme__ltr_13v3w_55",
  "yext-default-richtextv2-theme__rtl": "_yext-default-richtextv2-theme__rtl_13v3w_58",
  "yext-default-richtextv2-theme__paragraph": "_yext-default-richtextv2-theme__paragraph_13v3w_61",
  "yext-default-richtextv2-theme__quote": "_yext-default-richtextv2-theme__quote_13v3w_70",
  "yext-default-richtextv2-theme__h1": "_yext-default-richtextv2-theme__h1_13v3w_81",
  "yext-default-richtextv2-theme__h2": "_yext-default-richtextv2-theme__h2_13v3w_89",
  "yext-default-richtextv2-theme__h3": "_yext-default-richtextv2-theme__h3_13v3w_97",
  "yext-default-richtextv2-theme__h4": "_yext-default-richtextv2-theme__h4_13v3w_105",
  "yext-default-richtextv2-theme__h5": "_yext-default-richtextv2-theme__h5_13v3w_113",
  "yext-default-richtextv2-theme__h6": "_yext-default-richtextv2-theme__h6_13v3w_121",
  "yext-default-richtextv2-theme__textBold": "_yext-default-richtextv2-theme__textBold_13v3w_130",
  "yext-default-richtextv2-theme__textItalic": "_yext-default-richtextv2-theme__textItalic_13v3w_133",
  "yext-default-richtextv2-theme__textUnderline": "_yext-default-richtextv2-theme__textUnderline_13v3w_136",
  "yext-default-richtextv2-theme__textStrikethrough": "_yext-default-richtextv2-theme__textStrikethrough_13v3w_139",
  "yext-default-richtextv2-theme__textUnderlineStrikethrough": "_yext-default-richtextv2-theme__textUnderlineStrikethrough_13v3w_142",
  "yext-default-richtextv2-theme__textSubscript": "_yext-default-richtextv2-theme__textSubscript_13v3w_145",
  "yext-default-richtextv2-theme__textSuperscript": "_yext-default-richtextv2-theme__textSuperscript_13v3w_149",
  "yext-default-richtextv2-theme__textCode": "_yext-default-richtextv2-theme__textCode_13v3w_153",
  "yext-default-richtextv2-theme__hashtag": "_yext-default-richtextv2-theme__hashtag_13v3w_159",
  "yext-default-richtextv2-theme__link": "_yext-default-richtextv2-theme__link_13v3w_163",
  "yext-default-richtextv2-theme__code": "_yext-default-richtextv2-theme__code_13v3w_171",
  "yext-default-richtextv2-theme__table": "_yext-default-richtextv2-theme__table_13v3w_199",
  "yext-default-richtextv2-theme__tableCell": "_yext-default-richtextv2-theme__tableCell_13v3w_208",
  "yext-default-richtextv2-theme__tableCellHeader": "_yext-default-richtextv2-theme__tableCellHeader_13v3w_218",
  "yext-default-richtextv2-theme__characterLimit": "_yext-default-richtextv2-theme__characterLimit_13v3w_222",
  "yext-default-richtextv2-theme__ol1": "_yext-default-richtextv2-theme__ol1_13v3w_226",
  "yext-default-richtextv2-theme__ol2": "_yext-default-richtextv2-theme__ol2_13v3w_233",
  "yext-default-richtextv2-theme__ol3": "_yext-default-richtextv2-theme__ol3_13v3w_240",
  "yext-default-richtextv2-theme__ol4": "_yext-default-richtextv2-theme__ol4_13v3w_247",
  "yext-default-richtextv2-theme__ol5": "_yext-default-richtextv2-theme__ol5_13v3w_254",
  "yext-default-richtextv2-theme__ul": "_yext-default-richtextv2-theme__ul_13v3w_17",
  "yext-default-richtextv2-theme__listItem": "_yext-default-richtextv2-theme__listItem_13v3w_267",
  "yext-default-richtextv2-theme__listItemChecked": "_yext-default-richtextv2-theme__listItemChecked_13v3w_270",
  "yext-default-richtextv2-theme__listItemUnchecked": "_yext-default-richtextv2-theme__listItemUnchecked_13v3w_271",
  rtl: cm,
  "yext-default-richtextv2-theme__nestedListItem": "_yext-default-richtextv2-theme__nestedListItem_13v3w_330",
  "yext-default-richtextv2-theme__tokenComment": "_yext-default-richtextv2-theme__tokenComment_13v3w_337",
  "yext-default-richtextv2-theme__tokenPunctuation": "_yext-default-richtextv2-theme__tokenPunctuation_13v3w_340",
  "yext-default-richtextv2-theme__tokenProperty": "_yext-default-richtextv2-theme__tokenProperty_13v3w_343",
  "yext-default-richtextv2-theme__tokenSelector": "_yext-default-richtextv2-theme__tokenSelector_13v3w_346",
  "yext-default-richtextv2-theme__tokenOperator": "_yext-default-richtextv2-theme__tokenOperator_13v3w_349",
  "yext-default-richtextv2-theme__tokenAttr": "_yext-default-richtextv2-theme__tokenAttr_13v3w_352",
  "yext-default-richtextv2-theme__tokenVariable": "_yext-default-richtextv2-theme__tokenVariable_13v3w_355",
  "yext-default-richtextv2-theme__tokenFunction": "_yext-default-richtextv2-theme__tokenFunction_13v3w_358",
  "yext-default-richtextv2-theme__mark": "_yext-default-richtextv2-theme__mark_13v3w_361",
  "yext-default-richtextv2-theme__markOverlap": "_yext-default-richtextv2-theme__markOverlap_13v3w_366",
  selected: um,
  "yext-default-richtextv2-theme__embedBlock": "_yext-default-richtextv2-theme__embedBlock_13v3w_378",
  "yext-default-richtextv2-theme__embedBlockFocus": "_yext-default-richtextv2-theme__embedBlockFocus_13v3w_381",
  "yext-default-richtextv2-theme__image": "_yext-default-richtextv2-theme__image_13v3w_385"
}, dm = {
  characterLimit: ot["yext-default-richtextv2-theme__characterLimit"],
  code: ot["yext-default-richtextv2-theme__code"],
  codeHighlight: {
    atrule: ot["yext-default-richtextv2-theme__tokenAttr"],
    attr: ot["yext-default-richtextv2-theme__tokenAttr"],
    boolean: ot["yext-default-richtextv2-theme__tokenProperty"],
    builtin: ot["yext-default-richtextv2-theme__tokenSelector"],
    cdata: ot["yext-default-richtextv2-theme__tokenComment"],
    char: ot["yext-default-richtextv2-theme__tokenSelector"],
    class: ot["yext-default-richtextv2-theme__tokenFunction"],
    "class-name": ot["yext-default-richtextv2-theme__tokenFunction"],
    comment: ot["yext-default-richtextv2-theme__tokenComment"],
    constant: ot["yext-default-richtextv2-theme__tokenProperty"],
    deleted: ot["yext-default-richtextv2-theme__tokenProperty"],
    doctype: ot["yext-default-richtextv2-theme__tokenComment"],
    entity: ot["yext-default-richtextv2-theme__tokenOperator"],
    function: ot["yext-default-richtextv2-theme__tokenFunction"],
    important: ot["yext-default-richtextv2-theme__tokenVariable"],
    inserted: ot["yext-default-richtextv2-theme__tokenSelector"],
    keyword: ot["yext-default-richtextv2-theme__tokenAttr"],
    namespace: ot["yext-default-richtextv2-theme__tokenVariable"],
    number: ot["yext-default-richtextv2-theme__tokenProperty"],
    operator: ot["yext-default-richtextv2-theme__tokenOperator"],
    prolog: ot["yext-default-richtextv2-theme__tokenComment"],
    property: ot["yext-default-richtextv2-theme__tokenProperty"],
    punctuation: ot["yext-default-richtextv2-theme__tokenPunctuation"],
    regex: ot["yext-default-richtextv2-theme__tokenVariable"],
    selector: ot["yext-default-richtextv2-theme__tokenSelector"],
    string: ot["yext-default-richtextv2-theme__tokenSelector"],
    symbol: ot["yext-default-richtextv2-theme__tokenProperty"],
    tag: ot["yext-default-richtextv2-theme__tokenProperty"],
    url: ot["yext-default-richtextv2-theme__tokenOperator"],
    variable: ot["yext-default-richtextv2-theme__tokenVariable"]
  },
  embedBlock: {
    base: ot["yext-default-richtextv2-theme__embedBlock"],
    focus: ot["yext-default-richtextv2-theme__embedBlockFocus"]
  },
  hashtag: ot["yext-default-richtextv2-theme__hashtag"],
  heading: {
    h1: ot["yext-default-richtextv2-theme__h1"],
    h2: ot["yext-default-richtextv2-theme__h2"],
    h3: ot["yext-default-richtextv2-theme__h3"],
    h4: ot["yext-default-richtextv2-theme__h4"],
    h5: ot["yext-default-richtextv2-theme__h5"],
    h6: ot["yext-default-richtextv2-theme__h6"]
  },
  image: ot["yext-default-richtextv2-theme__image"],
  link: ot["yext-default-richtextv2-theme__link"],
  list: {
    listitem: ot["yext-default-richtextv2-theme__listItem"],
    listitemChecked: ot["yext-default-richtextv2-theme__listItemChecked"],
    listitemUnchecked: ot["yext-default-richtextv2-theme__listItemUnchecked"],
    nested: {
      listitem: ot["yext-default-richtextv2-theme__nestedListItem"]
    },
    olDepth: [
      ot["yext-default-richtextv2-theme__ol1"],
      ot["yext-default-richtextv2-theme__ol2"],
      ot["yext-default-richtextv2-theme__ol3"],
      ot["yext-default-richtextv2-theme__ol4"],
      ot["yext-default-richtextv2-theme__ol5"]
    ],
    ulDepth: [
      ot["yext-default-richtextv2-theme__ul1"],
      ot["yext-default-richtextv2-theme__ul2"],
      ot["yext-default-richtextv2-theme__ul3"]
    ]
  },
  ltr: ot["yext-default-richtextv2-theme__ltr"],
  mark: ot["yext-default-richtextv2-theme__mark"],
  markOverlap: ot["yext-default-richtextv2-theme__markOverlap"],
  paragraph: ot["yext-default-richtextv2-theme__paragraph"],
  quote: ot["yext-default-richtextv2-theme__quote"],
  rtl: ot["yext-default-richtextv2-theme__rtl"],
  table: ot["yext-default-richtextv2-theme__table"],
  tableCell: ot["yext-default-richtextv2-theme__tableCell"],
  tableCellHeader: ot["yext-default-richtextv2-theme__tableCellHeader"],
  text: {
    bold: ot["yext-default-richtextv2-theme__textBold"],
    code: ot["yext-default-richtextv2-theme__textCode"],
    italic: ot["yext-default-richtextv2-theme__textItalic"],
    strikethrough: ot["yext-default-richtextv2-theme__textStrikethrough"],
    subscript: ot["yext-default-richtextv2-theme__textSubscript"],
    superscript: ot["yext-default-richtextv2-theme__textSuperscript"],
    underline: ot["yext-default-richtextv2-theme__textUnderline"],
    underlineStrikethrough: ot["yext-default-richtextv2-theme__textUnderlineStrikethrough"]
  }
}, fm = dm;
var _s = {}, gc = {}, mf;
function hm() {
  if (mf)
    return gc;
  mf = 1;
  var e = kn(), t = kt(), r = rn;
  function o(f, h) {
    return f.getEditorState().read(() => {
      let C = t.$getNodeByKey(h);
      return C === null ? !1 : C.isSelected();
    });
  }
  return gc.useLexicalNodeSelection = function(f) {
    let [h] = e.useLexicalComposerContext(), [C, T] = r.useState(() => o(h, f));
    r.useEffect(() => {
      let x = !0, D = h.registerUpdateListener(() => {
        x && T(o(h, f));
      });
      return () => {
        x = !1, D();
      };
    }, [h, f]);
    let O = r.useCallback((x) => {
      h.update(() => {
        let D = t.$getSelection();
        t.$isNodeSelection(D) || (D = t.$createNodeSelection(), t.$setSelection(D)), t.$isNodeSelection(D) && (x ? D.add(f) : D.delete(f));
      });
    }, [h, f]), S = r.useCallback(
      () => {
        h.update(() => {
          const x = t.$getSelection();
          t.$isNodeSelection(x) && x.clear();
        });
      },
      [h]
    );
    return [C, O, S];
  }, gc;
}
var pc = {}, yf;
function gm() {
  if (yf)
    return pc;
  yf = 1;
  var e = kn(), t = kt(), r = rn;
  function o(h, C) {
    return h.getEditorState().read(() => {
      const T = t.$getNodeByKey(C);
      return T === null ? !1 : T.isSelected();
    });
  }
  function f(h) {
    const [C] = e.useLexicalComposerContext(), [T, O] = r.useState(() => o(C, h));
    r.useEffect(() => {
      let D = !0;
      const k = C.registerUpdateListener(() => {
        D && O(o(C, h));
      });
      return () => {
        D = !1, k();
      };
    }, [C, h]);
    const S = r.useCallback((D) => {
      C.update(() => {
        let k = t.$getSelection();
        t.$isNodeSelection(k) || (k = t.$createNodeSelection(), t.$setSelection(k)), t.$isNodeSelection(k) && (D ? k.add(h) : k.delete(h));
      });
    }, [C, h]), x = r.useCallback(() => {
      C.update(() => {
        const D = t.$getSelection();
        t.$isNodeSelection(D) && D.clear();
      });
    }, [C]);
    return [T, S, x];
  }
  return pc.useLexicalNodeSelection = f, pc;
}
var _c, Cf;
function Rh() {
  return Cf || (Cf = 1, _c = process.env.NODE_ENV === "development" ? gm() : hm()), _c;
}
var Nf;
function pm() {
  if (Nf)
    return _s;
  Nf = 1;
  var e = kn(), t = Rh(), r = Jt(), o = kt(), f = rn;
  let h = o.createCommand("INSERT_HORIZONTAL_RULE_COMMAND");
  function C({ nodeKey: D }) {
    let [k] = e.useLexicalComposerContext(), [H, N, v] = t.useLexicalNodeSelection(D), F = f.useCallback((U) => (H && o.$isNodeSelection(o.$getSelection()) && (U.preventDefault(), U = o.$getNodeByKey(D), x(U) && U.remove()), !1), [H, D]);
    return f.useEffect(() => r.mergeRegister(k.registerCommand(o.CLICK_COMMAND, (U) => {
      let I = k.getElementByKey(D);
      return U.target === I ? (U.shiftKey || v(), N(!H), !0) : !1;
    }, o.COMMAND_PRIORITY_LOW), k.registerCommand(o.KEY_DELETE_COMMAND, F, o.COMMAND_PRIORITY_LOW), k.registerCommand(
      o.KEY_BACKSPACE_COMMAND,
      F,
      o.COMMAND_PRIORITY_LOW
    )), [v, k, H, D, F, N]), f.useEffect(() => {
      let U = k.getElementByKey(D);
      U !== null && (U.className = H ? "selected" : "");
    }, [k, H, D]), null;
  }
  class T extends o.DecoratorNode {
    static getType() {
      return "horizontalrule";
    }
    static clone(k) {
      return new T(k.__key);
    }
    static importJSON() {
      return S();
    }
    static importDOM() {
      return { hr: () => ({ conversion: O, priority: 0 }) };
    }
    exportJSON() {
      return { type: "horizontalrule", version: 1 };
    }
    exportDOM() {
      return { element: document.createElement("hr") };
    }
    createDOM() {
      return document.createElement("hr");
    }
    getTextContent() {
      return `
`;
    }
    isInline() {
      return !1;
    }
    updateDOM() {
      return !1;
    }
    decorate() {
      return f.createElement(C, { nodeKey: this.__key });
    }
  }
  function O() {
    return { node: S() };
  }
  function S() {
    return o.$applyNodeReplacement(new T());
  }
  function x(D) {
    return D instanceof T;
  }
  return _s.$createHorizontalRuleNode = S, _s.$isHorizontalRuleNode = x, _s.HorizontalRuleNode = T, _s.INSERT_HORIZONTAL_RULE_COMMAND = h, _s;
}
var ms = {}, Ef;
function _m() {
  if (Ef)
    return ms;
  Ef = 1;
  var e = kn(), t = Rh(), r = Jt(), o = kt(), f = rn;
  const h = o.createCommand("INSERT_HORIZONTAL_RULE_COMMAND");
  function C({
    nodeKey: D
  }) {
    const [k] = e.useLexicalComposerContext(), [H, N, v] = t.useLexicalNodeSelection(D), F = f.useCallback((U) => {
      if (H && o.$isNodeSelection(o.$getSelection())) {
        U.preventDefault();
        const I = o.$getNodeByKey(D);
        x(I) && I.remove();
      }
      return !1;
    }, [H, D]);
    return f.useEffect(() => r.mergeRegister(k.registerCommand(o.CLICK_COMMAND, (U) => {
      const I = k.getElementByKey(D);
      return U.target === I ? (U.shiftKey || v(), N(!H), !0) : !1;
    }, o.COMMAND_PRIORITY_LOW), k.registerCommand(o.KEY_DELETE_COMMAND, F, o.COMMAND_PRIORITY_LOW), k.registerCommand(o.KEY_BACKSPACE_COMMAND, F, o.COMMAND_PRIORITY_LOW)), [v, k, H, D, F, N]), f.useEffect(() => {
      const U = k.getElementByKey(D);
      U !== null && (U.className = H ? "selected" : "");
    }, [k, H, D]), null;
  }
  class T extends o.DecoratorNode {
    static getType() {
      return "horizontalrule";
    }
    static clone(k) {
      return new T(k.__key);
    }
    static importJSON(k) {
      return S();
    }
    static importDOM() {
      return {
        hr: () => ({
          conversion: O,
          priority: 0
        })
      };
    }
    exportJSON() {
      return {
        type: "horizontalrule",
        version: 1
      };
    }
    exportDOM() {
      return {
        element: document.createElement("hr")
      };
    }
    createDOM() {
      return document.createElement("hr");
    }
    getTextContent() {
      return `
`;
    }
    isInline() {
      return !1;
    }
    updateDOM() {
      return !1;
    }
    decorate() {
      return /* @__PURE__ */ f.createElement(C, {
        nodeKey: this.__key
      });
    }
  }
  function O() {
    return {
      node: S()
    };
  }
  function S() {
    return o.$applyNodeReplacement(new T());
  }
  function x(D) {
    return D instanceof T;
  }
  return ms.$createHorizontalRuleNode = S, ms.$isHorizontalRuleNode = x, ms.HorizontalRuleNode = T, ms.INSERT_HORIZONTAL_RULE_COMMAND = h, ms;
}
const mm = process.env.NODE_ENV === "development" ? _m() : pm();
var ym = mm;
function Cm(e, t) {
  return {
    namespace: "",
    editable: !1,
    onError: (r) => {
      throw r;
    },
    editorState: e,
    theme: t ?? fm,
    nodes: [
      gf.HeadingNode,
      am.HashtagNode,
      Ts,
      Io.ListNode,
      Io.ListItemNode,
      gf.QuoteNode,
      vc.CodeNode,
      vc.CodeHighlightNode,
      hc.TableNode,
      hc.TableCellNode,
      hc.TableRowNode,
      hf.AutoLinkNode,
      hf.LinkNode,
      ym.HorizontalRuleNode
    ]
  };
}
const mc = {
  "editor-inner": "_editor-inner_1mmqo_6",
  "no-border": "_no-border_1mmqo_10"
};
function JC({
  serializedAST: e,
  nodeClassNames: t
}) {
  return /* @__PURE__ */ yt.jsx(
    jp.LexicalComposer,
    {
      initialConfig: Cm(e, t),
      children: /* @__PURE__ */ yt.jsx("div", { className: `${mc["editor-inner"]} ${mc["no-border"]}`, children: /* @__PURE__ */ yt.jsxs("div", { className: mc["editor-inner"], children: [
        /* @__PURE__ */ yt.jsx(
          h_.RichTextPlugin,
          {
            contentEditable: /* @__PURE__ */ yt.jsx(
              m_.ContentEditable,
              {
                className: "editor-input",
                ariaLabel: "Lexical Rich Text"
              }
            ),
            ErrorBoundary: T_,
            placeholder: /* @__PURE__ */ yt.jsx("div", {})
          }
        ),
        /* @__PURE__ */ yt.jsx(z_, {}),
        /* @__PURE__ */ yt.jsx(R_.ListPlugin, {}),
        /* @__PURE__ */ yt.jsx(P_.LinkPlugin, {}),
        /* @__PURE__ */ yt.jsx(K_.TablePlugin, {}),
        /* @__PURE__ */ yt.jsx(V_, {}),
        /* @__PURE__ */ yt.jsx(im, { maxDepth: 7 })
      ] }) })
    }
  );
}
function Wc(e, t, r, o) {
  const f = e.length;
  let h = 0, C;
  if (t < 0 ? t = -t > f ? 0 : f + t : t = t > f ? f : t, r = r > 0 ? r : 0, o.length < 1e4)
    C = Array.from(o), C.unshift(t, r), [].splice.apply(e, C);
  else
    for (r && [].splice.apply(e, [t, r]); h < o.length; )
      C = o.slice(h, h + 1e4), C.unshift(t, 0), [].splice.apply(e, C), h += 1e4, t += 1e4;
}
function rl(e, t) {
  return e.length > 0 ? (Wc(e, e.length, 0, t), e) : t;
}
const Tf = {}.hasOwnProperty;
function Nm(e) {
  const t = {};
  let r = -1;
  for (; ++r < e.length; )
    Em(t, e[r]);
  return t;
}
function Em(e, t) {
  let r;
  for (r in t) {
    const f = (Tf.call(e, r) ? e[r] : void 0) || (e[r] = {}), h = t[r];
    let C;
    for (C in h) {
      Tf.call(f, C) || (f[C] = []);
      const T = h[C];
      Tm(
        // @ts-expect-error Looks like a list.
        f[C],
        Array.isArray(T) ? T : T ? [T] : []
      );
    }
  }
}
function Tm(e, t) {
  let r = -1;
  const o = [];
  for (; ++r < t.length; )
    (t[r].add === "after" ? e : o).push(t[r]);
  Wc(e, 0, 0, o);
}
const ki = {
  carriageReturn: -5,
  lineFeed: -4,
  carriageReturnLineFeed: -3,
  horizontalTab: -2,
  virtualSpace: -1,
  eof: null,
  nul: 0,
  soh: 1,
  stx: 2,
  etx: 3,
  eot: 4,
  enq: 5,
  ack: 6,
  bel: 7,
  bs: 8,
  ht: 9,
  // `\t`
  lf: 10,
  // `\n`
  vt: 11,
  // `\v`
  ff: 12,
  // `\f`
  cr: 13,
  // `\r`
  so: 14,
  si: 15,
  dle: 16,
  dc1: 17,
  dc2: 18,
  dc3: 19,
  dc4: 20,
  nak: 21,
  syn: 22,
  etb: 23,
  can: 24,
  em: 25,
  sub: 26,
  esc: 27,
  fs: 28,
  gs: 29,
  rs: 30,
  us: 31,
  space: 32,
  exclamationMark: 33,
  // `!`
  quotationMark: 34,
  // `"`
  numberSign: 35,
  // `#`
  dollarSign: 36,
  // `$`
  percentSign: 37,
  // `%`
  ampersand: 38,
  // `&`
  apostrophe: 39,
  // `'`
  leftParenthesis: 40,
  // `(`
  rightParenthesis: 41,
  // `)`
  asterisk: 42,
  // `*`
  plusSign: 43,
  // `+`
  comma: 44,
  // `,`
  dash: 45,
  // `-`
  dot: 46,
  // `.`
  slash: 47,
  // `/`
  digit0: 48,
  // `0`
  digit1: 49,
  // `1`
  digit2: 50,
  // `2`
  digit3: 51,
  // `3`
  digit4: 52,
  // `4`
  digit5: 53,
  // `5`
  digit6: 54,
  // `6`
  digit7: 55,
  // `7`
  digit8: 56,
  // `8`
  digit9: 57,
  // `9`
  colon: 58,
  // `:`
  semicolon: 59,
  // `;`
  lessThan: 60,
  // `<`
  equalsTo: 61,
  // `=`
  greaterThan: 62,
  // `>`
  questionMark: 63,
  // `?`
  atSign: 64,
  // `@`
  uppercaseA: 65,
  // `A`
  uppercaseB: 66,
  // `B`
  uppercaseC: 67,
  // `C`
  uppercaseD: 68,
  // `D`
  uppercaseE: 69,
  // `E`
  uppercaseF: 70,
  // `F`
  uppercaseG: 71,
  // `G`
  uppercaseH: 72,
  // `H`
  uppercaseI: 73,
  // `I`
  uppercaseJ: 74,
  // `J`
  uppercaseK: 75,
  // `K`
  uppercaseL: 76,
  // `L`
  uppercaseM: 77,
  // `M`
  uppercaseN: 78,
  // `N`
  uppercaseO: 79,
  // `O`
  uppercaseP: 80,
  // `P`
  uppercaseQ: 81,
  // `Q`
  uppercaseR: 82,
  // `R`
  uppercaseS: 83,
  // `S`
  uppercaseT: 84,
  // `T`
  uppercaseU: 85,
  // `U`
  uppercaseV: 86,
  // `V`
  uppercaseW: 87,
  // `W`
  uppercaseX: 88,
  // `X`
  uppercaseY: 89,
  // `Y`
  uppercaseZ: 90,
  // `Z`
  leftSquareBracket: 91,
  // `[`
  backslash: 92,
  // `\`
  rightSquareBracket: 93,
  // `]`
  caret: 94,
  // `^`
  underscore: 95,
  // `_`
  graveAccent: 96,
  // `` ` ``
  lowercaseA: 97,
  // `a`
  lowercaseB: 98,
  // `b`
  lowercaseC: 99,
  // `c`
  lowercaseD: 100,
  // `d`
  lowercaseE: 101,
  // `e`
  lowercaseF: 102,
  // `f`
  lowercaseG: 103,
  // `g`
  lowercaseH: 104,
  // `h`
  lowercaseI: 105,
  // `i`
  lowercaseJ: 106,
  // `j`
  lowercaseK: 107,
  // `k`
  lowercaseL: 108,
  // `l`
  lowercaseM: 109,
  // `m`
  lowercaseN: 110,
  // `n`
  lowercaseO: 111,
  // `o`
  lowercaseP: 112,
  // `p`
  lowercaseQ: 113,
  // `q`
  lowercaseR: 114,
  // `r`
  lowercaseS: 115,
  // `s`
  lowercaseT: 116,
  // `t`
  lowercaseU: 117,
  // `u`
  lowercaseV: 118,
  // `v`
  lowercaseW: 119,
  // `w`
  lowercaseX: 120,
  // `x`
  lowercaseY: 121,
  // `y`
  lowercaseZ: 122,
  // `z`
  leftCurlyBrace: 123,
  // `{`
  verticalBar: 124,
  // `|`
  rightCurlyBrace: 125,
  // `}`
  tilde: 126,
  // `~`
  del: 127,
  // Unicode Specials block.
  byteOrderMarker: 65279,
  // Unicode Specials block.
  replacementCharacter: 65533
  // `�`
};
var xf = Object.prototype.hasOwnProperty;
function vf(e, t, r) {
  for (r of e.keys())
    if (sl(r, t))
      return r;
}
function sl(e, t) {
  var r, o, f;
  if (e === t)
    return !0;
  if (e && t && (r = e.constructor) === t.constructor) {
    if (r === Date)
      return e.getTime() === t.getTime();
    if (r === RegExp)
      return e.toString() === t.toString();
    if (r === Array) {
      if ((o = e.length) === t.length)
        for (; o-- && sl(e[o], t[o]); )
          ;
      return o === -1;
    }
    if (r === Set) {
      if (e.size !== t.size)
        return !1;
      for (o of e)
        if (f = o, f && typeof f == "object" && (f = vf(t, f), !f) || !t.has(f))
          return !1;
      return !0;
    }
    if (r === Map) {
      if (e.size !== t.size)
        return !1;
      for (o of e)
        if (f = o[0], f && typeof f == "object" && (f = vf(t, f), !f) || !sl(o[1], t.get(f)))
          return !1;
      return !0;
    }
    if (r === ArrayBuffer)
      e = new Uint8Array(e), t = new Uint8Array(t);
    else if (r === DataView) {
      if ((o = e.byteLength) === t.byteLength)
        for (; o-- && e.getInt8(o) === t.getInt8(o); )
          ;
      return o === -1;
    }
    if (ArrayBuffer.isView(e)) {
      if ((o = e.byteLength) === t.byteLength)
        for (; o-- && e[o] === t[o]; )
          ;
      return o === -1;
    }
    if (!r || typeof e == "object") {
      o = 0;
      for (r in e)
        if (xf.call(e, r) && ++o && !xf.call(t, r) || !(r in t) || !sl(e[r], t[r]))
          return !1;
      return Object.keys(t).length === o;
    }
  }
  return e !== e && t !== t;
}
let Sc, Dh, Ah, bh, Mh = !0;
typeof process < "u" && ({ FORCE_COLOR: Sc, NODE_DISABLE_COLORS: Dh, NO_COLOR: Ah, TERM: bh } = process.env || {}, Mh = process.stdout && process.stdout.isTTY);
const Bt = {
  enabled: !Dh && Ah == null && bh !== "dumb" && (Sc != null && Sc !== "0" || Mh),
  // modifiers
  reset: tn(0, 0),
  bold: tn(1, 22),
  dim: tn(2, 22),
  italic: tn(3, 23),
  underline: tn(4, 24),
  inverse: tn(7, 27),
  hidden: tn(8, 28),
  strikethrough: tn(9, 29),
  // colors
  black: tn(30, 39),
  red: tn(31, 39),
  green: tn(32, 39),
  yellow: tn(33, 39),
  blue: tn(34, 39),
  magenta: tn(35, 39),
  cyan: tn(36, 39),
  white: tn(37, 39),
  gray: tn(90, 39),
  grey: tn(90, 39),
  // background colors
  bgBlack: tn(40, 49),
  bgRed: tn(41, 49),
  bgGreen: tn(42, 49),
  bgYellow: tn(43, 49),
  bgBlue: tn(44, 49),
  bgMagenta: tn(45, 49),
  bgCyan: tn(46, 49),
  bgWhite: tn(47, 49)
};
function Sf(e, t) {
  let r = 0, o, f = "", h = "";
  for (; r < e.length; r++)
    o = e[r], f += o.open, h += o.close, ~t.indexOf(o.close) && (t = t.replace(o.rgx, o.close + o.open));
  return f + t + h;
}
function xm(e, t) {
  let r = { has: e, keys: t };
  return r.reset = Bt.reset.bind(r), r.bold = Bt.bold.bind(r), r.dim = Bt.dim.bind(r), r.italic = Bt.italic.bind(r), r.underline = Bt.underline.bind(r), r.inverse = Bt.inverse.bind(r), r.hidden = Bt.hidden.bind(r), r.strikethrough = Bt.strikethrough.bind(r), r.black = Bt.black.bind(r), r.red = Bt.red.bind(r), r.green = Bt.green.bind(r), r.yellow = Bt.yellow.bind(r), r.blue = Bt.blue.bind(r), r.magenta = Bt.magenta.bind(r), r.cyan = Bt.cyan.bind(r), r.white = Bt.white.bind(r), r.gray = Bt.gray.bind(r), r.grey = Bt.grey.bind(r), r.bgBlack = Bt.bgBlack.bind(r), r.bgRed = Bt.bgRed.bind(r), r.bgGreen = Bt.bgGreen.bind(r), r.bgYellow = Bt.bgYellow.bind(r), r.bgBlue = Bt.bgBlue.bind(r), r.bgMagenta = Bt.bgMagenta.bind(r), r.bgCyan = Bt.bgCyan.bind(r), r.bgWhite = Bt.bgWhite.bind(r), r;
}
function tn(e, t) {
  let r = {
    open: `\x1B[${e}m`,
    close: `\x1B[${t}m`,
    rgx: new RegExp(`\\x1b\\[${t}m`, "g")
  };
  return function(o) {
    return this !== void 0 && this.has !== void 0 ? (~this.has.indexOf(e) || (this.has.push(e), this.keys.push(r)), o === void 0 ? this : Bt.enabled ? Sf(this.keys, o + "") : o + "") : o === void 0 ? xm([e], [r]) : Bt.enabled ? Sf([r], o + "") : o + "";
  };
}
function so() {
}
so.prototype = {
  diff: function(t, r) {
    var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, f = o.callback;
    typeof o == "function" && (f = o, o = {}), this.options = o;
    var h = this;
    function C(v) {
      return f ? (setTimeout(function() {
        f(void 0, v);
      }, 0), !0) : v;
    }
    t = this.castInput(t), r = this.castInput(r), t = this.removeEmpty(this.tokenize(t)), r = this.removeEmpty(this.tokenize(r));
    var T = r.length, O = t.length, S = 1, x = T + O;
    o.maxEditLength && (x = Math.min(x, o.maxEditLength));
    var D = [{
      newPos: -1,
      components: []
    }], k = this.extractCommon(D[0], r, t, 0);
    if (D[0].newPos + 1 >= T && k + 1 >= O)
      return C([{
        value: this.join(r),
        count: r.length
      }]);
    function H() {
      for (var v = -1 * S; v <= S; v += 2) {
        var F = void 0, U = D[v - 1], I = D[v + 1], K = (I ? I.newPos : 0) - v;
        U && (D[v - 1] = void 0);
        var B = U && U.newPos + 1 < T, z = I && 0 <= K && K < O;
        if (!B && !z) {
          D[v] = void 0;
          continue;
        }
        if (!B || z && U.newPos < I.newPos ? (F = Sm(I), h.pushComponent(F.components, void 0, !0)) : (F = U, F.newPos++, h.pushComponent(F.components, !0, void 0)), K = h.extractCommon(F, r, t, v), F.newPos + 1 >= T && K + 1 >= O)
          return C(vm(h, F.components, r, t, h.useLongestToken));
        D[v] = F;
      }
      S++;
    }
    if (f)
      (function v() {
        setTimeout(function() {
          if (S > x)
            return f();
          H() || v();
        }, 0);
      })();
    else
      for (; S <= x; ) {
        var N = H();
        if (N)
          return N;
      }
  },
  pushComponent: function(t, r, o) {
    var f = t[t.length - 1];
    f && f.added === r && f.removed === o ? t[t.length - 1] = {
      count: f.count + 1,
      added: r,
      removed: o
    } : t.push({
      count: 1,
      added: r,
      removed: o
    });
  },
  extractCommon: function(t, r, o, f) {
    for (var h = r.length, C = o.length, T = t.newPos, O = T - f, S = 0; T + 1 < h && O + 1 < C && this.equals(r[T + 1], o[O + 1]); )
      T++, O++, S++;
    return S && t.components.push({
      count: S
    }), t.newPos = T, O;
  },
  equals: function(t, r) {
    return this.options.comparator ? this.options.comparator(t, r) : t === r || this.options.ignoreCase && t.toLowerCase() === r.toLowerCase();
  },
  removeEmpty: function(t) {
    for (var r = [], o = 0; o < t.length; o++)
      t[o] && r.push(t[o]);
    return r;
  },
  castInput: function(t) {
    return t;
  },
  tokenize: function(t) {
    return t.split("");
  },
  join: function(t) {
    return t.join("");
  }
};
function vm(e, t, r, o, f) {
  for (var h = 0, C = t.length, T = 0, O = 0; h < C; h++) {
    var S = t[h];
    if (S.removed) {
      if (S.value = e.join(o.slice(O, O + S.count)), O += S.count, h && t[h - 1].added) {
        var D = t[h - 1];
        t[h - 1] = t[h], t[h] = D;
      }
    } else {
      if (!S.added && f) {
        var x = r.slice(T, T + S.count);
        x = x.map(function(H, N) {
          var v = o[O + N];
          return v.length > H.length ? v : H;
        }), S.value = e.join(x);
      } else
        S.value = e.join(r.slice(T, T + S.count));
      T += S.count, S.added || (O += S.count);
    }
  }
  var k = t[C - 1];
  return C > 1 && typeof k.value == "string" && (k.added || k.removed) && e.equals("", k.value) && (t[C - 2].value += k.value, t.pop()), t;
}
function Sm(e) {
  return {
    newPos: e.newPos,
    components: e.components.slice(0)
  };
}
var wf = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, Of = /\S/, Lh = new so();
Lh.equals = function(e, t) {
  return this.options.ignoreCase && (e = e.toLowerCase(), t = t.toLowerCase()), e === t || this.options.ignoreWhitespace && !Of.test(e) && !Of.test(t);
};
Lh.tokenize = function(e) {
  for (var t = e.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), r = 0; r < t.length - 1; r++)
    !t[r + 1] && t[r + 2] && wf.test(t[r]) && wf.test(t[r + 2]) && (t[r] += t[r + 2], t.splice(r + 1, 2), r--);
  return t;
};
var Ph = new so();
Ph.tokenize = function(e) {
  var t = [], r = e.split(/(\n|\r\n)/);
  r[r.length - 1] || r.pop();
  for (var o = 0; o < r.length; o++) {
    var f = r[o];
    o % 2 && !this.options.newlineIsToken ? t[t.length - 1] += f : (this.options.ignoreWhitespace && (f = f.trim()), t.push(f));
  }
  return t;
};
var wm = new so();
wm.tokenize = function(e) {
  return e.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var Om = new so();
Om.tokenize = function(e) {
  return e.split(/([{}:;,]|\s+)/);
};
function Xl(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Xl = function(t) {
    return typeof t;
  } : Xl = function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Xl(e);
}
var Rm = Object.prototype.toString, ll = new so();
ll.useLongestToken = !0;
ll.tokenize = Ph.tokenize;
ll.castInput = function(e) {
  var t = this.options, r = t.undefinedReplacement, o = t.stringifyReplacer, f = o === void 0 ? function(h, C) {
    return typeof C > "u" ? r : C;
  } : o;
  return typeof e == "string" ? e : JSON.stringify(wc(e, null, null, f), f, "  ");
};
ll.equals = function(e, t) {
  return so.prototype.equals.call(ll, e.replace(/,([\r\n])/g, "$1"), t.replace(/,([\r\n])/g, "$1"));
};
function wc(e, t, r, o, f) {
  t = t || [], r = r || [], o && (e = o(f, e));
  var h;
  for (h = 0; h < t.length; h += 1)
    if (t[h] === e)
      return r[h];
  var C;
  if (Rm.call(e) === "[object Array]") {
    for (t.push(e), C = new Array(e.length), r.push(C), h = 0; h < e.length; h += 1)
      C[h] = wc(e[h], t, r, o, f);
    return t.pop(), r.pop(), C;
  }
  if (e && e.toJSON && (e = e.toJSON()), Xl(e) === "object" && e !== null) {
    t.push(e), C = {}, r.push(C);
    var T = [], O;
    for (O in e)
      e.hasOwnProperty(O) && T.push(O);
    for (T.sort(), h = 0; h < T.length; h += 1)
      O = T[h], C[O] = wc(e[O], t, r, o, O);
    t.pop(), r.pop();
  } else
    C = e;
  return C;
}
var Oc = new so();
Oc.tokenize = function(e) {
  return e.slice();
};
Oc.join = Oc.removeEmpty = function(e) {
  return e;
};
Bt.red, Bt.grey, Bt.green;
Bt.dim().italic;
Bt.dim("→");
Bt.dim("·");
Bt.dim("↵");
function ea(e) {
  e = e.replace(/\r?\n/g, `
`);
  let t = e.match(/^[ \t]*(?=\S)/gm), r = 0, o = 1 / 0, f = (t || []).length;
  for (; r < f; r++)
    o = Math.min(o, t[r].length);
  return f && o ? e.replace(new RegExp(`^[ \\t]{${o}}`, "gm"), "") : e;
}
class Dm extends Error {
  constructor(t = {}) {
    super(t.message), this.name = "Assertion", this.code = "ERR_ASSERTION", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), this.details = t.details || !1, this.generated = !!t.generated, this.operator = t.operator, this.expects = t.expects, this.actual = t.actual;
  }
}
function kr(e, t, r, o, f, h, C) {
  if (e)
    return;
  let T = C || h;
  if (C instanceof Error)
    throw C;
  let O = f && f(t, r);
  throw new Dm({ actual: t, expects: r, operator: o, message: T, details: O, generated: !C });
}
function aa(e, t) {
  kr(!!e, !1, !0, "ok", !1, "Expected value to be truthy", t);
}
function $i(e, t) {
  kr(!e, !0, !1, "not", !1, "Expected value to be falsey", t);
}
$i.ok = $i;
$i.equal = function(e, t, r) {
  kr(!sl(e, t), e, t, "not.equal", !1, "Expected values not to be deeply equal", r);
};
$i.type = function(e, t, r) {
  let o = typeof e;
  kr(o !== t, o, t, "not.type", !1, `Expected "${o}" not to be "${t}"`, r);
};
$i.instance = function(e, t, r) {
  let o = "`" + (t.name || t.constructor.name) + "`";
  kr(!(e instanceof t), e, t, "not.instance", !1, `Expected value not to be an instance of ${o}`, r);
};
$i.snapshot = function(e, t, r) {
  e = ea(e), t = ea(t), kr(e !== t, e, t, "not.snapshot", !1, "Expected value not to match snapshot", r);
};
$i.fixture = function(e, t, r) {
  e = ea(e), t = ea(t), kr(e !== t, e, t, "not.fixture", !1, "Expected value not to match fixture", r);
};
$i.match = function(e, t, r) {
  typeof t == "string" ? kr(!e.includes(t), e, t, "not.match", !1, `Expected value not to include "${t}" substring`, r) : kr(!t.test(e), e, t, "not.match", !1, `Expected value not to match \`${String(t)}\` pattern`, r);
};
$i.throws = function(e, t, r) {
  !r && typeof t == "string" && (r = t, t = null);
  try {
    e();
  } catch (o) {
    typeof t == "function" ? kr(!t(o), !0, !1, "not.throws", !1, "Expected function not to throw matching exception", r) : t instanceof RegExp ? kr(!t.test(o.message), !0, !1, "not.throws", !1, `Expected function not to throw exception matching \`${String(t)}\` pattern`, r) : t || kr(!1, !0, !1, "not.throws", !1, "Expected function not to throw", r);
  }
};
const Am = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, ZC = lo(/[A-Za-z]/), Rf = lo(/[\dA-Za-z]/), XC = lo(/[#-'*+\--9=?A-Z^-~]/);
function QC(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const eN = lo(/\d/), tN = lo(/[\dA-Fa-f]/), nN = lo(/[!-/:-@[-`{-~]/);
function rN(e) {
  return e !== null && e < -2;
}
function bm(e) {
  return e !== null && (e < 0 || e === 32);
}
function iN(e) {
  return e === -2 || e === -1 || e === 32;
}
const Mm = lo(Am), Lm = lo(/\s/);
function lo(e) {
  return t;
  function t(r) {
    return r !== null && e.test(String.fromCharCode(r));
  }
}
function ta(e) {
  if (e === null || bm(e) || Lm(e))
    return 1;
  if (Mm(e))
    return 2;
}
const na = {
  attentionSideBefore: 1,
  // Symbol to mark an attention sequence as before content: `*a`
  attentionSideAfter: 2,
  // Symbol to mark an attention sequence as after content: `a*`
  atxHeadingOpeningFenceSizeMax: 6,
  // 6 number signs is fine, 7 isn’t.
  autolinkDomainSizeMax: 63,
  // 63 characters is fine, 64 is too many.
  autolinkSchemeSizeMax: 32,
  // 32 characters is fine, 33 is too many.
  cdataOpeningString: "CDATA[",
  // And preceded by `<![`.
  characterGroupWhitespace: 1,
  // Symbol used to indicate a character is whitespace
  characterGroupPunctuation: 2,
  // Symbol used to indicate a character is punctuation
  characterReferenceDecimalSizeMax: 7,
  // `&#9999999;`.
  characterReferenceHexadecimalSizeMax: 6,
  // `&#xff9999;`.
  characterReferenceNamedSizeMax: 31,
  // `&CounterClockwiseContourIntegral;`.
  codeFencedSequenceSizeMin: 3,
  // At least 3 ticks or tildes are needed.
  contentTypeDocument: "document",
  contentTypeFlow: "flow",
  contentTypeContent: "content",
  contentTypeString: "string",
  contentTypeText: "text",
  hardBreakPrefixSizeMin: 2,
  // At least 2 trailing spaces are needed.
  htmlRaw: 1,
  // Symbol for `<script>`
  htmlComment: 2,
  // Symbol for `<!---->`
  htmlInstruction: 3,
  // Symbol for `<?php?>`
  htmlDeclaration: 4,
  // Symbol for `<!doctype>`
  htmlCdata: 5,
  // Symbol for `<![CDATA[]]>`
  htmlBasic: 6,
  // Symbol for `<div`
  htmlComplete: 7,
  // Symbol for `<x>`
  htmlRawSizeMax: 8,
  // Length of `textarea`.
  linkResourceDestinationBalanceMax: 32,
  // See: <https://spec.commonmark.org/0.30/#link-destination>, <https://github.com/remarkjs/react-markdown/issues/658#issuecomment-984345577>
  linkReferenceSizeMax: 999,
  // See: <https://spec.commonmark.org/0.30/#link-label>
  listItemValueSizeMax: 10,
  // See: <https://spec.commonmark.org/0.30/#ordered-list-marker>
  numericBaseDecimal: 10,
  numericBaseHexadecimal: 16,
  tabSize: 4,
  // Tabs have a hard-coded size of 4, per CommonMark.
  thematicBreakMarkerCountMin: 3,
  // At least 3 asterisks, dashes, or underscores are needed.
  v8MaxSafeChunkSize: 1e4
  // V8 (and potentially others) have problems injecting giant arrays into other arrays, hence we operate in chunks.
};
function Pm(e, t) {
  const r = this.previous, o = ta(r);
  return f;
  function f(C) {
    return aa(C === ki.tilde, "expected `~`"), e.enter("tildeSequenceTemporary"), h(C);
  }
  function h(C) {
    if (C === ki.tilde)
      return e.consume(C), h;
    const T = e.exit("tildeSequenceTemporary"), O = ta(C);
    return T._open = !O || O === na.characterGroupPunctuation && !!o, T._close = !o || o === na.characterGroupPunctuation && !!O, t(C);
  }
}
function Im(e, t, r) {
  const o = [];
  let f = -1;
  for (; ++f < e.length; ) {
    const h = e[f].resolveAll;
    h && !o.includes(h) && (t = h(t, r), o.push(h));
  }
  return t;
}
const km = {
  // Generic type for data, such as in a title, a destination, etc.
  data: "data",
  // Generic type for syntactic whitespace (tabs, virtual spaces, spaces).
  // Such as, between a fenced code fence and an info string.
  whitespace: "whitespace",
  // Generic type for line endings (line feed, carriage return, carriage return +
  // line feed).
  lineEnding: "lineEnding",
  // A line ending, but ending a blank line.
  lineEndingBlank: "lineEndingBlank",
  // Generic type for whitespace (tabs, virtual spaces, spaces) at the start of a
  // line.
  linePrefix: "linePrefix",
  // Generic type for whitespace (tabs, virtual spaces, spaces) at the end of a
  // line.
  lineSuffix: "lineSuffix",
  // Whole ATX heading:
  //
  // ```markdown
  // #
  // ## Alpha
  // ### Bravo ###
  // ```
  //
  // Includes `atxHeadingSequence`, `whitespace`, `atxHeadingText`.
  atxHeading: "atxHeading",
  // Sequence of number signs in an ATX heading (`###`).
  atxHeadingSequence: "atxHeadingSequence",
  // Content in an ATX heading (`alpha`).
  // Includes text.
  atxHeadingText: "atxHeadingText",
  // Whole autolink (`<https://example.com>` or `<admin@example.com>`)
  // Includes `autolinkMarker` and `autolinkProtocol` or `autolinkEmail`.
  autolink: "autolink",
  // Email autolink w/o markers (`admin@example.com`)
  autolinkEmail: "autolinkEmail",
  // Marker around an `autolinkProtocol` or `autolinkEmail` (`<` or `>`).
  autolinkMarker: "autolinkMarker",
  // Protocol autolink w/o markers (`https://example.com`)
  autolinkProtocol: "autolinkProtocol",
  // A whole character escape (`\-`).
  // Includes `escapeMarker` and `characterEscapeValue`.
  characterEscape: "characterEscape",
  // The escaped character (`-`).
  characterEscapeValue: "characterEscapeValue",
  // A whole character reference (`&amp;`, `&#8800;`, or `&#x1D306;`).
  // Includes `characterReferenceMarker`, an optional
  // `characterReferenceMarkerNumeric`, in which case an optional
  // `characterReferenceMarkerHexadecimal`, and a `characterReferenceValue`.
  characterReference: "characterReference",
  // The start or end marker (`&` or `;`).
  characterReferenceMarker: "characterReferenceMarker",
  // Mark reference as numeric (`#`).
  characterReferenceMarkerNumeric: "characterReferenceMarkerNumeric",
  // Mark reference as numeric (`x` or `X`).
  characterReferenceMarkerHexadecimal: "characterReferenceMarkerHexadecimal",
  // Value of character reference w/o markers (`amp`, `8800`, or `1D306`).
  characterReferenceValue: "characterReferenceValue",
  // Whole fenced code:
  //
  // ````markdown
  // ```js
  // alert(1)
  // ```
  // ````
  codeFenced: "codeFenced",
  // A fenced code fence, including whitespace, sequence, info, and meta
  // (` ```js `).
  codeFencedFence: "codeFencedFence",
  // Sequence of grave accent or tilde characters (` ``` `) in a fence.
  codeFencedFenceSequence: "codeFencedFenceSequence",
  // Info word (`js`) in a fence.
  // Includes string.
  codeFencedFenceInfo: "codeFencedFenceInfo",
  // Meta words (`highlight="1"`) in a fence.
  // Includes string.
  codeFencedFenceMeta: "codeFencedFenceMeta",
  // A line of code.
  codeFlowValue: "codeFlowValue",
  // Whole indented code:
  //
  // ```markdown
  //     alert(1)
  // ```
  //
  // Includes `lineEnding`, `linePrefix`, and `codeFlowValue`.
  codeIndented: "codeIndented",
  // A text code (``` `alpha` ```).
  // Includes `codeTextSequence`, `codeTextData`, `lineEnding`, and can include
  // `codeTextPadding`.
  codeText: "codeText",
  codeTextData: "codeTextData",
  // A space or line ending right after or before a tick.
  codeTextPadding: "codeTextPadding",
  // A text code fence (` `` `).
  codeTextSequence: "codeTextSequence",
  // Whole content:
  //
  // ```markdown
  // [a]: b
  // c
  // =
  // d
  // ```
  //
  // Includes `paragraph` and `definition`.
  content: "content",
  // Whole definition:
  //
  // ```markdown
  // [micromark]: https://github.com/micromark/micromark
  // ```
  //
  // Includes `definitionLabel`, `definitionMarker`, `whitespace`,
  // `definitionDestination`, and optionally `lineEnding` and `definitionTitle`.
  definition: "definition",
  // Destination of a definition (`https://github.com/micromark/micromark` or
  // `<https://github.com/micromark/micromark>`).
  // Includes `definitionDestinationLiteral` or `definitionDestinationRaw`.
  definitionDestination: "definitionDestination",
  // Enclosed destination of a definition
  // (`<https://github.com/micromark/micromark>`).
  // Includes `definitionDestinationLiteralMarker` and optionally
  // `definitionDestinationString`.
  definitionDestinationLiteral: "definitionDestinationLiteral",
  // Markers of an enclosed definition destination (`<` or `>`).
  definitionDestinationLiteralMarker: "definitionDestinationLiteralMarker",
  // Unenclosed destination of a definition
  // (`https://github.com/micromark/micromark`).
  // Includes `definitionDestinationString`.
  definitionDestinationRaw: "definitionDestinationRaw",
  // Text in an destination (`https://github.com/micromark/micromark`).
  // Includes string.
  definitionDestinationString: "definitionDestinationString",
  // Label of a definition (`[micromark]`).
  // Includes `definitionLabelMarker` and `definitionLabelString`.
  definitionLabel: "definitionLabel",
  // Markers of a definition label (`[` or `]`).
  definitionLabelMarker: "definitionLabelMarker",
  // Value of a definition label (`micromark`).
  // Includes string.
  definitionLabelString: "definitionLabelString",
  // Marker between a label and a destination (`:`).
  definitionMarker: "definitionMarker",
  // Title of a definition (`"x"`, `'y'`, or `(z)`).
  // Includes `definitionTitleMarker` and optionally `definitionTitleString`.
  definitionTitle: "definitionTitle",
  // Marker around a title of a definition (`"`, `'`, `(`, or `)`).
  definitionTitleMarker: "definitionTitleMarker",
  // Data without markers in a title (`z`).
  // Includes string.
  definitionTitleString: "definitionTitleString",
  // Emphasis (`*alpha*`).
  // Includes `emphasisSequence` and `emphasisText`.
  emphasis: "emphasis",
  // Sequence of emphasis markers (`*` or `_`).
  emphasisSequence: "emphasisSequence",
  // Emphasis text (`alpha`).
  // Includes text.
  emphasisText: "emphasisText",
  // The character escape marker (`\`).
  escapeMarker: "escapeMarker",
  // A hard break created with a backslash (`\\n`).
  // Includes `escapeMarker` (does not include the line ending)
  hardBreakEscape: "hardBreakEscape",
  // A hard break created with trailing spaces (`  \n`).
  // Does not include the line ending.
  hardBreakTrailing: "hardBreakTrailing",
  // Flow HTML:
  //
  // ```markdown
  // <div
  // ```
  //
  // Inlcudes `lineEnding`, `htmlFlowData`.
  htmlFlow: "htmlFlow",
  htmlFlowData: "htmlFlowData",
  // HTML in text (the tag in `a <i> b`).
  // Includes `lineEnding`, `htmlTextData`.
  htmlText: "htmlText",
  htmlTextData: "htmlTextData",
  // Whole image (`![alpha](bravo)`, `![alpha][bravo]`, `![alpha][]`, or
  // `![alpha]`).
  // Includes `label` and an optional `resource` or `reference`.
  image: "image",
  // Whole link label (`[*alpha*]`).
  // Includes `labelLink` or `labelImage`, `labelText`, and `labelEnd`.
  label: "label",
  // Text in an label (`*alpha*`).
  // Includes text.
  labelText: "labelText",
  // Start a link label (`[`).
  // Includes a `labelMarker`.
  labelLink: "labelLink",
  // Start an image label (`![`).
  // Includes `labelImageMarker` and `labelMarker`.
  labelImage: "labelImage",
  // Marker of a label (`[` or `]`).
  labelMarker: "labelMarker",
  // Marker to start an image (`!`).
  labelImageMarker: "labelImageMarker",
  // End a label (`]`).
  // Includes `labelMarker`.
  labelEnd: "labelEnd",
  // Whole link (`[alpha](bravo)`, `[alpha][bravo]`, `[alpha][]`, or `[alpha]`).
  // Includes `label` and an optional `resource` or `reference`.
  link: "link",
  // Whole paragraph:
  //
  // ```markdown
  // alpha
  // bravo.
  // ```
  //
  // Includes text.
  paragraph: "paragraph",
  // A reference (`[alpha]` or `[]`).
  // Includes `referenceMarker` and an optional `referenceString`.
  reference: "reference",
  // A reference marker (`[` or `]`).
  referenceMarker: "referenceMarker",
  // Reference text (`alpha`).
  // Includes string.
  referenceString: "referenceString",
  // A resource (`(https://example.com "alpha")`).
  // Includes `resourceMarker`, an optional `resourceDestination` with an optional
  // `whitespace` and `resourceTitle`.
  resource: "resource",
  // A resource destination (`https://example.com`).
  // Includes `resourceDestinationLiteral` or `resourceDestinationRaw`.
  resourceDestination: "resourceDestination",
  // A literal resource destination (`<https://example.com>`).
  // Includes `resourceDestinationLiteralMarker` and optionally
  // `resourceDestinationString`.
  resourceDestinationLiteral: "resourceDestinationLiteral",
  // A resource destination marker (`<` or `>`).
  resourceDestinationLiteralMarker: "resourceDestinationLiteralMarker",
  // A raw resource destination (`https://example.com`).
  // Includes `resourceDestinationString`.
  resourceDestinationRaw: "resourceDestinationRaw",
  // Resource destination text (`https://example.com`).
  // Includes string.
  resourceDestinationString: "resourceDestinationString",
  // A resource marker (`(` or `)`).
  resourceMarker: "resourceMarker",
  // A resource title (`"alpha"`, `'alpha'`, or `(alpha)`).
  // Includes `resourceTitleMarker` and optionally `resourceTitleString`.
  resourceTitle: "resourceTitle",
  // A resource title marker (`"`, `'`, `(`, or `)`).
  resourceTitleMarker: "resourceTitleMarker",
  // Resource destination title (`alpha`).
  // Includes string.
  resourceTitleString: "resourceTitleString",
  // Whole setext heading:
  //
  // ```markdown
  // alpha
  // bravo
  // =====
  // ```
  //
  // Includes `setextHeadingText`, `lineEnding`, `linePrefix`, and
  // `setextHeadingLine`.
  setextHeading: "setextHeading",
  // Content in a setext heading (`alpha\nbravo`).
  // Includes text.
  setextHeadingText: "setextHeadingText",
  // Underline in a setext heading, including whitespace suffix (`==`).
  // Includes `setextHeadingLineSequence`.
  setextHeadingLine: "setextHeadingLine",
  // Sequence of equals or dash characters in underline in a setext heading (`-`).
  setextHeadingLineSequence: "setextHeadingLineSequence",
  // Strong (`**alpha**`).
  // Includes `strongSequence` and `strongText`.
  strong: "strong",
  // Sequence of strong markers (`**` or `__`).
  strongSequence: "strongSequence",
  // Strong text (`alpha`).
  // Includes text.
  strongText: "strongText",
  // Whole thematic break:
  //
  // ```markdown
  // * * *
  // ```
  //
  // Includes `thematicBreakSequence` and `whitespace`.
  thematicBreak: "thematicBreak",
  // A sequence of one or more thematic break markers (`***`).
  thematicBreakSequence: "thematicBreakSequence",
  // Whole block quote:
  //
  // ```markdown
  // > a
  // >
  // > b
  // ```
  //
  // Includes `blockQuotePrefix` and flow.
  blockQuote: "blockQuote",
  // The `>` or `> ` of a block quote.
  blockQuotePrefix: "blockQuotePrefix",
  // The `>` of a block quote prefix.
  blockQuoteMarker: "blockQuoteMarker",
  // The optional ` ` of a block quote prefix.
  blockQuotePrefixWhitespace: "blockQuotePrefixWhitespace",
  // Whole unordered list:
  //
  // ```markdown
  // - a
  //   b
  // ```
  //
  // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
  // lines.
  listOrdered: "listOrdered",
  // Whole ordered list:
  //
  // ```markdown
  // 1. a
  //    b
  // ```
  //
  // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
  // lines.
  listUnordered: "listUnordered",
  // The indent of further list item lines.
  listItemIndent: "listItemIndent",
  // A marker, as in, `*`, `+`, `-`, `.`, or `)`.
  listItemMarker: "listItemMarker",
  // The thing that starts a list item, such as `1. `.
  // Includes `listItemValue` if ordered, `listItemMarker`, and
  // `listItemPrefixWhitespace` (unless followed by a line ending).
  listItemPrefix: "listItemPrefix",
  // The whitespace after a marker.
  listItemPrefixWhitespace: "listItemPrefixWhitespace",
  // The numerical value of an ordered item.
  listItemValue: "listItemValue",
  // Internal types used for subtokenizers, compiled away
  chunkDocument: "chunkDocument",
  chunkContent: "chunkContent",
  chunkFlow: "chunkFlow",
  chunkText: "chunkText",
  chunkString: "chunkString"
};
function zc(e, t) {
  return !!(e[0] === "enter" && e[1].type === `${t}SequenceTemporary` && e[1]._close);
}
function Gc(e, t) {
  return !!(e[0] === "exit" && e[1].type === `${t}SequenceTemporary` && e[1]._open);
}
function Yc(e, t, r, o, f, h) {
  const [C, T, O, S] = $m(
    e[t],
    e[r],
    f,
    h
  );
  e[t][1].end = Object.assign({}, C.start), e[r][1].start = Object.assign({}, T.end);
  let x = [];
  e[t][1].end.offset - e[t][1].start.offset && (x = rl(x, [
    ["enter", e[t][1], o],
    ["exit", e[t][1], o]
  ])), x = rl(x, [
    ["enter", S, o],
    ["enter", C, o],
    ["exit", C, o],
    ["enter", O, o]
  ]), x = rl(
    x,
    Im(
      o.parser.constructs.insideSpan.null,
      e.slice(t + 1, r),
      o
    )
  ), x = rl(x, [
    ["exit", O, o],
    ["enter", T, o],
    ["exit", T, o],
    ["exit", S, o]
  ]);
  let D = 0;
  return e[r][1].end.offset - e[r][1].start.offset && (D = 2, x = rl(x, [
    ["enter", e[r][1], o],
    ["exit", e[r][1], o]
  ])), Wc(e, t - 1, r - t + 3, x), t + x.length - D - 2;
}
function $m(e, t, r, o) {
  const f = Object.assign({}, e[1].end), h = Object.assign({}, t[1].start);
  Df(f, -o), Df(h, o);
  const C = {
    type: `${r}Sequence`,
    start: f,
    end: Object.assign({}, e[1].end)
  }, T = {
    type: `${r}Sequence`,
    start: Object.assign({}, t[1].start),
    end: h
  }, O = {
    type: `${r}Text`,
    start: Object.assign({}, e[1].end),
    end: Object.assign({}, t[1].start)
  }, S = {
    type: `${r}`,
    start: Object.assign({}, C.start),
    end: Object.assign({}, T.end)
  };
  return [C, T, O, S];
}
function Df(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
function jc(e, t) {
  e.forEach((r) => {
    r[1].type === `${t}SequenceTemporary` && (r[1].type = km.data);
  });
}
function Fm(e, t) {
  let r = -1;
  for (; ++r < e.length; )
    if (zc(e[r], "tilde")) {
      let o = r;
      for (; o--; )
        if (Gc(e[o], "tilde")) {
          const f = Bm(e[o], e[r]);
          r = Yc(
            e,
            o,
            r,
            t,
            f === 1 ? "subscript" : "strikethrough",
            f
          );
          break;
        }
    }
  return jc(e, "tilde"), e;
}
function Bm(e, t) {
  const r = e[1].end.offset - e[1].start.offset, o = t[1].end.offset - t[1].start.offset;
  return r < 3 || o < 3 ? o < r ? o : r : o % 2 === 0 ? 2 : 1;
}
function Km() {
  const e = {
    tokenize: Pm,
    resolveAll: Fm
  };
  return {
    text: { [ki.tilde]: e },
    insideSpan: { null: [e] }
  };
}
function Hm(e, t) {
  let r = -1;
  for (; ++r < e.length; )
    if (zc(e[r], "superscript")) {
      let o = r;
      for (; o--; )
        if (Gc(e[o], "superscript")) {
          r = Yc(
            e,
            o,
            r,
            t,
            "superscript",
            1
          );
          break;
        }
    }
  return jc(e, "superscript"), e;
}
function Um(e, t) {
  return r;
  function r(f) {
    return aa(f === ki.caret, "expected `^`"), e.enter("superscriptSequenceTemporary"), o(f);
  }
  function o(f) {
    if (f === ki.caret)
      return e.consume(f), o;
    const h = e.exit("superscriptSequenceTemporary");
    return h._open = !0, h._close = !0, t(f);
  }
}
function Wm() {
  const e = {
    tokenize: Um,
    resolveAll: Hm
  };
  return {
    text: { [ki.caret]: e },
    insideSpan: { null: [e] }
  };
}
function zm(e, t, r) {
  const o = this.previous, f = ta(o);
  let h = 0;
  return C;
  function C(O) {
    return aa(O === ki.plusSign, "expected `+`"), e.enter("underlineSequenceTemporary"), T(O);
  }
  function T(O) {
    if (O === ki.plusSign)
      return e.consume(O), h++, T;
    if (h < 2)
      return r(O);
    const S = e.exit("underlineSequenceTemporary"), x = ta(O);
    return S._open = !x || x === na.characterGroupPunctuation && !!f, S._close = !f || f === na.characterGroupPunctuation && !!x, t(O);
  }
}
function Gm(e, t) {
  let r = -1;
  for (; ++r < e.length; )
    if (zc(e[r], "underline") && e[r][1].end.offset - e[r][1].start.offset > 1) {
      let o = r;
      for (; o--; )
        if (Gc(e[o], "underline") && e[o][1].end.offset - e[o][1].start.offset > 1) {
          r = Yc(
            e,
            o,
            r,
            t,
            "underline",
            2
          );
          break;
        }
    }
  return jc(e, "underline"), e;
}
function Ym() {
  const e = {
    tokenize: zm,
    resolveAll: Gm
  };
  return {
    text: { [ki.plusSign]: e },
    insideSpan: { null: [e] }
  };
}
function jm() {
  return Nm([
    Ym(),
    Wm(),
    Km()
  ]);
}
const qm = {
  canContainEols: ["strikethrough"],
  enter: { strikethrough: Vm },
  exit: { strikethrough: Jm }
};
function Vm(e) {
  this.enter({ type: "strikethrough", children: [] }, e);
}
function Jm(e) {
  this.exit(e);
}
const Zm = {
  canContainEols: ["subscript"],
  enter: { subscript: Xm },
  exit: { subscript: Qm }
};
function Xm(e) {
  this.enter({ type: "subscript", children: [] }, e);
}
function Qm(e) {
  this.exit(e);
}
const ey = {
  canContainEols: ["superscript"],
  enter: { superscript: ty },
  exit: { superscript: ny }
};
function ty(e) {
  this.enter({ type: "superscript", children: [] }, e);
}
function ny(e) {
  this.exit(e);
}
const ry = {
  canContainEols: ["underline"],
  enter: { underline: iy },
  exit: { underline: oy }
};
function iy(e) {
  this.enter({ type: "underline", children: [] }, e);
}
function oy(e) {
  this.exit(e);
}
function sy() {
  return [
    ry,
    qm,
    Zm,
    ey
  ];
}
function ly() {
  const e = this.data();
  t("micromarkExtensions", jm()), t("fromMarkdownExtensions", sy());
  function t(r, o) {
    const f = e[r];
    f ? (aa(Array.isArray(f)), f.push(o)) : e[r] = [o];
  }
}
function ay(e, t) {
  const r = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function cy(e, t) {
  const r = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, r), [e.applyData(t, r), { type: "text", value: `
` }];
}
function uy(e, t) {
  const r = t.value ? t.value + `
` : "", o = t.lang ? t.lang.match(/^[^ \t]+(?=[ \t]|$)/) : null, f = {};
  o && (f.className = ["language-" + o]);
  let h = {
    type: "element",
    tagName: "code",
    properties: f,
    children: [{ type: "text", value: r }]
  };
  return t.meta && (h.data = { meta: t.meta }), e.patch(t, h), h = e.applyData(t, h), h = { type: "element", tagName: "pre", properties: {}, children: [h] }, e.patch(t, h), h;
}
function dy(e, t) {
  const r = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function fy(e, t) {
  const r = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function al(e) {
  const t = [];
  let r = -1, o = 0, f = 0;
  for (; ++r < e.length; ) {
    const h = e.charCodeAt(r);
    let C = "";
    if (h === 37 && Rf(e.charCodeAt(r + 1)) && Rf(e.charCodeAt(r + 2)))
      f = 2;
    else if (h < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(h)) || (C = String.fromCharCode(h));
    else if (h > 55295 && h < 57344) {
      const T = e.charCodeAt(r + 1);
      h < 56320 && T > 56319 && T < 57344 ? (C = String.fromCharCode(h, T), f = 1) : C = "�";
    } else
      C = String.fromCharCode(h);
    C && (t.push(e.slice(o, r), encodeURIComponent(C)), o = r + f + 1, C = ""), f && (r += f, f = 0);
  }
  return t.join("") + e.slice(o);
}
function Ih(e, t) {
  const r = String(t.identifier).toUpperCase(), o = al(r.toLowerCase()), f = e.footnoteOrder.indexOf(r);
  let h;
  f === -1 ? (e.footnoteOrder.push(r), e.footnoteCounts[r] = 1, h = e.footnoteOrder.length) : (e.footnoteCounts[r]++, h = f + 1);
  const C = e.footnoteCounts[r], T = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + e.clobberPrefix + "fn-" + o,
      id: e.clobberPrefix + "fnref-" + o + (C > 1 ? "-" + C : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(h) }]
  };
  e.patch(t, T);
  const O = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [T]
  };
  return e.patch(t, O), e.applyData(t, O);
}
function hy(e, t) {
  const r = e.footnoteById;
  let o = 1;
  for (; o in r; )
    o++;
  const f = String(o);
  return r[f] = {
    type: "footnoteDefinition",
    identifier: f,
    children: [{ type: "paragraph", children: t.children }],
    position: t.position
  }, Ih(e, {
    type: "footnoteReference",
    identifier: f,
    position: t.position
  });
}
function gy(e, t) {
  const r = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function py(e, t) {
  if (e.dangerous) {
    const r = { type: "raw", value: t.value };
    return e.patch(t, r), e.applyData(t, r);
  }
  return null;
}
function kh(e, t) {
  const r = t.referenceType;
  let o = "]";
  if (r === "collapsed" ? o += "[]" : r === "full" && (o += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return { type: "text", value: "![" + t.alt + o };
  const f = e.all(t), h = f[0];
  h && h.type === "text" ? h.value = "[" + h.value : f.unshift({ type: "text", value: "[" });
  const C = f[f.length - 1];
  return C && C.type === "text" ? C.value += o : f.push({ type: "text", value: o }), f;
}
function _y(e, t) {
  const r = e.definition(t.identifier);
  if (!r)
    return kh(e, t);
  const o = { src: al(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (o.title = r.title);
  const f = { type: "element", tagName: "img", properties: o, children: [] };
  return e.patch(t, f), e.applyData(t, f);
}
function my(e, t) {
  const r = { src: al(t.url) };
  t.alt !== null && t.alt !== void 0 && (r.alt = t.alt), t.title !== null && t.title !== void 0 && (r.title = t.title);
  const o = { type: "element", tagName: "img", properties: r, children: [] };
  return e.patch(t, o), e.applyData(t, o);
}
function yy(e, t) {
  const r = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, r);
  const o = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [r]
  };
  return e.patch(t, o), e.applyData(t, o);
}
function Cy(e, t) {
  const r = e.definition(t.identifier);
  if (!r)
    return kh(e, t);
  const o = { href: al(r.url || "") };
  r.title !== null && r.title !== void 0 && (o.title = r.title);
  const f = {
    type: "element",
    tagName: "a",
    properties: o,
    children: e.all(t)
  };
  return e.patch(t, f), e.applyData(t, f);
}
function Ny(e, t) {
  const r = { href: al(t.url) };
  t.title !== null && t.title !== void 0 && (r.title = t.title);
  const o = {
    type: "element",
    tagName: "a",
    properties: r,
    children: e.all(t)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function Ey(e, t, r) {
  const o = e.all(t), f = r ? Ty(r) : $h(t), h = {}, C = [];
  if (typeof t.checked == "boolean") {
    const x = o[0];
    let D;
    x && x.type === "element" && x.tagName === "p" ? D = x : (D = { type: "element", tagName: "p", properties: {}, children: [] }, o.unshift(D)), D.children.length > 0 && D.children.unshift({ type: "text", value: " " }), D.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), h.className = ["task-list-item"];
  }
  let T = -1;
  for (; ++T < o.length; ) {
    const x = o[T];
    (f || T !== 0 || x.type !== "element" || x.tagName !== "p") && C.push({ type: "text", value: `
` }), x.type === "element" && x.tagName === "p" && !f ? C.push(...x.children) : C.push(x);
  }
  const O = o[o.length - 1];
  O && (f || O.type !== "element" || O.tagName !== "p") && C.push({ type: "text", value: `
` });
  const S = { type: "element", tagName: "li", properties: h, children: C };
  return e.patch(t, S), e.applyData(t, S);
}
function Ty(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const r = e.children;
    let o = -1;
    for (; !t && ++o < r.length; )
      t = $h(r[o]);
  }
  return t;
}
function $h(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function xy(e, t) {
  const r = {}, o = e.all(t);
  let f = -1;
  for (typeof t.start == "number" && t.start !== 1 && (r.start = t.start); ++f < o.length; ) {
    const C = o[f];
    if (C.type === "element" && C.tagName === "li" && C.properties && Array.isArray(C.properties.className) && C.properties.className.includes("task-list-item")) {
      r.className = ["contains-task-list"];
      break;
    }
  }
  const h = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: r,
    children: e.wrap(o, !0)
  };
  return e.patch(t, h), e.applyData(t, h);
}
function vy(e, t) {
  const r = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Sy(e, t) {
  const r = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, r), e.applyData(t, r);
}
function wy(e, t) {
  const r = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
const qc = Fh("start"), Vc = Fh("end");
function Oy(e) {
  return { start: qc(e), end: Vc(e) };
}
function Fh(e) {
  return t;
  function t(r) {
    const o = r && r.position && r.position[e] || {};
    return {
      // @ts-expect-error: in practice, null is allowed.
      line: o.line || null,
      // @ts-expect-error: in practice, null is allowed.
      column: o.column || null,
      // @ts-expect-error: in practice, null is allowed.
      offset: o.offset > -1 ? o.offset : null
    };
  }
}
function Ry(e, t) {
  const r = e.all(t), o = r.shift(), f = [];
  if (o) {
    const C = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([o], !0)
    };
    e.patch(t.children[0], C), f.push(C);
  }
  if (r.length > 0) {
    const C = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(r, !0)
    }, T = qc(t.children[1]), O = Vc(t.children[t.children.length - 1]);
    T.line && O.line && (C.position = { start: T, end: O }), f.push(C);
  }
  const h = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(f, !0)
  };
  return e.patch(t, h), e.applyData(t, h);
}
function Dy(e, t, r) {
  const o = r ? r.children : void 0, h = (o ? o.indexOf(t) : 1) === 0 ? "th" : "td", C = r && r.type === "table" ? r.align : void 0, T = C ? C.length : t.children.length;
  let O = -1;
  const S = [];
  for (; ++O < T; ) {
    const D = t.children[O], k = {}, H = C ? C[O] : void 0;
    H && (k.align = H);
    let N = { type: "element", tagName: h, properties: k, children: [] };
    D && (N.children = e.all(D), e.patch(D, N), N = e.applyData(t, N)), S.push(N);
  }
  const x = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(S, !0)
  };
  return e.patch(t, x), e.applyData(t, x);
}
function Ay(e, t) {
  const r = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
const Af = 9, bf = 32;
function by(e) {
  const t = String(e), r = /\r?\n|\r/g;
  let o = r.exec(t), f = 0;
  const h = [];
  for (; o; )
    h.push(
      Mf(t.slice(f, o.index), f > 0, !0),
      o[0]
    ), f = o.index + o[0].length, o = r.exec(t);
  return h.push(Mf(t.slice(f), f > 0, !1)), h.join("");
}
function Mf(e, t, r) {
  let o = 0, f = e.length;
  if (t) {
    let h = e.codePointAt(o);
    for (; h === Af || h === bf; )
      o++, h = e.codePointAt(o);
  }
  if (r) {
    let h = e.codePointAt(f - 1);
    for (; h === Af || h === bf; )
      f--, h = e.codePointAt(f - 1);
  }
  return f > o ? e.slice(o, f) : "";
}
function My(e, t) {
  const r = { type: "text", value: by(String(t.value)) };
  return e.patch(t, r), e.applyData(t, r);
}
function Ly(e, t) {
  const r = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, r), e.applyData(t, r);
}
const Py = {
  blockquote: ay,
  break: cy,
  code: uy,
  delete: dy,
  emphasis: fy,
  footnoteReference: Ih,
  footnote: hy,
  heading: gy,
  html: py,
  imageReference: _y,
  image: my,
  inlineCode: yy,
  linkReference: Cy,
  link: Ny,
  listItem: Ey,
  list: xy,
  paragraph: vy,
  root: Sy,
  strong: wy,
  table: Ry,
  tableCell: Ay,
  tableRow: Dy,
  text: My,
  thematicBreak: Ly,
  toml: Zl,
  yaml: Zl,
  definition: Zl,
  footnoteDefinition: Zl
};
function Zl() {
  return null;
}
const Bh = (
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {AssertAnything}
   */
  function(e) {
    if (e == null)
      return Fy;
    if (typeof e == "string")
      return $y(e);
    if (typeof e == "object")
      return Array.isArray(e) ? Iy(e) : ky(e);
    if (typeof e == "function")
      return ca(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function Iy(e) {
  const t = [];
  let r = -1;
  for (; ++r < e.length; )
    t[r] = Bh(e[r]);
  return ca(o);
  function o(...f) {
    let h = -1;
    for (; ++h < t.length; )
      if (t[h].call(this, ...f))
        return !0;
    return !1;
  }
}
function ky(e) {
  return ca(t);
  function t(r) {
    let o;
    for (o in e)
      if (r[o] !== e[o])
        return !1;
    return !0;
  }
}
function $y(e) {
  return ca(t);
  function t(r) {
    return r && r.type === e;
  }
}
function ca(e) {
  return t;
  function t(r, ...o) {
    return !!(r && typeof r == "object" && "type" in r && e.call(this, r, ...o));
  }
}
function Fy() {
  return !0;
}
const By = !0, Lf = !1, Ky = "skip", Hy = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor<Node>} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(e, t, r, o) {
    typeof t == "function" && typeof r != "function" && (o = r, r = t, t = null);
    const f = Bh(t), h = o ? -1 : 1;
    C(e, void 0, [])();
    function C(T, O, S) {
      const x = T && typeof T == "object" ? T : {};
      if (typeof x.type == "string") {
        const k = (
          // `hast`
          typeof x.tagName == "string" ? x.tagName : (
            // `xast`
            typeof x.name == "string" ? x.name : void 0
          )
        );
        Object.defineProperty(D, "name", {
          value: "node (" + (T.type + (k ? "<" + k + ">" : "")) + ")"
        });
      }
      return D;
      function D() {
        let k = [], H, N, v;
        if ((!t || f(T, O, S[S.length - 1] || null)) && (k = Uy(r(T, S)), k[0] === Lf))
          return k;
        if (T.children && k[0] !== Ky)
          for (N = (o ? T.children.length : -1) + h, v = S.concat(T); N > -1 && N < T.children.length; ) {
            if (H = C(T.children[N], N, v)(), H[0] === Lf)
              return H;
            N = typeof H[1] == "number" ? H[1] : N + h;
          }
        return k;
      }
    }
  }
);
function Uy(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [By, e] : [e];
}
const Kh = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(e, t, r, o) {
    typeof t == "function" && typeof r != "function" && (o = r, r = t, t = null), Hy(e, t, f, o);
    function f(h, C) {
      const T = C[C.length - 1];
      return r(
        h,
        T ? T.children.indexOf(h) : null,
        T
      );
    }
  }
);
function Wy(e) {
  return !e || !e.position || !e.position.start || !e.position.start.line || !e.position.start.column || !e.position.end || !e.position.end.line || !e.position.end.column;
}
const Pf = {}.hasOwnProperty;
function zy(e) {
  const t = /* @__PURE__ */ Object.create(null);
  if (!e || !e.type)
    throw new Error("mdast-util-definitions expected node");
  return Kh(e, "definition", (o) => {
    const f = If(o.identifier);
    f && !Pf.call(t, f) && (t[f] = o);
  }), r;
  function r(o) {
    const f = If(o);
    return f && Pf.call(t, f) ? t[f] : null;
  }
}
function If(e) {
  return String(e || "").toUpperCase();
}
const ra = {}.hasOwnProperty;
function oN(e, t) {
  const r = t || {}, o = r.allowDangerousHtml || !1, f = {};
  return C.dangerous = o, C.clobberPrefix = r.clobberPrefix === void 0 || r.clobberPrefix === null ? "user-content-" : r.clobberPrefix, C.footnoteLabel = r.footnoteLabel || "Footnotes", C.footnoteLabelTagName = r.footnoteLabelTagName || "h2", C.footnoteLabelProperties = r.footnoteLabelProperties || {
    className: ["sr-only"]
  }, C.footnoteBackLabel = r.footnoteBackLabel || "Back to content", C.unknownHandler = r.unknownHandler, C.passThrough = r.passThrough, C.handlers = { ...Py, ...r.handlers }, C.definition = zy(e), C.footnoteById = f, C.footnoteOrder = [], C.footnoteCounts = {}, C.patch = Gy, C.applyData = Yy, C.one = T, C.all = O, C.wrap = qy, C.augment = h, Kh(e, "footnoteDefinition", (S) => {
    const x = String(S.identifier).toUpperCase();
    ra.call(f, x) || (f[x] = S);
  }), C;
  function h(S, x) {
    if (S && "data" in S && S.data) {
      const D = S.data;
      D.hName && (x.type !== "element" && (x = {
        type: "element",
        tagName: "",
        properties: {},
        children: []
      }), x.tagName = D.hName), x.type === "element" && D.hProperties && (x.properties = { ...x.properties, ...D.hProperties }), "children" in x && x.children && D.hChildren && (x.children = D.hChildren);
    }
    if (S) {
      const D = "type" in S ? S : { position: S };
      Wy(D) || (x.position = { start: qc(D), end: Vc(D) });
    }
    return x;
  }
  function C(S, x, D, k) {
    return Array.isArray(D) && (k = D, D = {}), h(S, {
      type: "element",
      tagName: x,
      properties: D || {},
      children: k || []
    });
  }
  function T(S, x) {
    return Hh(C, S, x);
  }
  function O(S) {
    return Fi(C, S);
  }
}
function Gy(e, t) {
  e.position && (t.position = Oy(e));
}
function Yy(e, t) {
  let r = t;
  if (e && e.data) {
    const o = e.data.hName, f = e.data.hChildren, h = e.data.hProperties;
    typeof o == "string" && (r.type === "element" ? r.tagName = o : r = {
      type: "element",
      tagName: o,
      properties: {},
      children: []
    }), r.type === "element" && h && (r.properties = { ...r.properties, ...h }), "children" in r && r.children && f !== null && f !== void 0 && (r.children = f);
  }
  return r;
}
function Hh(e, t, r) {
  const o = t && t.type;
  if (!o)
    throw new Error("Expected node, got `" + t + "`");
  return ra.call(e.handlers, o) ? e.handlers[o](e, t, r) : e.passThrough && e.passThrough.includes(o) ? "children" in t ? { ...t, children: Fi(e, t) } : t : e.unknownHandler ? e.unknownHandler(e, t, r) : jy(e, t);
}
function Fi(e, t) {
  const r = [];
  if ("children" in t) {
    const o = t.children;
    let f = -1;
    for (; ++f < o.length; ) {
      const h = Hh(e, o[f], t);
      if (h) {
        if (f && o[f - 1].type === "break" && (!Array.isArray(h) && h.type === "text" && (h.value = h.value.replace(/^\s+/, "")), !Array.isArray(h) && h.type === "element")) {
          const C = h.children[0];
          C && C.type === "text" && (C.value = C.value.replace(/^\s+/, ""));
        }
        Array.isArray(h) ? r.push(...h) : r.push(h);
      }
    }
  }
  return r;
}
function jy(e, t) {
  const r = t.data || {}, o = "value" in t && !(ra.call(r, "hProperties") || ra.call(r, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: Fi(e, t)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function qy(e, t) {
  const r = [];
  let o = -1;
  for (t && r.push({ type: "text", value: `
` }); ++o < e.length; )
    o && r.push({ type: "text", value: `
` }), r.push(e[o]);
  return t && e.length > 0 && r.push({ type: "text", value: `
` }), r;
}
const Vy = (e, t) => e(t, "i", Fi(e, t)), Jy = (e, t) => e(t, "b", Fi(e, t)), Zy = (e, t) => e(t, "u", Fi(e, t)), Xy = (e, t) => e(t, "s", Fi(e, t)), Qy = (e, t) => e(t, "sub", Fi(e, t)), eC = (e, t) => e(t, "sup", Fi(e, t)), tC = {
  emphasis: Vy,
  strong: Jy,
  underline: Zy,
  strikethrough: Xy,
  subscript: Qy,
  superscript: eC
}, sN = (e) => {
  const [t, r] = Tr();
  let o;
  return fr(() => {
    (async () => {
      if (!o)
        try {
          o = (await import("./index--cy1NwMF.js")).default;
        } catch {
          throw new Error(
            "Failed to import React Markdown, cannot properly render LegacyRichText."
          );
        }
      const h = o({
        children: e.markdown,
        remarkPlugins: [ly],
        remarkRehypeOptions: {
          handlers: tC
        }
      });
      r(h);
    })();
  }, [e.markdown]), t || null;
}, nC = [
  "sunday",
  "monday",
  "tuesday",
  "wednesday",
  "thursday",
  "friday"
];
class kf {
  /**
   * @param date - the Date for the day on which the interval starts
   * @param interval - the Yext Streams interval data
   */
  constructor(t, r) {
    Ln(this, "end");
    Ln(this, "start");
    this.end = new Date(t), this.start = new Date(t), [r.start, r.end].forEach((T) => {
      if (T.split(":").length !== 2)
        throw new Error(
          'expected interval start and end data to be in the format "HH:MM"'
        );
    });
    const [o, f] = r.start.split(":"), [h, C] = r.end.split(":");
    this.end.setHours(Number(h), Number(C)), this.start.setHours(Number(o), Number(f)), this.end < this.start && this.end.setDate(this.end.getDate() + 1), this.end.getMinutes() === 59 && this.end.setMinutes(60);
  }
  /**
   * @param date - A moment in time
   * @returns True if the given moment is within the interval
   */
  contains(t) {
    return this.start <= t && t < this.end;
  }
  /**
   * @param opts - intl.DateTimeFormatOptions
   * @param locale - defaults to 'en-US'
   * @returns representation of this interval's start time
   */
  getStartTime(t, r) {
    const o = {
      hour: "numeric",
      minute: "numeric",
      ...r
    };
    return this.start.toLocaleString(t || "en-US", o);
  }
  /**
   * @param opts - intl.DateTimeFormatOptions
   * @param locale - defaults to 'en-US'
   * @returns representation of this interval's end time
   */
  getEndTime(t, r) {
    const o = {
      hour: "numeric",
      minute: "numeric",
      ...r
    };
    return this.end.toLocaleString(t || "en-US", o);
  }
  /**
   * @param other - HoursIntervalManipulator
   * @returns if this interval and 'other' have the same start/end
   */
  timeIsEqualTo(t) {
    const r = this.getStartTime() === t.getStartTime(), o = this.getEndTime() === t.getEndTime();
    return r && o;
  }
}
class rC {
  /**
   * @param hours - Hours object in the format returned by Yext Streams
   */
  constructor(t) {
    Ln(this, "holidayHoursByDate");
    Ln(this, "hours");
    this.holidayHoursByDate = Object.fromEntries(
      (t.holidayHours || []).map((r) => [r.date, r])
    ), this.hours = t;
  }
  /**
   * @param date - A moment in time
   * @returns The first interval that contains the given moment, null if none
   */
  getInterval(t) {
    if (this.isTemporarilyClosedAt(t))
      return null;
    const r = new Date(t);
    r.setDate(r.getDate() - 1);
    for (const o of [r, t]) {
      const f = this.getHours(o);
      if (f && !f.isClosed)
        for (const h of f.openIntervals || []) {
          const C = new kf(
            o,
            h
          );
          if (C.contains(t))
            return C;
        }
    }
    return null;
  }
  /**
   * @returns The first interval that contains the current time, null if none
   */
  getCurrentInterval() {
    return this.getInterval(/* @__PURE__ */ new Date());
  }
  /**
   * @param date - A moment in time
   * @returns The next interval that hasn't started as of the given moment
   */
  getIntervalAfter(t) {
    const r = this.getIntervalsForNDays(8, t), o = (h, C) => h.start === C.start ? 0 : h.start > C.start ? 1 : -1, f = r.sort(o);
    for (const [h, C] of f.entries())
      if (C.contains(t) && f.length > h + 1)
        return f[h + 1];
    for (const h of f)
      if (h.start > t)
        return h;
    return null;
  }
  /**
   * @returns The next interval that hasn't started as of the current time
   */
  getNextInterval() {
    return this.getIntervalAfter(/* @__PURE__ */ new Date());
  }
  /**
   * @param n - number of days to check
   * @param startDate - first day to check
   * @returns list of intervals in range [startDate, startDate+7]
   */
  getIntervalsForNDays(t, r) {
    const o = [];
    for (let f = 0; f < t; f++) {
      const h = new Date(r);
      h.setDate(h.getDate() + f);
      const C = this.getHours(h);
      C && !C.isClosed && o.push(
        ...C.openIntervals.map(
          (T) => new kf(h, T)
        )
      );
    }
    return o;
  }
  /**
   * @param date - The day to get the hours for
   * @returns The daily holiday hours object from the original Streams response for the
   *   given date, null if none
   */
  getHolidayHours(t) {
    return this.isTemporarilyClosedAt(t) ? null : this.holidayHoursByDate[this.transformDateToYext(t)] || null;
  }
  /**
   * @param date - The day to get the hours for
   * @returns The daily normal hours object from the original Streams response for the
   *   given date, null if none
   */
  getNormalHours(t) {
    return this.isTemporarilyClosedAt(t) ? null : this.hours[nC[t.getDay()]];
  }
  /**
   * @param date - The day to get the hours for
   * @returns The daily hours object from the original Streams response for the given
   *   date, null if none
   */
  getHours(t) {
    const r = this.getHolidayHours(t);
    return !r || r.isRegularHours ? this.getNormalHours(t) : r;
  }
  /**
   * @param date - A day
   * @returns True if the given day has holiday hours
   */
  isHoliday(t) {
    return !!this.getHolidayHours(t);
  }
  /**
   * Yext platform uses the field `hours.reopenDate` to indicate an entity is
   *  temporarily closed for more than one day.
   * @param targetDate - the date to check against
   * @returns True if the given date is before 'reopenDate'
   */
  isTemporarilyClosedAt(t) {
    return this.hours.reopenDate ? this.transformDateToYext(t) < this.hours.reopenDate : !1;
  }
  /**
   * @param date - A moment in time
   * @returns True if the given moment falls within any interval
   */
  isOpenAt(t) {
    return this.isTemporarilyClosedAt(t) ? !1 : !!this.getInterval(t);
  }
  /**
   * @returns True if the current time falls within any interval
   */
  isOpenNow() {
    return this.isOpenAt(/* @__PURE__ */ new Date());
  }
  /**
   * Convert ISO Date which have 1-based months, to Yext date string which have 0-based months
   * @param date - a moment in time
   * @returns a Yext date string
   */
  transformDateToYext(t) {
    const [r, o, f] = t.toISOString().split("T")[0].split("-"), h = Number(o) - 1, C = h < 10 ? "0" + h : h.toString();
    return `${r}-${C}-${f}`;
  }
}
function $f(e, t) {
  const r = [...e];
  return t = t % r.length, r.concat(r.splice(0, r.length - t));
}
function iC(e, t) {
  if (e.length !== t.length)
    return !1;
  for (const [r, o] of e.entries())
    if (!o.timeIsEqualTo(t[r]))
      return !1;
  return !0;
}
const Ii = [
  "sunday",
  "monday",
  "tuesday",
  "wednesday",
  "thursday",
  "friday",
  "saturday"
], yc = [0, 1, 2, 3, 4, 5, 6];
function oC(e, t) {
  let r = 0;
  return e.startOfWeek === "today" ? (r = t.getDay(), $f(yc, r)) : e.startOfWeek ? (r = Ii.indexOf(e.startOfWeek), $f(yc, r)) : yc;
}
function sC(e) {
  const t = [];
  return e.forEach((r) => {
    const o = t[t.length - 1];
    o ? iC(o.intervals, r.intervals) ? (o.endDay = r.dayOfWeek, o.isToday = o.isToday || r.isToday) : t.push({
      startDay: r.dayOfWeek,
      endDay: r.dayOfWeek,
      ...r
    }) : t.push({
      startDay: r.dayOfWeek,
      endDay: r.dayOfWeek,
      ...r
    });
  }), t.map((r) => ({
    ...r,
    dayOfWeek: r.startDay === r.endDay ? `${r.startDay}` : `${r.startDay} - ${r.endDay}`
  }));
}
function lC(e, t) {
  const r = [];
  return e.intervals.length === 0 ? r.push("Closed") : e.intervals.forEach((o) => {
    const f = o.getStartTime("en-US", t), h = o.getEndTime("en-US", t);
    r.push(`${f} - ${h}`);
  }), r;
}
function aC(e) {
  return [
    e.sunday || Ii[0],
    e.monday || Ii[1],
    e.tuesday || Ii[2],
    e.wednesday || Ii[3],
    e.thursday || Ii[4],
    e.friday || Ii[5],
    e.saturday || Ii[6]
  ];
}
const lN = (e) => {
  const [t, r] = Tr(!1);
  fr(() => {
    r(!0);
  }, []);
  const o = new rC(e.hours), f = /* @__PURE__ */ new Date(), h = e.dayOfWeekNames ? aC(e.dayOfWeekNames) : Ii, C = oC(e, /* @__PURE__ */ new Date()), T = o.getIntervalsForNDays(7, f);
  let O = [];
  for (let x = 0; x < 7; x++)
    O.push({
      dayOfWeek: h[x],
      sortIdx: C[x],
      intervals: T.filter(
        (D) => D.start.getDay() === x
      ),
      isToday: f.getDay() === x
    });
  const S = (x, D) => x.sortIdx === D.sortIdx ? 0 : x.sortIdx > D.sortIdx ? 1 : -1;
  return O.sort(S), e.collapseDays && (O = sC(O)), /* @__PURE__ */ yt.jsx(yt.Fragment, { children: t && /* @__PURE__ */ yt.jsx("div", { className: Ql("HoursTable", e.className), children: O.map((x) => {
    const k = (e.intervalStringsBuilderFn || lC)(
      x,
      e.timeOptions
    );
    return /* @__PURE__ */ yt.jsxs(
      "div",
      {
        className: Ql("HoursTable-row", { "is-today": x.isToday }),
        children: [
          /* @__PURE__ */ yt.jsx("span", { className: "HoursTable-day", children: x.dayOfWeek }),
          /* @__PURE__ */ yt.jsx("span", { className: "HoursTable-intervals", children: k.map((H, N) => /* @__PURE__ */ yt.jsx("span", { className: "HoursTable-interval", children: H }, N)) })
        ]
      },
      x.sortIdx
    );
  }) }) });
}, Rc = Math.log2(1.6745627884839434), cC = 4, uC = 19, Dc = "js-baidu-neg-lng-fix";
let Uh;
const dC = new Promise((e) => Uh = e), fC = "https://api.map.baidu.com/geoconv/v1/";
let il = [];
const hC = "gcj02ToBD09Callback_b872c21c";
let gC = 0, Ff;
async function Wh(e) {
  return await new Promise((t, r) => {
    il.push({ coordinates: e, resolve: t, reject: r }), il.length === 1 && (Ff = setTimeout(o, 100)), il.length > 40 && (clearTimeout(Ff), o());
    function o() {
      const f = il;
      il = [];
      const h = [].concat(
        ...f.map((O) => O.coordinates)
      ), C = hC + "_" + gC++, T = document.createElement("script");
      window[C] = (O) => {
        if (O.status) {
          const D = new Error(
            `Unable to convert coordinates to BD-09: Received status code ${O.status}${O.message ? ": " + O.message : ""}`
          );
          f.forEach((k) => k.reject(D));
        }
        const S = O.result.map(
          (D) => new Vt(D.y, D.x)
        );
        let x = 0;
        f.forEach((D) => {
          D.resolve(
            S.slice(
              x,
              x += D.coordinates.length
            )
          );
        }), delete window[C], T.parentNode.removeChild(T);
      }, dC.then((O) => {
        const S = {
          ak: O,
          callback: C,
          coords: h.map(
            (x) => `${x.longitude},${x.latitude}`
          ).join(";"),
          from: 3,
          to: 5
        };
        T.src = fC + "?" + Object.entries(S).map(([x, D]) => x + "=" + D).join("&"), document.head.appendChild(T);
      });
    }
  });
}
class pC extends Es {
  /**
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(t) {
    super(t);
    const r = !!(window.MSInputMethodContext && document.documentMode);
    this._wrapper = t.wrapper, this.map = new BMap.Map(this._wrapper, {
      enableMapClick: t.controlEnabled,
      // A side effect of the negative pin longitude glitch is that pins don't render at higher zoom levels.
      // For IE, 15 and above is broken. For other browsers, 19 and above.
      maxZoom: r ? 14 : 18,
      ...t.providerOptions
    }), t.controlEnabled ? (this.map.enableScrollWheelZoom(), this.map.addControl(
      new BMap.NavigationControl({
        anchor: BMAP_ANCHOR_TOP_RIGHT,
        type: BMAP_NAVIGATION_CONTROL_ZOOM
      })
    )) : (this.map.disableDragging(), this.map.disableDoubleClickZoom(), this.map.disablePinchToZoom()), this.map.addEventListener("movestart", () => this._panStartHandler()), this.map.addEventListener("moveend", () => this._panHandler()), this.map.addEventListener("zoomstart", () => this._panStartHandler()), this.map.addEventListener("zoomend", () => {
      this._wrapper.dataset.baiduZoom = this.map.getZoom(), this._panHandler();
    }), this._centerReady = Promise.resolve();
  }
  /**
   * @inheritdoc
   */
  getCenter() {
    return new Vt(this.map.getCenter());
  }
  /**
   * @inheritdoc
   */
  getZoom() {
    return this.map.getZoom() - Rc;
  }
  /**
   * @inheritdoc
   */
  setCenter(t, r) {
    this._centerReady = Wh([t]).then(([o]) => {
      const f = new BMap.Point(
        o.longitude,
        o.latitude
      );
      this.map.panTo(f, { noAnimation: !r });
    });
  }
  /**
   * @inheritdoc
   */
  setZoom(t, r) {
    this._centerReady.then(() => {
      this.map.setViewport(
        {
          center: this.map.getCenter(),
          zoom: Math.floor(t + Rc)
          // Baidu only allows integer zoom
        },
        { enableAnimation: r }
      );
    });
  }
}
class _C extends sa {
  /**
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(t) {
    super(t), this._wrapper = null, this._zIndex = 0, this._wrapperClass = "", this._originalWrapperClass = "", this._element = this._pinEl, this._coordinateReady = Promise.resolve(), this._negativeLngFix = !1;
    const r = this;
    class o extends BMap.Marker {
      initialize(C) {
        return r._wrapper = super.initialize(C), r._wrapper && (r._wrapper.style.zIndex = r._zIndex, r._originalWrapperClass = r._wrapper.getAttribute("class"), r._wrapper.setAttribute("class", r._getClass()), r._wrapper.appendChild(r._element), r.addListeners()), r._wrapper;
      }
      draw() {
        if (r._wrapper) {
          const C = r._wrapper.style.zIndex;
          super.draw(), r._wrapper.style.height = "", r._wrapper.style.width = "", r._wrapper.style.pointerEvents = "none", r._wrapper.style.zIndex = C;
        } else
          super.draw();
      }
    }
    this.pin = new o(new BMap.Point(0, 0));
    const f = new BMap.Icon(
      "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
      { height: 0, width: 0 }
    );
    this.pin.setIcon(f), this.pin.setShadow(f);
  }
  /**
   * @inheritdoc
   */
  addListeners() {
    super.addListeners(), this._wrapper.addEventListener("touchend", () => this._clickHandler());
  }
  /**
   * @inheritdoc
   */
  setCoordinate(t) {
    this._coordinateReady = Wh([t]).then(
      ([r]) => {
        this._negativeLngFix = r.longitude < 0, this.pin.setPosition(
          new BMap.Point(
            r.longitude + (this._negativeLngFix ? 180 : 0),
            r.latitude
          )
        ), this._wrapper && this._wrapper.classList[this._negativeLngFix ? "add" : "remove"](
          Dc
        );
      }
    );
  }
  /**
   * @inheritdoc
   */
  setMap(t, r) {
    this._coordinateReady.then(() => {
      r && r.getProviderMap().map.removeOverlay(this.pin), t && t.getProviderMap().map.addOverlay(this.pin);
    });
  }
  /**
   * @inheritdoc
   */
  setProperties(t) {
    super.setProperties(t), this._wrapperClass = t.getClass(), this._element = t.getElement() || this._pinEl, this._zIndex = t.getZIndex(), this._wrapper && this._wrapper.setAttribute("class", this._getClass());
  }
  /**
   * Get the class attribute value for the pin element
   * @protected
   * @returns {string}
   */
  _getClass() {
    return `${this._originalWrapperClass} ${this._negativeLngFix ? Dc : ""} ${this._wrapperClass}`;
  }
}
const mC = "https://api.map.baidu.com/getscript";
function yC(e, t, r, { params: o = {}, version: f = "3.0" } = {}) {
  window.BMAP_PROTOCOL = "https", window.BMap_loadScriptTime = (/* @__PURE__ */ new Date()).getTime();
  const h = r, C = {
    ak: h,
    v: f,
    ...o
  };
  Uh(h);
  const T = document.createElement("script");
  T.src = mC + "?" + Object.entries(C).map(([x, D]) => x + "=" + D).join("&"), T.onload = () => e(), document.head.appendChild(T);
  let O = "";
  for (let x = cC; x <= uC; x++) {
    const D = 2 ** (x - Rc + 7);
    O += `[data-baidu-zoom="${x}"] .${Dc}{transform:translateX(-${D}px);}`;
  }
  const S = document.createElement("style");
  S.innerHTML = O, document.head.appendChild(S);
}
const aN = new Bo().withLoadFunction(yC).withMapClass(pC).withPinClass(_C).withProviderName("Baidu").build();
let zh;
function CC() {
  class e extends Microsoft.Maps.CustomOverlay {
    constructor() {
      super({ beneathLabels: !1 }), this._container = document.createElement("div"), this._map = null, this._pins = /* @__PURE__ */ new Set(), this._viewChangeEventHandler = null, this._container.style.position = "absolute", this._container.style.left = "0", this._container.style.top = "0";
    }
    addPin(r) {
      this._pins.add(r), r._wrapper.style.position = "absolute", this._container.appendChild(r._wrapper), this._map && this.updatePinPosition(r);
    }
    onAdd() {
      this._map = this.getMap(), this.setHtmlElement(this._container);
    }
    onLoad() {
      this._viewChangeEventHandler = Microsoft.Maps.Events.addHandler(
        this._map,
        "viewchange",
        () => this.updatePinPositions()
      ), this.updatePinPositions();
    }
    onRemove() {
      Microsoft.Maps.Events.removeHandler(this._viewChangeEventHandler), this._map = null;
    }
    removePin(r) {
      this._pins.delete(r), this._container.removeChild(r._wrapper);
    }
    updatePinPosition(r) {
      if (!this._map)
        return;
      const o = this._map.tryLocationToPixel(
        r._location,
        Microsoft.Maps.PixelReference.control
      );
      r._wrapper.style.left = o.x + "px", r._wrapper.style.top = o.y + "px";
    }
    updatePinPositions() {
      this._pins.forEach((r) => this.updatePinPosition(r));
    }
  }
  zh = e;
}
class NC extends Es {
  /**
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(t) {
    super(t), this.wrapper = t.wrapper, this.map = new Microsoft.Maps.Map(this.wrapper, {
      disablePanning: !t.controlEnabled,
      disableZooming: !t.controlEnabled,
      showLocateMeButton: !1,
      showMapTypeSelector: !1,
      showScalebar: !1,
      showTrafficButton: !1,
      ...t.providerOptions
    }), this.pinOverlay = new zh(this.map), this.map.layers.insert(this.pinOverlay), Microsoft.Maps.Events.addHandler(
      this.map,
      "viewchangestart",
      () => this._panStartHandler()
    ), Microsoft.Maps.Events.addHandler(
      this.map,
      "viewchangeend",
      () => this._panHandler()
    );
  }
  /**
   * @inheritdoc
   */
  getCenter() {
    return new Vt(this.map.getCenter());
  }
  /**
   * @inheritdoc
   */
  getZoom() {
    return this.map.getZoom();
  }
  /**
   * @inheritdoc
   */
  setCenter(t, r) {
    const o = new Microsoft.Maps.Location(
      t.latitude,
      t.longitude
    );
    this.map.setView({ center: o }), this.pinOverlay.updatePinPositions();
  }
  /**
   * @inheritdoc
   */
  setZoom(t, r) {
    this.map.setView({ zoom: Math.floor(t) }), this.pinOverlay.updatePinPositions();
  }
}
class EC extends sa {
  /**
   * Bing pins need global callbacks to complete initialization.
   * This function provides a unique ID to include in the name of the callback.
   * @returns {number} An ID for the pin unique across all instances of {@link module:@yext/components-maps~BingPin BingPin}
   */
  static getId() {
    return this._pinId = (this._pinId || 0) + 1, this._pinId;
  }
  /**
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(t) {
    super(t), this._map = null, this._location = new Microsoft.Maps.Location(0, 0);
  }
  /**
   * @inheritdoc
   */
  setCoordinate(t) {
    this._location = new Microsoft.Maps.Location(
      t.latitude,
      t.longitude
    ), this._map && this._map.getProviderMap().pinOverlay.updatePinPosition(this);
  }
  /**
   * @inheritdoc
   */
  setMap(t, r) {
    r && r.getProviderMap().pinOverlay.removePin(this), t && t.getProviderMap().pinOverlay.addPin(this), this._map = t;
  }
}
const Bf = "BingMapsCallback_593d7d33", TC = "https://www.bing.com/api/maps/mapcontrol";
function xC(e, t, r, { params: o = {} } = {}) {
  window[Bf] = () => {
    CC(), e();
  };
  const f = {
    callback: Bf,
    key: r,
    ...o
  };
  Xf(
    TC + "?" + Object.entries(f).map(([h, C]) => h + "=" + C).join("&")
  );
}
const cN = new Bo().withLoadFunction(xC).withMapClass(NC).withPinClass(EC).withProviderName("Bing").build();
class vC extends Es {
  /**
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(t) {
    if (super(t), this.map = new mapboxgl.Map({
      container: t.wrapper,
      interactive: t.controlEnabled,
      style: "mapbox://styles/mapbox/streets-v9",
      ...t.providerOptions
    }), t.controlEnabled) {
      const r = new mapboxgl.NavigationControl({
        showCompass: !1
      });
      this.map.addControl(r);
    }
    this.map.on("movestart", () => this._panStartHandler()), this.map.on("moveend", () => this._panHandler());
  }
  /**
   * @inheritdoc
   */
  getCenter() {
    return new Vt(this.map.getCenter());
  }
  /**
   * @inheritdoc
   */
  getZoom() {
    return this.map.getZoom() + 1;
  }
  /**
   * @inheritdoc
   */
  setCenter(t, r) {
    const o = new mapboxgl.LngLat(
      t.longitude,
      t.latitude
    );
    this.map[r ? "panTo" : "setCenter"](o);
  }
  /**
   * @inheritdoc
   */
  setZoom(t, r) {
    this.map[r ? "zoomTo" : "setZoom"](t - 1);
  }
  /**
   * @inheritdoc
   */
  setZoomCenter(t, r, o) {
    const f = new mapboxgl.LngLat(
      r.longitude,
      r.latitude
    );
    this.map[o ? "easeTo" : "jumpTo"]({ center: f, zoom: t - 1 });
  }
}
class SC extends sa {
  /**
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(t) {
    super(t), this._wrapper.style.position = "relative", this.pin = new mapboxgl.Marker({
      anchor: "top-left",
      element: this._wrapper
    });
  }
  /**
   * @inheritdoc
   */
  setCoordinate(t) {
    this.pin.setLngLat(
      new mapboxgl.LngLat(t.longitude, t.latitude)
    );
  }
  /**
   * @inheritdoc
   */
  setMap(t, r) {
    t ? this.pin.addTo(t.getProviderMap().map) : this.pin.remove();
  }
}
function wC(e, t, r, { version: o = "v1.13.0" } = {}) {
  const f = `https://api.mapbox.com/mapbox-gl-js/${o}/mapbox-gl`, h = document.createElement("link");
  h.rel = "stylesheet", h.href = f + ".css";
  const C = document.createElement("script");
  C.src = f + ".js", C.onload = () => {
    mapboxgl.accessToken = r, e();
  }, document.head.appendChild(h), document.head.appendChild(C);
}
const uN = new Bo().withLoadFunction(wC).withMapClass(vC).withPinClass(SC).withProviderName("Mapbox").build();
let Gh = class extends Es {
  /**
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(t) {
    super(t), this._initMap(t), t.controlEnabled && this.map.zoomControl.setPosition("topright"), this.map.on("movestart", () => this._panStartHandler()), this.map.on("moveend", () => this._panHandler());
  }
  /**
   * @inheritdoc
   */
  getCenter() {
    return new Vt(this.map.getCenter());
  }
  /**
   * @inheritdoc
   */
  getZoom() {
    return this.map.getZoom();
  }
  /**
   * @inheritdoc
   */
  setCenter(t, r) {
    const o = new L.latLng(t.latitude, t.longitude);
    this.map.panTo(o, { animate: r });
  }
  /**
   * @inheritdoc
   */
  setZoom(t, r) {
    this.map.setZoom(t, { animate: r });
  }
  /**
   * @inheritdoc
   */
  setZoomCenter(t, r, o) {
    const f = new L.latLng(r.latitude, r.longitude);
    this.map.setView(f, t, { animate: o });
  }
  /**
   * Initialize the Leaflet map
   * @protected
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  _initMap(t) {
    this.map = new L.map(t.wrapper, {
      boxZoom: t.controlEnabled,
      doubleClickZoom: t.controlEnabled,
      dragging: t.controlEnabled,
      zoom: 0,
      zoomControl: t.controlEnabled,
      zoomSnap: 0,
      ...t.providerOptions
    });
    const r = t.providerOptions, o = r.tileLayerSrc || "https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token={accessToken}", f = r.tileLayerOptions || {
      attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
      id: "mapbox/streets-v11"
    };
    f.accessToken = this.constructor.apiKey, L.tileLayer(o, f).addTo(this.map);
  }
}, OC = class extends Lc {
  /**
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(t) {
    super(t), this.pin = new L.marker(), this.pin.on("click", () => this._clickHandler()), this.pin.on("mouseover", () => this._hoverHandler(!0)), this.pin.on("mouseout", () => this._hoverHandler(!1));
  }
  /**
   * @inheritdoc
   */
  setCoordinate(t) {
    const r = new L.latLng(t.latitude, t.longitude);
    this.pin.setLatLng(r);
  }
  /**
   * @inheritdoc
   */
  setMap(t, r) {
    t ? this.pin.addTo(t.getProviderMap().map) : this.pin.remove();
  }
  /**
   * @inheritdoc
   */
  setProperties(t) {
    const r = t.getWidth(), o = t.getHeight(), f = t.getAnchorX(), h = t.getAnchorY();
    this.pin.setIcon(
      new L.icon({
        iconUrl: this._icons[t.getIcon()],
        iconSize: [r, o],
        iconAnchor: [f * r, h * o],
        className: t.getClass()
      })
    ), this.pin.setZIndexOffset(t.getZIndex());
  }
};
function RC(e, t, r, { version: o = "1.7.1" } = {}) {
  const f = `https://unpkg.com/leaflet@${o}/dist/leaflet`;
  Gh.apiKey = r;
  const h = document.createElement("link");
  h.rel = "stylesheet", h.href = f + ".css";
  const C = document.createElement("script");
  C.src = f + ".js", C.onload = () => e(), document.head.appendChild(h), document.head.appendChild(C);
}
const Yh = new Bo().withLoadFunction(RC).withMapClass(Gh).withPinClass(OC).withProviderName("Leaflet").build(), DC = Yh.getMapClass(), AC = Yh.getPinClass();
class bC extends DC {
  /**
   * @inheritdoc
   */
  _initMap(t) {
    this.map = L.mapquest.map(t.wrapper, {
      boxZoom: t.controlEnabled,
      center: new L.latLng(0, 0),
      doubleClickZoom: t.controlEnabled,
      dragging: t.controlEnabled,
      layers: L.mapquest.tileLayer("map"),
      zoom: 0,
      zoomControl: t.controlEnabled,
      zoomSnap: 0,
      ...t.providerOptions
    });
  }
}
class MC extends AC {
}
function LC(e, t, r, { version: o = "v1.3.2" } = {}) {
  const f = `https://api.mqcdn.com/sdk/mapquest-js/${o}/mapquest-maps`, h = document.createElement("link");
  h.rel = "stylesheet", h.href = f + ".css";
  const C = document.createElement("script");
  C.src = f + ".js", C.onload = () => {
    L.mapquest.key = r, e();
  }, document.head.appendChild(h), document.head.appendChild(C);
}
const hN = new Bo().withLoadFunction(LC).withMapClass(bC).withPinClass(MC).withProviderName("MapQuest").build();
export {
  FC as A,
  WC as B,
  qf as C,
  BC as D,
  ko as E,
  xp as F,
  GC as G,
  ih as H,
  zC as I,
  jC as J,
  kc as K,
  Pg as L,
  Tu as M,
  VC as N,
  qC as O,
  Bp as P,
  JC as Q,
  sN as R,
  lN as S,
  rC as T,
  aN as U,
  cN as V,
  th as W,
  uN as X,
  Yh as Y,
  hN as Z,
  rN as a,
  ta as b,
  oN as c,
  ZC as d,
  Rf as e,
  QC as f,
  bc as g,
  XC as h,
  nN as i,
  tN as j,
  eN as k,
  bm as l,
  iN as m,
  al as n,
  Nm as o,
  rl as p,
  $C as q,
  Im as r,
  Wc as s,
  fp as t,
  Yf as u,
  Kh as v,
  oa as w,
  KC as x,
  HC as y,
  UC as z
};
