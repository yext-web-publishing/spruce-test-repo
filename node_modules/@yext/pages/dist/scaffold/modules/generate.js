import fs from "node:fs";
import path from "node:path";
import { glob } from "glob";
import prompts from "prompts";
import {
  indexCssCode,
  moduleCode,
  postcssCode,
  tailwindCode
} from "./templates.js";
import {
  installDependencies,
  updatePackageDependency
} from "../../upgrade/pagesUpdater.js";
import { logErrorAndExit } from "../../util/logError.js";
import { addResponseHeadersToConfigYaml } from "../../util/editConfigYaml.js";
const moduleResponseHeaderProps = {
  headerKey: "Access-Control-Allow-Origin",
  headerValues: ["*"]
};
const generateModule = async (projectStructure) => {
  const questions = [
    {
      type: "text",
      name: "moduleName",
      message: "What would you like to name your Module?",
      validate: (moduleName) => validateModuleName(moduleName, projectStructure) || "Please ensure the name provided isn't already used and is valid."
    },
    {
      type: "confirm",
      name: "useTailwind",
      message: "Would you like to use Tailwind CSS?",
      initial: true
    }
  ];
  const response = await prompts(questions);
  const modulePath = path.join(
    projectStructure.getModulePaths()[0].path,
    response.moduleName
  );
  process.on(
    "SIGINT",
    () => handleCancel(response.moduleName, projectStructure)
  );
  fs.mkdirSync(modulePath, { recursive: true });
  fs.writeFileSync(
    path.join(modulePath, `${response.moduleName}.tsx`),
    moduleCode(response.moduleName, response.useTailwind)
  );
  fs.writeFileSync(
    path.join(modulePath, "index.css"),
    indexCssCode(response.useTailwind)
  );
  if (response.useTailwind) {
    fs.writeFileSync(
      path.join(modulePath, "tailwind.config.ts"),
      tailwindCode(projectStructure)
    );
    fs.writeFileSync(path.join(modulePath, "postcss.config.js"), postcssCode());
  }
  try {
    await getDependencies();
  } catch (error) {
    logErrorAndExit(error);
  }
  const configPathPattern = modulePath.replace(
    `${projectStructure.config.rootFolders.source}${path.sep}`,
    "^"
  );
  addResponseHeadersToConfigYaml(
    projectStructure,
    {
      pathPattern: `${configPathPattern}.*`,
      ...moduleResponseHeaderProps
    },
    "# The ^modules/ header allows access to your modules from other sites\n"
  );
  process.removeListener("SIGINT", () => handleCancel);
  console.log(
    `
Module "${response.moduleName}" created successfully at ${modulePath}`
  );
};
const validateModuleName = (moduleName, projectStructure) => {
  const modulePath = path.join(
    projectStructure.getModulePaths()[0].path,
    moduleName
  );
  if (fs.existsSync(modulePath)) {
    return false;
  }
  return isValidModuleName(moduleName);
};
function isValidModuleName(moduleName) {
  return /^[a-zA-Z]+$/.test(moduleName.charAt(0)) && // moduleName starts with alphabetic character
  !/\s/.test(moduleName) && // moduleName doesn't contain spaces
  /^[0-9a-zA-Z_$-]+$/.test(moduleName);
}
function handleCancel(moduleName, projectStructure) {
  const modulePath = projectStructure.getModulePaths(moduleName)[0].path;
  if (fs.existsSync(modulePath)) {
    const moduleFiles = glob.sync("**/*", { cwd: modulePath, nodir: true });
    moduleFiles.forEach((file) => {
      const filePath = path.join(modulePath, file);
      fs.unlinkSync(filePath);
    });
    fs.rmdirSync(modulePath);
  }
  process.exit(0);
}
const getDependencies = async () => {
  await updatePackageDependency("@yext/pages-components", null, true);
  await updatePackageDependency("tailwindcss", null, true);
  await installDependencies();
};
export {
  generateModule,
  isValidModuleName
};
