import pathLib from "node:path";
import merge from "lodash/merge.js";
import fs from "node:fs";
import { Path } from "./path.js";
import { determineAssetsFilepath } from "../assets/getAssetsFilepath.js";
import { determinePublicFilepath } from "../assets/getPublicFilepath.js";
const DEFAULT_ASSETS_DIR = "assets";
const DEFAULT_PUBLIC_DIR = "public";
const defaultProjectStructureConfig = {
  rootFolders: {
    source: "src",
    dist: "dist",
    sitesConfig: "sites-config",
    functions: "functions"
  },
  subfolders: {
    templates: "templates",
    modules: "modules",
    redirects: "redirects",
    serverlessFunctions: "functions",
    assets: DEFAULT_ASSETS_DIR,
    public: DEFAULT_PUBLIC_DIR,
    clientBundle: "client",
    serverBundle: "server",
    redirectBundle: "redirect",
    renderBundle: "render",
    renderer: "renderer",
    static: "static",
    plugin: "plugin"
  },
  sitesConfigFiles: {
    ci: "ci.json",
    features: "features.json",
    siteStream: "site-stream.json",
    serving: "serving.json",
    sitemap: "sitemap.json",
    redirects: "redirects.csv",
    auth: "auth.json"
  },
  distConfigFiles: {
    templates: "templates.json",
    artifacts: "artifacts.json",
    functionMetadata: "functionMetadata.json"
  },
  rootFiles: {
    config: "config.yaml"
  },
  envVarConfig: {
    envVarDir: "",
    envVarPrefix: "YEXT_PUBLIC"
  }
};
class ProjectStructure {
  config;
  constructor(config) {
    const mergedConfig = merge(defaultProjectStructureConfig, config);
    this.config = mergedConfig;
  }
  static init = async (projectStructureConfig) => {
    const config = merge(defaultProjectStructureConfig, projectStructureConfig);
    const assetsDir = await determineAssetsFilepath(
      DEFAULT_ASSETS_DIR,
      pathLib.resolve("vite.config.js")
    );
    config.subfolders.assets = assetsDir;
    const publicDir = await determinePublicFilepath(
      DEFAULT_PUBLIC_DIR,
      pathLib.resolve("vite.config.js")
    );
    config.subfolders.public = publicDir;
    return new ProjectStructure(config);
  };
  /**
   * @returns the list of of src/templates, taking scope into account. If a scope is defined and
   * the scoped path exists, then both the scoped and non-scoped template paths are returned.
   */
  getTemplatePaths = () => {
    const templatesRoot = pathLib.join(
      this.config.rootFolders.source,
      this.config.subfolders.templates
    );
    const scopedPath = pathLib.join(templatesRoot, this.config.scope ?? "");
    if (this.config.scope && fs.existsSync(scopedPath)) {
      return [new Path(scopedPath), new Path(templatesRoot)];
    }
    return [new Path(templatesRoot)];
  };
  /**
   * @returns the list of src/redirects, taking scope into account. If a scope is defined and
   * the scoped path exists, then both the scoped and non-scoped redirect paths are returned.
   */
  getRedirectPaths = () => {
    const redirectsRoot = pathLib.join(
      this.config.rootFolders.source,
      this.config.subfolders.redirects
    );
    if (!fs?.existsSync(redirectsRoot)) {
      return [];
    }
    if (this.config.scope) {
      const scopedPath = pathLib.join(redirectsRoot, this.config.scope);
      if (fs?.existsSync(scopedPath)) {
        return [new Path(scopedPath), new Path(redirectsRoot)];
      }
    }
    return [new Path(redirectsRoot)];
  };
  /**
   * @returns the {@link Path} to the sites-config folder, taking scope into account.
   */
  getSitesConfigPath = () => {
    return new Path(
      pathLib.join(this.config.rootFolders.sitesConfig, this.config.scope ?? "")
    );
  };
  /**
   * @returns the {@link Path} to the dist folder, taking scope into account.
   */
  getScopedDistPath = () => {
    return new Path(
      pathLib.join(this.config.rootFolders.dist, this.config.scope ?? "")
    );
  };
  /**
   * @returns the {@link Path} to the config.yaml file, taking scope into account.
   */
  getConfigYamlPath = () => {
    return new Path(
      pathLib.join(this.config.scope ?? "", this.config.rootFiles.config)
    );
  };
  /**
   * @returns the {@link Path} to the modules folder, taking scope into account.
   * If moduleName is provided, returns the path to that modules folder. If a scope is
   * defined and scoped path exists, then both the scoped and non-scoped module paths are returned.
   */
  getModulePaths = (moduleName) => {
    const modulesPath = pathLib.join(
      this.config.rootFolders.source,
      this.config.subfolders.modules,
      moduleName ?? ""
    );
    const scopedPath = pathLib.join(
      this.config.rootFolders.source,
      this.config.subfolders.modules,
      this.config.scope ?? "",
      moduleName ?? ""
    );
    if (this.config.scope && fs.existsSync(scopedPath)) {
      return [new Path(scopedPath), new Path(modulesPath)];
    }
    return [new Path(modulesPath)];
  };
}
export {
  ProjectStructure
};
