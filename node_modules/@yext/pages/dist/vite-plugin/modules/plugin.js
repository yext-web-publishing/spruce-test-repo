import { build } from "vite";
import { glob } from "glob";
import path from "node:path";
import fs from "node:fs";
import { convertToPosixPath } from "../../common/src/template/paths.js";
import { processEnvVariables } from "../../util/processEnvVariables.js";
import { nodePolyfills } from "vite-plugin-node-polyfills";
import pc from "picocolors";
import SourceFileParser, {
  createTsMorphProject
} from "../../common/src/parsers/sourceFileParser.js";
import { logWarning } from "../../util/logError.js";
import postcss from "postcss";
import nested from "postcss-nested";
import { createModuleLogger } from "../../common/src/module/internal/logger.js";
import { getModuleName } from "../../common/src/module/internal/getModuleName.js";
const buildModules = async (projectStructure) => {
  if (!shouldBundleModules(projectStructure)) {
    return;
  }
  const { rootFolders, subfolders, envVarConfig } = projectStructure.config;
  const outdir = path.join(rootFolders.dist, subfolders.modules);
  const filepaths = {};
  const modulePaths = projectStructure.getModulePaths();
  modulePaths.forEach((modulePath) => {
    glob.sync(convertToPosixPath(path.join(modulePath.path, "*/*.{jsx,tsx}")), {
      nodir: true
    }).forEach((f) => {
      const filepath = path.resolve(f);
      const moduleName = getModuleName(filepath);
      const { name } = path.parse(filepath);
      if (!((moduleName ?? name) in filepaths)) {
        filepaths[moduleName ?? name] = { path: filepath, name };
      }
    });
  });
  const logger = createModuleLogger();
  const loggerInfo = logger.info;
  if (tailwindBaseExists()) {
    logWarning(
      `Please be aware that using @tailwind base applies styles globally. This can affect code outside of the widget.`
    );
  }
  for (const [moduleName, fileInfo] of Object.entries(filepaths)) {
    logger.info = (msg, options) => {
      if (msg.includes("building for production")) {
        loggerInfo(pc.green(`
Building ${moduleName} module...`));
        return;
      }
      loggerInfo(msg, options);
    };
    await build({
      customLogger: logger,
      configFile: false,
      envDir: envVarConfig.envVarDir,
      envPrefix: envVarConfig.envVarPrefix,
      resolve: {
        conditions: ["worker", "webworker"]
      },
      publicDir: false,
      css: {
        postcss: getPostCssConfigFilepath(
          rootFolders,
          subfolders,
          fileInfo.name
        )
      },
      esbuild: {
        logOverride: {
          "css-syntax-error": "silent"
        }
      },
      build: {
        chunkSizeWarningLimit: 2e3,
        emptyOutDir: false,
        outDir: outdir,
        minify: true,
        rollupOptions: {
          input: fileInfo.path,
          output: {
            format: "umd",
            entryFileNames: `${moduleName}.umd.js`
          }
        },
        reportCompressedSize: false
      },
      define: processEnvVariables(envVarConfig.envVarPrefix),
      plugins: [
        addWrappedCodePlugin(fileInfo.path, moduleName),
        nodePolyfills({
          globals: {
            Buffer: "build",
            global: "build",
            process: "build"
          }
        })
      ]
    });
  }
};
const wrappedCode = (moduleName, containerName) => {
  return `
  const moduleContainerForBuildUseOnly = document.getElementById('${containerName}');
  if (!moduleContainerForBuildUseOnly) {
    throw new Error('could not find ${containerName} element');
  }
  ReactDOM.render(
    <${moduleName}/>,
    moduleContainerForBuildUseOnly
  );`;
};
function addWrappedCodePlugin(path2, moduleName) {
  return {
    name: "wrapped-code-plugin",
    enforce: "pre",
    transform(source, id) {
      if (id === path2) {
        return getReactImports(source) + source + extraModuleCode(path2, moduleName);
      }
      return null;
    }
  };
}
const getReactImports = (source) => {
  let imports = "";
  if (!(source.includes(`from 'react'`) || source.includes(`from "react"`))) {
    imports += `import * as React from 'react';
`;
  }
  if (!(source.includes(`from 'react-dom'`) || source.includes(`from "react-dom"`))) {
    imports += `import * as ReactDOM from 'react-dom';
`;
  }
  return imports;
};
const shouldBundleModules = (projectStructure) => {
  const { rootFolders, subfolders } = projectStructure.config;
  return fs.existsSync(path.join(rootFolders.source, subfolders.modules));
};
const extraModuleCode = (modulePath, name) => {
  const sfp = new SourceFileParser(modulePath, createTsMorphProject());
  const declaration = sfp.getVariableDeclarationByType("Module");
  if (declaration === void 0) {
    throw new Error(`Cannot find variable Module in ${modulePath}`);
  }
  const moduleName = declaration.getName();
  return wrappedCode(moduleName, name);
};
const getPostCssConfigFilepath = (rootFolders, subfolders, filename) => {
  const filePath = path.join(
    rootFolders.source,
    subfolders.modules,
    `${filename}/postcss.config`
  );
  let filePaths = glob.sync(filePath + ".{js,cjs,ts,mjs}");
  if (filePaths.length == 1) {
    return filePaths[0];
  }
  filePaths = glob.sync("postcss.config.{js,cjs,ts,mjs}");
  if (filePaths.length == 1) {
    return filePaths[0];
  }
  return;
};
const tailwindBaseExists = () => {
  const files = glob.sync("./src/**/*.css");
  let isTailwindBaseInRule = false;
  for (const filePath of files) {
    try {
      const data = fs.readFileSync(filePath, "utf8");
      postcss([nested]).process(data, { from: void 0 }).then((result) => {
        result.root.walkRules((rule) => {
          if (rule.toString().includes("@tailwind base")) {
            isTailwindBaseInRule = true;
          }
        });
      }).then(() => {
        if (data.includes(`@tailwind base`) && !isTailwindBaseInRule) {
          return true;
        }
      });
    } catch (err) {
      return false;
    }
  }
  return false;
};
export {
  buildModules,
  addWrappedCodePlugin as default
};
